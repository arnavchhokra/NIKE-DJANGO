{"ast":null,"code":"import { Vector2 } from 'three';\n/**\r\n * Triangle blur shader\r\n * based on glfx.js triangle blur shader\r\n * https://github.com/evanw/glfx.js\r\n *\r\n * A basic blur filter, which convolves the image with a\r\n * pyramid filter. The pyramid filter is separable and is applied as two\r\n * perpendicular triangle filters.\r\n */\n\nvar TriangleBlurShader = {\n  uniforms: {\n    texture: {\n      value: null\n    },\n    delta: {\n      value: new Vector2(1, 1)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = vec4( 0.0 );', '\tfloat total = 0.0;', // randomize the lookup values to hide the fixed number of samples\n  '\tfloat offset = rand( vUv );', '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\t\tfloat weight = 1.0 - abs( percent );', '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\t\ttotal += weight;', '\t}', '\tgl_FragColor = color / total;', '}'].join('\\n')\n};\nexport { TriangleBlurShader };","map":{"version":3,"names":["Vector2","TriangleBlurShader","uniforms","texture","value","delta","vertexShader","join","fragmentShader"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/shaders/TriangleBlurShader.js"],"sourcesContent":["import { Vector2 } from 'three';\r\n\r\n/**\r\n * Triangle blur shader\r\n * based on glfx.js triangle blur shader\r\n * https://github.com/evanw/glfx.js\r\n *\r\n * A basic blur filter, which convolves the image with a\r\n * pyramid filter. The pyramid filter is separable and is applied as two\r\n * perpendicular triangle filters.\r\n */\r\n\r\nconst TriangleBlurShader = {\r\n  uniforms: {\r\n    texture: {\r\n      value: null\r\n    },\r\n    delta: {\r\n      value: new Vector2(1, 1)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#include <common>', '#define ITERATIONS 10.0', 'uniform sampler2D texture;', 'uniform vec2 delta;', 'varying vec2 vUv;', 'void main() {', '\tvec4 color = vec4( 0.0 );', '\tfloat total = 0.0;', // randomize the lookup values to hide the fixed number of samples\r\n  '\tfloat offset = rand( vUv );', '\tfor ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {', '\t\tfloat percent = ( t + offset - 0.5 ) / ITERATIONS;', '\t\tfloat weight = 1.0 - abs( percent );', '\t\tcolor += texture2D( texture, vUv + delta * percent ) * weight;', '\t\ttotal += weight;', '\t}', '\tgl_FragColor = color / total;', '}'].join('\\n')\r\n};\r\n\r\nexport { TriangleBlurShader };\r\n"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMC,kBAAkB,GAAG;EACzBC,QAAQ,EAAE;IACRC,OAAO,EAAE;MACPC,KAAK,EAAE;IADA,CADD;IAIRC,KAAK,EAAE;MACLD,KAAK,EAAE,IAAIJ,OAAJ,CAAY,CAAZ,EAAe,CAAf;IADF;EAJC,CADe;EASzBM,YAAY,EAAE,CAAC,mBAAD,EAAsB,eAAtB,EAAuC,YAAvC,EAAqD,4EAArD,EAAmI,GAAnI,EAAwIC,IAAxI,CAA6I,IAA7I,CATW;EAUzBC,cAAc,EAAE,CAAC,mBAAD,EAAsB,yBAAtB,EAAiD,4BAAjD,EAA+E,qBAA/E,EAAsG,mBAAtG,EAA2H,eAA3H,EAA4I,4BAA5I,EAA0K,qBAA1K,EAAiM;EACjN,8BADgB,EACgB,yDADhB,EAC2E,sDAD3E,EACmI,wCADnI,EAC6K,kEAD7K,EACiP,oBADjP,EACuQ,IADvQ,EAC6Q,gCAD7Q,EAC+S,GAD/S,EACoTD,IADpT,CACyT,IADzT;AAVS,CAA3B;AAcA,SAASN,kBAAT"},"metadata":{},"sourceType":"module"}