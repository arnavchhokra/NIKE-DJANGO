{"ast":null,"code":"import { Vector2 } from 'three';\n/**\r\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\r\n *\r\n * Sample usage:\r\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\r\n *\r\n */\n\nvar UVsDebug = function UVsDebug(geometry, size) {\n  // handles wrapping of uv.x > 1 only\n  var abc = 'abc';\n  var a = new Vector2();\n  var b = new Vector2();\n  var uvs = [new Vector2(), new Vector2(), new Vector2()];\n  var face = [];\n  var canvas = document.createElement('canvas');\n  var width = size || 1024; // power of 2 required for wrapping\n\n  var height = size || 1024;\n  canvas.width = width;\n  canvas.height = height;\n  var ctx = canvas.getContext('2d');\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\n  ctx.textAlign = 'center'; // paint background white\n\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\n  ctx.fillRect(0, 0, width, height);\n\n  if (geometry.isGeometry) {\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\n    return;\n  } else {\n    var index = geometry.index;\n    var uvAttribute = geometry.attributes.uv;\n\n    if (index) {\n      // indexed geometry\n      for (var i = 0, il = index.count; i < il; i += 3) {\n        face[0] = index.getX(i);\n        face[1] = index.getX(i + 1);\n        face[2] = index.getX(i + 2);\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, i / 3);\n      }\n    } else {\n      // non-indexed geometry\n      for (var _i = 0, _il = uvAttribute.count; _i < _il; _i += 3) {\n        face[0] = _i;\n        face[1] = _i + 1;\n        face[2] = _i + 2;\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\n        processFace(face, uvs, _i / 3);\n      }\n    }\n  }\n\n  return canvas;\n\n  function processFace(face, uvs, index) {\n    // draw contour of face\n    ctx.beginPath();\n    a.set(0, 0);\n\n    for (var _j = 0, _jl = uvs.length; _j < _jl; _j++) {\n      var uv = uvs[_j];\n      a.x += uv.x;\n      a.y += uv.y;\n\n      if (_j === 0) {\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      } else {\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\n      }\n    }\n\n    ctx.closePath();\n    ctx.stroke(); // calculate center of face\n\n    a.divideScalar(uvs.length); // label the face number\n\n    ctx.font = '18px Arial';\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\n\n    if (a.x > 0.95) {\n      // wrap x // 0.95 is arbitrary\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\n    } //\n\n\n    ctx.font = '12px Arial';\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\n\n    for (j = 0, jl = uvs.length; j < jl; j++) {\n      var uv = uvs[j];\n      b.addVectors(a, uv).divideScalar(2);\n      var vnum = face[j];\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\n\n      if (b.x > 0.95) {\n        // wrap x\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\n      }\n    }\n  }\n};\n\nexport { UVsDebug };","map":{"version":3,"names":["Vector2","UVsDebug","geometry","size","abc","a","b","uvs","face","canvas","document","createElement","width","height","ctx","getContext","lineWidth","strokeStyle","textAlign","fillStyle","fillRect","isGeometry","console","error","index","uvAttribute","attributes","uv","i","il","count","getX","fromBufferAttribute","processFace","beginPath","set","j","jl","length","x","y","moveTo","lineTo","closePath","stroke","divideScalar","font","fillText","addVectors","vnum"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/utils/UVsDebug.js"],"sourcesContent":["import { Vector2 } from 'three';\r\n\r\n/**\r\n * tool for \"unwrapping\" and debugging three.js geometries UV mapping\r\n *\r\n * Sample usage:\r\n *\tdocument.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) );\r\n *\r\n */\r\n\r\nvar UVsDebug = function (geometry, size) {\r\n  // handles wrapping of uv.x > 1 only\r\n  var abc = 'abc';\r\n  var a = new Vector2();\r\n  var b = new Vector2();\r\n  var uvs = [new Vector2(), new Vector2(), new Vector2()];\r\n  var face = [];\r\n  var canvas = document.createElement('canvas');\r\n  var width = size || 1024; // power of 2 required for wrapping\r\n\r\n  var height = size || 1024;\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  var ctx = canvas.getContext('2d');\r\n  ctx.lineWidth = 1;\r\n  ctx.strokeStyle = 'rgb( 63, 63, 63 )';\r\n  ctx.textAlign = 'center'; // paint background white\r\n\r\n  ctx.fillStyle = 'rgb( 255, 255, 255 )';\r\n  ctx.fillRect(0, 0, width, height);\r\n\r\n  if (geometry.isGeometry) {\r\n    console.error('THREE.UVsDebug no longer supports Geometry. Use THREE.BufferGeometry instead.');\r\n    return;\r\n  } else {\r\n    var index = geometry.index;\r\n    var uvAttribute = geometry.attributes.uv;\r\n\r\n    if (index) {\r\n      // indexed geometry\r\n      for (let i = 0, il = index.count; i < il; i += 3) {\r\n        face[0] = index.getX(i);\r\n        face[1] = index.getX(i + 1);\r\n        face[2] = index.getX(i + 2);\r\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\r\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\r\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\r\n        processFace(face, uvs, i / 3);\r\n      }\r\n    } else {\r\n      // non-indexed geometry\r\n      for (let i = 0, il = uvAttribute.count; i < il; i += 3) {\r\n        face[0] = i;\r\n        face[1] = i + 1;\r\n        face[2] = i + 2;\r\n        uvs[0].fromBufferAttribute(uvAttribute, face[0]);\r\n        uvs[1].fromBufferAttribute(uvAttribute, face[1]);\r\n        uvs[2].fromBufferAttribute(uvAttribute, face[2]);\r\n        processFace(face, uvs, i / 3);\r\n      }\r\n    }\r\n  }\r\n\r\n  return canvas;\r\n\r\n  function processFace(face, uvs, index) {\r\n    // draw contour of face\r\n    ctx.beginPath();\r\n    a.set(0, 0);\r\n\r\n    for (let j = 0, jl = uvs.length; j < jl; j++) {\r\n      var uv = uvs[j];\r\n      a.x += uv.x;\r\n      a.y += uv.y;\r\n\r\n      if (j === 0) {\r\n        ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\r\n      } else {\r\n        ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);\r\n      }\r\n    }\r\n\r\n    ctx.closePath();\r\n    ctx.stroke(); // calculate center of face\r\n\r\n    a.divideScalar(uvs.length); // label the face number\r\n\r\n    ctx.font = '18px Arial';\r\n    ctx.fillStyle = 'rgb( 63, 63, 63 )';\r\n    ctx.fillText(index, a.x * width, (1 - a.y) * height);\r\n\r\n    if (a.x > 0.95) {\r\n      // wrap x // 0.95 is arbitrary\r\n      ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);\r\n    } //\r\n\r\n\r\n    ctx.font = '12px Arial';\r\n    ctx.fillStyle = 'rgb( 191, 191, 191 )'; // label uv edge orders\r\n\r\n    for (j = 0, jl = uvs.length; j < jl; j++) {\r\n      var uv = uvs[j];\r\n      b.addVectors(a, uv).divideScalar(2);\r\n      var vnum = face[j];\r\n      ctx.fillText(abc[j] + vnum, b.x * width, (1 - b.y) * height);\r\n\r\n      if (b.x > 0.95) {\r\n        // wrap x\r\n        ctx.fillText(abc[j] + vnum, b.x % 1 * width, (1 - b.y) * height);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport { UVsDebug };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}