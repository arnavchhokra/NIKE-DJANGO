{"ast":null,"code":"import * as THREE from 'three';\nimport { version } from '../helpers/constants.js';\nclass SpotLightMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    super({\n      uniforms: {\n        depth: {\n          value: null\n        },\n        opacity: {\n          value: 1\n        },\n        attenuation: {\n          value: 2.5\n        },\n        anglePower: {\n          value: 12\n        },\n        spotPosition: {\n          value: new THREE.Vector3(0, 0, 0)\n        },\n        lightColor: {\n          value: new THREE.Color('white')\n        },\n        cameraNear: {\n          value: 0\n        },\n        cameraFar: {\n          value: 1\n        },\n        resolution: {\n          value: new THREE.Vector2(0, 0)\n        }\n      },\n      transparent: true,\n      depthWrite: false,\n      vertexShader: /* glsl */\"\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n        uniform vec3 spotPosition;\\n        uniform float attenuation;\\n\\n        #include <common>\\n        #include <logdepthbuf_pars_vertex>\\n\\n        void main() {\\n          // compute intensity\\n          vNormal = normalize(normalMatrix * normal);\\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\\n          vec4 viewPosition = viewMatrix * worldPosition;\\n          vViewZ = viewPosition.z;\\n\\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\\n\\n          gl_Position = projectionMatrix * viewPosition;\\n\\n          #include <logdepthbuf_vertex>\\n        }\\n      \",\n      fragmentShader: /* glsl */\"\\n        varying vec3 vNormal;\\n        varying float vViewZ;\\n        varying float vIntensity;\\n\\n        uniform vec3 lightColor;\\n        uniform float anglePower;\\n        uniform sampler2D depth;\\n        uniform vec2 resolution;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float opacity;\\n\\n        #include <packing>\\n        #include <logdepthbuf_pars_fragment>\\n\\n        float readDepth(sampler2D depthSampler, vec2 uv) {\\n          float fragCoordZ = texture(depthSampler, uv).r;\\n\\n          // https://github.com/mrdoob/three.js/issues/23072\\n          #ifdef USE_LOGDEPTHBUF\\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\\n          #else\\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\\n          #endif\\n\\n          return viewZ;\\n        }\\n\\n        void main() {\\n          #include <logdepthbuf_fragment>\\n\\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\\n          float intensity = vIntensity * angleIntensity;\\n\\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\\n          if (isSoft) {\\n            vec2 uv = gl_FragCoord.xy / resolution;\\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\\n          }\\n\\n          gl_FragColor = vec4(lightColor, intensity * opacity);\\n\\n          #include <tonemapping_fragment>\\n          #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n        }\\n      \")\n    });\n  }\n}\nexport { SpotLightMaterial };","map":{"version":3,"names":["THREE","version","SpotLightMaterial","ShaderMaterial","constructor","uniforms","depth","value","opacity","attenuation","anglePower","spotPosition","Vector3","lightColor","Color","cameraNear","cameraFar","resolution","Vector2","transparent","depthWrite","vertexShader","fragmentShader","concat"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/@react-three/drei/materials/SpotLightMaterial.js"],"sourcesContent":["import * as THREE from 'three';\r\nimport { version } from '../helpers/constants.js';\r\n\r\nclass SpotLightMaterial extends THREE.ShaderMaterial {\r\n  constructor() {\r\n    super({\r\n      uniforms: {\r\n        depth: {\r\n          value: null\r\n        },\r\n        opacity: {\r\n          value: 1\r\n        },\r\n        attenuation: {\r\n          value: 2.5\r\n        },\r\n        anglePower: {\r\n          value: 12\r\n        },\r\n        spotPosition: {\r\n          value: new THREE.Vector3(0, 0, 0)\r\n        },\r\n        lightColor: {\r\n          value: new THREE.Color('white')\r\n        },\r\n        cameraNear: {\r\n          value: 0\r\n        },\r\n        cameraFar: {\r\n          value: 1\r\n        },\r\n        resolution: {\r\n          value: new THREE.Vector2(0, 0)\r\n        }\r\n      },\r\n      transparent: true,\r\n      depthWrite: false,\r\n      vertexShader: /* glsl */`\r\n        varying vec3 vNormal;\r\n        varying float vViewZ;\r\n        varying float vIntensity;\r\n        uniform vec3 spotPosition;\r\n        uniform float attenuation;\r\n\r\n        #include <common>\r\n        #include <logdepthbuf_pars_vertex>\r\n\r\n        void main() {\r\n          // compute intensity\r\n          vNormal = normalize(normalMatrix * normal);\r\n          vec4 worldPosition = modelMatrix * vec4(position, 1);\r\n          vec4 viewPosition = viewMatrix * worldPosition;\r\n          vViewZ = viewPosition.z;\r\n\r\n          vIntensity = 1.0 - saturate(distance(worldPosition.xyz, spotPosition) / attenuation);\r\n\r\n          gl_Position = projectionMatrix * viewPosition;\r\n\r\n          #include <logdepthbuf_vertex>\r\n        }\r\n      `,\r\n      fragmentShader: /* glsl */`\r\n        varying vec3 vNormal;\r\n        varying float vViewZ;\r\n        varying float vIntensity;\r\n\r\n        uniform vec3 lightColor;\r\n        uniform float anglePower;\r\n        uniform sampler2D depth;\r\n        uniform vec2 resolution;\r\n        uniform float cameraNear;\r\n        uniform float cameraFar;\r\n        uniform float opacity;\r\n\r\n        #include <packing>\r\n        #include <logdepthbuf_pars_fragment>\r\n\r\n        float readDepth(sampler2D depthSampler, vec2 uv) {\r\n          float fragCoordZ = texture(depthSampler, uv).r;\r\n\r\n          // https://github.com/mrdoob/three.js/issues/23072\r\n          #ifdef USE_LOGDEPTHBUF\r\n            float viewZ = 1.0 - exp2(fragCoordZ * log(cameraFar + 1.0) / log(2.0));\r\n          #else\r\n            float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\r\n          #endif\r\n\r\n          return viewZ;\r\n        }\r\n\r\n        void main() {\r\n          #include <logdepthbuf_fragment>\r\n\r\n          vec3 normal = vec3(vNormal.x, vNormal.y, abs(vNormal.z));\r\n          float angleIntensity = pow(dot(normal, vec3(0, 0, 1)), anglePower);\r\n          float intensity = vIntensity * angleIntensity;\r\n\r\n          // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\r\n          bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\r\n          if (isSoft) {\r\n            vec2 uv = gl_FragCoord.xy / resolution;\r\n            intensity *= smoothstep(0.0, 1.0, vViewZ - readDepth(depth, uv));\r\n          }\r\n\r\n          gl_FragColor = vec4(lightColor, intensity * opacity);\r\n\r\n          #include <tonemapping_fragment>\r\n          #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\r\n        }\r\n      `\r\n    });\r\n  }\r\n}\r\n\r\nexport { SpotLightMaterial };\r\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,OAAO,QAAQ,yBAAyB;AAEjD,MAAMC,iBAAiB,SAASF,KAAK,CAACG,cAAc,CAAC;EACnDC,WAAWA,CAAA,EAAG;IACZ,KAAK,CAAC;MACJC,QAAQ,EAAE;QACRC,KAAK,EAAE;UACLC,KAAK,EAAE;QACT,CAAC;QACDC,OAAO,EAAE;UACPD,KAAK,EAAE;QACT,CAAC;QACDE,WAAW,EAAE;UACXF,KAAK,EAAE;QACT,CAAC;QACDG,UAAU,EAAE;UACVH,KAAK,EAAE;QACT,CAAC;QACDI,YAAY,EAAE;UACZJ,KAAK,EAAE,IAAIP,KAAK,CAACY,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC;QAClC,CAAC;QACDC,UAAU,EAAE;UACVN,KAAK,EAAE,IAAIP,KAAK,CAACc,KAAK,CAAC,OAAO;QAChC,CAAC;QACDC,UAAU,EAAE;UACVR,KAAK,EAAE;QACT,CAAC;QACDS,SAAS,EAAE;UACTT,KAAK,EAAE;QACT,CAAC;QACDU,UAAU,EAAE;UACVV,KAAK,EAAE,IAAIP,KAAK,CAACkB,OAAO,CAAC,CAAC,EAAE,CAAC;QAC/B;MACF,CAAC;MACDC,WAAW,EAAE,IAAI;MACjBC,UAAU,EAAE,KAAK;MACjBC,YAAY,EAAE,2uBAuBb;MACDC,cAAc,EAAE,8mDAAAC,MAAA,CA8CAtB,OAAO,IAAI,GAAG,GAAG,qBAAqB,GAAG,oBAAoB;IAG/E,CAAC,CAAC;EACJ;AACF;AAEA,SAASC,iBAAiB"},"metadata":{},"sourceType":"module","externalDependencies":[]}