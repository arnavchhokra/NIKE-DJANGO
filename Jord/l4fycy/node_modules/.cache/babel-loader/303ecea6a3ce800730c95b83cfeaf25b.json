{"ast":null,"code":"import _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _possibleConstructorReturn from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _assertThisInitialized from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\nimport { Reflector } from './Reflector.js';\nimport { Refractor } from './Refractor.js';\n/**\r\n * References:\r\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\r\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\r\n *\r\n */\n\nvar Water2 = /*#__PURE__*/function (_Mesh) {\n  _inherits(Water2, _Mesh);\n\n  var _super = _createSuper(Water2);\n\n  function Water2(geometry) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Water2);\n\n    _this = _super.call(this, geometry);\n    _this.type = 'Water';\n\n    var scope = _assertThisInitialized(_this);\n\n    var color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\n    var textureWidth = options.textureWidth || 512;\n    var textureHeight = options.textureHeight || 512;\n    var clipBias = options.clipBias || 0;\n    var flowDirection = options.flowDirection || new Vector2(1, 0);\n    var flowSpeed = options.flowSpeed || 0.03;\n    var reflectivity = options.reflectivity || 0.02;\n    var scale = options.scale || 1;\n    var shader = options.shader || Water.WaterShader;\n    var encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\n    var textureLoader = new TextureLoader();\n    var flowMap = options.flowMap || undefined;\n    var normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\n    var normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\n    var cycle = 0.15; // a cycle of a flow map phase\n\n    var halfCycle = cycle * 0.5;\n    var textureMatrix = new Matrix4();\n    var clock = new Clock(); // internal components\n\n    if (Reflector === undefined) {\n      console.error('THREE.Water: Required component Reflector not found.');\n      return _possibleConstructorReturn(_this);\n    }\n\n    if (Refractor === undefined) {\n      console.error('THREE.Water: Required component Refractor not found.');\n      return _possibleConstructorReturn(_this);\n    }\n\n    var reflector = new Reflector(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    var refractor = new Refractor(geometry, {\n      textureWidth: textureWidth,\n      textureHeight: textureHeight,\n      clipBias: clipBias,\n      encoding: encoding\n    });\n    reflector.matrixAutoUpdate = false;\n    refractor.matrixAutoUpdate = false; // material\n\n    _this.material = new ShaderMaterial({\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      transparent: true,\n      fog: true\n    });\n\n    if (flowMap !== undefined) {\n      _this.material.defines.USE_FLOWMAP = '';\n      _this.material.uniforms['tFlowMap'] = {\n        type: 't',\n        value: flowMap\n      };\n    } else {\n      _this.material.uniforms['flowDirection'] = {\n        type: 'v2',\n        value: flowDirection\n      };\n    } // maps\n\n\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\n    _this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\n    _this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\n    _this.material.uniforms['tNormalMap0'].value = normalMap0;\n    _this.material.uniforms['tNormalMap1'].value = normalMap1; // water\n\n    _this.material.uniforms['color'].value = color;\n    _this.material.uniforms['reflectivity'].value = reflectivity;\n    _this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\n\n    _this.material.uniforms['config'].value.x = 0; // flowMapOffset0\n\n    _this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\n\n    _this.material.uniforms['config'].value.z = halfCycle; // halfCycle\n\n    _this.material.uniforms['config'].value.w = scale; // scale\n    // functions\n\n    function updateTextureMatrix(camera) {\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      textureMatrix.multiply(camera.projectionMatrix);\n      textureMatrix.multiply(camera.matrixWorldInverse);\n      textureMatrix.multiply(scope.matrixWorld);\n    }\n\n    function updateFlow() {\n      var delta = clock.getDelta();\n      var config = scope.material.uniforms['config'];\n      config.value.x += flowSpeed * delta; // flowMapOffset0\n\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\n\n      if (config.value.x >= cycle) {\n        config.value.x = 0;\n        config.value.y = halfCycle;\n      } else if (config.value.y >= cycle) {\n        config.value.y = config.value.y - cycle;\n      }\n    } //\n\n\n    _this.onBeforeRender = function (renderer, scene, camera) {\n      updateTextureMatrix(camera);\n      updateFlow();\n      scope.visible = false;\n      reflector.matrixWorld.copy(scope.matrixWorld);\n      refractor.matrixWorld.copy(scope.matrixWorld);\n      reflector.onBeforeRender(renderer, scene, camera);\n      refractor.onBeforeRender(renderer, scene, camera);\n      scope.visible = true;\n    };\n\n    return _this;\n  }\n\n  return _createClass(Water2);\n}(Mesh);\n\nWater2.prototype.isWater = true;\nWater2.WaterShader = {\n  uniforms: {\n    color: {\n      type: 'c',\n      value: null\n    },\n    reflectivity: {\n      type: 'f',\n      value: 0\n    },\n    tReflectionMap: {\n      type: 't',\n      value: null\n    },\n    tRefractionMap: {\n      type: 't',\n      value: null\n    },\n    tNormalMap0: {\n      type: 't',\n      value: null\n    },\n    tNormalMap1: {\n      type: 't',\n      value: null\n    },\n    textureMatrix: {\n      type: 'm4',\n      value: null\n    },\n    config: {\n      type: 'v4',\n      value: new Vector4()\n    }\n  },\n  vertexShader:\n  /* glsl */\n  \"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\n\\t\\tuniform mat4 textureMatrix;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\tvUv = uv;\\n\\t\\t\\tvCoord = textureMatrix * vec4( position, 1.0 );\\n\\n\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\t\\t\\tvToEye = cameraPosition - worldPosition.xyz;\\n\\n\\t\\t\\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\\n\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\n\\t\\t#include <common>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\n\\t\\tuniform sampler2D tReflectionMap;\\n\\t\\tuniform sampler2D tRefractionMap;\\n\\t\\tuniform sampler2D tNormalMap0;\\n\\t\\tuniform sampler2D tNormalMap1;\\n\\n\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\tuniform sampler2D tFlowMap;\\n\\t\\t#else\\n\\t\\t\\tuniform vec2 flowDirection;\\n\\t\\t#endif\\n\\n\\t\\tuniform vec3 color;\\n\\t\\tuniform float reflectivity;\\n\\t\\tuniform vec4 config;\\n\\n\\t\\tvarying vec4 vCoord;\\n\\t\\tvarying vec2 vUv;\\n\\t\\tvarying vec3 vToEye;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\n\\t\\t\\tfloat flowMapOffset0 = config.x;\\n\\t\\t\\tfloat flowMapOffset1 = config.y;\\n\\t\\t\\tfloat halfCycle = config.z;\\n\\t\\t\\tfloat scale = config.w;\\n\\n\\t\\t\\tvec3 toEye = normalize( vToEye );\\n\\n\\t\\t\\t// determine flow direction\\n\\t\\t\\tvec2 flow;\\n\\t\\t\\t#ifdef USE_FLOWMAP\\n\\t\\t\\t\\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\\n\\t\\t\\t#else\\n\\t\\t\\t\\tflow = flowDirection;\\n\\t\\t\\t#endif\\n\\t\\t\\tflow.x *= - 1.0;\\n\\n\\t\\t\\t// sample normal maps (distort uvs with flowdata)\\n\\t\\t\\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\\n\\t\\t\\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\\n\\n\\t\\t\\t// linear interpolate to get the final normal color\\n\\t\\t\\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\\n\\t\\t\\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\\n\\n\\t\\t\\t// calculate normal vector\\n\\t\\t\\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\\n\\n\\t\\t\\t// calculate the fresnel term to blend reflection and refraction maps\\n\\t\\t\\tfloat theta = max( dot( toEye, normal ), 0.0 );\\n\\t\\t\\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\\n\\n\\t\\t\\t// calculate final uv coords\\n\\t\\t\\tvec3 coord = vCoord.xyz / vCoord.w;\\n\\t\\t\\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\\n\\n\\t\\t\\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\\n\\t\\t\\tvec4 refractColor = texture2D( tRefractionMap, uv );\\n\\n\\t\\t\\t// multiply water color with the mix of both textures\\n\\t\\t\\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t#include <fog_fragment>\\n\\n\\t\\t}\"\n};\nexport { Water2 };","map":{"version":3,"names":["Mesh","Color","Vector2","LinearEncoding","TextureLoader","Matrix4","Clock","ShaderMaterial","UniformsUtils","UniformsLib","RepeatWrapping","Vector4","Reflector","Refractor","Water2","geometry","options","type","scope","color","undefined","textureWidth","textureHeight","clipBias","flowDirection","flowSpeed","reflectivity","scale","shader","Water","WaterShader","encoding","textureLoader","flowMap","normalMap0","load","normalMap1","cycle","halfCycle","textureMatrix","clock","console","error","reflector","refractor","matrixAutoUpdate","material","uniforms","merge","vertexShader","fragmentShader","transparent","fog","defines","USE_FLOWMAP","value","wrapS","wrapT","getRenderTarget","texture","x","y","z","w","updateTextureMatrix","camera","set","multiply","projectionMatrix","matrixWorldInverse","matrixWorld","updateFlow","delta","getDelta","config","onBeforeRender","renderer","scene","visible","copy","prototype","isWater","tReflectionMap","tRefractionMap","tNormalMap0","tNormalMap1"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/objects/Water2.js"],"sourcesContent":["import { Mesh, Color, Vector2, LinearEncoding, TextureLoader, Matrix4, Clock, ShaderMaterial, UniformsUtils, UniformsLib, RepeatWrapping, Vector4 } from 'three';\r\nimport { Reflector } from './Reflector.js';\r\nimport { Refractor } from './Refractor.js';\r\n\r\n/**\r\n * References:\r\n *\thttp://www.valvesoftware.com/publications/2010/siggraph2010_vlachos_waterflow.pdf\r\n * \thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\r\n *\r\n */\r\n\r\nclass Water2 extends Mesh {\r\n  constructor(geometry, options = {}) {\r\n    super(geometry);\r\n    this.type = 'Water';\r\n    const scope = this;\r\n    const color = options.color !== undefined ? new Color(options.color) : new Color(0xffffff);\r\n    const textureWidth = options.textureWidth || 512;\r\n    const textureHeight = options.textureHeight || 512;\r\n    const clipBias = options.clipBias || 0;\r\n    const flowDirection = options.flowDirection || new Vector2(1, 0);\r\n    const flowSpeed = options.flowSpeed || 0.03;\r\n    const reflectivity = options.reflectivity || 0.02;\r\n    const scale = options.scale || 1;\r\n    const shader = options.shader || Water.WaterShader;\r\n    const encoding = options.encoding !== undefined ? options.encoding : LinearEncoding;\r\n    const textureLoader = new TextureLoader();\r\n    const flowMap = options.flowMap || undefined;\r\n    const normalMap0 = options.normalMap0 || textureLoader.load('textures/water/Water_1_M_Normal.jpg');\r\n    const normalMap1 = options.normalMap1 || textureLoader.load('textures/water/Water_2_M_Normal.jpg');\r\n    const cycle = 0.15; // a cycle of a flow map phase\r\n\r\n    const halfCycle = cycle * 0.5;\r\n    const textureMatrix = new Matrix4();\r\n    const clock = new Clock(); // internal components\r\n\r\n    if (Reflector === undefined) {\r\n      console.error('THREE.Water: Required component Reflector not found.');\r\n      return;\r\n    }\r\n\r\n    if (Refractor === undefined) {\r\n      console.error('THREE.Water: Required component Refractor not found.');\r\n      return;\r\n    }\r\n\r\n    const reflector = new Reflector(geometry, {\r\n      textureWidth: textureWidth,\r\n      textureHeight: textureHeight,\r\n      clipBias: clipBias,\r\n      encoding: encoding\r\n    });\r\n    const refractor = new Refractor(geometry, {\r\n      textureWidth: textureWidth,\r\n      textureHeight: textureHeight,\r\n      clipBias: clipBias,\r\n      encoding: encoding\r\n    });\r\n    reflector.matrixAutoUpdate = false;\r\n    refractor.matrixAutoUpdate = false; // material\r\n\r\n    this.material = new ShaderMaterial({\r\n      uniforms: UniformsUtils.merge([UniformsLib['fog'], shader.uniforms]),\r\n      vertexShader: shader.vertexShader,\r\n      fragmentShader: shader.fragmentShader,\r\n      transparent: true,\r\n      fog: true\r\n    });\r\n\r\n    if (flowMap !== undefined) {\r\n      this.material.defines.USE_FLOWMAP = '';\r\n      this.material.uniforms['tFlowMap'] = {\r\n        type: 't',\r\n        value: flowMap\r\n      };\r\n    } else {\r\n      this.material.uniforms['flowDirection'] = {\r\n        type: 'v2',\r\n        value: flowDirection\r\n      };\r\n    } // maps\r\n\r\n\r\n    normalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\r\n    normalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\r\n    this.material.uniforms['tReflectionMap'].value = reflector.getRenderTarget().texture;\r\n    this.material.uniforms['tRefractionMap'].value = refractor.getRenderTarget().texture;\r\n    this.material.uniforms['tNormalMap0'].value = normalMap0;\r\n    this.material.uniforms['tNormalMap1'].value = normalMap1; // water\r\n\r\n    this.material.uniforms['color'].value = color;\r\n    this.material.uniforms['reflectivity'].value = reflectivity;\r\n    this.material.uniforms['textureMatrix'].value = textureMatrix; // inital values\r\n\r\n    this.material.uniforms['config'].value.x = 0; // flowMapOffset0\r\n\r\n    this.material.uniforms['config'].value.y = halfCycle; // flowMapOffset1\r\n\r\n    this.material.uniforms['config'].value.z = halfCycle; // halfCycle\r\n\r\n    this.material.uniforms['config'].value.w = scale; // scale\r\n    // functions\r\n\r\n    function updateTextureMatrix(camera) {\r\n      textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\r\n      textureMatrix.multiply(camera.projectionMatrix);\r\n      textureMatrix.multiply(camera.matrixWorldInverse);\r\n      textureMatrix.multiply(scope.matrixWorld);\r\n    }\r\n\r\n    function updateFlow() {\r\n      const delta = clock.getDelta();\r\n      const config = scope.material.uniforms['config'];\r\n      config.value.x += flowSpeed * delta; // flowMapOffset0\r\n\r\n      config.value.y = config.value.x + halfCycle; // flowMapOffset1\r\n      // Important: The distance between offsets should be always the value of \"halfCycle\".\r\n      // Moreover, both offsets should be in the range of [ 0, cycle ].\r\n      // This approach ensures a smooth water flow and avoids \"reset\" effects.\r\n\r\n      if (config.value.x >= cycle) {\r\n        config.value.x = 0;\r\n        config.value.y = halfCycle;\r\n      } else if (config.value.y >= cycle) {\r\n        config.value.y = config.value.y - cycle;\r\n      }\r\n    } //\r\n\r\n\r\n    this.onBeforeRender = function (renderer, scene, camera) {\r\n      updateTextureMatrix(camera);\r\n      updateFlow();\r\n      scope.visible = false;\r\n      reflector.matrixWorld.copy(scope.matrixWorld);\r\n      refractor.matrixWorld.copy(scope.matrixWorld);\r\n      reflector.onBeforeRender(renderer, scene, camera);\r\n      refractor.onBeforeRender(renderer, scene, camera);\r\n      scope.visible = true;\r\n    };\r\n  }\r\n\r\n}\r\n\r\nWater2.prototype.isWater = true;\r\nWater2.WaterShader = {\r\n  uniforms: {\r\n    color: {\r\n      type: 'c',\r\n      value: null\r\n    },\r\n    reflectivity: {\r\n      type: 'f',\r\n      value: 0\r\n    },\r\n    tReflectionMap: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    tRefractionMap: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    tNormalMap0: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    tNormalMap1: {\r\n      type: 't',\r\n      value: null\r\n    },\r\n    textureMatrix: {\r\n      type: 'm4',\r\n      value: null\r\n    },\r\n    config: {\r\n      type: 'v4',\r\n      value: new Vector4()\r\n    }\r\n  },\r\n  vertexShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\tuniform mat4 textureMatrix;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\r\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\r\n\r\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}`,\r\n  fragmentShader:\r\n  /* glsl */\r\n  `\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\r\n\t\tuniform sampler2D tReflectionMap;\r\n\t\tuniform sampler2D tRefractionMap;\r\n\t\tuniform sampler2D tNormalMap0;\r\n\t\tuniform sampler2D tNormalMap1;\r\n\r\n\t\t#ifdef USE_FLOWMAP\r\n\t\t\tuniform sampler2D tFlowMap;\r\n\t\t#else\r\n\t\t\tuniform vec2 flowDirection;\r\n\t\t#endif\r\n\r\n\t\tuniform vec3 color;\r\n\t\tuniform float reflectivity;\r\n\t\tuniform vec4 config;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\r\n\t\t\tfloat flowMapOffset0 = config.x;\r\n\t\t\tfloat flowMapOffset1 = config.y;\r\n\t\t\tfloat halfCycle = config.z;\r\n\t\t\tfloat scale = config.w;\r\n\r\n\t\t\tvec3 toEye = normalize( vToEye );\r\n\r\n\t\t\t// determine flow direction\r\n\t\t\tvec2 flow;\r\n\t\t\t#ifdef USE_FLOWMAP\r\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\r\n\t\t\t#else\r\n\t\t\t\tflow = flowDirection;\r\n\t\t\t#endif\r\n\t\t\tflow.x *= - 1.0;\r\n\r\n\t\t\t// sample normal maps (distort uvs with flowdata)\r\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\r\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\r\n\r\n\t\t\t// linear interpolate to get the final normal color\r\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\r\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\r\n\r\n\t\t\t// calculate normal vector\r\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\r\n\r\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\r\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\r\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\r\n\r\n\t\t\t// calculate final uv coords\r\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\r\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\r\n\r\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\r\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\r\n\r\n\t\t\t// multiply water color with the mix of both textures\r\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\r\n\t\t}`\r\n};\r\n\r\nexport { Water2 };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}