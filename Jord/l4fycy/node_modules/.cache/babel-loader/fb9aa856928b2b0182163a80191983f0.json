{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TreeBuilder = void 0;\n\nvar cst_1 = require(\"../../cst/cst\");\n\nvar noop_1 = __importDefault(require(\"lodash/noop\"));\n\nvar has_1 = __importDefault(require(\"lodash/has\"));\n\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\n\nvar isUndefined_1 = __importDefault(require(\"lodash/isUndefined\"));\n\nvar cst_visitor_1 = require(\"../../cst/cst_visitor\");\n\nvar parser_1 = require(\"../parser\");\n/**\r\n * This trait is responsible for the CST building logic.\r\n */\n\n\nvar TreeBuilder =\n/** @class */\nfunction () {\n  function TreeBuilder() {}\n\n  TreeBuilder.prototype.initTreeBuilder = function (config) {\n    this.CST_STACK = []; // outputCst is no longer exposed/defined in the pubic API\n\n    this.outputCst = config.outputCst;\n    this.nodeLocationTracking = (0, has_1.default)(config, \"nodeLocationTracking\") ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n    : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n\n    if (!this.outputCst) {\n      this.cstInvocationStateUpdate = noop_1.default;\n      this.cstFinallyStateUpdate = noop_1.default;\n      this.cstPostTerminal = noop_1.default;\n      this.cstPostNonTerminal = noop_1.default;\n      this.cstPostRule = noop_1.default;\n    } else {\n      if (/full/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationFull;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationFull;\n          this.cstPostRule = noop_1.default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_1.default;\n          this.setNodeLocationFromNode = noop_1.default;\n          this.cstPostRule = this.cstPostRuleFull;\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n        }\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n        if (this.recoveryEnabled) {\n          this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;\n          this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;\n          this.cstPostRule = noop_1.default;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;\n        } else {\n          this.setNodeLocationFromToken = noop_1.default;\n          this.setNodeLocationFromNode = noop_1.default;\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\n          this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;\n        }\n      } else if (/none/i.test(this.nodeLocationTracking)) {\n        this.setNodeLocationFromToken = noop_1.default;\n        this.setNodeLocationFromNode = noop_1.default;\n        this.cstPostRule = noop_1.default;\n        this.setInitialNodeLocation = noop_1.default;\n      } else {\n        throw Error(\"Invalid <nodeLocationTracking> config option: \\\"\".concat(config.nodeLocationTracking, \"\\\"\"));\n      }\n    }\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationOnlyOffsetRegular = function (cstNode) {\n    cstNode.location = {\n      // without error recovery the starting Location of a new CstNode is guaranteed\n      // To be the next Token's startOffset (for valid inputs).\n      // For invalid inputs there won't be any CSTOutput so this potential\n      // inaccuracy does not matter\n      startOffset: this.LA(1).startOffset,\n      endOffset: NaN\n    };\n  };\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRecovery = function (cstNode) {\n    cstNode.location = {\n      startOffset: NaN,\n      startLine: NaN,\n      startColumn: NaN,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n  /**\r\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\r\n         * @param cstNode\r\n     */\n\n\n  TreeBuilder.prototype.setInitialNodeLocationFullRegular = function (cstNode) {\n    var nextToken = this.LA(1);\n    cstNode.location = {\n      startOffset: nextToken.startOffset,\n      startLine: nextToken.startLine,\n      startColumn: nextToken.startColumn,\n      endOffset: NaN,\n      endLine: NaN,\n      endColumn: NaN\n    };\n  };\n\n  TreeBuilder.prototype.cstInvocationStateUpdate = function (fullRuleName) {\n    var cstNode = {\n      name: fullRuleName,\n      children: Object.create(null)\n    };\n    this.setInitialNodeLocation(cstNode);\n    this.CST_STACK.push(cstNode);\n  };\n\n  TreeBuilder.prototype.cstFinallyStateUpdate = function () {\n    this.CST_STACK.pop();\n  };\n\n  TreeBuilder.prototype.cstPostRuleFull = function (ruleCstNode) {\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n    var prevToken = this.LA(0);\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n      loc.endLine = prevToken.endLine;\n      loc.endColumn = prevToken.endColumn;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n      loc.startLine = NaN;\n      loc.startColumn = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostRuleOnlyOffset = function (ruleCstNode) {\n    var prevToken = this.LA(0); // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n\n    var loc = ruleCstNode.location; // If this condition is true it means we consumed at least one Token\n    // In this CstNode.\n\n    if (loc.startOffset <= prevToken.startOffset === true) {\n      loc.endOffset = prevToken.endOffset;\n    } // \"empty\" CstNode edge case\n    else {\n      loc.startOffset = NaN;\n    }\n  };\n\n  TreeBuilder.prototype.cstPostTerminal = function (key, consumedToken) {\n    var rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n    (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromToken(rootCst.location, consumedToken);\n  };\n\n  TreeBuilder.prototype.cstPostNonTerminal = function (ruleCstResult, ruleName) {\n    var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n    (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult); // This is only used when **both** error recovery and CST Output are enabled.\n\n    this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructor = function () {\n    if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {\n      var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n      return newBaseCstVisitorConstructor;\n    }\n\n    return this.baseCstVisitorConstructor;\n  };\n\n  TreeBuilder.prototype.getBaseCstVisitorConstructorWithDefaults = function () {\n    if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {\n      var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n      return newConstructor;\n    }\n\n    return this.baseCstVisitorWithDefaultsConstructor;\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 1];\n  };\n\n  TreeBuilder.prototype.getPreviousExplicitRuleShortName = function () {\n    var ruleStack = this.RULE_STACK;\n    return ruleStack[ruleStack.length - 2];\n  };\n\n  TreeBuilder.prototype.getLastExplicitRuleOccurrenceIndex = function () {\n    var occurrenceStack = this.RULE_OCCURRENCE_STACK;\n    return occurrenceStack[occurrenceStack.length - 1];\n  };\n\n  return TreeBuilder;\n}();\n\nexports.TreeBuilder = TreeBuilder;","map":{"version":3,"mappings":"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","names":["TreeBuilder","config","CST_STACK","outputCst","nodeLocationTracking","parser_1","cstInvocationStateUpdate","noop_1","cstFinallyStateUpdate","cstPostTerminal","cstPostNonTerminal","cstPostRule","test","recoveryEnabled","setNodeLocationFromToken","cst_1","setNodeLocationFromNode","setInitialNodeLocation","setInitialNodeLocationFullRecovery","cstPostRuleFull","setInitialNodeLocationFullRegular","setInitialNodeLocationOnlyOffsetRecovery","cstPostRuleOnlyOffset","setInitialNodeLocationOnlyOffsetRegular","Error","cstNode","location","startOffset","NaN","endOffset","LA","startLine","startColumn","endLine","endColumn","nextToken","fullRuleName","name","children","Object","create","push","pop","ruleCstNode","prevToken","loc","key","consumedToken","rootCst","length","ruleCstResult","ruleName","preCstNode","baseCstVisitorConstructor","newBaseCstVisitorConstructor","className","gastProductionsCache","baseCstVisitorWithDefaultsConstructor","newConstructor","getBaseCstVisitorConstructor","ruleStack","RULE_STACK","occurrenceStack","RULE_OCCURRENCE_STACK","exports"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\chevrotain\\src\\parse\\parser\\traits\\tree_builder.ts"],"sourcesContent":["import {\r\n  addNoneTerminalToCst,\r\n  addTerminalToCst,\r\n  setNodeLocationFull,\r\n  setNodeLocationOnlyOffset\r\n} from \"../../cst/cst\"\r\nimport noop from \"lodash/noop\"\r\nimport has from \"lodash/has\"\r\nimport keys from \"lodash/keys\"\r\nimport isUndefined from \"lodash/isUndefined\"\r\nimport {\r\n  createBaseSemanticVisitorConstructor,\r\n  createBaseVisitorConstructorWithDefaults\r\n} from \"../../cst/cst_visitor\"\r\nimport {\r\n  CstNode,\r\n  CstNodeLocation,\r\n  ICstVisitor,\r\n  IParserConfig,\r\n  IToken,\r\n  nodeLocationTrackingOptions\r\n} from \"@chevrotain/types\"\r\nimport { MixedInParser } from \"./parser_traits\"\r\nimport { DEFAULT_PARSER_CONFIG } from \"../parser\"\r\n\r\n/**\r\n * This trait is responsible for the CST building logic.\r\n */\r\nexport class TreeBuilder {\r\n  outputCst: boolean\r\n  CST_STACK: CstNode[]\r\n  baseCstVisitorConstructor: Function\r\n  baseCstVisitorWithDefaultsConstructor: Function\r\n\r\n  // dynamically assigned Methods\r\n  setNodeLocationFromNode: (\r\n    nodeLocation: CstNodeLocation,\r\n    locationInformation: CstNodeLocation\r\n  ) => void\r\n  setNodeLocationFromToken: (\r\n    nodeLocation: CstNodeLocation,\r\n    locationInformation: CstNodeLocation\r\n  ) => void\r\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void\r\n\r\n  setInitialNodeLocation: (cstNode: CstNode) => void\r\n  nodeLocationTracking: nodeLocationTrackingOptions\r\n\r\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\r\n    this.CST_STACK = []\r\n\r\n    // outputCst is no longer exposed/defined in the pubic API\r\n    this.outputCst = (config as any).outputCst\r\n\r\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\r\n      ? (config.nodeLocationTracking as nodeLocationTrackingOptions) // assumes end user provides the correct config value/type\r\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking\r\n\r\n    if (!this.outputCst) {\r\n      this.cstInvocationStateUpdate = noop\r\n      this.cstFinallyStateUpdate = noop\r\n      this.cstPostTerminal = noop\r\n      this.cstPostNonTerminal = noop\r\n      this.cstPostRule = noop\r\n    } else {\r\n      if (/full/i.test(this.nodeLocationTracking)) {\r\n        if (this.recoveryEnabled) {\r\n          this.setNodeLocationFromToken = setNodeLocationFull\r\n          this.setNodeLocationFromNode = setNodeLocationFull\r\n          this.cstPostRule = noop\r\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery\r\n        } else {\r\n          this.setNodeLocationFromToken = noop\r\n          this.setNodeLocationFromNode = noop\r\n          this.cstPostRule = this.cstPostRuleFull\r\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular\r\n        }\r\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\r\n        if (this.recoveryEnabled) {\r\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset\r\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset\r\n          this.cstPostRule = noop\r\n          this.setInitialNodeLocation =\r\n            this.setInitialNodeLocationOnlyOffsetRecovery\r\n        } else {\r\n          this.setNodeLocationFromToken = noop\r\n          this.setNodeLocationFromNode = noop\r\n          this.cstPostRule = this.cstPostRuleOnlyOffset\r\n          this.setInitialNodeLocation =\r\n            this.setInitialNodeLocationOnlyOffsetRegular\r\n        }\r\n      } else if (/none/i.test(this.nodeLocationTracking)) {\r\n        this.setNodeLocationFromToken = noop\r\n        this.setNodeLocationFromNode = noop\r\n        this.cstPostRule = noop\r\n        this.setInitialNodeLocation = noop\r\n      } else {\r\n        throw Error(\r\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  setInitialNodeLocationOnlyOffsetRecovery(\r\n    this: MixedInParser,\r\n    cstNode: any\r\n  ): void {\r\n    cstNode.location = {\r\n      startOffset: NaN,\r\n      endOffset: NaN\r\n    }\r\n  }\r\n\r\n  setInitialNodeLocationOnlyOffsetRegular(\r\n    this: MixedInParser,\r\n    cstNode: any\r\n  ): void {\r\n    cstNode.location = {\r\n      // without error recovery the starting Location of a new CstNode is guaranteed\r\n      // To be the next Token's startOffset (for valid inputs).\r\n      // For invalid inputs there won't be any CSTOutput so this potential\r\n      // inaccuracy does not matter\r\n      startOffset: this.LA(1).startOffset,\r\n      endOffset: NaN\r\n    }\r\n  }\r\n\r\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\r\n    cstNode.location = {\r\n      startOffset: NaN,\r\n      startLine: NaN,\r\n      startColumn: NaN,\r\n      endOffset: NaN,\r\n      endLine: NaN,\r\n      endColumn: NaN\r\n    }\r\n  }\r\n\r\n  /**\r\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\r\n\r\n     * @param cstNode\r\n     */\r\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\r\n    const nextToken = this.LA(1)\r\n    cstNode.location = {\r\n      startOffset: nextToken.startOffset,\r\n      startLine: nextToken.startLine,\r\n      startColumn: nextToken.startColumn,\r\n      endOffset: NaN,\r\n      endLine: NaN,\r\n      endColumn: NaN\r\n    }\r\n  }\r\n\r\n  cstInvocationStateUpdate(this: MixedInParser, fullRuleName: string): void {\r\n    const cstNode: CstNode = {\r\n      name: fullRuleName,\r\n      children: Object.create(null)\r\n    }\r\n\r\n    this.setInitialNodeLocation(cstNode)\r\n    this.CST_STACK.push(cstNode)\r\n  }\r\n\r\n  cstFinallyStateUpdate(this: MixedInParser): void {\r\n    this.CST_STACK.pop()\r\n  }\r\n\r\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\r\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\r\n    const prevToken = this.LA(0) as Required<CstNodeLocation>\r\n    const loc = ruleCstNode.location as Required<CstNodeLocation>\r\n\r\n    // If this condition is true it means we consumed at least one Token\r\n    // In this CstNode.\r\n    if (loc.startOffset <= prevToken.startOffset === true) {\r\n      loc.endOffset = prevToken.endOffset\r\n      loc.endLine = prevToken.endLine\r\n      loc.endColumn = prevToken.endColumn\r\n    }\r\n    // \"empty\" CstNode edge case\r\n    else {\r\n      loc.startOffset = NaN\r\n      loc.startLine = NaN\r\n      loc.startColumn = NaN\r\n    }\r\n  }\r\n\r\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\r\n    const prevToken = this.LA(0)\r\n    // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\r\n    const loc = ruleCstNode.location!\r\n\r\n    // If this condition is true it means we consumed at least one Token\r\n    // In this CstNode.\r\n    if (loc.startOffset <= prevToken.startOffset === true) {\r\n      loc.endOffset = prevToken.endOffset\r\n    }\r\n    // \"empty\" CstNode edge case\r\n    else {\r\n      loc.startOffset = NaN\r\n    }\r\n  }\r\n\r\n  cstPostTerminal(\r\n    this: MixedInParser,\r\n    key: string,\r\n    consumedToken: IToken\r\n  ): void {\r\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1]\r\n    addTerminalToCst(rootCst, consumedToken, key)\r\n    // This is only used when **both** error recovery and CST Output are enabled.\r\n    this.setNodeLocationFromToken(rootCst.location!, <any>consumedToken)\r\n  }\r\n\r\n  cstPostNonTerminal(\r\n    this: MixedInParser,\r\n    ruleCstResult: CstNode,\r\n    ruleName: string\r\n  ): void {\r\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1]\r\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult)\r\n    // This is only used when **both** error recovery and CST Output are enabled.\r\n    this.setNodeLocationFromNode(preCstNode.location!, ruleCstResult.location!)\r\n  }\r\n\r\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\r\n    this: MixedInParser\r\n  ): {\r\n    new (...args: any[]): ICstVisitor<IN, OUT>\r\n  } {\r\n    if (isUndefined(this.baseCstVisitorConstructor)) {\r\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\r\n        this.className,\r\n        keys(this.gastProductionsCache)\r\n      )\r\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor\r\n      return newBaseCstVisitorConstructor\r\n    }\r\n\r\n    return <any>this.baseCstVisitorConstructor\r\n  }\r\n\r\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\r\n    this: MixedInParser\r\n  ): {\r\n    new (...args: any[]): ICstVisitor<IN, OUT>\r\n  } {\r\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\r\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\r\n        this.className,\r\n        keys(this.gastProductionsCache),\r\n        this.getBaseCstVisitorConstructor()\r\n      )\r\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor\r\n      return newConstructor\r\n    }\r\n\r\n    return <any>this.baseCstVisitorWithDefaultsConstructor\r\n  }\r\n\r\n  getLastExplicitRuleShortName(this: MixedInParser): number {\r\n    const ruleStack = this.RULE_STACK\r\n    return ruleStack[ruleStack.length - 1]\r\n  }\r\n\r\n  getPreviousExplicitRuleShortName(this: MixedInParser): number {\r\n    const ruleStack = this.RULE_STACK\r\n    return ruleStack[ruleStack.length - 2]\r\n  }\r\n\r\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\r\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK\r\n    return occurrenceStack[occurrenceStack.length - 1]\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}