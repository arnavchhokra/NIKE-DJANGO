{"ast":null,"code":";\n\n(function (root, factory) {\n  // istanbul ignore next\n  if (typeof define === \"function\" && define.amd) {\n    // istanbul ignore next\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    // istanbul ignore next\n    root.regexpToAst = factory();\n  }\n})(typeof self !== \"undefined\" ? // istanbul ignore next\nself : this, function () {\n  // references\n  // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n  // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n  function RegExpParser() {}\n\n  RegExpParser.prototype.saveState = function () {\n    return {\n      idx: this.idx,\n      input: this.input,\n      groupIdx: this.groupIdx\n    };\n  };\n\n  RegExpParser.prototype.restoreState = function (newState) {\n    this.idx = newState.idx;\n    this.input = newState.input;\n    this.groupIdx = newState.groupIdx;\n  };\n\n  RegExpParser.prototype.pattern = function (input) {\n    // parser state\n    this.idx = 0;\n    this.input = input;\n    this.groupIdx = 0;\n    this.consumeChar(\"/\");\n    var value = this.disjunction();\n    this.consumeChar(\"/\");\n    var flags = {\n      type: \"Flags\",\n      loc: {\n        begin: this.idx,\n        end: input.length\n      },\n      global: false,\n      ignoreCase: false,\n      multiLine: false,\n      unicode: false,\n      sticky: false\n    };\n\n    while (this.isRegExpFlag()) {\n      switch (this.popChar()) {\n        case \"g\":\n          addFlag(flags, \"global\");\n          break;\n\n        case \"i\":\n          addFlag(flags, \"ignoreCase\");\n          break;\n\n        case \"m\":\n          addFlag(flags, \"multiLine\");\n          break;\n\n        case \"u\":\n          addFlag(flags, \"unicode\");\n          break;\n\n        case \"y\":\n          addFlag(flags, \"sticky\");\n          break;\n      }\n    }\n\n    if (this.idx !== this.input.length) {\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\n    }\n\n    return {\n      type: \"Pattern\",\n      flags: flags,\n      value: value,\n      loc: this.loc(0)\n    };\n  };\n\n  RegExpParser.prototype.disjunction = function () {\n    var alts = [];\n    var begin = this.idx;\n    alts.push(this.alternative());\n\n    while (this.peekChar() === \"|\") {\n      this.consumeChar(\"|\");\n      alts.push(this.alternative());\n    }\n\n    return {\n      type: \"Disjunction\",\n      value: alts,\n      loc: this.loc(begin)\n    };\n  };\n\n  RegExpParser.prototype.alternative = function () {\n    var terms = [];\n    var begin = this.idx;\n\n    while (this.isTerm()) {\n      terms.push(this.term());\n    }\n\n    return {\n      type: \"Alternative\",\n      value: terms,\n      loc: this.loc(begin)\n    };\n  };\n\n  RegExpParser.prototype.term = function () {\n    if (this.isAssertion()) {\n      return this.assertion();\n    } else {\n      return this.atom();\n    }\n  };\n\n  RegExpParser.prototype.assertion = function () {\n    var begin = this.idx;\n\n    switch (this.popChar()) {\n      case \"^\":\n        return {\n          type: \"StartAnchor\",\n          loc: this.loc(begin)\n        };\n\n      case \"$\":\n        return {\n          type: \"EndAnchor\",\n          loc: this.loc(begin)\n        };\n      // '\\b' or '\\B'\n\n      case \"\\\\\":\n        switch (this.popChar()) {\n          case \"b\":\n            return {\n              type: \"WordBoundary\",\n              loc: this.loc(begin)\n            };\n\n          case \"B\":\n            return {\n              type: \"NonWordBoundary\",\n              loc: this.loc(begin)\n            };\n        } // istanbul ignore next\n\n\n        throw Error(\"Invalid Assertion Escape\");\n      // '(?=' or '(?!'\n\n      case \"(\":\n        this.consumeChar(\"?\");\n        var type;\n\n        switch (this.popChar()) {\n          case \"=\":\n            type = \"Lookahead\";\n            break;\n\n          case \"!\":\n            type = \"NegativeLookahead\";\n            break;\n        }\n\n        ASSERT_EXISTS(type);\n        var disjunction = this.disjunction();\n        this.consumeChar(\")\");\n        return {\n          type: type,\n          value: disjunction,\n          loc: this.loc(begin)\n        };\n    } // istanbul ignore next\n\n\n    ASSERT_NEVER_REACH_HERE();\n  };\n\n  RegExpParser.prototype.quantifier = function (isBacktracking) {\n    var range;\n    var begin = this.idx;\n\n    switch (this.popChar()) {\n      case \"*\":\n        range = {\n          atLeast: 0,\n          atMost: Infinity\n        };\n        break;\n\n      case \"+\":\n        range = {\n          atLeast: 1,\n          atMost: Infinity\n        };\n        break;\n\n      case \"?\":\n        range = {\n          atLeast: 0,\n          atMost: 1\n        };\n        break;\n\n      case \"{\":\n        var atLeast = this.integerIncludingZero();\n\n        switch (this.popChar()) {\n          case \"}\":\n            range = {\n              atLeast: atLeast,\n              atMost: atLeast\n            };\n            break;\n\n          case \",\":\n            var atMost;\n\n            if (this.isDigit()) {\n              atMost = this.integerIncludingZero();\n              range = {\n                atLeast: atLeast,\n                atMost: atMost\n              };\n            } else {\n              range = {\n                atLeast: atLeast,\n                atMost: Infinity\n              };\n            }\n\n            this.consumeChar(\"}\");\n            break;\n        } // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n        // causes severe performance degradations\n\n\n        if (isBacktracking === true && range === undefined) {\n          return undefined;\n        }\n\n        ASSERT_EXISTS(range);\n        break;\n    } // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n    // causes severe performance degradations\n\n\n    if (isBacktracking === true && range === undefined) {\n      return undefined;\n    }\n\n    ASSERT_EXISTS(range);\n\n    if (this.peekChar(0) === \"?\") {\n      this.consumeChar(\"?\");\n      range.greedy = false;\n    } else {\n      range.greedy = true;\n    }\n\n    range.type = \"Quantifier\";\n    range.loc = this.loc(begin);\n    return range;\n  };\n\n  RegExpParser.prototype.atom = function () {\n    var atom;\n    var begin = this.idx;\n\n    switch (this.peekChar()) {\n      case \".\":\n        atom = this.dotAll();\n        break;\n\n      case \"\\\\\":\n        atom = this.atomEscape();\n        break;\n\n      case \"[\":\n        atom = this.characterClass();\n        break;\n\n      case \"(\":\n        atom = this.group();\n        break;\n    }\n\n    if (atom === undefined && this.isPatternCharacter()) {\n      atom = this.patternCharacter();\n    }\n\n    ASSERT_EXISTS(atom);\n    atom.loc = this.loc(begin);\n\n    if (this.isQuantifier()) {\n      atom.quantifier = this.quantifier();\n    }\n\n    return atom;\n  };\n\n  RegExpParser.prototype.dotAll = function () {\n    this.consumeChar(\".\");\n    return {\n      type: \"Set\",\n      complement: true,\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n    };\n  };\n\n  RegExpParser.prototype.atomEscape = function () {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        return this.decimalEscapeAtom();\n\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n\n      case \"0\":\n        return this.nulCharacterAtom();\n\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n\n  RegExpParser.prototype.decimalEscapeAtom = function () {\n    var value = this.positiveInteger();\n    return {\n      type: \"GroupBackReference\",\n      value: value\n    };\n  };\n\n  RegExpParser.prototype.characterClassEscape = function () {\n    var set;\n    var complement = false;\n\n    switch (this.popChar()) {\n      case \"d\":\n        set = digitsCharCodes;\n        break;\n\n      case \"D\":\n        set = digitsCharCodes;\n        complement = true;\n        break;\n\n      case \"s\":\n        set = whitespaceCodes;\n        break;\n\n      case \"S\":\n        set = whitespaceCodes;\n        complement = true;\n        break;\n\n      case \"w\":\n        set = wordCharCodes;\n        break;\n\n      case \"W\":\n        set = wordCharCodes;\n        complement = true;\n        break;\n    }\n\n    ASSERT_EXISTS(set);\n    return {\n      type: \"Set\",\n      value: set,\n      complement: complement\n    };\n  };\n\n  RegExpParser.prototype.controlEscapeAtom = function () {\n    var escapeCode;\n\n    switch (this.popChar()) {\n      case \"f\":\n        escapeCode = cc(\"\\f\");\n        break;\n\n      case \"n\":\n        escapeCode = cc(\"\\n\");\n        break;\n\n      case \"r\":\n        escapeCode = cc(\"\\r\");\n        break;\n\n      case \"t\":\n        escapeCode = cc(\"\\t\");\n        break;\n\n      case \"v\":\n        escapeCode = cc(\"\\v\");\n        break;\n    }\n\n    ASSERT_EXISTS(escapeCode);\n    return {\n      type: \"Character\",\n      value: escapeCode\n    };\n  };\n\n  RegExpParser.prototype.controlLetterEscapeAtom = function () {\n    this.consumeChar(\"c\");\n    var letter = this.popChar();\n\n    if (/[a-zA-Z]/.test(letter) === false) {\n      throw Error(\"Invalid \");\n    }\n\n    var letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n    return {\n      type: \"Character\",\n      value: letterCode\n    };\n  };\n\n  RegExpParser.prototype.nulCharacterAtom = function () {\n    // TODO implement '[lookahead ∉ DecimalDigit]'\n    // TODO: for the deprecated octal escape sequence\n    this.consumeChar(\"0\");\n    return {\n      type: \"Character\",\n      value: cc(\"\\0\")\n    };\n  };\n\n  RegExpParser.prototype.hexEscapeSequenceAtom = function () {\n    this.consumeChar(\"x\");\n    return this.parseHexDigits(2);\n  };\n\n  RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function () {\n    this.consumeChar(\"u\");\n    return this.parseHexDigits(4);\n  };\n\n  RegExpParser.prototype.identityEscapeAtom = function () {\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n    var escapedChar = this.popChar();\n    return {\n      type: \"Character\",\n      value: cc(escapedChar)\n    };\n  };\n\n  RegExpParser.prototype.classPatternCharacterAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\": // istanbul ignore next\n\n      case \"\\\\\": // istanbul ignore next\n\n      case \"]\":\n        throw Error(\"TBD\");\n\n      default:\n        var nextChar = this.popChar();\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n\n  RegExpParser.prototype.characterClass = function () {\n    var set = [];\n    var complement = false;\n    this.consumeChar(\"[\");\n\n    if (this.peekChar(0) === \"^\") {\n      this.consumeChar(\"^\");\n      complement = true;\n    }\n\n    while (this.isClassAtom()) {\n      var from = this.classAtom();\n      var isFromSingleChar = from.type === \"Character\";\n\n      if (isFromSingleChar && this.isRangeDash()) {\n        this.consumeChar(\"-\");\n        var to = this.classAtom();\n        var isToSingleChar = to.type === \"Character\"; // a range can only be used when both sides are single characters\n\n        if (isToSingleChar) {\n          if (to.value < from.value) {\n            throw Error(\"Range out of order in character class\");\n          }\n\n          set.push({\n            from: from.value,\n            to: to.value\n          });\n        } else {\n          // literal dash\n          insertToSet(from.value, set);\n          set.push(cc(\"-\"));\n          insertToSet(to.value, set);\n        }\n      } else {\n        insertToSet(from.value, set);\n      }\n    }\n\n    this.consumeChar(\"]\");\n    return {\n      type: \"Set\",\n      complement: complement,\n      value: set\n    };\n  };\n\n  RegExpParser.prototype.classAtom = function () {\n    switch (this.peekChar()) {\n      // istanbul ignore next\n      case \"]\": // istanbul ignore next\n\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\":\n        throw Error(\"TBD\");\n\n      case \"\\\\\":\n        return this.classEscape();\n\n      default:\n        return this.classPatternCharacterAtom();\n    }\n  };\n\n  RegExpParser.prototype.classEscape = function () {\n    this.consumeChar(\"\\\\\");\n\n    switch (this.peekChar()) {\n      // Matches a backspace.\n      // (Not to be confused with \\b word boundary outside characterClass)\n      case \"b\":\n        this.consumeChar(\"b\");\n        return {\n          type: \"Character\",\n          value: cc(\"\\b\")\n        };\n\n      case \"d\":\n      case \"D\":\n      case \"s\":\n      case \"S\":\n      case \"w\":\n      case \"W\":\n        return this.characterClassEscape();\n\n      case \"f\":\n      case \"n\":\n      case \"r\":\n      case \"t\":\n      case \"v\":\n        return this.controlEscapeAtom();\n\n      case \"c\":\n        return this.controlLetterEscapeAtom();\n\n      case \"0\":\n        return this.nulCharacterAtom();\n\n      case \"x\":\n        return this.hexEscapeSequenceAtom();\n\n      case \"u\":\n        return this.regExpUnicodeEscapeSequenceAtom();\n\n      default:\n        return this.identityEscapeAtom();\n    }\n  };\n\n  RegExpParser.prototype.group = function () {\n    var capturing = true;\n    this.consumeChar(\"(\");\n\n    switch (this.peekChar(0)) {\n      case \"?\":\n        this.consumeChar(\"?\");\n        this.consumeChar(\":\");\n        capturing = false;\n        break;\n\n      default:\n        this.groupIdx++;\n        break;\n    }\n\n    var value = this.disjunction();\n    this.consumeChar(\")\");\n    var groupAst = {\n      type: \"Group\",\n      capturing: capturing,\n      value: value\n    };\n\n    if (capturing) {\n      groupAst.idx = this.groupIdx;\n    }\n\n    return groupAst;\n  };\n\n  RegExpParser.prototype.positiveInteger = function () {\n    var number = this.popChar(); // istanbul ignore next - can't ever get here due to previous lookahead checks\n    // still implementing this error checking in case this ever changes.\n\n    if (decimalPatternNoZero.test(number) === false) {\n      throw Error(\"Expecting a positive integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  };\n\n  RegExpParser.prototype.integerIncludingZero = function () {\n    var number = this.popChar();\n\n    if (decimalPattern.test(number) === false) {\n      throw Error(\"Expecting an integer\");\n    }\n\n    while (decimalPattern.test(this.peekChar(0))) {\n      number += this.popChar();\n    }\n\n    return parseInt(number, 10);\n  };\n\n  RegExpParser.prototype.patternCharacter = function () {\n    var nextChar = this.popChar();\n\n    switch (nextChar) {\n      // istanbul ignore next\n      case \"\\n\": // istanbul ignore next\n\n      case \"\\r\": // istanbul ignore next\n\n      case \"\\u2028\": // istanbul ignore next\n\n      case \"\\u2029\": // istanbul ignore next\n\n      case \"^\": // istanbul ignore next\n\n      case \"$\": // istanbul ignore next\n\n      case \"\\\\\": // istanbul ignore next\n\n      case \".\": // istanbul ignore next\n\n      case \"*\": // istanbul ignore next\n\n      case \"+\": // istanbul ignore next\n\n      case \"?\": // istanbul ignore next\n\n      case \"(\": // istanbul ignore next\n\n      case \")\": // istanbul ignore next\n\n      case \"[\": // istanbul ignore next\n\n      case \"|\":\n        // istanbul ignore next\n        throw Error(\"TBD\");\n\n      default:\n        return {\n          type: \"Character\",\n          value: cc(nextChar)\n        };\n    }\n  };\n\n  RegExpParser.prototype.isRegExpFlag = function () {\n    switch (this.peekChar(0)) {\n      case \"g\":\n      case \"i\":\n      case \"m\":\n      case \"u\":\n      case \"y\":\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isRangeDash = function () {\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\n  };\n\n  RegExpParser.prototype.isDigit = function () {\n    return decimalPattern.test(this.peekChar(0));\n  };\n\n  RegExpParser.prototype.isClassAtom = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n\n    switch (this.peekChar(howMuch)) {\n      case \"]\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n\n      default:\n        return true;\n    }\n  };\n\n  RegExpParser.prototype.isTerm = function () {\n    return this.isAtom() || this.isAssertion();\n  };\n\n  RegExpParser.prototype.isAtom = function () {\n    if (this.isPatternCharacter()) {\n      return true;\n    }\n\n    switch (this.peekChar(0)) {\n      case \".\":\n      case \"\\\\\": // atomEscape\n\n      case \"[\": // characterClass\n      // TODO: isAtom must be called before isAssertion - disambiguate\n\n      case \"(\":\n        // group\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isAssertion = function () {\n    switch (this.peekChar(0)) {\n      case \"^\":\n      case \"$\":\n        return true;\n      // '\\b' or '\\B'\n\n      case \"\\\\\":\n        switch (this.peekChar(1)) {\n          case \"b\":\n          case \"B\":\n            return true;\n\n          default:\n            return false;\n        }\n\n      // '(?=' or '(?!'\n\n      case \"(\":\n        return this.peekChar(1) === \"?\" && (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\");\n\n      default:\n        return false;\n    }\n  };\n\n  RegExpParser.prototype.isQuantifier = function () {\n    var prevState = this.saveState();\n\n    try {\n      return this.quantifier(true) !== undefined;\n    } catch (e) {\n      return false;\n    } finally {\n      this.restoreState(prevState);\n    }\n  };\n\n  RegExpParser.prototype.isPatternCharacter = function () {\n    switch (this.peekChar()) {\n      case \"^\":\n      case \"$\":\n      case \"\\\\\":\n      case \".\":\n      case \"*\":\n      case \"+\":\n      case \"?\":\n      case \"(\":\n      case \")\":\n      case \"[\":\n      case \"|\":\n      case \"/\":\n      case \"\\n\":\n      case \"\\r\":\n      case \"\\u2028\":\n      case \"\\u2029\":\n        return false;\n\n      default:\n        return true;\n    }\n  };\n\n  RegExpParser.prototype.parseHexDigits = function (howMany) {\n    var hexString = \"\";\n\n    for (var i = 0; i < howMany; i++) {\n      var hexChar = this.popChar();\n\n      if (hexDigitPattern.test(hexChar) === false) {\n        throw Error(\"Expecting a HexDecimal digits\");\n      }\n\n      hexString += hexChar;\n    }\n\n    var charCode = parseInt(hexString, 16);\n    return {\n      type: \"Character\",\n      value: charCode\n    };\n  };\n\n  RegExpParser.prototype.peekChar = function (howMuch) {\n    if (howMuch === undefined) {\n      howMuch = 0;\n    }\n\n    return this.input[this.idx + howMuch];\n  };\n\n  RegExpParser.prototype.popChar = function () {\n    var nextChar = this.peekChar(0);\n    this.consumeChar();\n    return nextChar;\n  };\n\n  RegExpParser.prototype.consumeChar = function (char) {\n    if (char !== undefined && this.input[this.idx] !== char) {\n      throw Error(\"Expected: '\" + char + \"' but found: '\" + this.input[this.idx] + \"' at offset: \" + this.idx);\n    }\n\n    if (this.idx >= this.input.length) {\n      throw Error(\"Unexpected end of input\");\n    }\n\n    this.idx++;\n  };\n\n  RegExpParser.prototype.loc = function (begin) {\n    return {\n      begin: begin,\n      end: this.idx\n    };\n  }; // consts and utilities\n\n\n  var hexDigitPattern = /[0-9a-fA-F]/;\n  var decimalPattern = /[0-9]/;\n  var decimalPatternNoZero = /[1-9]/;\n\n  function cc(char) {\n    return char.charCodeAt(0);\n  }\n\n  function insertToSet(item, set) {\n    if (item.length !== undefined) {\n      item.forEach(function (subItem) {\n        set.push(subItem);\n      });\n    } else {\n      set.push(item);\n    }\n  }\n\n  function addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n      throw \"duplicate flag \" + flagKey;\n    }\n\n    flagObj[flagKey] = true;\n  }\n\n  function ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n      throw Error(\"Internal Error - Should never get here!\");\n    }\n  } // istanbul ignore next\n\n\n  function ASSERT_NEVER_REACH_HERE() {\n    throw Error(\"Internal Error - Should never get here!\");\n  }\n\n  var i;\n  var digitsCharCodes = [];\n\n  for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n    digitsCharCodes.push(i);\n  }\n\n  var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes);\n\n  for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n    wordCharCodes.push(i);\n  }\n\n  for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n    wordCharCodes.push(i);\n  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n\n\n  var whitespaceCodes = [cc(\" \"), cc(\"\\f\"), cc(\"\\n\"), cc(\"\\r\"), cc(\"\\t\"), cc(\"\\v\"), cc(\"\\t\"), cc(\"\\xA0\"), cc(\"\\u1680\"), cc(\"\\u2000\"), cc(\"\\u2001\"), cc(\"\\u2002\"), cc(\"\\u2003\"), cc(\"\\u2004\"), cc(\"\\u2005\"), cc(\"\\u2006\"), cc(\"\\u2007\"), cc(\"\\u2008\"), cc(\"\\u2009\"), cc(\"\\u200A\"), cc(\"\\u2028\"), cc(\"\\u2029\"), cc(\"\\u202F\"), cc(\"\\u205F\"), cc(\"\\u3000\"), cc(\"\\uFEFF\")];\n\n  function BaseRegExpVisitor() {}\n\n  BaseRegExpVisitor.prototype.visitChildren = function (node) {\n    for (var key in node) {\n      var child = node[key];\n      /* istanbul ignore else */\n\n      if (node.hasOwnProperty(key)) {\n        if (child.type !== undefined) {\n          this.visit(child);\n        } else if (Array.isArray(child)) {\n          child.forEach(function (subChild) {\n            this.visit(subChild);\n          }, this);\n        }\n      }\n    }\n  };\n\n  BaseRegExpVisitor.prototype.visit = function (node) {\n    switch (node.type) {\n      case \"Pattern\":\n        this.visitPattern(node);\n        break;\n\n      case \"Flags\":\n        this.visitFlags(node);\n        break;\n\n      case \"Disjunction\":\n        this.visitDisjunction(node);\n        break;\n\n      case \"Alternative\":\n        this.visitAlternative(node);\n        break;\n\n      case \"StartAnchor\":\n        this.visitStartAnchor(node);\n        break;\n\n      case \"EndAnchor\":\n        this.visitEndAnchor(node);\n        break;\n\n      case \"WordBoundary\":\n        this.visitWordBoundary(node);\n        break;\n\n      case \"NonWordBoundary\":\n        this.visitNonWordBoundary(node);\n        break;\n\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        break;\n\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        break;\n\n      case \"Character\":\n        this.visitCharacter(node);\n        break;\n\n      case \"Set\":\n        this.visitSet(node);\n        break;\n\n      case \"Group\":\n        this.visitGroup(node);\n        break;\n\n      case \"GroupBackReference\":\n        this.visitGroupBackReference(node);\n        break;\n\n      case \"Quantifier\":\n        this.visitQuantifier(node);\n        break;\n    }\n\n    this.visitChildren(node);\n  };\n\n  BaseRegExpVisitor.prototype.visitPattern = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitFlags = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitDisjunction = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitAlternative = function (node) {}; // Assertion\n\n\n  BaseRegExpVisitor.prototype.visitStartAnchor = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitEndAnchor = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitWordBoundary = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitNonWordBoundary = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitLookahead = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitNegativeLookahead = function (node) {}; // atoms\n\n\n  BaseRegExpVisitor.prototype.visitCharacter = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitSet = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitGroup = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitGroupBackReference = function (node) {};\n\n  BaseRegExpVisitor.prototype.visitQuantifier = function (node) {};\n\n  return {\n    RegExpParser: RegExpParser,\n    BaseRegExpVisitor: BaseRegExpVisitor,\n    VERSION: \"0.5.0\"\n  };\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","regexpToAst","self","RegExpParser","prototype","saveState","idx","input","groupIdx","restoreState","newState","pattern","consumeChar","value","disjunction","flags","type","loc","begin","end","length","global","ignoreCase","multiLine","unicode","sticky","isRegExpFlag","popChar","addFlag","Error","substring","alts","push","alternative","peekChar","terms","isTerm","term","isAssertion","assertion","atom","ASSERT_EXISTS","ASSERT_NEVER_REACH_HERE","quantifier","isBacktracking","range","atLeast","atMost","Infinity","integerIncludingZero","isDigit","undefined","greedy","dotAll","atomEscape","characterClass","group","isPatternCharacter","patternCharacter","isQuantifier","complement","cc","decimalEscapeAtom","characterClassEscape","controlEscapeAtom","controlLetterEscapeAtom","nulCharacterAtom","hexEscapeSequenceAtom","regExpUnicodeEscapeSequenceAtom","identityEscapeAtom","positiveInteger","set","digitsCharCodes","whitespaceCodes","wordCharCodes","escapeCode","letter","test","letterCode","toUpperCase","charCodeAt","parseHexDigits","escapedChar","classPatternCharacterAtom","nextChar","isClassAtom","from","classAtom","isFromSingleChar","isRangeDash","to","isToSingleChar","insertToSet","classEscape","capturing","groupAst","number","decimalPatternNoZero","decimalPattern","parseInt","howMuch","isAtom","prevState","e","howMany","hexString","i","hexChar","hexDigitPattern","charCode","char","item","forEach","subItem","flagObj","flagKey","obj","concat","BaseRegExpVisitor","visitChildren","node","key","child","hasOwnProperty","visit","Array","isArray","subChild","visitPattern","visitFlags","visitDisjunction","visitAlternative","visitStartAnchor","visitEndAnchor","visitWordBoundary","visitNonWordBoundary","visitLookahead","visitNegativeLookahead","visitCharacter","visitSet","visitGroup","visitGroupBackReference","visitQuantifier","VERSION"],"sources":["D:/Jord/l4fycy/node_modules/regexp-to-ast/lib/regexp-to-ast.js"],"sourcesContent":[";(function(root, factory) {\n    // istanbul ignore next\n    if (typeof define === \"function\" && define.amd) {\n        // istanbul ignore next\n        define([], factory)\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory()\n    } else {\n        // istanbul ignore next\n        root.regexpToAst = factory()\n    }\n})(\n    typeof self !== \"undefined\"\n        ? // istanbul ignore next\n          self\n        : this,\n    function() {\n        // references\n        // https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n        // https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\n        function RegExpParser() {}\n\n        RegExpParser.prototype.saveState = function() {\n            return {\n                idx: this.idx,\n                input: this.input,\n                groupIdx: this.groupIdx\n            }\n        }\n\n        RegExpParser.prototype.restoreState = function(newState) {\n            this.idx = newState.idx\n            this.input = newState.input\n            this.groupIdx = newState.groupIdx\n        }\n\n        RegExpParser.prototype.pattern = function(input) {\n            // parser state\n            this.idx = 0\n            this.input = input\n            this.groupIdx = 0\n\n            this.consumeChar(\"/\")\n            var value = this.disjunction()\n            this.consumeChar(\"/\")\n\n            var flags = {\n                type: \"Flags\",\n                loc: { begin: this.idx, end: input.length },\n                global: false,\n                ignoreCase: false,\n                multiLine: false,\n                unicode: false,\n                sticky: false\n            }\n\n            while (this.isRegExpFlag()) {\n                switch (this.popChar()) {\n                    case \"g\":\n                        addFlag(flags, \"global\")\n                        break\n                    case \"i\":\n                        addFlag(flags, \"ignoreCase\")\n                        break\n                    case \"m\":\n                        addFlag(flags, \"multiLine\")\n                        break\n                    case \"u\":\n                        addFlag(flags, \"unicode\")\n                        break\n                    case \"y\":\n                        addFlag(flags, \"sticky\")\n                        break\n                }\n            }\n\n            if (this.idx !== this.input.length) {\n                throw Error(\n                    \"Redundant input: \" + this.input.substring(this.idx)\n                )\n            }\n            return {\n                type: \"Pattern\",\n                flags: flags,\n                value: value,\n                loc: this.loc(0)\n            }\n        }\n\n        RegExpParser.prototype.disjunction = function() {\n            var alts = []\n            var begin = this.idx\n\n            alts.push(this.alternative())\n\n            while (this.peekChar() === \"|\") {\n                this.consumeChar(\"|\")\n                alts.push(this.alternative())\n            }\n\n            return { type: \"Disjunction\", value: alts, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.alternative = function() {\n            var terms = []\n            var begin = this.idx\n\n            while (this.isTerm()) {\n                terms.push(this.term())\n            }\n\n            return { type: \"Alternative\", value: terms, loc: this.loc(begin) }\n        }\n\n        RegExpParser.prototype.term = function() {\n            if (this.isAssertion()) {\n                return this.assertion()\n            } else {\n                return this.atom()\n            }\n        }\n\n        RegExpParser.prototype.assertion = function() {\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"^\":\n                    return {\n                        type: \"StartAnchor\",\n                        loc: this.loc(begin)\n                    }\n                case \"$\":\n                    return { type: \"EndAnchor\", loc: this.loc(begin) }\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.popChar()) {\n                        case \"b\":\n                            return {\n                                type: \"WordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                        case \"B\":\n                            return {\n                                type: \"NonWordBoundary\",\n                                loc: this.loc(begin)\n                            }\n                    }\n                    // istanbul ignore next\n                    throw Error(\"Invalid Assertion Escape\")\n                // '(?=' or '(?!'\n                case \"(\":\n                    this.consumeChar(\"?\")\n\n                    var type\n                    switch (this.popChar()) {\n                        case \"=\":\n                            type = \"Lookahead\"\n                            break\n                        case \"!\":\n                            type = \"NegativeLookahead\"\n                            break\n                    }\n                    ASSERT_EXISTS(type)\n\n                    var disjunction = this.disjunction()\n\n                    this.consumeChar(\")\")\n\n                    return {\n                        type: type,\n                        value: disjunction,\n                        loc: this.loc(begin)\n                    }\n            }\n            // istanbul ignore next\n            ASSERT_NEVER_REACH_HERE()\n        }\n\n        RegExpParser.prototype.quantifier = function(isBacktracking) {\n            var range\n            var begin = this.idx\n            switch (this.popChar()) {\n                case \"*\":\n                    range = {\n                        atLeast: 0,\n                        atMost: Infinity\n                    }\n                    break\n                case \"+\":\n                    range = {\n                        atLeast: 1,\n                        atMost: Infinity\n                    }\n                    break\n                case \"?\":\n                    range = {\n                        atLeast: 0,\n                        atMost: 1\n                    }\n                    break\n                case \"{\":\n                    var atLeast = this.integerIncludingZero()\n                    switch (this.popChar()) {\n                        case \"}\":\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atLeast\n                            }\n                            break\n                        case \",\":\n                            var atMost\n                            if (this.isDigit()) {\n                                atMost = this.integerIncludingZero()\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: atMost\n                                }\n                            } else {\n                                range = {\n                                    atLeast: atLeast,\n                                    atMost: Infinity\n                                }\n                            }\n                            this.consumeChar(\"}\")\n                            break\n                    }\n                    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n                    // causes severe performance degradations\n                    if (isBacktracking === true && range === undefined) {\n                        return undefined\n                    }\n                    ASSERT_EXISTS(range)\n                    break\n            }\n\n            // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\n            // causes severe performance degradations\n            if (isBacktracking === true && range === undefined) {\n                return undefined\n            }\n\n            ASSERT_EXISTS(range)\n\n            if (this.peekChar(0) === \"?\") {\n                this.consumeChar(\"?\")\n                range.greedy = false\n            } else {\n                range.greedy = true\n            }\n\n            range.type = \"Quantifier\"\n            range.loc = this.loc(begin)\n            return range\n        }\n\n        RegExpParser.prototype.atom = function() {\n            var atom\n            var begin = this.idx\n            switch (this.peekChar()) {\n                case \".\":\n                    atom = this.dotAll()\n                    break\n                case \"\\\\\":\n                    atom = this.atomEscape()\n                    break\n                case \"[\":\n                    atom = this.characterClass()\n                    break\n                case \"(\":\n                    atom = this.group()\n                    break\n            }\n\n            if (atom === undefined && this.isPatternCharacter()) {\n                atom = this.patternCharacter()\n            }\n\n            ASSERT_EXISTS(atom)\n\n            atom.loc = this.loc(begin)\n\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier()\n            }\n\n            return atom\n        }\n\n        RegExpParser.prototype.dotAll = function() {\n            this.consumeChar(\".\")\n            return {\n                type: \"Set\",\n                complement: true,\n                value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")]\n            }\n        }\n\n        RegExpParser.prototype.atomEscape = function() {\n            this.consumeChar(\"\\\\\")\n\n            switch (this.peekChar()) {\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    return this.decimalEscapeAtom()\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.decimalEscapeAtom = function() {\n            var value = this.positiveInteger()\n\n            return { type: \"GroupBackReference\", value: value }\n        }\n\n        RegExpParser.prototype.characterClassEscape = function() {\n            var set\n            var complement = false\n            switch (this.popChar()) {\n                case \"d\":\n                    set = digitsCharCodes\n                    break\n                case \"D\":\n                    set = digitsCharCodes\n                    complement = true\n                    break\n                case \"s\":\n                    set = whitespaceCodes\n                    break\n                case \"S\":\n                    set = whitespaceCodes\n                    complement = true\n                    break\n                case \"w\":\n                    set = wordCharCodes\n                    break\n                case \"W\":\n                    set = wordCharCodes\n                    complement = true\n                    break\n            }\n\n            ASSERT_EXISTS(set)\n\n            return { type: \"Set\", value: set, complement: complement }\n        }\n\n        RegExpParser.prototype.controlEscapeAtom = function() {\n            var escapeCode\n            switch (this.popChar()) {\n                case \"f\":\n                    escapeCode = cc(\"\\f\")\n                    break\n                case \"n\":\n                    escapeCode = cc(\"\\n\")\n                    break\n                case \"r\":\n                    escapeCode = cc(\"\\r\")\n                    break\n                case \"t\":\n                    escapeCode = cc(\"\\t\")\n                    break\n                case \"v\":\n                    escapeCode = cc(\"\\v\")\n                    break\n            }\n            ASSERT_EXISTS(escapeCode)\n\n            return { type: \"Character\", value: escapeCode }\n        }\n\n        RegExpParser.prototype.controlLetterEscapeAtom = function() {\n            this.consumeChar(\"c\")\n            var letter = this.popChar()\n            if (/[a-zA-Z]/.test(letter) === false) {\n                throw Error(\"Invalid \")\n            }\n\n            var letterCode = letter.toUpperCase().charCodeAt(0) - 64\n            return { type: \"Character\", value: letterCode }\n        }\n\n        RegExpParser.prototype.nulCharacterAtom = function() {\n            // TODO implement '[lookahead ∉ DecimalDigit]'\n            // TODO: for the deprecated octal escape sequence\n            this.consumeChar(\"0\")\n            return { type: \"Character\", value: cc(\"\\0\") }\n        }\n\n        RegExpParser.prototype.hexEscapeSequenceAtom = function() {\n            this.consumeChar(\"x\")\n            return this.parseHexDigits(2)\n        }\n\n        RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {\n            this.consumeChar(\"u\")\n            return this.parseHexDigits(4)\n        }\n\n        RegExpParser.prototype.identityEscapeAtom = function() {\n            // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\n            // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n            var escapedChar = this.popChar()\n            return { type: \"Character\", value: cc(escapedChar) }\n        }\n\n        RegExpParser.prototype.classPatternCharacterAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \"]\":\n                    throw Error(\"TBD\")\n                default:\n                    var nextChar = this.popChar()\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n\n        RegExpParser.prototype.characterClass = function() {\n            var set = []\n            var complement = false\n            this.consumeChar(\"[\")\n            if (this.peekChar(0) === \"^\") {\n                this.consumeChar(\"^\")\n                complement = true\n            }\n\n            while (this.isClassAtom()) {\n                var from = this.classAtom()\n                var isFromSingleChar = from.type === \"Character\"\n                if (isFromSingleChar && this.isRangeDash()) {\n                    this.consumeChar(\"-\")\n                    var to = this.classAtom()\n                    var isToSingleChar = to.type === \"Character\"\n\n                    // a range can only be used when both sides are single characters\n                    if (isToSingleChar) {\n                        if (to.value < from.value) {\n                            throw Error(\"Range out of order in character class\")\n                        }\n                        set.push({ from: from.value, to: to.value })\n                    } else {\n                        // literal dash\n                        insertToSet(from.value, set)\n                        set.push(cc(\"-\"))\n                        insertToSet(to.value, set)\n                    }\n                } else {\n                    insertToSet(from.value, set)\n                }\n            }\n\n            this.consumeChar(\"]\")\n\n            return { type: \"Set\", complement: complement, value: set }\n        }\n\n        RegExpParser.prototype.classAtom = function() {\n            switch (this.peekChar()) {\n                // istanbul ignore next\n                case \"]\":\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                    throw Error(\"TBD\")\n                case \"\\\\\":\n                    return this.classEscape()\n                default:\n                    return this.classPatternCharacterAtom()\n            }\n        }\n\n        RegExpParser.prototype.classEscape = function() {\n            this.consumeChar(\"\\\\\")\n            switch (this.peekChar()) {\n                // Matches a backspace.\n                // (Not to be confused with \\b word boundary outside characterClass)\n                case \"b\":\n                    this.consumeChar(\"b\")\n                    return { type: \"Character\", value: cc(\"\\u0008\") }\n                case \"d\":\n                case \"D\":\n                case \"s\":\n                case \"S\":\n                case \"w\":\n                case \"W\":\n                    return this.characterClassEscape()\n                case \"f\":\n                case \"n\":\n                case \"r\":\n                case \"t\":\n                case \"v\":\n                    return this.controlEscapeAtom()\n                case \"c\":\n                    return this.controlLetterEscapeAtom()\n                case \"0\":\n                    return this.nulCharacterAtom()\n                case \"x\":\n                    return this.hexEscapeSequenceAtom()\n                case \"u\":\n                    return this.regExpUnicodeEscapeSequenceAtom()\n                default:\n                    return this.identityEscapeAtom()\n            }\n        }\n\n        RegExpParser.prototype.group = function() {\n            var capturing = true\n            this.consumeChar(\"(\")\n            switch (this.peekChar(0)) {\n                case \"?\":\n                    this.consumeChar(\"?\")\n                    this.consumeChar(\":\")\n                    capturing = false\n                    break\n                default:\n                    this.groupIdx++\n                    break\n            }\n            var value = this.disjunction()\n            this.consumeChar(\")\")\n\n            var groupAst = {\n                type: \"Group\",\n                capturing: capturing,\n                value: value\n            }\n\n            if (capturing) {\n                groupAst.idx = this.groupIdx\n            }\n\n            return groupAst\n        }\n\n        RegExpParser.prototype.positiveInteger = function() {\n            var number = this.popChar()\n\n            // istanbul ignore next - can't ever get here due to previous lookahead checks\n            // still implementing this error checking in case this ever changes.\n            if (decimalPatternNoZero.test(number) === false) {\n                throw Error(\"Expecting a positive integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.integerIncludingZero = function() {\n            var number = this.popChar()\n            if (decimalPattern.test(number) === false) {\n                throw Error(\"Expecting an integer\")\n            }\n\n            while (decimalPattern.test(this.peekChar(0))) {\n                number += this.popChar()\n            }\n\n            return parseInt(number, 10)\n        }\n\n        RegExpParser.prototype.patternCharacter = function() {\n            var nextChar = this.popChar()\n            switch (nextChar) {\n                // istanbul ignore next\n                case \"\\n\":\n                // istanbul ignore next\n                case \"\\r\":\n                // istanbul ignore next\n                case \"\\u2028\":\n                // istanbul ignore next\n                case \"\\u2029\":\n                // istanbul ignore next\n                case \"^\":\n                // istanbul ignore next\n                case \"$\":\n                // istanbul ignore next\n                case \"\\\\\":\n                // istanbul ignore next\n                case \".\":\n                // istanbul ignore next\n                case \"*\":\n                // istanbul ignore next\n                case \"+\":\n                // istanbul ignore next\n                case \"?\":\n                // istanbul ignore next\n                case \"(\":\n                // istanbul ignore next\n                case \")\":\n                // istanbul ignore next\n                case \"[\":\n                // istanbul ignore next\n                case \"|\":\n                    // istanbul ignore next\n                    throw Error(\"TBD\")\n                default:\n                    return { type: \"Character\", value: cc(nextChar) }\n            }\n        }\n        RegExpParser.prototype.isRegExpFlag = function() {\n            switch (this.peekChar(0)) {\n                case \"g\":\n                case \"i\":\n                case \"m\":\n                case \"u\":\n                case \"y\":\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isRangeDash = function() {\n            return this.peekChar() === \"-\" && this.isClassAtom(1)\n        }\n\n        RegExpParser.prototype.isDigit = function() {\n            return decimalPattern.test(this.peekChar(0))\n        }\n\n        RegExpParser.prototype.isClassAtom = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n\n            switch (this.peekChar(howMuch)) {\n                case \"]\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.isTerm = function() {\n            return this.isAtom() || this.isAssertion()\n        }\n\n        RegExpParser.prototype.isAtom = function() {\n            if (this.isPatternCharacter()) {\n                return true\n            }\n\n            switch (this.peekChar(0)) {\n                case \".\":\n                case \"\\\\\": // atomEscape\n                case \"[\": // characterClass\n                // TODO: isAtom must be called before isAssertion - disambiguate\n                case \"(\": // group\n                    return true\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isAssertion = function() {\n            switch (this.peekChar(0)) {\n                case \"^\":\n                case \"$\":\n                    return true\n                // '\\b' or '\\B'\n                case \"\\\\\":\n                    switch (this.peekChar(1)) {\n                        case \"b\":\n                        case \"B\":\n                            return true\n                        default:\n                            return false\n                    }\n                // '(?=' or '(?!'\n                case \"(\":\n                    return (\n                        this.peekChar(1) === \"?\" &&\n                        (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\n                    )\n                default:\n                    return false\n            }\n        }\n\n        RegExpParser.prototype.isQuantifier = function() {\n            var prevState = this.saveState()\n            try {\n                return this.quantifier(true) !== undefined\n            } catch (e) {\n                return false\n            } finally {\n                this.restoreState(prevState)\n            }\n        }\n\n        RegExpParser.prototype.isPatternCharacter = function() {\n            switch (this.peekChar()) {\n                case \"^\":\n                case \"$\":\n                case \"\\\\\":\n                case \".\":\n                case \"*\":\n                case \"+\":\n                case \"?\":\n                case \"(\":\n                case \")\":\n                case \"[\":\n                case \"|\":\n                case \"/\":\n                case \"\\n\":\n                case \"\\r\":\n                case \"\\u2028\":\n                case \"\\u2029\":\n                    return false\n                default:\n                    return true\n            }\n        }\n\n        RegExpParser.prototype.parseHexDigits = function(howMany) {\n            var hexString = \"\"\n            for (var i = 0; i < howMany; i++) {\n                var hexChar = this.popChar()\n                if (hexDigitPattern.test(hexChar) === false) {\n                    throw Error(\"Expecting a HexDecimal digits\")\n                }\n                hexString += hexChar\n            }\n            var charCode = parseInt(hexString, 16)\n            return { type: \"Character\", value: charCode }\n        }\n\n        RegExpParser.prototype.peekChar = function(howMuch) {\n            if (howMuch === undefined) {\n                howMuch = 0\n            }\n            return this.input[this.idx + howMuch]\n        }\n\n        RegExpParser.prototype.popChar = function() {\n            var nextChar = this.peekChar(0)\n            this.consumeChar()\n            return nextChar\n        }\n\n        RegExpParser.prototype.consumeChar = function(char) {\n            if (char !== undefined && this.input[this.idx] !== char) {\n                throw Error(\n                    \"Expected: '\" +\n                        char +\n                        \"' but found: '\" +\n                        this.input[this.idx] +\n                        \"' at offset: \" +\n                        this.idx\n                )\n            }\n\n            if (this.idx >= this.input.length) {\n                throw Error(\"Unexpected end of input\")\n            }\n            this.idx++\n        }\n\n        RegExpParser.prototype.loc = function(begin) {\n            return { begin: begin, end: this.idx }\n        }\n\n        // consts and utilities\n        var hexDigitPattern = /[0-9a-fA-F]/\n        var decimalPattern = /[0-9]/\n        var decimalPatternNoZero = /[1-9]/\n\n        function cc(char) {\n            return char.charCodeAt(0)\n        }\n\n        function insertToSet(item, set) {\n            if (item.length !== undefined) {\n                item.forEach(function(subItem) {\n                    set.push(subItem)\n                })\n            } else {\n                set.push(item)\n            }\n        }\n\n        function addFlag(flagObj, flagKey) {\n            if (flagObj[flagKey] === true) {\n                throw \"duplicate flag \" + flagKey\n            }\n\n            flagObj[flagKey] = true\n        }\n\n        function ASSERT_EXISTS(obj) {\n            // istanbul ignore next\n            if (obj === undefined) {\n                throw Error(\"Internal Error - Should never get here!\")\n            }\n        }\n\n        // istanbul ignore next\n        function ASSERT_NEVER_REACH_HERE() {\n            throw Error(\"Internal Error - Should never get here!\")\n        }\n\n        var i\n        var digitsCharCodes = []\n        for (i = cc(\"0\"); i <= cc(\"9\"); i++) {\n            digitsCharCodes.push(i)\n        }\n\n        var wordCharCodes = [cc(\"_\")].concat(digitsCharCodes)\n        for (i = cc(\"a\"); i <= cc(\"z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        for (i = cc(\"A\"); i <= cc(\"Z\"); i++) {\n            wordCharCodes.push(i)\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\n        var whitespaceCodes = [\n            cc(\" \"),\n            cc(\"\\f\"),\n            cc(\"\\n\"),\n            cc(\"\\r\"),\n            cc(\"\\t\"),\n            cc(\"\\v\"),\n            cc(\"\\t\"),\n            cc(\"\\u00a0\"),\n            cc(\"\\u1680\"),\n            cc(\"\\u2000\"),\n            cc(\"\\u2001\"),\n            cc(\"\\u2002\"),\n            cc(\"\\u2003\"),\n            cc(\"\\u2004\"),\n            cc(\"\\u2005\"),\n            cc(\"\\u2006\"),\n            cc(\"\\u2007\"),\n            cc(\"\\u2008\"),\n            cc(\"\\u2009\"),\n            cc(\"\\u200a\"),\n            cc(\"\\u2028\"),\n            cc(\"\\u2029\"),\n            cc(\"\\u202f\"),\n            cc(\"\\u205f\"),\n            cc(\"\\u3000\"),\n            cc(\"\\ufeff\")\n        ]\n\n        function BaseRegExpVisitor() {}\n\n        BaseRegExpVisitor.prototype.visitChildren = function(node) {\n            for (var key in node) {\n                var child = node[key]\n                /* istanbul ignore else */\n                if (node.hasOwnProperty(key)) {\n                    if (child.type !== undefined) {\n                        this.visit(child)\n                    } else if (Array.isArray(child)) {\n                        child.forEach(function(subChild) {\n                            this.visit(subChild)\n                        }, this)\n                    }\n                }\n            }\n        }\n\n        BaseRegExpVisitor.prototype.visit = function(node) {\n            switch (node.type) {\n                case \"Pattern\":\n                    this.visitPattern(node)\n                    break\n                case \"Flags\":\n                    this.visitFlags(node)\n                    break\n                case \"Disjunction\":\n                    this.visitDisjunction(node)\n                    break\n                case \"Alternative\":\n                    this.visitAlternative(node)\n                    break\n                case \"StartAnchor\":\n                    this.visitStartAnchor(node)\n                    break\n                case \"EndAnchor\":\n                    this.visitEndAnchor(node)\n                    break\n                case \"WordBoundary\":\n                    this.visitWordBoundary(node)\n                    break\n                case \"NonWordBoundary\":\n                    this.visitNonWordBoundary(node)\n                    break\n                case \"Lookahead\":\n                    this.visitLookahead(node)\n                    break\n                case \"NegativeLookahead\":\n                    this.visitNegativeLookahead(node)\n                    break\n                case \"Character\":\n                    this.visitCharacter(node)\n                    break\n                case \"Set\":\n                    this.visitSet(node)\n                    break\n                case \"Group\":\n                    this.visitGroup(node)\n                    break\n                case \"GroupBackReference\":\n                    this.visitGroupBackReference(node)\n                    break\n                case \"Quantifier\":\n                    this.visitQuantifier(node)\n                    break\n            }\n\n            this.visitChildren(node)\n        }\n\n        BaseRegExpVisitor.prototype.visitPattern = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitFlags = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitDisjunction = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitAlternative = function(node) {}\n\n        // Assertion\n        BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitLookahead = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {}\n\n        // atoms\n        BaseRegExpVisitor.prototype.visitCharacter = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitSet = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroup = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {}\n\n        BaseRegExpVisitor.prototype.visitQuantifier = function(node) {}\n\n        return {\n            RegExpParser: RegExpParser,\n            BaseRegExpVisitor: BaseRegExpVisitor,\n            VERSION: \"0.5.0\"\n        }\n    }\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}