{"ast":null,"code":"import _classCallCheck from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Frustum, Vector3 } from 'three';\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\n\nvar SelectionBox = function () {\n  var frustum = new Frustum();\n  var center = new Vector3();\n  var tmpPoint = new Vector3();\n  var vecNear = new Vector3();\n  var vecTopLeft = new Vector3();\n  var vecTopRight = new Vector3();\n  var vecDownRight = new Vector3();\n  var vecDownLeft = new Vector3();\n  var vecFarTopLeft = new Vector3();\n  var vecFarTopRight = new Vector3();\n  var vecFarDownRight = new Vector3();\n  var vecFarDownLeft = new Vector3();\n  var vectemp1 = new Vector3();\n  var vectemp2 = new Vector3();\n  var vectemp3 = new Vector3();\n\n  var SelectionBox = /*#__PURE__*/function () {\n    function SelectionBox(camera, scene, deep) {\n      _classCallCheck(this, SelectionBox);\n\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new Vector3();\n      this.endPoint = new Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n\n    _createClass(SelectionBox, [{\n      key: \"select\",\n      value: function select(startPoint, endPoint) {\n        this.startPoint = startPoint || this.startPoint;\n        this.endPoint = endPoint || this.endPoint;\n        this.collection = [];\n        this.updateFrustum(this.startPoint, this.endPoint);\n        this.searchChildInFrustum(frustum, this.scene);\n        return this.collection;\n      }\n    }, {\n      key: \"updateFrustum\",\n      value: function updateFrustum(startPoint, endPoint) {\n        startPoint = startPoint || this.startPoint;\n        endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n        if (startPoint.x === endPoint.x) {\n          endPoint.x += Number.EPSILON;\n        }\n\n        if (startPoint.y === endPoint.y) {\n          endPoint.y += Number.EPSILON;\n        }\n\n        this.camera.updateProjectionMatrix();\n        this.camera.updateMatrixWorld();\n\n        if (this.camera.isPerspectiveCamera) {\n          tmpPoint.copy(startPoint);\n          tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n          tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n          endPoint.x = Math.max(startPoint.x, endPoint.x);\n          endPoint.y = Math.min(startPoint.y, endPoint.y);\n          vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n          vecTopLeft.copy(tmpPoint);\n          vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n          vecDownRight.copy(endPoint);\n          vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n          vecTopLeft.unproject(this.camera);\n          vecTopRight.unproject(this.camera);\n          vecDownRight.unproject(this.camera);\n          vecDownLeft.unproject(this.camera);\n          vectemp1.copy(vecTopLeft).sub(vecNear);\n          vectemp2.copy(vecTopRight).sub(vecNear);\n          vectemp3.copy(vecDownRight).sub(vecNear);\n          vectemp1.normalize();\n          vectemp2.normalize();\n          vectemp3.normalize();\n          vectemp1.multiplyScalar(this.deep);\n          vectemp2.multiplyScalar(this.deep);\n          vectemp3.multiplyScalar(this.deep);\n          vectemp1.add(vecNear);\n          vectemp2.add(vecNear);\n          vectemp3.add(vecNear);\n          var planes = frustum.planes;\n          planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n          planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n          planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n          planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n          planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n          planes[5].normal.multiplyScalar(-1);\n        } else if (this.camera.isOrthographicCamera) {\n          var left = Math.min(startPoint.x, endPoint.x);\n          var top = Math.max(startPoint.y, endPoint.y);\n          var right = Math.max(startPoint.x, endPoint.x);\n          var down = Math.min(startPoint.y, endPoint.y);\n          vecTopLeft.set(left, top, -1);\n          vecTopRight.set(right, top, -1);\n          vecDownRight.set(right, down, -1);\n          vecDownLeft.set(left, down, -1);\n          vecFarTopLeft.set(left, top, 1);\n          vecFarTopRight.set(right, top, 1);\n          vecFarDownRight.set(right, down, 1);\n          vecFarDownLeft.set(left, down, 1);\n          vecTopLeft.unproject(this.camera);\n          vecTopRight.unproject(this.camera);\n          vecDownRight.unproject(this.camera);\n          vecDownLeft.unproject(this.camera);\n          vecFarTopLeft.unproject(this.camera);\n          vecFarTopRight.unproject(this.camera);\n          vecFarDownRight.unproject(this.camera);\n          vecFarDownLeft.unproject(this.camera);\n          var planes = frustum.planes;\n          planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n          planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n          planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n          planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n          planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n          planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n          planes[5].normal.multiplyScalar(-1);\n        } else {\n          console.error('THREE.SelectionBox: Unsupported camera type.');\n        }\n      }\n    }, {\n      key: \"searchChildInFrustum\",\n      value: function searchChildInFrustum(frustum, object) {\n        if (object.isMesh || object.isLine || object.isPoints) {\n          if (object.material !== undefined) {\n            if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n            center.copy(object.geometry.boundingSphere.center);\n            center.applyMatrix4(object.matrixWorld);\n\n            if (frustum.containsPoint(center)) {\n              this.collection.push(object);\n            }\n          }\n        }\n\n        if (object.children.length > 0) {\n          for (var x = 0; x < object.children.length; x++) {\n            this.searchChildInFrustum(frustum, object.children[x]);\n          }\n        }\n      }\n    }]);\n\n    return SelectionBox;\n  }();\n\n  return SelectionBox;\n}();\n\nexport { SelectionBox };","map":{"version":3,"names":["Frustum","Vector3","SelectionBox","frustum","center","tmpPoint","vecNear","vecTopLeft","vecTopRight","vecDownRight","vecDownLeft","vecFarTopLeft","vecFarTopRight","vecFarDownRight","vecFarDownLeft","vectemp1","vectemp2","vectemp3","camera","scene","deep","startPoint","endPoint","collection","Number","MAX_VALUE","updateFrustum","searchChildInFrustum","x","EPSILON","y","updateProjectionMatrix","updateMatrixWorld","isPerspectiveCamera","copy","Math","min","max","setFromMatrixPosition","matrixWorld","set","unproject","sub","normalize","multiplyScalar","add","planes","setFromCoplanarPoints","normal","isOrthographicCamera","left","top","right","down","console","error","object","isMesh","isLine","isPoints","material","undefined","geometry","boundingSphere","computeBoundingSphere","applyMatrix4","containsPoint","push","children","length"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/interactive/SelectionBox.js"],"sourcesContent":["import { Frustum, Vector3 } from 'three';\n\n/**\n * This is a class to check whether objects are in a selection area in 3D space\n */\n\nconst SelectionBox = (() => {\n  const frustum = new Frustum();\n  const center = new Vector3();\n  const tmpPoint = new Vector3();\n  const vecNear = new Vector3();\n  const vecTopLeft = new Vector3();\n  const vecTopRight = new Vector3();\n  const vecDownRight = new Vector3();\n  const vecDownLeft = new Vector3();\n  const vecFarTopLeft = new Vector3();\n  const vecFarTopRight = new Vector3();\n  const vecFarDownRight = new Vector3();\n  const vecFarDownLeft = new Vector3();\n  const vectemp1 = new Vector3();\n  const vectemp2 = new Vector3();\n  const vectemp3 = new Vector3();\n\n  class SelectionBox {\n    constructor(camera, scene, deep) {\n      this.camera = camera;\n      this.scene = scene;\n      this.startPoint = new Vector3();\n      this.endPoint = new Vector3();\n      this.collection = [];\n      this.deep = deep || Number.MAX_VALUE;\n    }\n\n    select(startPoint, endPoint) {\n      this.startPoint = startPoint || this.startPoint;\n      this.endPoint = endPoint || this.endPoint;\n      this.collection = [];\n      this.updateFrustum(this.startPoint, this.endPoint);\n      this.searchChildInFrustum(frustum, this.scene);\n      return this.collection;\n    }\n\n    updateFrustum(startPoint, endPoint) {\n      startPoint = startPoint || this.startPoint;\n      endPoint = endPoint || this.endPoint; // Avoid invalid frustum\n\n      if (startPoint.x === endPoint.x) {\n        endPoint.x += Number.EPSILON;\n      }\n\n      if (startPoint.y === endPoint.y) {\n        endPoint.y += Number.EPSILON;\n      }\n\n      this.camera.updateProjectionMatrix();\n      this.camera.updateMatrixWorld();\n\n      if (this.camera.isPerspectiveCamera) {\n        tmpPoint.copy(startPoint);\n        tmpPoint.x = Math.min(startPoint.x, endPoint.x);\n        tmpPoint.y = Math.max(startPoint.y, endPoint.y);\n        endPoint.x = Math.max(startPoint.x, endPoint.x);\n        endPoint.y = Math.min(startPoint.y, endPoint.y);\n        vecNear.setFromMatrixPosition(this.camera.matrixWorld);\n        vecTopLeft.copy(tmpPoint);\n        vecTopRight.set(endPoint.x, tmpPoint.y, 0);\n        vecDownRight.copy(endPoint);\n        vecDownLeft.set(tmpPoint.x, endPoint.y, 0);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vectemp1.copy(vecTopLeft).sub(vecNear);\n        vectemp2.copy(vecTopRight).sub(vecNear);\n        vectemp3.copy(vecDownRight).sub(vecNear);\n        vectemp1.normalize();\n        vectemp2.normalize();\n        vectemp3.normalize();\n        vectemp1.multiplyScalar(this.deep);\n        vectemp2.multiplyScalar(this.deep);\n        vectemp3.multiplyScalar(this.deep);\n        vectemp1.add(vecNear);\n        vectemp2.add(vecNear);\n        vectemp3.add(vecNear);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecNear, vecTopLeft, vecTopRight);\n        planes[1].setFromCoplanarPoints(vecNear, vecTopRight, vecDownRight);\n        planes[2].setFromCoplanarPoints(vecDownRight, vecDownLeft, vecNear);\n        planes[3].setFromCoplanarPoints(vecDownLeft, vecTopLeft, vecNear);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vectemp3, vectemp2, vectemp1);\n        planes[5].normal.multiplyScalar(-1);\n      } else if (this.camera.isOrthographicCamera) {\n        const left = Math.min(startPoint.x, endPoint.x);\n        const top = Math.max(startPoint.y, endPoint.y);\n        const right = Math.max(startPoint.x, endPoint.x);\n        const down = Math.min(startPoint.y, endPoint.y);\n        vecTopLeft.set(left, top, -1);\n        vecTopRight.set(right, top, -1);\n        vecDownRight.set(right, down, -1);\n        vecDownLeft.set(left, down, -1);\n        vecFarTopLeft.set(left, top, 1);\n        vecFarTopRight.set(right, top, 1);\n        vecFarDownRight.set(right, down, 1);\n        vecFarDownLeft.set(left, down, 1);\n        vecTopLeft.unproject(this.camera);\n        vecTopRight.unproject(this.camera);\n        vecDownRight.unproject(this.camera);\n        vecDownLeft.unproject(this.camera);\n        vecFarTopLeft.unproject(this.camera);\n        vecFarTopRight.unproject(this.camera);\n        vecFarDownRight.unproject(this.camera);\n        vecFarDownLeft.unproject(this.camera);\n        var planes = frustum.planes;\n        planes[0].setFromCoplanarPoints(vecTopLeft, vecFarTopLeft, vecFarTopRight);\n        planes[1].setFromCoplanarPoints(vecTopRight, vecFarTopRight, vecFarDownRight);\n        planes[2].setFromCoplanarPoints(vecFarDownRight, vecFarDownLeft, vecDownLeft);\n        planes[3].setFromCoplanarPoints(vecFarDownLeft, vecFarTopLeft, vecTopLeft);\n        planes[4].setFromCoplanarPoints(vecTopRight, vecDownRight, vecDownLeft);\n        planes[5].setFromCoplanarPoints(vecFarDownRight, vecFarTopRight, vecFarTopLeft);\n        planes[5].normal.multiplyScalar(-1);\n      } else {\n        console.error('THREE.SelectionBox: Unsupported camera type.');\n      }\n    }\n\n    searchChildInFrustum(frustum, object) {\n      if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.material !== undefined) {\n          if (object.geometry.boundingSphere === null) object.geometry.computeBoundingSphere();\n          center.copy(object.geometry.boundingSphere.center);\n          center.applyMatrix4(object.matrixWorld);\n\n          if (frustum.containsPoint(center)) {\n            this.collection.push(object);\n          }\n        }\n      }\n\n      if (object.children.length > 0) {\n        for (let x = 0; x < object.children.length; x++) {\n          this.searchChildInFrustum(frustum, object.children[x]);\n        }\n      }\n    }\n\n  }\n\n  return SelectionBox;\n})();\n\nexport { SelectionBox };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}