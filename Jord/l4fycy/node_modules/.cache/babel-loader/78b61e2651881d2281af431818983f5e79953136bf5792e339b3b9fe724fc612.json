{"ast":null,"code":"import { Box3, Vector3, InstancedBufferGeometry, Float32BufferAttribute, InstancedInterleavedBuffer, InterleavedBufferAttribute, WireframeGeometry, Sphere } from \"three\";\nconst _box = new Box3();\nconst _vector = new Vector3();\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super();\n    this.isLineSegmentsGeometry = true;\n    this.type = \"LineSegmentsGeometry\";\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];\n    this.setIndex(index);\n    this.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0) {\n      start.applyMatrix4(matrix);\n      end.applyMatrix4(matrix);\n      start.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  setPositions(array) {\n    let lineSegments;\n    if (array instanceof Float32Array) {\n      lineSegments = array;\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array);\n    }\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);\n    this.setAttribute(\"instanceStart\", new InterleavedBufferAttribute(instanceBuffer, 3, 0));\n    this.setAttribute(\"instanceEnd\", new InterleavedBufferAttribute(instanceBuffer, 3, 3));\n    this.computeBoundingBox();\n    this.computeBoundingSphere();\n    return this;\n  }\n  setColors(array) {\n    let itemSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n    let colors;\n    if (array instanceof Float32Array) {\n      colors = array;\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array);\n    }\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1);\n    this.setAttribute(\"instanceColorStart\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0));\n    this.setAttribute(\"instanceColorEnd\", new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize));\n    return this;\n  }\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));\n    return this;\n  }\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry;\n    this.setPositions(geometry.attributes.position.array);\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      this.boundingBox.setFromBufferAttribute(start);\n      _box.setFromBufferAttribute(end);\n      this.boundingBox.union(_box);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    if (this.boundingBox === null) {\n      this.computeBoundingBox();\n    }\n    const start = this.attributes.instanceStart;\n    const end = this.attributes.instanceEnd;\n    if (start !== void 0 && end !== void 0) {\n      const center = this.boundingSphere.center;\n      this.boundingBox.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n        _vector.fromBufferAttribute(end, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\"THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.\", this);\n      }\n    }\n  }\n  toJSON() {}\n  applyMatrix(matrix) {\n    console.warn(\"THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().\");\n    return this.applyMatrix4(matrix);\n  }\n}\nexport { LineSegmentsGeometry };","map":{"version":3,"names":["_box","Box3","_vector","Vector3","LineSegmentsGeometry","InstancedBufferGeometry","constructor","isLineSegmentsGeometry","type","positions","uvs","index","setIndex","setAttribute","Float32BufferAttribute","applyMatrix4","matrix","start","attributes","instanceStart","end","instanceEnd","needsUpdate","boundingBox","computeBoundingBox","boundingSphere","computeBoundingSphere","setPositions","array","lineSegments","Float32Array","Array","isArray","instanceBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","setColors","itemSize","arguments","length","undefined","colors","instanceColorBuffer","fromWireframeGeometry","geometry","position","fromEdgesGeometry","fromMesh","mesh","WireframeGeometry","fromLineSegments","setFromBufferAttribute","union","Sphere","center","getCenter","maxRadiusSq","i","il","count","fromBufferAttribute","Math","max","distanceToSquared","radius","sqrt","isNaN","console","error","toJSON","applyMatrix","warn"],"sources":["D:\\Repos\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\src\\lines\\LineSegmentsGeometry.js"],"sourcesContent":["import {\n  Box3,\n  Float32BufferAttribute,\n  InstancedBufferGeometry,\n  InstancedInterleavedBuffer,\n  InterleavedBufferAttribute,\n  Sphere,\n  Vector3,\n  WireframeGeometry,\n} from 'three'\n\nconst _box = new Box3()\nconst _vector = new Vector3()\n\nclass LineSegmentsGeometry extends InstancedBufferGeometry {\n  constructor() {\n    super()\n\n    this.isLineSegmentsGeometry = true\n\n    this.type = 'LineSegmentsGeometry'\n\n    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0]\n    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2]\n    const index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5]\n\n    this.setIndex(index)\n    this.setAttribute('position', new Float32BufferAttribute(positions, 3))\n    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))\n  }\n\n  applyMatrix4(matrix) {\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined) {\n      start.applyMatrix4(matrix)\n\n      end.applyMatrix4(matrix)\n\n      start.needsUpdate = true\n    }\n\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox()\n    }\n\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere()\n    }\n\n    return this\n  }\n\n  setPositions(array) {\n    let lineSegments\n\n    if (array instanceof Float32Array) {\n      lineSegments = array\n    } else if (Array.isArray(array)) {\n      lineSegments = new Float32Array(array)\n    }\n\n    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1) // xyz, xyz\n\n    this.setAttribute('instanceStart', new InterleavedBufferAttribute(instanceBuffer, 3, 0)) // xyz\n    this.setAttribute('instanceEnd', new InterleavedBufferAttribute(instanceBuffer, 3, 3)) // xyz\n\n    //\n\n    this.computeBoundingBox()\n    this.computeBoundingSphere()\n\n    return this\n  }\n\n  setColors(array, itemSize = 3) {\n    let colors\n\n    if (array instanceof Float32Array) {\n      colors = array\n    } else if (Array.isArray(array)) {\n      colors = new Float32Array(array)\n    }\n\n    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, itemSize * 2, 1) // rgb(a), rgb(a)\n\n    this.setAttribute('instanceColorStart', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, 0)) // rgb(a)\n    this.setAttribute('instanceColorEnd', new InterleavedBufferAttribute(instanceColorBuffer, itemSize, itemSize)) // rgb(a)\n\n    return this\n  }\n\n  fromWireframeGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromEdgesGeometry(geometry) {\n    this.setPositions(geometry.attributes.position.array)\n\n    return this\n  }\n\n  fromMesh(mesh) {\n    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry))\n\n    // set colors, maybe\n\n    return this\n  }\n\n  fromLineSegments(lineSegments) {\n    const geometry = lineSegments.geometry\n\n    this.setPositions(geometry.attributes.position.array) // assumes non-indexed\n\n    // set colors, maybe\n\n    return this\n  }\n\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      this.boundingBox.setFromBufferAttribute(start)\n\n      _box.setFromBufferAttribute(end)\n\n      this.boundingBox.union(_box)\n    }\n  }\n\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere()\n    }\n\n    if (this.boundingBox === null) {\n      this.computeBoundingBox()\n    }\n\n    const start = this.attributes.instanceStart\n    const end = this.attributes.instanceEnd\n\n    if (start !== undefined && end !== undefined) {\n      const center = this.boundingSphere.center\n\n      this.boundingBox.getCenter(center)\n\n      let maxRadiusSq = 0\n\n      for (let i = 0, il = start.count; i < il; i++) {\n        _vector.fromBufferAttribute(start, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n\n        _vector.fromBufferAttribute(end, i)\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector))\n      }\n\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq)\n\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error(\n          'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.',\n          this,\n        )\n      }\n    }\n  }\n\n  toJSON() {\n    // todo\n  }\n\n  applyMatrix(matrix) {\n    console.warn('THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().')\n\n    return this.applyMatrix4(matrix)\n  }\n}\n\nexport { LineSegmentsGeometry }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}