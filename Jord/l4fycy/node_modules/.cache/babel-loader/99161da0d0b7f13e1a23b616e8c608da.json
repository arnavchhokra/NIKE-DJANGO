{"ast":null,"code":"import { Line3, Plane, Vector3, Mesh } from 'three';\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\n/**\r\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\r\n *\r\n * Usage:\r\n *\r\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\r\n *\r\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\r\n *\r\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\r\n *\r\n * Requisites for the object:\r\n *\r\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\r\n *\r\n *  - Vertex normals must be planar (not smoothed)\r\n *\r\n *  - The geometry must be convex (this is not checked in the library). You can create convex\r\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\r\n *  can also be used.\r\n *\r\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\r\n * Use with caution and read the code when using with other libs.\r\n *\r\n * @param {double} minSizeForBreak Min size a debris can have to break.\r\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\r\n *\r\n */\n\nvar ConvexObjectBreaker = function ConvexObjectBreaker(minSizeForBreak, smallDelta) {\n  this.minSizeForBreak = minSizeForBreak || 1.4;\n  this.smallDelta = smallDelta || 0.0001;\n  this.tempLine1 = new Line3();\n  this.tempPlane1 = new Plane();\n  this.tempPlane2 = new Plane();\n  this.tempPlane_Cut = new Plane();\n  this.tempCM1 = new Vector3();\n  this.tempCM2 = new Vector3();\n  this.tempVector3 = new Vector3();\n  this.tempVector3_2 = new Vector3();\n  this.tempVector3_3 = new Vector3();\n  this.tempVector3_P0 = new Vector3();\n  this.tempVector3_P1 = new Vector3();\n  this.tempVector3_P2 = new Vector3();\n  this.tempVector3_N0 = new Vector3();\n  this.tempVector3_N1 = new Vector3();\n  this.tempVector3_AB = new Vector3();\n  this.tempVector3_CB = new Vector3();\n  this.tempResultObjects = {\n    object1: null,\n    object2: null\n  };\n  this.segments = [];\n  var n = 30 * 30;\n\n  for (var i = 0; i < n; i++) {\n    this.segments[i] = false;\n  }\n};\n\nConvexObjectBreaker.prototype = {\n  constructor: ConvexObjectBreaker,\n  prepareBreakableObject: function prepareBreakableObject(object, mass, velocity, angularVelocity, breakable) {\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\n    // Its material property is propagated to its children (sub-pieces)\n    // mass must be > 0\n    if (!object.geometry.isBufferGeometry) {\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\n    }\n\n    var userData = object.userData;\n    userData.mass = mass;\n    userData.velocity = velocity.clone();\n    userData.angularVelocity = angularVelocity.clone();\n    userData.breakable = breakable;\n  },\n\n  /*\r\n   * @param {int} maxRadialIterations Iterations for radial cuts.\r\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\r\n   *\r\n   * Returns the array of pieces\r\n   */\n  subdivideByImpact: function subdivideByImpact(object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\n    var debris = [];\n    var tempPlane1 = this.tempPlane1;\n    var tempPlane2 = this.tempPlane2;\n    this.tempVector3.addVectors(pointOfImpact, normal);\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\n    var scope = this;\n\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\n        debris.push(subObject);\n        return;\n      }\n\n      var angle = Math.PI;\n\n      if (numIterations === 0) {\n        tempPlane2.normal.copy(tempPlane1.normal);\n        tempPlane2.constant = tempPlane1.constant;\n      } else {\n        if (numIterations <= maxRadialIterations) {\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\n\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\n        } else {\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\n\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\n          scope.tempVector3_3.copy(normal).add(subObject.position);\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\n        }\n      } // Perform the cut\n\n\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\n      var obj1 = scope.tempResultObjects.object1;\n      var obj2 = scope.tempResultObjects.object2;\n\n      if (obj1) {\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\n      }\n\n      if (obj2) {\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\n      }\n    }\n\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\n    return debris;\n  },\n  cutByPlane: function cutByPlane(object, plane, output) {\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\n    // object2 can be null if the plane doesn't cut the object.\n    // object1 can be null only in case of internal error\n    // Returned value is number of pieces, 0 for error.\n    var geometry = object.geometry;\n    var coords = geometry.attributes.position.array;\n    var normals = geometry.attributes.normal.array;\n    var numPoints = coords.length / 3;\n    var numFaces = numPoints / 3;\n    var indices = geometry.getIndex();\n\n    if (indices) {\n      indices = indices.array;\n      numFaces = indices.length / 3;\n    }\n\n    function getVertexIndex(faceIdx, vert) {\n      // vert = 0, 1 or 2.\n      var idx = faceIdx * 3 + vert;\n      return indices ? indices[idx] : idx;\n    }\n\n    var points1 = [];\n    var points2 = [];\n    var delta = this.smallDelta; // Reset segments mark\n\n    var numPointPairs = numPoints * numPoints;\n\n    for (var i = 0; i < numPointPairs; i++) {\n      this.segments[i] = false;\n    }\n\n    var p0 = this.tempVector3_P0;\n    var p1 = this.tempVector3_P1;\n    var n0 = this.tempVector3_N0;\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\n\n    for (var _i = 0; _i < numFaces - 1; _i++) {\n      var a1 = getVertexIndex(_i, 0);\n      var b1 = getVertexIndex(_i, 1);\n      var c1 = getVertexIndex(_i, 2); // Assuming all 3 vertices have the same normal\n\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\n\n      for (var j = _i + 1; j < numFaces; j++) {\n        var a2 = getVertexIndex(j, 0);\n        var b2 = getVertexIndex(j, 1);\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\n\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\n        var coplanar = 1 - n0.dot(n1) < delta;\n\n        if (coplanar) {\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\n              this.segments[a1 * numPoints + b1] = true;\n              this.segments[b1 * numPoints + a1] = true;\n            } else {\n              this.segments[c1 * numPoints + a1] = true;\n              this.segments[a1 * numPoints + c1] = true;\n            }\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\n            this.segments[c1 * numPoints + b1] = true;\n            this.segments[b1 * numPoints + c1] = true;\n          }\n        }\n      }\n    } // Transform the plane to object local space\n\n\n    var localPlane = this.tempPlane_Cut;\n    object.updateMatrix();\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\n\n    for (var _i2 = 0; _i2 < numFaces; _i2++) {\n      var va = getVertexIndex(_i2, 0);\n      var vb = getVertexIndex(_i2, 1);\n      var vc = getVertexIndex(_i2, 2);\n\n      for (var segment = 0; segment < 3; segment++) {\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\n        var segmentState = this.segments[i0 * numPoints + i1];\n        if (segmentState) continue; // The segment already has been processed in another face\n        // Mark segment as processed (also inverted segment)\n\n        this.segments[i0 * numPoints + i1] = true;\n        this.segments[i1 * numPoints + i0] = true;\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n        var mark0 = 0;\n        var d = localPlane.distanceToPoint(p0);\n\n        if (d > delta) {\n          mark0 = 2;\n          points2.push(p0.clone());\n        } else if (d < -delta) {\n          mark0 = 1;\n          points1.push(p0.clone());\n        } else {\n          mark0 = 3;\n          points1.push(p0.clone());\n          points2.push(p0.clone());\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\n\n\n        var mark1 = 0;\n        var d = localPlane.distanceToPoint(p1);\n\n        if (d > delta) {\n          mark1 = 2;\n          points2.push(p1.clone());\n        } else if (d < -delta) {\n          mark1 = 1;\n          points1.push(p1.clone());\n        } else {\n          mark1 = 3;\n          points1.push(p1.clone());\n          points2.push(p1.clone());\n        }\n\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\n          // Intersection of segment with the plane\n          this.tempLine1.start.copy(p0);\n          this.tempLine1.end.copy(p1);\n          var intersection = new Vector3();\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\n\n          if (intersection === undefined) {\n            // Shouldn't happen\n            console.error('Internal error: segment does not intersect plane.');\n            output.segmentedObject1 = null;\n            output.segmentedObject2 = null;\n            return 0;\n          }\n\n          points1.push(intersection);\n          points2.push(intersection.clone());\n        }\n      }\n    } // Calculate debris mass (very fast and imprecise):\n\n\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\n\n    this.tempCM1.set(0, 0, 0);\n    var radius1 = 0;\n    var numPoints1 = points1.length;\n\n    if (numPoints1 > 0) {\n      for (var _i3 = 0; _i3 < numPoints1; _i3++) {\n        this.tempCM1.add(points1[_i3]);\n      }\n\n      this.tempCM1.divideScalar(numPoints1);\n\n      for (var _i4 = 0; _i4 < numPoints1; _i4++) {\n        var p = points1[_i4];\n        p.sub(this.tempCM1);\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\n      }\n\n      this.tempCM1.add(object.position);\n    }\n\n    this.tempCM2.set(0, 0, 0);\n    var radius2 = 0;\n    var numPoints2 = points2.length;\n\n    if (numPoints2 > 0) {\n      for (var _i5 = 0; _i5 < numPoints2; _i5++) {\n        this.tempCM2.add(points2[_i5]);\n      }\n\n      this.tempCM2.divideScalar(numPoints2);\n\n      for (var _i6 = 0; _i6 < numPoints2; _i6++) {\n        var p = points2[_i6];\n        p.sub(this.tempCM2);\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\n      }\n\n      this.tempCM2.add(object.position);\n    }\n\n    var object1 = null;\n    var object2 = null;\n    var numObjects = 0;\n\n    if (numPoints1 > 4) {\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\n      object1.position.copy(this.tempCM1);\n      object1.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    if (numPoints2 > 4) {\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\n      object2.position.copy(this.tempCM2);\n      object2.quaternion.copy(object.quaternion);\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\n      numObjects++;\n    }\n\n    output.object1 = object1;\n    output.object2 = object2;\n    return numObjects;\n  }\n};\n\nConvexObjectBreaker.transformFreeVector = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[4] * y + e[8] * z;\n  v.y = e[1] * x + e[5] * y + e[9] * z;\n  v.z = e[2] * x + e[6] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a free vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z;\n  v.y = e[4] * x + e[5] * y + e[6] * z;\n  v.z = e[8] * x + e[9] * y + e[10] * z;\n  return v;\n};\n\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\n  // input:\n  // vector interpreted as a tied (ordinary) vector\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\n  var x = v.x,\n      y = v.y,\n      z = v.z;\n  var e = m.elements;\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\n  return v;\n};\n\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\n  var v1 = new Vector3();\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\n    resultPlane.normal.copy(plane.normal);\n    resultPlane.constant = plane.constant;\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\n\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\n  };\n}();\n\nexport { ConvexObjectBreaker };","map":{"version":3,"names":["Line3","Plane","Vector3","Mesh","ConvexGeometry","ConvexObjectBreaker","minSizeForBreak","smallDelta","tempLine1","tempPlane1","tempPlane2","tempPlane_Cut","tempCM1","tempCM2","tempVector3","tempVector3_2","tempVector3_3","tempVector3_P0","tempVector3_P1","tempVector3_P2","tempVector3_N0","tempVector3_N1","tempVector3_AB","tempVector3_CB","tempResultObjects","object1","object2","segments","n","i","prototype","constructor","prepareBreakableObject","object","mass","velocity","angularVelocity","breakable","geometry","isBufferGeometry","console","error","userData","clone","subdivideByImpact","pointOfImpact","normal","maxRadialIterations","maxRandomIterations","debris","addVectors","setFromCoplanarPoints","position","maxTotalIterations","scope","subdivideRadial","subObject","startAngle","endAngle","numIterations","Math","random","push","angle","PI","copy","constant","sub","applyAxisAngle","add","cutByPlane","obj1","obj2","plane","output","coords","attributes","array","normals","numPoints","length","numFaces","indices","getIndex","getVertexIndex","faceIdx","vert","idx","points1","points2","delta","numPointPairs","p0","p1","n0","n1","a1","b1","c1","set","j","a2","b2","c2","coplanar","dot","localPlane","updateMatrix","transformPlaneToLocalSpace","matrix","va","vb","vc","segment","i0","i1","segmentState","mark0","d","distanceToPoint","mark1","start","end","intersection","intersectLine","undefined","segmentedObject1","segmentedObject2","newMass","radius1","numPoints1","divideScalar","p","max","x","y","z","radius2","numPoints2","numObjects","material","quaternion","transformFreeVector","v","m","e","elements","transformFreeVectorInverse","transformTiedVectorInverse","v1","resultPlane","referencePoint","coplanarPoint"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/misc/ConvexObjectBreaker.js"],"sourcesContent":["import { Line3, Plane, Vector3, Mesh } from 'three';\r\nimport { ConvexGeometry } from '../geometries/ConvexGeometry.js';\r\n\r\n/**\r\n * @fileoverview This class can be used to subdivide a convex Geometry object into pieces.\r\n *\r\n * Usage:\r\n *\r\n * Use the function prepareBreakableObject to prepare a Mesh object to be broken.\r\n *\r\n * Then, call the various functions to subdivide the object (subdivideByImpact, cutByPlane)\r\n *\r\n * Sub-objects that are product of subdivision don't need prepareBreakableObject to be called on them.\r\n *\r\n * Requisites for the object:\r\n *\r\n *  - Mesh object must have a BufferGeometry (not Geometry) and a Material\r\n *\r\n *  - Vertex normals must be planar (not smoothed)\r\n *\r\n *  - The geometry must be convex (this is not checked in the library). You can create convex\r\n *  geometries with ConvexGeometry. The BoxGeometry, SphereGeometry and other convex primitives\r\n *  can also be used.\r\n *\r\n * Note: This lib adds member variables to object's userData member (see prepareBreakableObject function)\r\n * Use with caution and read the code when using with other libs.\r\n *\r\n * @param {double} minSizeForBreak Min size a debris can have to break.\r\n * @param {double} smallDelta Max distance to consider that a point belongs to a plane.\r\n *\r\n */\r\n\r\nvar ConvexObjectBreaker = function (minSizeForBreak, smallDelta) {\r\n  this.minSizeForBreak = minSizeForBreak || 1.4;\r\n  this.smallDelta = smallDelta || 0.0001;\r\n  this.tempLine1 = new Line3();\r\n  this.tempPlane1 = new Plane();\r\n  this.tempPlane2 = new Plane();\r\n  this.tempPlane_Cut = new Plane();\r\n  this.tempCM1 = new Vector3();\r\n  this.tempCM2 = new Vector3();\r\n  this.tempVector3 = new Vector3();\r\n  this.tempVector3_2 = new Vector3();\r\n  this.tempVector3_3 = new Vector3();\r\n  this.tempVector3_P0 = new Vector3();\r\n  this.tempVector3_P1 = new Vector3();\r\n  this.tempVector3_P2 = new Vector3();\r\n  this.tempVector3_N0 = new Vector3();\r\n  this.tempVector3_N1 = new Vector3();\r\n  this.tempVector3_AB = new Vector3();\r\n  this.tempVector3_CB = new Vector3();\r\n  this.tempResultObjects = {\r\n    object1: null,\r\n    object2: null\r\n  };\r\n  this.segments = [];\r\n  var n = 30 * 30;\r\n\r\n  for (let i = 0; i < n; i++) this.segments[i] = false;\r\n};\r\n\r\nConvexObjectBreaker.prototype = {\r\n  constructor: ConvexObjectBreaker,\r\n  prepareBreakableObject: function (object, mass, velocity, angularVelocity, breakable) {\r\n    // object is a Object3d (normally a Mesh), must have a BufferGeometry, and it must be convex.\r\n    // Its material property is propagated to its children (sub-pieces)\r\n    // mass must be > 0\r\n    if (!object.geometry.isBufferGeometry) {\r\n      console.error('THREE.ConvexObjectBreaker.prepareBreakableObject(): Parameter object must have a BufferGeometry.');\r\n    }\r\n\r\n    var userData = object.userData;\r\n    userData.mass = mass;\r\n    userData.velocity = velocity.clone();\r\n    userData.angularVelocity = angularVelocity.clone();\r\n    userData.breakable = breakable;\r\n  },\r\n\r\n  /*\r\n   * @param {int} maxRadialIterations Iterations for radial cuts.\r\n   * @param {int} maxRandomIterations Max random iterations for not-radial cuts\r\n   *\r\n   * Returns the array of pieces\r\n   */\r\n  subdivideByImpact: function (object, pointOfImpact, normal, maxRadialIterations, maxRandomIterations) {\r\n    var debris = [];\r\n    var tempPlane1 = this.tempPlane1;\r\n    var tempPlane2 = this.tempPlane2;\r\n    this.tempVector3.addVectors(pointOfImpact, normal);\r\n    tempPlane1.setFromCoplanarPoints(pointOfImpact, object.position, this.tempVector3);\r\n    var maxTotalIterations = maxRandomIterations + maxRadialIterations;\r\n    var scope = this;\r\n\r\n    function subdivideRadial(subObject, startAngle, endAngle, numIterations) {\r\n      if (Math.random() < numIterations * 0.05 || numIterations > maxTotalIterations) {\r\n        debris.push(subObject);\r\n        return;\r\n      }\r\n\r\n      var angle = Math.PI;\r\n\r\n      if (numIterations === 0) {\r\n        tempPlane2.normal.copy(tempPlane1.normal);\r\n        tempPlane2.constant = tempPlane1.constant;\r\n      } else {\r\n        if (numIterations <= maxRadialIterations) {\r\n          angle = (endAngle - startAngle) * (0.2 + 0.6 * Math.random()) + startAngle; // Rotate tempPlane2 at impact point around normal axis and the angle\r\n\r\n          scope.tempVector3_2.copy(object.position).sub(pointOfImpact).applyAxisAngle(normal, angle).add(pointOfImpact);\r\n          tempPlane2.setFromCoplanarPoints(pointOfImpact, scope.tempVector3, scope.tempVector3_2);\r\n        } else {\r\n          angle = (0.5 * (numIterations & 1) + 0.2 * (2 - Math.random())) * Math.PI; // Rotate tempPlane2 at object position around normal axis and the angle\r\n\r\n          scope.tempVector3_2.copy(pointOfImpact).sub(subObject.position).applyAxisAngle(normal, angle).add(subObject.position);\r\n          scope.tempVector3_3.copy(normal).add(subObject.position);\r\n          tempPlane2.setFromCoplanarPoints(subObject.position, scope.tempVector3_3, scope.tempVector3_2);\r\n        }\r\n      } // Perform the cut\r\n\r\n\r\n      scope.cutByPlane(subObject, tempPlane2, scope.tempResultObjects);\r\n      var obj1 = scope.tempResultObjects.object1;\r\n      var obj2 = scope.tempResultObjects.object2;\r\n\r\n      if (obj1) {\r\n        subdivideRadial(obj1, startAngle, angle, numIterations + 1);\r\n      }\r\n\r\n      if (obj2) {\r\n        subdivideRadial(obj2, angle, endAngle, numIterations + 1);\r\n      }\r\n    }\r\n\r\n    subdivideRadial(object, 0, 2 * Math.PI, 0);\r\n    return debris;\r\n  },\r\n  cutByPlane: function (object, plane, output) {\r\n    // Returns breakable objects in output.object1 and output.object2 members, the resulting 2 pieces of the cut.\r\n    // object2 can be null if the plane doesn't cut the object.\r\n    // object1 can be null only in case of internal error\r\n    // Returned value is number of pieces, 0 for error.\r\n    var geometry = object.geometry;\r\n    var coords = geometry.attributes.position.array;\r\n    var normals = geometry.attributes.normal.array;\r\n    var numPoints = coords.length / 3;\r\n    var numFaces = numPoints / 3;\r\n    var indices = geometry.getIndex();\r\n\r\n    if (indices) {\r\n      indices = indices.array;\r\n      numFaces = indices.length / 3;\r\n    }\r\n\r\n    function getVertexIndex(faceIdx, vert) {\r\n      // vert = 0, 1 or 2.\r\n      var idx = faceIdx * 3 + vert;\r\n      return indices ? indices[idx] : idx;\r\n    }\r\n\r\n    var points1 = [];\r\n    var points2 = [];\r\n    var delta = this.smallDelta; // Reset segments mark\r\n\r\n    var numPointPairs = numPoints * numPoints;\r\n\r\n    for (let i = 0; i < numPointPairs; i++) this.segments[i] = false;\r\n\r\n    var p0 = this.tempVector3_P0;\r\n    var p1 = this.tempVector3_P1;\r\n    var n0 = this.tempVector3_N0;\r\n    var n1 = this.tempVector3_N1; // Iterate through the faces to mark edges shared by coplanar faces\r\n\r\n    for (let i = 0; i < numFaces - 1; i++) {\r\n      var a1 = getVertexIndex(i, 0);\r\n      var b1 = getVertexIndex(i, 1);\r\n      var c1 = getVertexIndex(i, 2); // Assuming all 3 vertices have the same normal\r\n\r\n      n0.set(normals[a1], normals[a1] + 1, normals[a1] + 2);\r\n\r\n      for (let j = i + 1; j < numFaces; j++) {\r\n        var a2 = getVertexIndex(j, 0);\r\n        var b2 = getVertexIndex(j, 1);\r\n        var c2 = getVertexIndex(j, 2); // Assuming all 3 vertices have the same normal\r\n\r\n        n1.set(normals[a2], normals[a2] + 1, normals[a2] + 2);\r\n        var coplanar = 1 - n0.dot(n1) < delta;\r\n\r\n        if (coplanar) {\r\n          if (a1 === a2 || a1 === b2 || a1 === c2) {\r\n            if (b1 === a2 || b1 === b2 || b1 === c2) {\r\n              this.segments[a1 * numPoints + b1] = true;\r\n              this.segments[b1 * numPoints + a1] = true;\r\n            } else {\r\n              this.segments[c1 * numPoints + a1] = true;\r\n              this.segments[a1 * numPoints + c1] = true;\r\n            }\r\n          } else if (b1 === a2 || b1 === b2 || b1 === c2) {\r\n            this.segments[c1 * numPoints + b1] = true;\r\n            this.segments[b1 * numPoints + c1] = true;\r\n          }\r\n        }\r\n      }\r\n    } // Transform the plane to object local space\r\n\r\n\r\n    var localPlane = this.tempPlane_Cut;\r\n    object.updateMatrix();\r\n    ConvexObjectBreaker.transformPlaneToLocalSpace(plane, object.matrix, localPlane); // Iterate through the faces adding points to both pieces\r\n\r\n    for (let i = 0; i < numFaces; i++) {\r\n      var va = getVertexIndex(i, 0);\r\n      var vb = getVertexIndex(i, 1);\r\n      var vc = getVertexIndex(i, 2);\r\n\r\n      for (let segment = 0; segment < 3; segment++) {\r\n        var i0 = segment === 0 ? va : segment === 1 ? vb : vc;\r\n        var i1 = segment === 0 ? vb : segment === 1 ? vc : va;\r\n        var segmentState = this.segments[i0 * numPoints + i1];\r\n        if (segmentState) continue; // The segment already has been processed in another face\r\n        // Mark segment as processed (also inverted segment)\r\n\r\n        this.segments[i0 * numPoints + i1] = true;\r\n        this.segments[i1 * numPoints + i0] = true;\r\n        p0.set(coords[3 * i0], coords[3 * i0 + 1], coords[3 * i0 + 2]);\r\n        p1.set(coords[3 * i1], coords[3 * i1 + 1], coords[3 * i1 + 2]); // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\r\n        var mark0 = 0;\r\n        var d = localPlane.distanceToPoint(p0);\r\n\r\n        if (d > delta) {\r\n          mark0 = 2;\r\n          points2.push(p0.clone());\r\n        } else if (d < -delta) {\r\n          mark0 = 1;\r\n          points1.push(p0.clone());\r\n        } else {\r\n          mark0 = 3;\r\n          points1.push(p0.clone());\r\n          points2.push(p0.clone());\r\n        } // mark: 1 for negative side, 2 for positive side, 3 for coplanar point\r\n\r\n\r\n        var mark1 = 0;\r\n        var d = localPlane.distanceToPoint(p1);\r\n\r\n        if (d > delta) {\r\n          mark1 = 2;\r\n          points2.push(p1.clone());\r\n        } else if (d < -delta) {\r\n          mark1 = 1;\r\n          points1.push(p1.clone());\r\n        } else {\r\n          mark1 = 3;\r\n          points1.push(p1.clone());\r\n          points2.push(p1.clone());\r\n        }\r\n\r\n        if (mark0 === 1 && mark1 === 2 || mark0 === 2 && mark1 === 1) {\r\n          // Intersection of segment with the plane\r\n          this.tempLine1.start.copy(p0);\r\n          this.tempLine1.end.copy(p1);\r\n          var intersection = new Vector3();\r\n          intersection = localPlane.intersectLine(this.tempLine1, intersection);\r\n\r\n          if (intersection === undefined) {\r\n            // Shouldn't happen\r\n            console.error('Internal error: segment does not intersect plane.');\r\n            output.segmentedObject1 = null;\r\n            output.segmentedObject2 = null;\r\n            return 0;\r\n          }\r\n\r\n          points1.push(intersection);\r\n          points2.push(intersection.clone());\r\n        }\r\n      }\r\n    } // Calculate debris mass (very fast and imprecise):\r\n\r\n\r\n    var newMass = object.userData.mass * 0.5; // Calculate debris Center of Mass (again fast and imprecise)\r\n\r\n    this.tempCM1.set(0, 0, 0);\r\n    var radius1 = 0;\r\n    var numPoints1 = points1.length;\r\n\r\n    if (numPoints1 > 0) {\r\n      for (let i = 0; i < numPoints1; i++) this.tempCM1.add(points1[i]);\r\n\r\n      this.tempCM1.divideScalar(numPoints1);\r\n\r\n      for (let i = 0; i < numPoints1; i++) {\r\n        var p = points1[i];\r\n        p.sub(this.tempCM1);\r\n        radius1 = Math.max(radius1, p.x, p.y, p.z);\r\n      }\r\n\r\n      this.tempCM1.add(object.position);\r\n    }\r\n\r\n    this.tempCM2.set(0, 0, 0);\r\n    var radius2 = 0;\r\n    var numPoints2 = points2.length;\r\n\r\n    if (numPoints2 > 0) {\r\n      for (let i = 0; i < numPoints2; i++) this.tempCM2.add(points2[i]);\r\n\r\n      this.tempCM2.divideScalar(numPoints2);\r\n\r\n      for (let i = 0; i < numPoints2; i++) {\r\n        var p = points2[i];\r\n        p.sub(this.tempCM2);\r\n        radius2 = Math.max(radius2, p.x, p.y, p.z);\r\n      }\r\n\r\n      this.tempCM2.add(object.position);\r\n    }\r\n\r\n    var object1 = null;\r\n    var object2 = null;\r\n    var numObjects = 0;\r\n\r\n    if (numPoints1 > 4) {\r\n      object1 = new Mesh(new ConvexGeometry(points1), object.material);\r\n      object1.position.copy(this.tempCM1);\r\n      object1.quaternion.copy(object.quaternion);\r\n      this.prepareBreakableObject(object1, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius1 > this.minSizeForBreak);\r\n      numObjects++;\r\n    }\r\n\r\n    if (numPoints2 > 4) {\r\n      object2 = new Mesh(new ConvexGeometry(points2), object.material);\r\n      object2.position.copy(this.tempCM2);\r\n      object2.quaternion.copy(object.quaternion);\r\n      this.prepareBreakableObject(object2, newMass, object.userData.velocity, object.userData.angularVelocity, 2 * radius2 > this.minSizeForBreak);\r\n      numObjects++;\r\n    }\r\n\r\n    output.object1 = object1;\r\n    output.object2 = object2;\r\n    return numObjects;\r\n  }\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVector = function (v, m) {\r\n  // input:\r\n  // vector interpreted as a free vector\r\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n  var x = v.x,\r\n      y = v.y,\r\n      z = v.z;\r\n  var e = m.elements;\r\n  v.x = e[0] * x + e[4] * y + e[8] * z;\r\n  v.y = e[1] * x + e[5] * y + e[9] * z;\r\n  v.z = e[2] * x + e[6] * y + e[10] * z;\r\n  return v;\r\n};\r\n\r\nConvexObjectBreaker.transformFreeVectorInverse = function (v, m) {\r\n  // input:\r\n  // vector interpreted as a free vector\r\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n  var x = v.x,\r\n      y = v.y,\r\n      z = v.z;\r\n  var e = m.elements;\r\n  v.x = e[0] * x + e[1] * y + e[2] * z;\r\n  v.y = e[4] * x + e[5] * y + e[6] * z;\r\n  v.z = e[8] * x + e[9] * y + e[10] * z;\r\n  return v;\r\n};\r\n\r\nConvexObjectBreaker.transformTiedVectorInverse = function (v, m) {\r\n  // input:\r\n  // vector interpreted as a tied (ordinary) vector\r\n  // THREE.Matrix4 orthogonal matrix (matrix without scale)\r\n  var x = v.x,\r\n      y = v.y,\r\n      z = v.z;\r\n  var e = m.elements;\r\n  v.x = e[0] * x + e[1] * y + e[2] * z - e[12];\r\n  v.y = e[4] * x + e[5] * y + e[6] * z - e[13];\r\n  v.z = e[8] * x + e[9] * y + e[10] * z - e[14];\r\n  return v;\r\n};\r\n\r\nConvexObjectBreaker.transformPlaneToLocalSpace = function () {\r\n  var v1 = new Vector3();\r\n  return function transformPlaneToLocalSpace(plane, m, resultPlane) {\r\n    resultPlane.normal.copy(plane.normal);\r\n    resultPlane.constant = plane.constant;\r\n    var referencePoint = ConvexObjectBreaker.transformTiedVectorInverse(plane.coplanarPoint(v1), m);\r\n    ConvexObjectBreaker.transformFreeVectorInverse(resultPlane.normal, m); // recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\r\n    resultPlane.constant = -referencePoint.dot(resultPlane.normal);\r\n  };\r\n}();\r\n\r\nexport { ConvexObjectBreaker };\r\n"],"mappings":"AAAA,SAASA,KAAT,EAAgBC,KAAhB,EAAuBC,OAAvB,EAAgCC,IAAhC,QAA4C,OAA5C;AACA,SAASC,cAAT,QAA+B,iCAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAUC,eAAV,EAA2BC,UAA3B,EAAuC;EAC/D,KAAKD,eAAL,GAAuBA,eAAe,IAAI,GAA1C;EACA,KAAKC,UAAL,GAAkBA,UAAU,IAAI,MAAhC;EACA,KAAKC,SAAL,GAAiB,IAAIR,KAAJ,EAAjB;EACA,KAAKS,UAAL,GAAkB,IAAIR,KAAJ,EAAlB;EACA,KAAKS,UAAL,GAAkB,IAAIT,KAAJ,EAAlB;EACA,KAAKU,aAAL,GAAqB,IAAIV,KAAJ,EAArB;EACA,KAAKW,OAAL,GAAe,IAAIV,OAAJ,EAAf;EACA,KAAKW,OAAL,GAAe,IAAIX,OAAJ,EAAf;EACA,KAAKY,WAAL,GAAmB,IAAIZ,OAAJ,EAAnB;EACA,KAAKa,aAAL,GAAqB,IAAIb,OAAJ,EAArB;EACA,KAAKc,aAAL,GAAqB,IAAId,OAAJ,EAArB;EACA,KAAKe,cAAL,GAAsB,IAAIf,OAAJ,EAAtB;EACA,KAAKgB,cAAL,GAAsB,IAAIhB,OAAJ,EAAtB;EACA,KAAKiB,cAAL,GAAsB,IAAIjB,OAAJ,EAAtB;EACA,KAAKkB,cAAL,GAAsB,IAAIlB,OAAJ,EAAtB;EACA,KAAKmB,cAAL,GAAsB,IAAInB,OAAJ,EAAtB;EACA,KAAKoB,cAAL,GAAsB,IAAIpB,OAAJ,EAAtB;EACA,KAAKqB,cAAL,GAAsB,IAAIrB,OAAJ,EAAtB;EACA,KAAKsB,iBAAL,GAAyB;IACvBC,OAAO,EAAE,IADc;IAEvBC,OAAO,EAAE;EAFc,CAAzB;EAIA,KAAKC,QAAL,GAAgB,EAAhB;EACA,IAAIC,CAAC,GAAG,KAAK,EAAb;;EAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,CAApB,EAAuBC,CAAC,EAAxB;IAA4B,KAAKF,QAAL,CAAcE,CAAd,IAAmB,KAAnB;EAA5B;AACD,CA3BD;;AA6BAxB,mBAAmB,CAACyB,SAApB,GAAgC;EAC9BC,WAAW,EAAE1B,mBADiB;EAE9B2B,sBAAsB,EAAE,gCAAUC,MAAV,EAAkBC,IAAlB,EAAwBC,QAAxB,EAAkCC,eAAlC,EAAmDC,SAAnD,EAA8D;IACpF;IACA;IACA;IACA,IAAI,CAACJ,MAAM,CAACK,QAAP,CAAgBC,gBAArB,EAAuC;MACrCC,OAAO,CAACC,KAAR,CAAc,kGAAd;IACD;;IAED,IAAIC,QAAQ,GAAGT,MAAM,CAACS,QAAtB;IACAA,QAAQ,CAACR,IAAT,GAAgBA,IAAhB;IACAQ,QAAQ,CAACP,QAAT,GAAoBA,QAAQ,CAACQ,KAAT,EAApB;IACAD,QAAQ,CAACN,eAAT,GAA2BA,eAAe,CAACO,KAAhB,EAA3B;IACAD,QAAQ,CAACL,SAAT,GAAqBA,SAArB;EACD,CAf6B;;EAiB9B;AACF;AACA;AACA;AACA;AACA;EACEO,iBAAiB,EAAE,2BAAUX,MAAV,EAAkBY,aAAlB,EAAiCC,MAAjC,EAAyCC,mBAAzC,EAA8DC,mBAA9D,EAAmF;IACpG,IAAIC,MAAM,GAAG,EAAb;IACA,IAAIxC,UAAU,GAAG,KAAKA,UAAtB;IACA,IAAIC,UAAU,GAAG,KAAKA,UAAtB;IACA,KAAKI,WAAL,CAAiBoC,UAAjB,CAA4BL,aAA5B,EAA2CC,MAA3C;IACArC,UAAU,CAAC0C,qBAAX,CAAiCN,aAAjC,EAAgDZ,MAAM,CAACmB,QAAvD,EAAiE,KAAKtC,WAAtE;IACA,IAAIuC,kBAAkB,GAAGL,mBAAmB,GAAGD,mBAA/C;IACA,IAAIO,KAAK,GAAG,IAAZ;;IAEA,SAASC,eAAT,CAAyBC,SAAzB,EAAoCC,UAApC,EAAgDC,QAAhD,EAA0DC,aAA1D,EAAyE;MACvE,IAAIC,IAAI,CAACC,MAAL,KAAgBF,aAAa,GAAG,IAAhC,IAAwCA,aAAa,GAAGN,kBAA5D,EAAgF;QAC9EJ,MAAM,CAACa,IAAP,CAAYN,SAAZ;QACA;MACD;;MAED,IAAIO,KAAK,GAAGH,IAAI,CAACI,EAAjB;;MAEA,IAAIL,aAAa,KAAK,CAAtB,EAAyB;QACvBjD,UAAU,CAACoC,MAAX,CAAkBmB,IAAlB,CAAuBxD,UAAU,CAACqC,MAAlC;QACApC,UAAU,CAACwD,QAAX,GAAsBzD,UAAU,CAACyD,QAAjC;MACD,CAHD,MAGO;QACL,IAAIP,aAAa,IAAIZ,mBAArB,EAA0C;UACxCgB,KAAK,GAAG,CAACL,QAAQ,GAAGD,UAAZ,KAA2B,MAAM,MAAMG,IAAI,CAACC,MAAL,EAAvC,IAAwDJ,UAAhE,CADwC,CACoC;;UAE5EH,KAAK,CAACvC,aAAN,CAAoBkD,IAApB,CAAyBhC,MAAM,CAACmB,QAAhC,EAA0Ce,GAA1C,CAA8CtB,aAA9C,EAA6DuB,cAA7D,CAA4EtB,MAA5E,EAAoFiB,KAApF,EAA2FM,GAA3F,CAA+FxB,aAA/F;UACAnC,UAAU,CAACyC,qBAAX,CAAiCN,aAAjC,EAAgDS,KAAK,CAACxC,WAAtD,EAAmEwC,KAAK,CAACvC,aAAzE;QACD,CALD,MAKO;UACLgD,KAAK,GAAG,CAAC,OAAOJ,aAAa,GAAG,CAAvB,IAA4B,OAAO,IAAIC,IAAI,CAACC,MAAL,EAAX,CAA7B,IAA0DD,IAAI,CAACI,EAAvE,CADK,CACsE;;UAE3EV,KAAK,CAACvC,aAAN,CAAoBkD,IAApB,CAAyBpB,aAAzB,EAAwCsB,GAAxC,CAA4CX,SAAS,CAACJ,QAAtD,EAAgEgB,cAAhE,CAA+EtB,MAA/E,EAAuFiB,KAAvF,EAA8FM,GAA9F,CAAkGb,SAAS,CAACJ,QAA5G;UACAE,KAAK,CAACtC,aAAN,CAAoBiD,IAApB,CAAyBnB,MAAzB,EAAiCuB,GAAjC,CAAqCb,SAAS,CAACJ,QAA/C;UACA1C,UAAU,CAACyC,qBAAX,CAAiCK,SAAS,CAACJ,QAA3C,EAAqDE,KAAK,CAACtC,aAA3D,EAA0EsC,KAAK,CAACvC,aAAhF;QACD;MACF,CAxBsE,CAwBrE;;;MAGFuC,KAAK,CAACgB,UAAN,CAAiBd,SAAjB,EAA4B9C,UAA5B,EAAwC4C,KAAK,CAAC9B,iBAA9C;MACA,IAAI+C,IAAI,GAAGjB,KAAK,CAAC9B,iBAAN,CAAwBC,OAAnC;MACA,IAAI+C,IAAI,GAAGlB,KAAK,CAAC9B,iBAAN,CAAwBE,OAAnC;;MAEA,IAAI6C,IAAJ,EAAU;QACRhB,eAAe,CAACgB,IAAD,EAAOd,UAAP,EAAmBM,KAAnB,EAA0BJ,aAAa,GAAG,CAA1C,CAAf;MACD;;MAED,IAAIa,IAAJ,EAAU;QACRjB,eAAe,CAACiB,IAAD,EAAOT,KAAP,EAAcL,QAAd,EAAwBC,aAAa,GAAG,CAAxC,CAAf;MACD;IACF;;IAEDJ,eAAe,CAACtB,MAAD,EAAS,CAAT,EAAY,IAAI2B,IAAI,CAACI,EAArB,EAAyB,CAAzB,CAAf;IACA,OAAOf,MAAP;EACD,CA1E6B;EA2E9BqB,UAAU,EAAE,oBAAUrC,MAAV,EAAkBwC,KAAlB,EAAyBC,MAAzB,EAAiC;IAC3C;IACA;IACA;IACA;IACA,IAAIpC,QAAQ,GAAGL,MAAM,CAACK,QAAtB;IACA,IAAIqC,MAAM,GAAGrC,QAAQ,CAACsC,UAAT,CAAoBxB,QAApB,CAA6ByB,KAA1C;IACA,IAAIC,OAAO,GAAGxC,QAAQ,CAACsC,UAAT,CAAoB9B,MAApB,CAA2B+B,KAAzC;IACA,IAAIE,SAAS,GAAGJ,MAAM,CAACK,MAAP,GAAgB,CAAhC;IACA,IAAIC,QAAQ,GAAGF,SAAS,GAAG,CAA3B;IACA,IAAIG,OAAO,GAAG5C,QAAQ,CAAC6C,QAAT,EAAd;;IAEA,IAAID,OAAJ,EAAa;MACXA,OAAO,GAAGA,OAAO,CAACL,KAAlB;MACAI,QAAQ,GAAGC,OAAO,CAACF,MAAR,GAAiB,CAA5B;IACD;;IAED,SAASI,cAAT,CAAwBC,OAAxB,EAAiCC,IAAjC,EAAuC;MACrC;MACA,IAAIC,GAAG,GAAGF,OAAO,GAAG,CAAV,GAAcC,IAAxB;MACA,OAAOJ,OAAO,GAAGA,OAAO,CAACK,GAAD,CAAV,GAAkBA,GAAhC;IACD;;IAED,IAAIC,OAAO,GAAG,EAAd;IACA,IAAIC,OAAO,GAAG,EAAd;IACA,IAAIC,KAAK,GAAG,KAAKnF,UAAjB,CAzB2C,CAyBd;;IAE7B,IAAIoF,aAAa,GAAGZ,SAAS,GAAGA,SAAhC;;IAEA,KAAK,IAAIlD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8D,aAApB,EAAmC9D,CAAC,EAApC;MAAwC,KAAKF,QAAL,CAAcE,CAAd,IAAmB,KAAnB;IAAxC;;IAEA,IAAI+D,EAAE,GAAG,KAAK3E,cAAd;IACA,IAAI4E,EAAE,GAAG,KAAK3E,cAAd;IACA,IAAI4E,EAAE,GAAG,KAAK1E,cAAd;IACA,IAAI2E,EAAE,GAAG,KAAK1E,cAAd,CAlC2C,CAkCb;;IAE9B,KAAK,IAAIQ,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAGoD,QAAQ,GAAG,CAA/B,EAAkCpD,EAAC,EAAnC,EAAuC;MACrC,IAAImE,EAAE,GAAGZ,cAAc,CAACvD,EAAD,EAAI,CAAJ,CAAvB;MACA,IAAIoE,EAAE,GAAGb,cAAc,CAACvD,EAAD,EAAI,CAAJ,CAAvB;MACA,IAAIqE,EAAE,GAAGd,cAAc,CAACvD,EAAD,EAAI,CAAJ,CAAvB,CAHqC,CAGN;;MAE/BiE,EAAE,CAACK,GAAH,CAAOrB,OAAO,CAACkB,EAAD,CAAd,EAAoBlB,OAAO,CAACkB,EAAD,CAAP,GAAc,CAAlC,EAAqClB,OAAO,CAACkB,EAAD,CAAP,GAAc,CAAnD;;MAEA,KAAK,IAAII,CAAC,GAAGvE,EAAC,GAAG,CAAjB,EAAoBuE,CAAC,GAAGnB,QAAxB,EAAkCmB,CAAC,EAAnC,EAAuC;QACrC,IAAIC,EAAE,GAAGjB,cAAc,CAACgB,CAAD,EAAI,CAAJ,CAAvB;QACA,IAAIE,EAAE,GAAGlB,cAAc,CAACgB,CAAD,EAAI,CAAJ,CAAvB;QACA,IAAIG,EAAE,GAAGnB,cAAc,CAACgB,CAAD,EAAI,CAAJ,CAAvB,CAHqC,CAGN;;QAE/BL,EAAE,CAACI,GAAH,CAAOrB,OAAO,CAACuB,EAAD,CAAd,EAAoBvB,OAAO,CAACuB,EAAD,CAAP,GAAc,CAAlC,EAAqCvB,OAAO,CAACuB,EAAD,CAAP,GAAc,CAAnD;QACA,IAAIG,QAAQ,GAAG,IAAIV,EAAE,CAACW,GAAH,CAAOV,EAAP,CAAJ,GAAiBL,KAAhC;;QAEA,IAAIc,QAAJ,EAAc;UACZ,IAAIR,EAAE,KAAKK,EAAP,IAAaL,EAAE,KAAKM,EAApB,IAA0BN,EAAE,KAAKO,EAArC,EAAyC;YACvC,IAAIN,EAAE,KAAKI,EAAP,IAAaJ,EAAE,KAAKK,EAApB,IAA0BL,EAAE,KAAKM,EAArC,EAAyC;cACvC,KAAK5E,QAAL,CAAcqE,EAAE,GAAGjB,SAAL,GAAiBkB,EAA/B,IAAqC,IAArC;cACA,KAAKtE,QAAL,CAAcsE,EAAE,GAAGlB,SAAL,GAAiBiB,EAA/B,IAAqC,IAArC;YACD,CAHD,MAGO;cACL,KAAKrE,QAAL,CAAcuE,EAAE,GAAGnB,SAAL,GAAiBiB,EAA/B,IAAqC,IAArC;cACA,KAAKrE,QAAL,CAAcqE,EAAE,GAAGjB,SAAL,GAAiBmB,EAA/B,IAAqC,IAArC;YACD;UACF,CARD,MAQO,IAAID,EAAE,KAAKI,EAAP,IAAaJ,EAAE,KAAKK,EAApB,IAA0BL,EAAE,KAAKM,EAArC,EAAyC;YAC9C,KAAK5E,QAAL,CAAcuE,EAAE,GAAGnB,SAAL,GAAiBkB,EAA/B,IAAqC,IAArC;YACA,KAAKtE,QAAL,CAAcsE,EAAE,GAAGlB,SAAL,GAAiBmB,EAA/B,IAAqC,IAArC;UACD;QACF;MACF;IACF,CAlE0C,CAkEzC;;;IAGF,IAAIQ,UAAU,GAAG,KAAK/F,aAAtB;IACAsB,MAAM,CAAC0E,YAAP;IACAtG,mBAAmB,CAACuG,0BAApB,CAA+CnC,KAA/C,EAAsDxC,MAAM,CAAC4E,MAA7D,EAAqEH,UAArE,EAvE2C,CAuEuC;;IAElF,KAAK,IAAI7E,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGoD,QAApB,EAA8BpD,GAAC,EAA/B,EAAmC;MACjC,IAAIiF,EAAE,GAAG1B,cAAc,CAACvD,GAAD,EAAI,CAAJ,CAAvB;MACA,IAAIkF,EAAE,GAAG3B,cAAc,CAACvD,GAAD,EAAI,CAAJ,CAAvB;MACA,IAAImF,EAAE,GAAG5B,cAAc,CAACvD,GAAD,EAAI,CAAJ,CAAvB;;MAEA,KAAK,IAAIoF,OAAO,GAAG,CAAnB,EAAsBA,OAAO,GAAG,CAAhC,EAAmCA,OAAO,EAA1C,EAA8C;QAC5C,IAAIC,EAAE,GAAGD,OAAO,KAAK,CAAZ,GAAgBH,EAAhB,GAAqBG,OAAO,KAAK,CAAZ,GAAgBF,EAAhB,GAAqBC,EAAnD;QACA,IAAIG,EAAE,GAAGF,OAAO,KAAK,CAAZ,GAAgBF,EAAhB,GAAqBE,OAAO,KAAK,CAAZ,GAAgBD,EAAhB,GAAqBF,EAAnD;QACA,IAAIM,YAAY,GAAG,KAAKzF,QAAL,CAAcuF,EAAE,GAAGnC,SAAL,GAAiBoC,EAA/B,CAAnB;QACA,IAAIC,YAAJ,EAAkB,SAJ0B,CAIhB;QAC5B;;QAEA,KAAKzF,QAAL,CAAcuF,EAAE,GAAGnC,SAAL,GAAiBoC,EAA/B,IAAqC,IAArC;QACA,KAAKxF,QAAL,CAAcwF,EAAE,GAAGpC,SAAL,GAAiBmC,EAA/B,IAAqC,IAArC;QACAtB,EAAE,CAACO,GAAH,CAAOxB,MAAM,CAAC,IAAIuC,EAAL,CAAb,EAAuBvC,MAAM,CAAC,IAAIuC,EAAJ,GAAS,CAAV,CAA7B,EAA2CvC,MAAM,CAAC,IAAIuC,EAAJ,GAAS,CAAV,CAAjD;QACArB,EAAE,CAACM,GAAH,CAAOxB,MAAM,CAAC,IAAIwC,EAAL,CAAb,EAAuBxC,MAAM,CAAC,IAAIwC,EAAJ,GAAS,CAAV,CAA7B,EAA2CxC,MAAM,CAAC,IAAIwC,EAAJ,GAAS,CAAV,CAAjD,EAV4C,CAUoB;;QAEhE,IAAIE,KAAK,GAAG,CAAZ;QACA,IAAIC,CAAC,GAAGZ,UAAU,CAACa,eAAX,CAA2B3B,EAA3B,CAAR;;QAEA,IAAI0B,CAAC,GAAG5B,KAAR,EAAe;UACb2B,KAAK,GAAG,CAAR;UACA5B,OAAO,CAAC3B,IAAR,CAAa8B,EAAE,CAACjD,KAAH,EAAb;QACD,CAHD,MAGO,IAAI2E,CAAC,GAAG,CAAC5B,KAAT,EAAgB;UACrB2B,KAAK,GAAG,CAAR;UACA7B,OAAO,CAAC1B,IAAR,CAAa8B,EAAE,CAACjD,KAAH,EAAb;QACD,CAHM,MAGA;UACL0E,KAAK,GAAG,CAAR;UACA7B,OAAO,CAAC1B,IAAR,CAAa8B,EAAE,CAACjD,KAAH,EAAb;UACA8C,OAAO,CAAC3B,IAAR,CAAa8B,EAAE,CAACjD,KAAH,EAAb;QACD,CAzB2C,CAyB1C;;;QAGF,IAAI6E,KAAK,GAAG,CAAZ;QACA,IAAIF,CAAC,GAAGZ,UAAU,CAACa,eAAX,CAA2B1B,EAA3B,CAAR;;QAEA,IAAIyB,CAAC,GAAG5B,KAAR,EAAe;UACb8B,KAAK,GAAG,CAAR;UACA/B,OAAO,CAAC3B,IAAR,CAAa+B,EAAE,CAAClD,KAAH,EAAb;QACD,CAHD,MAGO,IAAI2E,CAAC,GAAG,CAAC5B,KAAT,EAAgB;UACrB8B,KAAK,GAAG,CAAR;UACAhC,OAAO,CAAC1B,IAAR,CAAa+B,EAAE,CAAClD,KAAH,EAAb;QACD,CAHM,MAGA;UACL6E,KAAK,GAAG,CAAR;UACAhC,OAAO,CAAC1B,IAAR,CAAa+B,EAAE,CAAClD,KAAH,EAAb;UACA8C,OAAO,CAAC3B,IAAR,CAAa+B,EAAE,CAAClD,KAAH,EAAb;QACD;;QAED,IAAI0E,KAAK,KAAK,CAAV,IAAeG,KAAK,KAAK,CAAzB,IAA8BH,KAAK,KAAK,CAAV,IAAeG,KAAK,KAAK,CAA3D,EAA8D;UAC5D;UACA,KAAKhH,SAAL,CAAeiH,KAAf,CAAqBxD,IAArB,CAA0B2B,EAA1B;UACA,KAAKpF,SAAL,CAAekH,GAAf,CAAmBzD,IAAnB,CAAwB4B,EAAxB;UACA,IAAI8B,YAAY,GAAG,IAAIzH,OAAJ,EAAnB;UACAyH,YAAY,GAAGjB,UAAU,CAACkB,aAAX,CAAyB,KAAKpH,SAA9B,EAAyCmH,YAAzC,CAAf;;UAEA,IAAIA,YAAY,KAAKE,SAArB,EAAgC;YAC9B;YACArF,OAAO,CAACC,KAAR,CAAc,mDAAd;YACAiC,MAAM,CAACoD,gBAAP,GAA0B,IAA1B;YACApD,MAAM,CAACqD,gBAAP,GAA0B,IAA1B;YACA,OAAO,CAAP;UACD;;UAEDvC,OAAO,CAAC1B,IAAR,CAAa6D,YAAb;UACAlC,OAAO,CAAC3B,IAAR,CAAa6D,YAAY,CAAChF,KAAb,EAAb;QACD;MACF;IACF,CA5I0C,CA4IzC;;;IAGF,IAAIqF,OAAO,GAAG/F,MAAM,CAACS,QAAP,CAAgBR,IAAhB,GAAuB,GAArC,CA/I2C,CA+ID;;IAE1C,KAAKtB,OAAL,CAAauF,GAAb,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;IACA,IAAI8B,OAAO,GAAG,CAAd;IACA,IAAIC,UAAU,GAAG1C,OAAO,CAACR,MAAzB;;IAEA,IAAIkD,UAAU,GAAG,CAAjB,EAAoB;MAClB,KAAK,IAAIrG,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGqG,UAApB,EAAgCrG,GAAC,EAAjC;QAAqC,KAAKjB,OAAL,CAAayD,GAAb,CAAiBmB,OAAO,CAAC3D,GAAD,CAAxB;MAArC;;MAEA,KAAKjB,OAAL,CAAauH,YAAb,CAA0BD,UAA1B;;MAEA,KAAK,IAAIrG,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAGqG,UAApB,EAAgCrG,GAAC,EAAjC,EAAqC;QACnC,IAAIuG,CAAC,GAAG5C,OAAO,CAAC3D,GAAD,CAAf;QACAuG,CAAC,CAACjE,GAAF,CAAM,KAAKvD,OAAX;QACAqH,OAAO,GAAGrE,IAAI,CAACyE,GAAL,CAASJ,OAAT,EAAkBG,CAAC,CAACE,CAApB,EAAuBF,CAAC,CAACG,CAAzB,EAA4BH,CAAC,CAACI,CAA9B,CAAV;MACD;;MAED,KAAK5H,OAAL,CAAayD,GAAb,CAAiBpC,MAAM,CAACmB,QAAxB;IACD;;IAED,KAAKvC,OAAL,CAAasF,GAAb,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;IACA,IAAIsC,OAAO,GAAG,CAAd;IACA,IAAIC,UAAU,GAAGjD,OAAO,CAACT,MAAzB;;IAEA,IAAI0D,UAAU,GAAG,CAAjB,EAAoB;MAClB,KAAK,IAAI7G,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG6G,UAApB,EAAgC7G,GAAC,EAAjC;QAAqC,KAAKhB,OAAL,CAAawD,GAAb,CAAiBoB,OAAO,CAAC5D,GAAD,CAAxB;MAArC;;MAEA,KAAKhB,OAAL,CAAasH,YAAb,CAA0BO,UAA1B;;MAEA,KAAK,IAAI7G,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG6G,UAApB,EAAgC7G,GAAC,EAAjC,EAAqC;QACnC,IAAIuG,CAAC,GAAG3C,OAAO,CAAC5D,GAAD,CAAf;QACAuG,CAAC,CAACjE,GAAF,CAAM,KAAKtD,OAAX;QACA4H,OAAO,GAAG7E,IAAI,CAACyE,GAAL,CAASI,OAAT,EAAkBL,CAAC,CAACE,CAApB,EAAuBF,CAAC,CAACG,CAAzB,EAA4BH,CAAC,CAACI,CAA9B,CAAV;MACD;;MAED,KAAK3H,OAAL,CAAawD,GAAb,CAAiBpC,MAAM,CAACmB,QAAxB;IACD;;IAED,IAAI3B,OAAO,GAAG,IAAd;IACA,IAAIC,OAAO,GAAG,IAAd;IACA,IAAIiH,UAAU,GAAG,CAAjB;;IAEA,IAAIT,UAAU,GAAG,CAAjB,EAAoB;MAClBzG,OAAO,GAAG,IAAItB,IAAJ,CAAS,IAAIC,cAAJ,CAAmBoF,OAAnB,CAAT,EAAsCvD,MAAM,CAAC2G,QAA7C,CAAV;MACAnH,OAAO,CAAC2B,QAAR,CAAiBa,IAAjB,CAAsB,KAAKrD,OAA3B;MACAa,OAAO,CAACoH,UAAR,CAAmB5E,IAAnB,CAAwBhC,MAAM,CAAC4G,UAA/B;MACA,KAAK7G,sBAAL,CAA4BP,OAA5B,EAAqCuG,OAArC,EAA8C/F,MAAM,CAACS,QAAP,CAAgBP,QAA9D,EAAwEF,MAAM,CAACS,QAAP,CAAgBN,eAAxF,EAAyG,IAAI6F,OAAJ,GAAc,KAAK3H,eAA5H;MACAqI,UAAU;IACX;;IAED,IAAID,UAAU,GAAG,CAAjB,EAAoB;MAClBhH,OAAO,GAAG,IAAIvB,IAAJ,CAAS,IAAIC,cAAJ,CAAmBqF,OAAnB,CAAT,EAAsCxD,MAAM,CAAC2G,QAA7C,CAAV;MACAlH,OAAO,CAAC0B,QAAR,CAAiBa,IAAjB,CAAsB,KAAKpD,OAA3B;MACAa,OAAO,CAACmH,UAAR,CAAmB5E,IAAnB,CAAwBhC,MAAM,CAAC4G,UAA/B;MACA,KAAK7G,sBAAL,CAA4BN,OAA5B,EAAqCsG,OAArC,EAA8C/F,MAAM,CAACS,QAAP,CAAgBP,QAA9D,EAAwEF,MAAM,CAACS,QAAP,CAAgBN,eAAxF,EAAyG,IAAIqG,OAAJ,GAAc,KAAKnI,eAA5H;MACAqI,UAAU;IACX;;IAEDjE,MAAM,CAACjD,OAAP,GAAiBA,OAAjB;IACAiD,MAAM,CAAChD,OAAP,GAAiBA,OAAjB;IACA,OAAOiH,UAAP;EACD;AAvR6B,CAAhC;;AA0RAtI,mBAAmB,CAACyI,mBAApB,GAA0C,UAAUC,CAAV,EAAaC,CAAb,EAAgB;EACxD;EACA;EACA;EACA,IAAIV,CAAC,GAAGS,CAAC,CAACT,CAAV;EAAA,IACIC,CAAC,GAAGQ,CAAC,CAACR,CADV;EAAA,IAEIC,CAAC,GAAGO,CAAC,CAACP,CAFV;EAGA,IAAIS,CAAC,GAAGD,CAAC,CAACE,QAAV;EACAH,CAAC,CAACT,CAAF,GAAMW,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,CAAD,CAAD,GAAOT,CAAnC;EACAO,CAAC,CAACR,CAAF,GAAMU,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,CAAD,CAAD,GAAOT,CAAnC;EACAO,CAAC,CAACP,CAAF,GAAMS,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,EAAD,CAAD,GAAQT,CAApC;EACA,OAAOO,CAAP;AACD,CAZD;;AAcA1I,mBAAmB,CAAC8I,0BAApB,GAAiD,UAAUJ,CAAV,EAAaC,CAAb,EAAgB;EAC/D;EACA;EACA;EACA,IAAIV,CAAC,GAAGS,CAAC,CAACT,CAAV;EAAA,IACIC,CAAC,GAAGQ,CAAC,CAACR,CADV;EAAA,IAEIC,CAAC,GAAGO,CAAC,CAACP,CAFV;EAGA,IAAIS,CAAC,GAAGD,CAAC,CAACE,QAAV;EACAH,CAAC,CAACT,CAAF,GAAMW,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,CAAD,CAAD,GAAOT,CAAnC;EACAO,CAAC,CAACR,CAAF,GAAMU,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,CAAD,CAAD,GAAOT,CAAnC;EACAO,CAAC,CAACP,CAAF,GAAMS,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,EAAD,CAAD,GAAQT,CAApC;EACA,OAAOO,CAAP;AACD,CAZD;;AAcA1I,mBAAmB,CAAC+I,0BAApB,GAAiD,UAAUL,CAAV,EAAaC,CAAb,EAAgB;EAC/D;EACA;EACA;EACA,IAAIV,CAAC,GAAGS,CAAC,CAACT,CAAV;EAAA,IACIC,CAAC,GAAGQ,CAAC,CAACR,CADV;EAAA,IAEIC,CAAC,GAAGO,CAAC,CAACP,CAFV;EAGA,IAAIS,CAAC,GAAGD,CAAC,CAACE,QAAV;EACAH,CAAC,CAACT,CAAF,GAAMW,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,CAAD,CAAD,GAAOT,CAA7B,GAAiCS,CAAC,CAAC,EAAD,CAAxC;EACAF,CAAC,CAACR,CAAF,GAAMU,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,CAAD,CAAD,GAAOT,CAA7B,GAAiCS,CAAC,CAAC,EAAD,CAAxC;EACAF,CAAC,CAACP,CAAF,GAAMS,CAAC,CAAC,CAAD,CAAD,GAAOX,CAAP,GAAWW,CAAC,CAAC,CAAD,CAAD,GAAOV,CAAlB,GAAsBU,CAAC,CAAC,EAAD,CAAD,GAAQT,CAA9B,GAAkCS,CAAC,CAAC,EAAD,CAAzC;EACA,OAAOF,CAAP;AACD,CAZD;;AAcA1I,mBAAmB,CAACuG,0BAApB,GAAiD,YAAY;EAC3D,IAAIyC,EAAE,GAAG,IAAInJ,OAAJ,EAAT;EACA,OAAO,SAAS0G,0BAAT,CAAoCnC,KAApC,EAA2CuE,CAA3C,EAA8CM,WAA9C,EAA2D;IAChEA,WAAW,CAACxG,MAAZ,CAAmBmB,IAAnB,CAAwBQ,KAAK,CAAC3B,MAA9B;IACAwG,WAAW,CAACpF,QAAZ,GAAuBO,KAAK,CAACP,QAA7B;IACA,IAAIqF,cAAc,GAAGlJ,mBAAmB,CAAC+I,0BAApB,CAA+C3E,KAAK,CAAC+E,aAAN,CAAoBH,EAApB,CAA/C,EAAwEL,CAAxE,CAArB;IACA3I,mBAAmB,CAAC8I,0BAApB,CAA+CG,WAAW,CAACxG,MAA3D,EAAmEkG,CAAnE,EAJgE,CAIO;;IAEvEM,WAAW,CAACpF,QAAZ,GAAuB,CAACqF,cAAc,CAAC9C,GAAf,CAAmB6C,WAAW,CAACxG,MAA/B,CAAxB;EACD,CAPD;AAQD,CAVgD,EAAjD;;AAYA,SAASzC,mBAAT"},"metadata":{},"sourceType":"module"}