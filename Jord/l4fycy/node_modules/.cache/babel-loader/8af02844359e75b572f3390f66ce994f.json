{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\nimport { unzlibSync } from 'fflate';\n\nvar VTKLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(VTKLoader, _Loader);\n\n  var _super = _createSuper(VTKLoader);\n\n  function VTKLoader(manager) {\n    _classCallCheck(this, VTKLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(VTKLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (text) {\n        try {\n          onLoad(scope.parse(text));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      function parseASCII(data) {\n        // connectivity of the triangles\n        var indices = []; // triangles vertices\n\n        var positions = []; // red, green, blue colors in the range 0 to 1\n\n        var colors = []; // normal vector, one per vertex\n\n        var normals = [];\n        var result; // pattern for detecting the end of a number sequence\n\n        var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\n\n        var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\n        // the first integer is the number of polygon nodes\n\n        var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\n\n        var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\n\n        var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\n\n        var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\n\n        var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\n\n        var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\n\n        var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\n\n        var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\n        var inPointsSection = false;\n        var inPolygonsSection = false;\n        var inTriangleStripSection = false;\n        var inPointDataSection = false;\n        var inCellDataSection = false;\n        var inColorSection = false;\n        var inNormalsSection = false;\n        var lines = data.split('\\n');\n\n        for (var i in lines) {\n          var line = lines[i].trim();\n\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (inPointsSection) {\n            // get the vertices\n            while ((result = pat3Floats.exec(line)) !== null) {\n              if (patWord.exec(line) !== null) break;\n              var x = parseFloat(result[1]);\n              var y = parseFloat(result[2]);\n              var z = parseFloat(result[3]);\n              positions.push(x, y, z);\n            }\n          } else if (inPolygonsSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n\n              if (numVertices >= 3) {\n                var i0 = parseInt(inds[0]);\n                var i1, i2;\n                var k = 1; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; ++j) {\n                  i1 = parseInt(inds[k]);\n                  i2 = parseInt(inds[k + 1]);\n                  indices.push(i0, i1, i2);\n                  k++;\n                }\n              }\n            }\n          } else if (inTriangleStripSection) {\n            if ((result = patConnectivity.exec(line)) !== null) {\n              // numVertices i0 i1 i2 ...\n              var numVertices = parseInt(result[1]);\n              var inds = result[2].split(/\\s+/);\n\n              if (numVertices >= 3) {\n                var i0, i1, i2; // split the polygon in numVertices - 2 triangles\n\n                for (var j = 0; j < numVertices - 2; j++) {\n                  if (j % 2 === 1) {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 2]);\n                    i2 = parseInt(inds[j + 1]);\n                    indices.push(i0, i1, i2);\n                  } else {\n                    i0 = parseInt(inds[j]);\n                    i1 = parseInt(inds[j + 1]);\n                    i2 = parseInt(inds[j + 2]);\n                    indices.push(i0, i1, i2);\n                  }\n                }\n              }\n            }\n          } else if (inPointDataSection || inCellDataSection) {\n            if (inColorSection) {\n              // Get the colors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var r = parseFloat(result[1]);\n                var g = parseFloat(result[2]);\n                var b = parseFloat(result[3]);\n                colors.push(r, g, b);\n              }\n            } else if (inNormalsSection) {\n              // Get the normal vectors\n              while ((result = pat3Floats.exec(line)) !== null) {\n                if (patWord.exec(line) !== null) break;\n                var nx = parseFloat(result[1]);\n                var ny = parseFloat(result[2]);\n                var nz = parseFloat(result[3]);\n                normals.push(nx, ny, nz);\n              }\n            }\n          }\n\n          if (patPOLYGONS.exec(line) !== null) {\n            inPolygonsSection = true;\n            inPointsSection = false;\n            inTriangleStripSection = false;\n          } else if (patPOINTS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = true;\n            inTriangleStripSection = false;\n          } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\n            inPolygonsSection = false;\n            inPointsSection = false;\n            inTriangleStripSection = true;\n          } else if (patPOINT_DATA.exec(line) !== null) {\n            inPointDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCELL_DATA.exec(line) !== null) {\n            inCellDataSection = true;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patCOLOR_SCALARS.exec(line) !== null) {\n            inColorSection = true;\n            inNormalsSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          } else if (patNORMALS.exec(line) !== null) {\n            inNormalsSection = true;\n            inColorSection = false;\n            inPointsSection = false;\n            inPolygonsSection = false;\n            inTriangleStripSection = false;\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setIndex(indices);\n        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\n\n        if (normals.length === positions.length) {\n          geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\n        }\n\n        if (colors.length !== indices.length) {\n          // stagger\n          if (colors.length === positions.length) {\n            geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\n          }\n        } else {\n          // cell\n          geometry = geometry.toNonIndexed();\n          var numTriangles = geometry.attributes.position.count / 3;\n\n          if (colors.length === numTriangles * 3) {\n            var newColors = [];\n\n            for (var i = 0; i < numTriangles; i++) {\n              var r = colors[3 * i + 0];\n              var g = colors[3 * i + 1];\n              var b = colors[3 * i + 2];\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n              newColors.push(r, g, b);\n            }\n\n            geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\n          }\n        }\n\n        return geometry;\n      }\n\n      function parseBinary(data) {\n        var count, pointIndex, i, numberOfPoints, s;\n        var buffer = new Uint8Array(data);\n        var dataView = new DataView(data); // Points and normals, by default, are empty\n\n        var points = [];\n        var normals = [];\n        var indices = []; // Going to make a big array of strings\n\n        var index = 0;\n\n        function findString(buffer, start) {\n          var index = start;\n          var c = buffer[index];\n          var s = [];\n\n          while (c !== 10) {\n            s.push(String.fromCharCode(c));\n            index++;\n            c = buffer[index];\n          }\n\n          return {\n            start: start,\n            end: index,\n            next: index + 1,\n            parsedString: s.join('')\n          };\n        }\n\n        var state, line;\n\n        while (true) {\n          // Get a string\n          state = findString(buffer, index);\n          line = state.parsedString;\n\n          if (line.indexOf('DATASET') === 0) {\n            var dataset = line.split(' ')[1];\n            if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\n          } else if (line.indexOf('POINTS') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\n\n            count = numberOfPoints * 4 * 3;\n            points = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfPoints; i++) {\n              points[3 * i] = dataView.getFloat32(pointIndex, false);\n              points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex = pointIndex + 12;\n            } // increment our next pointer\n\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // retrieves the n-2 triangles from the triangle strip\n\n\n              for (var j = 0; j < indexCount - 2; j++) {\n                if (j % 2) {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 2];\n                  indices[indicesIndex++] = strip[j + 1];\n                } else {\n                  indices[indicesIndex++] = strip[j];\n                  indices[indicesIndex++] = strip[j + 1];\n                  indices[indicesIndex++] = strip[j + 2];\n                }\n              }\n            } // increment our next pointer\n\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POLYGONS') === 0) {\n            var numberOfStrips = parseInt(line.split(' ')[1], 10);\n            var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\n\n            count = size * 4;\n            indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n            var indicesIndex = 0;\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfStrips; i++) {\n              // For each strip, read the first value, then record that many more points\n              var indexCount = dataView.getInt32(pointIndex, false);\n              var strip = [];\n              pointIndex += 4;\n\n              for (s = 0; s < indexCount; s++) {\n                strip.push(dataView.getInt32(pointIndex, false));\n                pointIndex += 4;\n              } // divide the polygon in n-2 triangle\n\n\n              for (var j = 1; j < indexCount - 1; j++) {\n                indices[indicesIndex++] = strip[0];\n                indices[indicesIndex++] = strip[j];\n                indices[indicesIndex++] = strip[j + 1];\n              }\n            } // increment our next pointer\n\n\n            state.next = state.next + count + 1;\n          } else if (line.indexOf('POINT_DATA') === 0) {\n            numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\n\n            state = findString(buffer, state.next); // Now grab the binary data\n\n            count = numberOfPoints * 4 * 3;\n            normals = new Float32Array(numberOfPoints * 3);\n            pointIndex = state.next;\n\n            for (i = 0; i < numberOfPoints; i++) {\n              normals[3 * i] = dataView.getFloat32(pointIndex, false);\n              normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\n              normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\n              pointIndex += 12;\n            } // Increment past our data\n\n\n            state.next = state.next + count;\n          } // Increment index\n\n\n          index = state.next;\n\n          if (index >= buffer.byteLength) {\n            break;\n          }\n        }\n\n        var geometry = new BufferGeometry();\n        geometry.setIndex(new BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n        if (normals.length === points.length) {\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n        }\n\n        return geometry;\n      }\n\n      function Float32Concat(first, second) {\n        var firstLength = first.length,\n            result = new Float32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n\n      function Int32Concat(first, second) {\n        var firstLength = first.length,\n            result = new Int32Array(firstLength + second.length);\n        result.set(first);\n        result.set(second, firstLength);\n        return result;\n      }\n\n      function parseXML(stringFile) {\n        // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\n        function xmlToJson(xml) {\n          // Create the return object\n          var obj = {};\n\n          if (xml.nodeType === 1) {\n            // element\n            // do attributes\n            if (xml.attributes) {\n              if (xml.attributes.length > 0) {\n                obj['attributes'] = {};\n\n                for (var j = 0; j < xml.attributes.length; j++) {\n                  var attribute = xml.attributes.item(j);\n                  obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\n                }\n              }\n            }\n          } else if (xml.nodeType === 3) {\n            // text\n            obj = xml.nodeValue.trim();\n          } // do children\n\n\n          if (xml.hasChildNodes()) {\n            for (var i = 0; i < xml.childNodes.length; i++) {\n              var item = xml.childNodes.item(i);\n              var nodeName = item.nodeName;\n\n              if (typeof obj[nodeName] === 'undefined') {\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName] = tmp;\n              } else {\n                if (typeof obj[nodeName].push === 'undefined') {\n                  var old = obj[nodeName];\n                  obj[nodeName] = [old];\n                }\n\n                var tmp = xmlToJson(item);\n                if (tmp !== '') obj[nodeName].push(tmp);\n              }\n            }\n          }\n\n          return obj;\n        } // Taken from Base64-js\n\n\n        function Base64toByteArray(b64) {\n          var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n          var i;\n          var lookup = [];\n          var revLookup = [];\n          var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n          var len = code.length;\n\n          for (i = 0; i < len; i++) {\n            lookup[i] = code[i];\n          }\n\n          for (i = 0; i < len; ++i) {\n            revLookup[code.charCodeAt(i)] = i;\n          }\n\n          revLookup['-'.charCodeAt(0)] = 62;\n          revLookup['_'.charCodeAt(0)] = 63;\n          var j, l, tmp, placeHolders, arr;\n          var len = b64.length;\n\n          if (len % 4 > 0) {\n            throw new Error('Invalid string. Length must be a multiple of 4');\n          }\n\n          placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\n          arr = new Arr(len * 3 / 4 - placeHolders);\n          l = placeHolders > 0 ? len - 4 : len;\n          var L = 0;\n\n          for (i = 0, j = 0; i < l; i += 4, j += 3) {\n            tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n            arr[L++] = (tmp & 0xff0000) >> 16;\n            arr[L++] = (tmp & 0xff00) >> 8;\n            arr[L++] = tmp & 0xff;\n          }\n\n          if (placeHolders === 2) {\n            tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n            arr[L++] = tmp & 0xff;\n          } else if (placeHolders === 1) {\n            tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n            arr[L++] = tmp >> 8 & 0xff;\n            arr[L++] = tmp & 0xff;\n          }\n\n          return arr;\n        }\n\n        function parseDataArray(ele, compressed) {\n          var numBytes = 0;\n\n          if (json.attributes.header_type === 'UInt64') {\n            numBytes = 8;\n          } else if (json.attributes.header_type === 'UInt32') {\n            numBytes = 4;\n          } // Check the format\n\n\n          if (ele.attributes.format === 'binary' && compressed) {\n            var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\n\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array();\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array();\n            } // VTP data with the header has the following structure:\n            // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\n            //\n            // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\n            // [#blocks] = Number of blocks\n            // [#u-size] = Block size before compression\n            // [#p-size] = Size of last partial block (zero if it not needed)\n            // [#c-size-i] = Size in bytes of block i after compression\n            //\n            // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\n            // computed by summing the compressed block sizes from preceding blocks according to the header.\n\n\n            rawData = ele['#text'];\n            byteData = Base64toByteArray(rawData);\n            blocks = byteData[0];\n\n            for (var i = 1; i < numBytes - 1; i++) {\n              blocks = blocks | byteData[i] << i * numBytes;\n            }\n\n            headerSize = (blocks + 3) * numBytes;\n            padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\n            headerSize = headerSize + padding;\n            dataOffsets = [];\n            currentOffset = headerSize;\n            dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\n            // There are three blocks before c-size-i, so we skip 3*numBytes\n\n            cSizeStart = 3 * numBytes;\n\n            for (var i = 0; i < blocks; i++) {\n              var currentBlockSize = byteData[i * numBytes + cSizeStart];\n\n              for (var j = 1; j < numBytes - 1; j++) {\n                // Each data point consists of 8 bytes regardless of the header type\n                currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\n              }\n\n              currentOffset = currentOffset + currentBlockSize;\n              dataOffsets.push(currentOffset);\n            }\n\n            for (var i = 0; i < dataOffsets.length - 1; i++) {\n              var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\n\n              content = data.buffer;\n\n              if (ele.attributes.type === 'Float32') {\n                content = new Float32Array(content);\n                txt = Float32Concat(txt, content);\n              } else if (ele.attributes.type === 'Int64') {\n                content = new Int32Array(content);\n                txt = Int32Concat(txt, content);\n              }\n            }\n\n            delete ele['#text'];\n\n            if (ele.attributes.type === 'Int64') {\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } else {\n            if (ele.attributes.format === 'binary' && !compressed) {\n              var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\n              // [#bytes][DATA]\n              // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\n\n              content = content.slice(numBytes).buffer;\n            } else {\n              if (ele['#text']) {\n                var content = ele['#text'].split(/\\s+/).filter(function (el) {\n                  if (el !== '') return el;\n                });\n              } else {\n                var content = new Int32Array(0).buffer;\n              }\n            }\n\n            delete ele['#text']; // Get the content and optimize it\n\n            if (ele.attributes.type === 'Float32') {\n              var txt = new Float32Array(content);\n            } else if (ele.attributes.type === 'Int32') {\n              var txt = new Int32Array(content);\n            } else if (ele.attributes.type === 'Int64') {\n              var txt = new Int32Array(content);\n\n              if (ele.attributes.format === 'binary') {\n                txt = txt.filter(function (el, idx) {\n                  if (idx % 2 !== 1) return true;\n                });\n              }\n            }\n          } // endif ( ele.attributes.format === 'binary' && compressed )\n\n\n          return txt;\n        } // Main part\n        // Get Dom\n\n\n        var dom = null;\n\n        if (window.DOMParser) {\n          try {\n            dom = new DOMParser().parseFromString(stringFile, 'text/xml');\n          } catch (e) {\n            dom = null;\n          }\n        } else if (window.ActiveXObject) {\n          try {\n            dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\n\n            dom.async = false;\n\n            if (!dom.loadXML()) {\n              throw new Error(dom.parseError.reason + dom.parseError.srcText);\n            }\n          } catch (e) {\n            dom = null;\n          }\n        } else {\n          throw new Error('Cannot parse xml string!');\n        } // Get the doc\n\n\n        var doc = dom.documentElement; // Convert to json\n\n        var json = xmlToJson(doc);\n        var points = [];\n        var normals = [];\n        var indices = [];\n\n        if (json.PolyData) {\n          var piece = json.PolyData.Piece;\n          var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\n          // Loop through the sections\n\n          var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\n\n          var sectionIndex = 0,\n              numberOfSections = sections.length;\n\n          while (sectionIndex < numberOfSections) {\n            var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\n\n            if (section && section.DataArray) {\n              // Depending on the number of DataArrays\n              if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\n                var arr = section.DataArray;\n              } else {\n                var arr = [section.DataArray];\n              }\n\n              var dataArrayIndex = 0,\n                  numberOfDataArrays = arr.length;\n\n              while (dataArrayIndex < numberOfDataArrays) {\n                // Parse the DataArray\n                if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\n                  arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\n                }\n\n                dataArrayIndex++;\n              }\n\n              switch (sections[sectionIndex]) {\n                // if iti is point data\n                case 'PointData':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n                  var normalsName = section.attributes.Normals;\n\n                  if (numberOfPoints > 0) {\n                    for (var i = 0, len = arr.length; i < len; i++) {\n                      if (normalsName === arr[i].attributes.Name) {\n                        var components = arr[i].attributes.NumberOfComponents;\n                        normals = new Float32Array(numberOfPoints * components);\n                        normals.set(arr[i].text, 0);\n                      }\n                    }\n                  }\n\n                  break;\n                // if it is points\n\n                case 'Points':\n                  var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\n\n                  if (numberOfPoints > 0) {\n                    var components = section.DataArray.attributes.NumberOfComponents;\n                    points = new Float32Array(numberOfPoints * components);\n                    points.set(section.DataArray.text, 0);\n                  }\n\n                  break;\n                // if it is strips\n\n                case 'Strips':\n                  var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\n\n                  if (numberOfStrips > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfStrips + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfStrips);\n                    var indicesIndex = 0;\n\n                    for (var i = 0, len = numberOfStrips; i < len; i++) {\n                      var strip = [];\n\n                      for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\n                        strip.push(connectivity[s]);\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n\n                      for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\n                        if (j % 2) {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 2];\n                          indices[indicesIndex++] = strip[j + 1];\n                        } else {\n                          indices[indicesIndex++] = strip[j];\n                          indices[indicesIndex++] = strip[j + 1];\n                          indices[indicesIndex++] = strip[j + 2];\n                        }\n\n                        if (i > 0) len0 = offset[i - 1];\n                      }\n                    }\n                  }\n\n                  break;\n                // if it is polys\n\n                case 'Polys':\n                  var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\n\n                  if (numberOfPolys > 0) {\n                    var connectivity = new Int32Array(section.DataArray[0].text.length);\n                    var offset = new Int32Array(section.DataArray[1].text.length);\n                    connectivity.set(section.DataArray[0].text, 0);\n                    offset.set(section.DataArray[1].text, 0);\n                    var size = numberOfPolys + connectivity.length;\n                    indices = new Uint32Array(3 * size - 9 * numberOfPolys);\n                    var indicesIndex = 0,\n                        connectivityIndex = 0;\n                    var i = 0,\n                        len = numberOfPolys,\n                        len0 = 0;\n\n                    while (i < len) {\n                      var poly = [];\n                      var s = 0,\n                          len1 = offset[i];\n\n                      while (s < len1 - len0) {\n                        poly.push(connectivity[connectivityIndex++]);\n                        s++;\n                      }\n\n                      var j = 1;\n\n                      while (j < len1 - len0 - 1) {\n                        indices[indicesIndex++] = poly[0];\n                        indices[indicesIndex++] = poly[j];\n                        indices[indicesIndex++] = poly[j + 1];\n                        j++;\n                      }\n\n                      i++;\n                      len0 = offset[i - 1];\n                    }\n                  }\n\n                  break;\n              }\n            }\n\n            sectionIndex++;\n          }\n\n          var geometry = new BufferGeometry();\n          geometry.setIndex(new BufferAttribute(indices, 1));\n          geometry.setAttribute('position', new BufferAttribute(points, 3));\n\n          if (normals.length === points.length) {\n            geometry.setAttribute('normal', new BufferAttribute(normals, 3));\n          }\n\n          return geometry;\n        } else {\n          throw new Error('Unsupported DATASET type');\n        }\n      } // get the 5 first lines of the files to check if there is the key word binary\n\n\n      var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\n\n      if (meta[0].indexOf('xml') !== -1) {\n        return parseXML(LoaderUtils.decodeText(data));\n      } else if (meta[2].includes('ASCII')) {\n        return parseASCII(LoaderUtils.decodeText(data));\n      } else {\n        return parseBinary(data);\n      }\n    }\n  }]);\n\n  return VTKLoader;\n}(Loader);\n\nexport { VTKLoader };","map":{"version":3,"names":["Loader","FileLoader","LoaderUtils","BufferGeometry","Float32BufferAttribute","BufferAttribute","unzlibSync","VTKLoader","manager","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","text","parse","e","console","error","itemError","data","parseASCII","indices","positions","colors","normals","result","patWord","pat3Floats","patConnectivity","patPOINTS","patPOLYGONS","patTRIANGLE_STRIPS","patPOINT_DATA","patCELL_DATA","patCOLOR_SCALARS","patNORMALS","inPointsSection","inPolygonsSection","inTriangleStripSection","inPointDataSection","inCellDataSection","inColorSection","inNormalsSection","lines","split","i","line","trim","indexOf","dataset","Error","exec","x","parseFloat","y","z","push","numVertices","parseInt","inds","i0","i1","i2","k","j","r","g","b","nx","ny","nz","geometry","setIndex","setAttribute","length","toNonIndexed","numTriangles","attributes","position","count","newColors","parseBinary","pointIndex","numberOfPoints","s","buffer","Uint8Array","dataView","DataView","points","index","findString","start","c","String","fromCharCode","end","next","parsedString","join","state","Float32Array","getFloat32","numberOfStrips","size","Uint32Array","indicesIndex","indexCount","getInt32","strip","byteLength","Float32Concat","first","second","firstLength","set","Int32Concat","Int32Array","parseXML","stringFile","xmlToJson","xml","obj","nodeType","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","tmp","old","Base64toByteArray","b64","Arr","Array","lookup","revLookup","code","len","charCodeAt","l","placeHolders","arr","L","parseDataArray","ele","compressed","numBytes","json","header_type","format","rawData","content","byteData","blocks","cSizeStart","headerSize","padding","dataOffsets","currentOffset","type","txt","currentBlockSize","slice","filter","el","idx","dom","window","DOMParser","parseFromString","ActiveXObject","async","loadXML","parseError","reason","srcText","doc","documentElement","PolyData","piece","Piece","hasOwnProperty","sections","sectionIndex","numberOfSections","section","DataArray","Object","prototype","toString","call","dataArrayIndex","numberOfDataArrays","NumberOfPoints","normalsName","Normals","Name","components","NumberOfComponents","NumberOfStrips","connectivity","offset","len1","len0","numberOfPolys","NumberOfPolys","connectivityIndex","poly","meta","decodeText","includes"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/loaders/VTKLoader.js"],"sourcesContent":["import { Loader, FileLoader, LoaderUtils, BufferGeometry, Float32BufferAttribute, BufferAttribute } from 'three';\r\nimport { unzlibSync } from 'fflate';\r\n\r\nclass VTKLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const scope = this;\r\n    const loader = new FileLoader(scope.manager);\r\n    loader.setPath(scope.path);\r\n    loader.setResponseType('arraybuffer');\r\n    loader.setRequestHeader(scope.requestHeader);\r\n    loader.setWithCredentials(scope.withCredentials);\r\n    loader.load(url, function (text) {\r\n      try {\r\n        onLoad(scope.parse(text));\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          console.error(e);\r\n        }\r\n\r\n        scope.manager.itemError(url);\r\n      }\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  parse(data) {\r\n    function parseASCII(data) {\r\n      // connectivity of the triangles\r\n      var indices = []; // triangles vertices\r\n\r\n      var positions = []; // red, green, blue colors in the range 0 to 1\r\n\r\n      var colors = []; // normal vector, one per vertex\r\n\r\n      var normals = [];\r\n      var result; // pattern for detecting the end of a number sequence\r\n\r\n      var patWord = /^[^\\d.\\s-]+/; // pattern for reading vertices, 3 floats or integers\r\n\r\n      var pat3Floats = /(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)\\s+(\\-?\\d+\\.?[\\d\\-\\+e]*)/g; // pattern for connectivity, an integer followed by any number of ints\r\n      // the first integer is the number of polygon nodes\r\n\r\n      var patConnectivity = /^(\\d+)\\s+([\\s\\d]*)/; // indicates start of vertex data section\r\n\r\n      var patPOINTS = /^POINTS /; // indicates start of polygon connectivity section\r\n\r\n      var patPOLYGONS = /^POLYGONS /; // indicates start of triangle strips section\r\n\r\n      var patTRIANGLE_STRIPS = /^TRIANGLE_STRIPS /; // POINT_DATA number_of_values\r\n\r\n      var patPOINT_DATA = /^POINT_DATA[ ]+(\\d+)/; // CELL_DATA number_of_polys\r\n\r\n      var patCELL_DATA = /^CELL_DATA[ ]+(\\d+)/; // Start of color section\r\n\r\n      var patCOLOR_SCALARS = /^COLOR_SCALARS[ ]+(\\w+)[ ]+3/; // NORMALS Normals float\r\n\r\n      var patNORMALS = /^NORMALS[ ]+(\\w+)[ ]+(\\w+)/;\r\n      var inPointsSection = false;\r\n      var inPolygonsSection = false;\r\n      var inTriangleStripSection = false;\r\n      var inPointDataSection = false;\r\n      var inCellDataSection = false;\r\n      var inColorSection = false;\r\n      var inNormalsSection = false;\r\n      var lines = data.split('\\n');\r\n\r\n      for (var i in lines) {\r\n        var line = lines[i].trim();\r\n\r\n        if (line.indexOf('DATASET') === 0) {\r\n          var dataset = line.split(' ')[1];\r\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\r\n        } else if (inPointsSection) {\r\n          // get the vertices\r\n          while ((result = pat3Floats.exec(line)) !== null) {\r\n            if (patWord.exec(line) !== null) break;\r\n            var x = parseFloat(result[1]);\r\n            var y = parseFloat(result[2]);\r\n            var z = parseFloat(result[3]);\r\n            positions.push(x, y, z);\r\n          }\r\n        } else if (inPolygonsSection) {\r\n          if ((result = patConnectivity.exec(line)) !== null) {\r\n            // numVertices i0 i1 i2 ...\r\n            var numVertices = parseInt(result[1]);\r\n            var inds = result[2].split(/\\s+/);\r\n\r\n            if (numVertices >= 3) {\r\n              var i0 = parseInt(inds[0]);\r\n              var i1, i2;\r\n              var k = 1; // split the polygon in numVertices - 2 triangles\r\n\r\n              for (var j = 0; j < numVertices - 2; ++j) {\r\n                i1 = parseInt(inds[k]);\r\n                i2 = parseInt(inds[k + 1]);\r\n                indices.push(i0, i1, i2);\r\n                k++;\r\n              }\r\n            }\r\n          }\r\n        } else if (inTriangleStripSection) {\r\n          if ((result = patConnectivity.exec(line)) !== null) {\r\n            // numVertices i0 i1 i2 ...\r\n            var numVertices = parseInt(result[1]);\r\n            var inds = result[2].split(/\\s+/);\r\n\r\n            if (numVertices >= 3) {\r\n              var i0, i1, i2; // split the polygon in numVertices - 2 triangles\r\n\r\n              for (var j = 0; j < numVertices - 2; j++) {\r\n                if (j % 2 === 1) {\r\n                  i0 = parseInt(inds[j]);\r\n                  i1 = parseInt(inds[j + 2]);\r\n                  i2 = parseInt(inds[j + 1]);\r\n                  indices.push(i0, i1, i2);\r\n                } else {\r\n                  i0 = parseInt(inds[j]);\r\n                  i1 = parseInt(inds[j + 1]);\r\n                  i2 = parseInt(inds[j + 2]);\r\n                  indices.push(i0, i1, i2);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        } else if (inPointDataSection || inCellDataSection) {\r\n          if (inColorSection) {\r\n            // Get the colors\r\n            while ((result = pat3Floats.exec(line)) !== null) {\r\n              if (patWord.exec(line) !== null) break;\r\n              var r = parseFloat(result[1]);\r\n              var g = parseFloat(result[2]);\r\n              var b = parseFloat(result[3]);\r\n              colors.push(r, g, b);\r\n            }\r\n          } else if (inNormalsSection) {\r\n            // Get the normal vectors\r\n            while ((result = pat3Floats.exec(line)) !== null) {\r\n              if (patWord.exec(line) !== null) break;\r\n              var nx = parseFloat(result[1]);\r\n              var ny = parseFloat(result[2]);\r\n              var nz = parseFloat(result[3]);\r\n              normals.push(nx, ny, nz);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (patPOLYGONS.exec(line) !== null) {\r\n          inPolygonsSection = true;\r\n          inPointsSection = false;\r\n          inTriangleStripSection = false;\r\n        } else if (patPOINTS.exec(line) !== null) {\r\n          inPolygonsSection = false;\r\n          inPointsSection = true;\r\n          inTriangleStripSection = false;\r\n        } else if (patTRIANGLE_STRIPS.exec(line) !== null) {\r\n          inPolygonsSection = false;\r\n          inPointsSection = false;\r\n          inTriangleStripSection = true;\r\n        } else if (patPOINT_DATA.exec(line) !== null) {\r\n          inPointDataSection = true;\r\n          inPointsSection = false;\r\n          inPolygonsSection = false;\r\n          inTriangleStripSection = false;\r\n        } else if (patCELL_DATA.exec(line) !== null) {\r\n          inCellDataSection = true;\r\n          inPointsSection = false;\r\n          inPolygonsSection = false;\r\n          inTriangleStripSection = false;\r\n        } else if (patCOLOR_SCALARS.exec(line) !== null) {\r\n          inColorSection = true;\r\n          inNormalsSection = false;\r\n          inPointsSection = false;\r\n          inPolygonsSection = false;\r\n          inTriangleStripSection = false;\r\n        } else if (patNORMALS.exec(line) !== null) {\r\n          inNormalsSection = true;\r\n          inColorSection = false;\r\n          inPointsSection = false;\r\n          inPolygonsSection = false;\r\n          inTriangleStripSection = false;\r\n        }\r\n      }\r\n\r\n      var geometry = new BufferGeometry();\r\n      geometry.setIndex(indices);\r\n      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));\r\n\r\n      if (normals.length === positions.length) {\r\n        geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3));\r\n      }\r\n\r\n      if (colors.length !== indices.length) {\r\n        // stagger\r\n        if (colors.length === positions.length) {\r\n          geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));\r\n        }\r\n      } else {\r\n        // cell\r\n        geometry = geometry.toNonIndexed();\r\n        var numTriangles = geometry.attributes.position.count / 3;\r\n\r\n        if (colors.length === numTriangles * 3) {\r\n          var newColors = [];\r\n\r\n          for (var i = 0; i < numTriangles; i++) {\r\n            var r = colors[3 * i + 0];\r\n            var g = colors[3 * i + 1];\r\n            var b = colors[3 * i + 2];\r\n            newColors.push(r, g, b);\r\n            newColors.push(r, g, b);\r\n            newColors.push(r, g, b);\r\n          }\r\n\r\n          geometry.setAttribute('color', new Float32BufferAttribute(newColors, 3));\r\n        }\r\n      }\r\n\r\n      return geometry;\r\n    }\r\n\r\n    function parseBinary(data) {\r\n      var count, pointIndex, i, numberOfPoints, s;\r\n      var buffer = new Uint8Array(data);\r\n      var dataView = new DataView(data); // Points and normals, by default, are empty\r\n\r\n      var points = [];\r\n      var normals = [];\r\n      var indices = []; // Going to make a big array of strings\r\n      var index = 0;\r\n\r\n      function findString(buffer, start) {\r\n        var index = start;\r\n        var c = buffer[index];\r\n        var s = [];\r\n\r\n        while (c !== 10) {\r\n          s.push(String.fromCharCode(c));\r\n          index++;\r\n          c = buffer[index];\r\n        }\r\n\r\n        return {\r\n          start: start,\r\n          end: index,\r\n          next: index + 1,\r\n          parsedString: s.join('')\r\n        };\r\n      }\r\n\r\n      var state, line;\r\n\r\n      while (true) {\r\n        // Get a string\r\n        state = findString(buffer, index);\r\n        line = state.parsedString;\r\n\r\n        if (line.indexOf('DATASET') === 0) {\r\n          var dataset = line.split(' ')[1];\r\n          if (dataset !== 'POLYDATA') throw new Error('Unsupported DATASET type: ' + dataset);\r\n        } else if (line.indexOf('POINTS') === 0) {\r\n\r\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Each point is 3 4-byte floats\r\n\r\n          count = numberOfPoints * 4 * 3;\r\n          points = new Float32Array(numberOfPoints * 3);\r\n          pointIndex = state.next;\r\n\r\n          for (i = 0; i < numberOfPoints; i++) {\r\n            points[3 * i] = dataView.getFloat32(pointIndex, false);\r\n            points[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\r\n            points[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\r\n            pointIndex = pointIndex + 12;\r\n          } // increment our next pointer\r\n\r\n\r\n          state.next = state.next + count + 1;\r\n        } else if (line.indexOf('TRIANGLE_STRIPS') === 0) {\r\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\r\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\r\n\r\n          count = size * 4;\r\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\r\n          var indicesIndex = 0;\r\n          pointIndex = state.next;\r\n\r\n          for (i = 0; i < numberOfStrips; i++) {\r\n            // For each strip, read the first value, then record that many more points\r\n            var indexCount = dataView.getInt32(pointIndex, false);\r\n            var strip = [];\r\n            pointIndex += 4;\r\n\r\n            for (s = 0; s < indexCount; s++) {\r\n              strip.push(dataView.getInt32(pointIndex, false));\r\n              pointIndex += 4;\r\n            } // retrieves the n-2 triangles from the triangle strip\r\n\r\n\r\n            for (var j = 0; j < indexCount - 2; j++) {\r\n              if (j % 2) {\r\n                indices[indicesIndex++] = strip[j];\r\n                indices[indicesIndex++] = strip[j + 2];\r\n                indices[indicesIndex++] = strip[j + 1];\r\n              } else {\r\n                indices[indicesIndex++] = strip[j];\r\n                indices[indicesIndex++] = strip[j + 1];\r\n                indices[indicesIndex++] = strip[j + 2];\r\n              }\r\n            }\r\n          } // increment our next pointer\r\n\r\n\r\n          state.next = state.next + count + 1;\r\n        } else if (line.indexOf('POLYGONS') === 0) {\r\n          var numberOfStrips = parseInt(line.split(' ')[1], 10);\r\n          var size = parseInt(line.split(' ')[2], 10); // 4 byte integers\r\n\r\n          count = size * 4;\r\n          indices = new Uint32Array(3 * size - 9 * numberOfStrips);\r\n          var indicesIndex = 0;\r\n          pointIndex = state.next;\r\n\r\n          for (i = 0; i < numberOfStrips; i++) {\r\n            // For each strip, read the first value, then record that many more points\r\n            var indexCount = dataView.getInt32(pointIndex, false);\r\n            var strip = [];\r\n            pointIndex += 4;\r\n\r\n            for (s = 0; s < indexCount; s++) {\r\n              strip.push(dataView.getInt32(pointIndex, false));\r\n              pointIndex += 4;\r\n            } // divide the polygon in n-2 triangle\r\n\r\n\r\n            for (var j = 1; j < indexCount - 1; j++) {\r\n              indices[indicesIndex++] = strip[0];\r\n              indices[indicesIndex++] = strip[j];\r\n              indices[indicesIndex++] = strip[j + 1];\r\n            }\r\n          } // increment our next pointer\r\n\r\n\r\n          state.next = state.next + count + 1;\r\n        } else if (line.indexOf('POINT_DATA') === 0) {\r\n          numberOfPoints = parseInt(line.split(' ')[1], 10); // Grab the next line\r\n\r\n          state = findString(buffer, state.next); // Now grab the binary data\r\n\r\n          count = numberOfPoints * 4 * 3;\r\n          normals = new Float32Array(numberOfPoints * 3);\r\n          pointIndex = state.next;\r\n\r\n          for (i = 0; i < numberOfPoints; i++) {\r\n            normals[3 * i] = dataView.getFloat32(pointIndex, false);\r\n            normals[3 * i + 1] = dataView.getFloat32(pointIndex + 4, false);\r\n            normals[3 * i + 2] = dataView.getFloat32(pointIndex + 8, false);\r\n            pointIndex += 12;\r\n          } // Increment past our data\r\n\r\n\r\n          state.next = state.next + count;\r\n        } // Increment index\r\n\r\n\r\n        index = state.next;\r\n\r\n        if (index >= buffer.byteLength) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      var geometry = new BufferGeometry();\r\n      geometry.setIndex(new BufferAttribute(indices, 1));\r\n      geometry.setAttribute('position', new BufferAttribute(points, 3));\r\n\r\n      if (normals.length === points.length) {\r\n        geometry.setAttribute('normal', new BufferAttribute(normals, 3));\r\n      }\r\n\r\n      return geometry;\r\n    }\r\n\r\n    function Float32Concat(first, second) {\r\n      const firstLength = first.length,\r\n            result = new Float32Array(firstLength + second.length);\r\n      result.set(first);\r\n      result.set(second, firstLength);\r\n      return result;\r\n    }\r\n\r\n    function Int32Concat(first, second) {\r\n      var firstLength = first.length,\r\n          result = new Int32Array(firstLength + second.length);\r\n      result.set(first);\r\n      result.set(second, firstLength);\r\n      return result;\r\n    }\r\n\r\n    function parseXML(stringFile) {\r\n      // Changes XML to JSON, based on https://davidwalsh.name/convert-xml-json\r\n      function xmlToJson(xml) {\r\n        // Create the return object\r\n        var obj = {};\r\n\r\n        if (xml.nodeType === 1) {\r\n          // element\r\n          // do attributes\r\n          if (xml.attributes) {\r\n            if (xml.attributes.length > 0) {\r\n              obj['attributes'] = {};\r\n\r\n              for (var j = 0; j < xml.attributes.length; j++) {\r\n                var attribute = xml.attributes.item(j);\r\n                obj['attributes'][attribute.nodeName] = attribute.nodeValue.trim();\r\n              }\r\n            }\r\n          }\r\n        } else if (xml.nodeType === 3) {\r\n          // text\r\n          obj = xml.nodeValue.trim();\r\n        } // do children\r\n\r\n\r\n        if (xml.hasChildNodes()) {\r\n          for (var i = 0; i < xml.childNodes.length; i++) {\r\n            var item = xml.childNodes.item(i);\r\n            var nodeName = item.nodeName;\r\n\r\n            if (typeof obj[nodeName] === 'undefined') {\r\n              var tmp = xmlToJson(item);\r\n              if (tmp !== '') obj[nodeName] = tmp;\r\n            } else {\r\n              if (typeof obj[nodeName].push === 'undefined') {\r\n                var old = obj[nodeName];\r\n                obj[nodeName] = [old];\r\n              }\r\n\r\n              var tmp = xmlToJson(item);\r\n              if (tmp !== '') obj[nodeName].push(tmp);\r\n            }\r\n          }\r\n        }\r\n\r\n        return obj;\r\n      } // Taken from Base64-js\r\n\r\n\r\n      function Base64toByteArray(b64) {\r\n        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\r\n        var i;\r\n        var lookup = [];\r\n        var revLookup = [];\r\n        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n        var len = code.length;\r\n\r\n        for (i = 0; i < len; i++) {\r\n          lookup[i] = code[i];\r\n        }\r\n\r\n        for (i = 0; i < len; ++i) {\r\n          revLookup[code.charCodeAt(i)] = i;\r\n        }\r\n\r\n        revLookup['-'.charCodeAt(0)] = 62;\r\n        revLookup['_'.charCodeAt(0)] = 63;\r\n        var j, l, tmp, placeHolders, arr;\r\n        var len = b64.length;\r\n\r\n        if (len % 4 > 0) {\r\n          throw new Error('Invalid string. Length must be a multiple of 4');\r\n        }\r\n\r\n        placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;\r\n        arr = new Arr(len * 3 / 4 - placeHolders);\r\n        l = placeHolders > 0 ? len - 4 : len;\r\n        var L = 0;\r\n\r\n        for (i = 0, j = 0; i < l; i += 4, j += 3) {\r\n          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\r\n          arr[L++] = (tmp & 0xff0000) >> 16;\r\n          arr[L++] = (tmp & 0xff00) >> 8;\r\n          arr[L++] = tmp & 0xff;\r\n        }\r\n\r\n        if (placeHolders === 2) {\r\n          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\r\n          arr[L++] = tmp & 0xff;\r\n        } else if (placeHolders === 1) {\r\n          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\r\n          arr[L++] = tmp >> 8 & 0xff;\r\n          arr[L++] = tmp & 0xff;\r\n        }\r\n\r\n        return arr;\r\n      }\r\n\r\n      function parseDataArray(ele, compressed) {\r\n        var numBytes = 0;\r\n\r\n        if (json.attributes.header_type === 'UInt64') {\r\n          numBytes = 8;\r\n        } else if (json.attributes.header_type === 'UInt32') {\r\n          numBytes = 4;\r\n        } // Check the format\r\n\r\n\r\n        if (ele.attributes.format === 'binary' && compressed) {\r\n          var rawData, content, byteData, blocks, cSizeStart, headerSize, padding, dataOffsets, currentOffset;\r\n\r\n          if (ele.attributes.type === 'Float32') {\r\n            var txt = new Float32Array();\r\n          } else if (ele.attributes.type === 'Int64') {\r\n            var txt = new Int32Array();\r\n          } // VTP data with the header has the following structure:\r\n          // [#blocks][#u-size][#p-size][#c-size-1][#c-size-2]...[#c-size-#blocks][DATA]\r\n          //\r\n          // Each token is an integer value whose type is specified by \"header_type\" at the top of the file (UInt32 if no type specified). The token meanings are:\r\n          // [#blocks] = Number of blocks\r\n          // [#u-size] = Block size before compression\r\n          // [#p-size] = Size of last partial block (zero if it not needed)\r\n          // [#c-size-i] = Size in bytes of block i after compression\r\n          //\r\n          // The [DATA] portion stores contiguously every block appended together. The offset from the beginning of the data section to the beginning of a block is\r\n          // computed by summing the compressed block sizes from preceding blocks according to the header.\r\n\r\n\r\n          rawData = ele['#text'];\r\n          byteData = Base64toByteArray(rawData);\r\n          blocks = byteData[0];\r\n\r\n          for (var i = 1; i < numBytes - 1; i++) {\r\n            blocks = blocks | byteData[i] << i * numBytes;\r\n          }\r\n\r\n          headerSize = (blocks + 3) * numBytes;\r\n          padding = headerSize % 3 > 0 ? 3 - headerSize % 3 : 0;\r\n          headerSize = headerSize + padding;\r\n          dataOffsets = [];\r\n          currentOffset = headerSize;\r\n          dataOffsets.push(currentOffset); // Get the blocks sizes after the compression.\r\n          // There are three blocks before c-size-i, so we skip 3*numBytes\r\n\r\n          cSizeStart = 3 * numBytes;\r\n\r\n          for (var i = 0; i < blocks; i++) {\r\n            var currentBlockSize = byteData[i * numBytes + cSizeStart];\r\n\r\n            for (var j = 1; j < numBytes - 1; j++) {\r\n              // Each data point consists of 8 bytes regardless of the header type\r\n              currentBlockSize = currentBlockSize | byteData[i * numBytes + cSizeStart + j] << j * 8;\r\n            }\r\n\r\n            currentOffset = currentOffset + currentBlockSize;\r\n            dataOffsets.push(currentOffset);\r\n          }\r\n\r\n          for (var i = 0; i < dataOffsets.length - 1; i++) {\r\n            var data = unzlibSync(byteData.slice(dataOffsets[i], dataOffsets[i + 1])); // eslint-disable-line no-undef\r\n\r\n            content = data.buffer;\r\n\r\n            if (ele.attributes.type === 'Float32') {\r\n              content = new Float32Array(content);\r\n              txt = Float32Concat(txt, content);\r\n            } else if (ele.attributes.type === 'Int64') {\r\n              content = new Int32Array(content);\r\n              txt = Int32Concat(txt, content);\r\n            }\r\n          }\r\n\r\n          delete ele['#text'];\r\n\r\n          if (ele.attributes.type === 'Int64') {\r\n            if (ele.attributes.format === 'binary') {\r\n              txt = txt.filter(function (el, idx) {\r\n                if (idx % 2 !== 1) return true;\r\n              });\r\n            }\r\n          }\r\n        } else {\r\n          if (ele.attributes.format === 'binary' && !compressed) {\r\n            var content = Base64toByteArray(ele['#text']); //  VTP data for the uncompressed case has the following structure:\r\n            // [#bytes][DATA]\r\n            // where \"[#bytes]\" is an integer value specifying the number of bytes in the block of data following it.\r\n\r\n            content = content.slice(numBytes).buffer;\r\n          } else {\r\n            if (ele['#text']) {\r\n              var content = ele['#text'].split(/\\s+/).filter(function (el) {\r\n                if (el !== '') return el;\r\n              });\r\n            } else {\r\n              var content = new Int32Array(0).buffer;\r\n            }\r\n          }\r\n\r\n          delete ele['#text']; // Get the content and optimize it\r\n\r\n          if (ele.attributes.type === 'Float32') {\r\n            var txt = new Float32Array(content);\r\n          } else if (ele.attributes.type === 'Int32') {\r\n            var txt = new Int32Array(content);\r\n          } else if (ele.attributes.type === 'Int64') {\r\n            var txt = new Int32Array(content);\r\n\r\n            if (ele.attributes.format === 'binary') {\r\n              txt = txt.filter(function (el, idx) {\r\n                if (idx % 2 !== 1) return true;\r\n              });\r\n            }\r\n          }\r\n        } // endif ( ele.attributes.format === 'binary' && compressed )\r\n\r\n\r\n        return txt;\r\n      } // Main part\r\n      // Get Dom\r\n\r\n\r\n      var dom = null;\r\n\r\n      if (window.DOMParser) {\r\n        try {\r\n          dom = new DOMParser().parseFromString(stringFile, 'text/xml');\r\n        } catch (e) {\r\n          dom = null;\r\n        }\r\n      } else if (window.ActiveXObject) {\r\n        try {\r\n          dom = new ActiveXObject('Microsoft.XMLDOM'); // eslint-disable-line no-undef\r\n\r\n          dom.async = false;\r\n\r\n          if (!dom.loadXML()) {\r\n            throw new Error(dom.parseError.reason + dom.parseError.srcText);\r\n          }\r\n        } catch (e) {\r\n          dom = null;\r\n        }\r\n      } else {\r\n        throw new Error('Cannot parse xml string!');\r\n      } // Get the doc\r\n\r\n\r\n      var doc = dom.documentElement; // Convert to json\r\n\r\n      var json = xmlToJson(doc);\r\n      var points = [];\r\n      var normals = [];\r\n      var indices = [];\r\n\r\n      if (json.PolyData) {\r\n        var piece = json.PolyData.Piece;\r\n        var compressed = json.attributes.hasOwnProperty('compressor'); // Can be optimized\r\n        // Loop through the sections\r\n\r\n        var sections = ['PointData', 'Points', 'Strips', 'Polys']; // +['CellData', 'Verts', 'Lines'];\r\n\r\n        var sectionIndex = 0,\r\n            numberOfSections = sections.length;\r\n\r\n        while (sectionIndex < numberOfSections) {\r\n          var section = piece[sections[sectionIndex]]; // If it has a DataArray in it\r\n\r\n          if (section && section.DataArray) {\r\n            // Depending on the number of DataArrays\r\n            if (Object.prototype.toString.call(section.DataArray) === '[object Array]') {\r\n              var arr = section.DataArray;\r\n            } else {\r\n              var arr = [section.DataArray];\r\n            }\r\n\r\n            var dataArrayIndex = 0,\r\n                numberOfDataArrays = arr.length;\r\n\r\n            while (dataArrayIndex < numberOfDataArrays) {\r\n              // Parse the DataArray\r\n              if ('#text' in arr[dataArrayIndex] && arr[dataArrayIndex]['#text'].length > 0) {\r\n                arr[dataArrayIndex].text = parseDataArray(arr[dataArrayIndex], compressed);\r\n              }\r\n\r\n              dataArrayIndex++;\r\n            }\r\n\r\n            switch (sections[sectionIndex]) {\r\n              // if iti is point data\r\n              case 'PointData':\r\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\r\n                var normalsName = section.attributes.Normals;\r\n\r\n                if (numberOfPoints > 0) {\r\n                  for (var i = 0, len = arr.length; i < len; i++) {\r\n                    if (normalsName === arr[i].attributes.Name) {\r\n                      var components = arr[i].attributes.NumberOfComponents;\r\n                      normals = new Float32Array(numberOfPoints * components);\r\n                      normals.set(arr[i].text, 0);\r\n                    }\r\n                  }\r\n                }\r\n\r\n                break;\r\n              // if it is points\r\n\r\n              case 'Points':\r\n                var numberOfPoints = parseInt(piece.attributes.NumberOfPoints);\r\n\r\n                if (numberOfPoints > 0) {\r\n                  var components = section.DataArray.attributes.NumberOfComponents;\r\n                  points = new Float32Array(numberOfPoints * components);\r\n                  points.set(section.DataArray.text, 0);\r\n                }\r\n\r\n                break;\r\n              // if it is strips\r\n\r\n              case 'Strips':\r\n                var numberOfStrips = parseInt(piece.attributes.NumberOfStrips);\r\n\r\n                if (numberOfStrips > 0) {\r\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\r\n                  var offset = new Int32Array(section.DataArray[1].text.length);\r\n                  connectivity.set(section.DataArray[0].text, 0);\r\n                  offset.set(section.DataArray[1].text, 0);\r\n                  var size = numberOfStrips + connectivity.length;\r\n                  indices = new Uint32Array(3 * size - 9 * numberOfStrips);\r\n                  var indicesIndex = 0;\r\n\r\n                  for (var i = 0, len = numberOfStrips; i < len; i++) {\r\n                    var strip = [];\r\n\r\n                    for (var s = 0, len1 = offset[i], len0 = 0; s < len1 - len0; s++) {\r\n                      strip.push(connectivity[s]);\r\n                      if (i > 0) len0 = offset[i - 1];\r\n                    }\r\n\r\n                    for (var j = 0, len1 = offset[i], len0 = 0; j < len1 - len0 - 2; j++) {\r\n                      if (j % 2) {\r\n                        indices[indicesIndex++] = strip[j];\r\n                        indices[indicesIndex++] = strip[j + 2];\r\n                        indices[indicesIndex++] = strip[j + 1];\r\n                      } else {\r\n                        indices[indicesIndex++] = strip[j];\r\n                        indices[indicesIndex++] = strip[j + 1];\r\n                        indices[indicesIndex++] = strip[j + 2];\r\n                      }\r\n\r\n                      if (i > 0) len0 = offset[i - 1];\r\n                    }\r\n                  }\r\n                }\r\n\r\n                break;\r\n              // if it is polys\r\n\r\n              case 'Polys':\r\n                var numberOfPolys = parseInt(piece.attributes.NumberOfPolys);\r\n\r\n                if (numberOfPolys > 0) {\r\n                  var connectivity = new Int32Array(section.DataArray[0].text.length);\r\n                  var offset = new Int32Array(section.DataArray[1].text.length);\r\n                  connectivity.set(section.DataArray[0].text, 0);\r\n                  offset.set(section.DataArray[1].text, 0);\r\n                  var size = numberOfPolys + connectivity.length;\r\n                  indices = new Uint32Array(3 * size - 9 * numberOfPolys);\r\n                  var indicesIndex = 0,\r\n                      connectivityIndex = 0;\r\n                  var i = 0,\r\n                      len = numberOfPolys,\r\n                      len0 = 0;\r\n\r\n                  while (i < len) {\r\n                    var poly = [];\r\n                    var s = 0,\r\n                        len1 = offset[i];\r\n\r\n                    while (s < len1 - len0) {\r\n                      poly.push(connectivity[connectivityIndex++]);\r\n                      s++;\r\n                    }\r\n\r\n                    var j = 1;\r\n\r\n                    while (j < len1 - len0 - 1) {\r\n                      indices[indicesIndex++] = poly[0];\r\n                      indices[indicesIndex++] = poly[j];\r\n                      indices[indicesIndex++] = poly[j + 1];\r\n                      j++;\r\n                    }\r\n\r\n                    i++;\r\n                    len0 = offset[i - 1];\r\n                  }\r\n                }\r\n\r\n                break;\r\n            }\r\n          }\r\n\r\n          sectionIndex++;\r\n        }\r\n\r\n        var geometry = new BufferGeometry();\r\n        geometry.setIndex(new BufferAttribute(indices, 1));\r\n        geometry.setAttribute('position', new BufferAttribute(points, 3));\r\n\r\n        if (normals.length === points.length) {\r\n          geometry.setAttribute('normal', new BufferAttribute(normals, 3));\r\n        }\r\n\r\n        return geometry;\r\n      } else {\r\n        throw new Error('Unsupported DATASET type');\r\n      }\r\n    } // get the 5 first lines of the files to check if there is the key word binary\r\n\r\n\r\n    var meta = LoaderUtils.decodeText(new Uint8Array(data, 0, 250)).split('\\n');\r\n\r\n    if (meta[0].indexOf('xml') !== -1) {\r\n      return parseXML(LoaderUtils.decodeText(data));\r\n    } else if (meta[2].includes('ASCII')) {\r\n      return parseASCII(LoaderUtils.decodeText(data));\r\n    } else {\r\n      return parseBinary(data);\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { VTKLoader };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}