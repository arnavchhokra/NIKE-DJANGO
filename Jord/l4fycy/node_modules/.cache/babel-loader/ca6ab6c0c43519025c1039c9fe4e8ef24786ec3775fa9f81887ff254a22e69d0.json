{"ast":null,"code":"'use client';\n\nimport { useUpdateEffect } from \"./chunk-6WEF4DIO.mjs\";\nimport { useEventListener } from \"./chunk-7JEV5YKL.mjs\";\nimport { useSafeLayoutEffect } from \"./chunk-724WJZW4.mjs\";\n\n// src/use-focus-on-show.ts\nimport { contains, focus, getAllFocusable, isRefObject } from \"@chakra-ui/utils\";\nimport { useCallback, useRef } from \"react\";\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\nfunction useFocusOnShow(target) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  const {\n    focusRef,\n    preventScroll,\n    shouldFocus,\n    visible\n  } = options;\n  const element = isRefObject(target) ? target.current : target;\n  const autoFocusValue = shouldFocus && visible;\n  const autoFocusRef = useRef(autoFocusValue);\n  const lastVisibleRef = useRef(visible);\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue;\n    }\n    lastVisibleRef.current = visible;\n  }, [visible, autoFocusValue]);\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current) return;\n    autoFocusRef.current = false;\n    if (contains(element, document.activeElement)) return;\n    if (focusRef == null ? void 0 : focusRef.current) {\n      focus(focusRef.current, {\n        preventScroll,\n        nextTick: true\n      });\n    } else {\n      const tabbableEls = getAllFocusable(element);\n      if (tabbableEls.length > 0) {\n        focus(tabbableEls[0], {\n          preventScroll,\n          nextTick: true\n        });\n      }\n    }\n  }, [visible, preventScroll, element, focusRef]);\n  useUpdateEffect(() => {\n    onFocus();\n  }, [onFocus]);\n  useEventListener(\"transitionend\", onFocus, element);\n}\nexport { useFocusOnShow };","map":{"version":3,"names":["contains","focus","getAllFocusable","isRefObject","useCallback","useRef","defaultOptions","preventScroll","shouldFocus","useFocusOnShow","target","options","arguments","length","undefined","focusRef","visible","element","current","autoFocusValue","autoFocusRef","lastVisibleRef","useSafeLayoutEffect","onFocus","document","activeElement","nextTick","tabbableEls","useUpdateEffect","useEventListener"],"sources":["D:\\Repos\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\@chakra-ui\\hooks\\src\\use-focus-on-show.ts"],"sourcesContent":["import {\n  contains,\n  focus,\n  FocusableElement,\n  getAllFocusable,\n  isRefObject,\n} from \"@chakra-ui/utils\"\nimport { useCallback, useRef } from \"react\"\nimport { useEventListener } from \"./use-event-listener\"\nimport { useSafeLayoutEffect } from \"./use-safe-layout-effect\"\nimport { useUpdateEffect } from \"./use-update-effect\"\n\nexport interface UseFocusOnShowOptions {\n  visible?: boolean\n  shouldFocus?: boolean\n  preventScroll?: boolean\n  focusRef?: React.RefObject<FocusableElement>\n}\n\nconst defaultOptions: UseFocusOnShowOptions = {\n  preventScroll: true,\n  shouldFocus: false,\n}\n\nexport function useFocusOnShow<T extends HTMLElement>(\n  target: React.RefObject<T> | T,\n  options = defaultOptions,\n) {\n  const { focusRef, preventScroll, shouldFocus, visible } = options\n  const element = isRefObject(target) ? target.current : target\n  const autoFocusValue = shouldFocus && visible\n  const autoFocusRef = useRef(autoFocusValue)\n  const lastVisibleRef = useRef(visible)\n\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue\n    }\n    lastVisibleRef.current = visible\n  }, [visible, autoFocusValue])\n\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current) return\n    autoFocusRef.current = false\n\n    if (contains(element, document.activeElement as HTMLElement)) return\n\n    if (focusRef?.current) {\n      focus(focusRef.current, { preventScroll, nextTick: true })\n    } else {\n      const tabbableEls = getAllFocusable(element)\n      if (tabbableEls.length > 0) {\n        focus(tabbableEls[0], { preventScroll, nextTick: true })\n      }\n    }\n  }, [visible, preventScroll, element, focusRef])\n\n  useUpdateEffect(() => {\n    onFocus()\n  }, [onFocus])\n\n  useEventListener(\"transitionend\", onFocus, element)\n}\n"],"mappings":";;;;;;;AAAA,SACEA,QAAA,EACAC,KAAA,EAEAC,eAAA,EACAC,WAAA,QACK;AACP,SAASC,WAAA,EAAaC,MAAA,QAAc;AAYpC,IAAMC,cAAA,GAAwC;EAC5CC,aAAA,EAAe;EACfC,WAAA,EAAa;AACf;AAEO,SAASC,eACdC,MAAA,EAEA;EAAA,IADAC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAUN,cAAA;EAEV,MAAM;IAAES,QAAA;IAAUR,aAAA;IAAeC,WAAA;IAAaQ;EAAQ,IAAIL,OAAA;EAC1D,MAAMM,OAAA,GAAUd,WAAA,CAAYO,MAAM,IAAIA,MAAA,CAAOQ,OAAA,GAAUR,MAAA;EACvD,MAAMS,cAAA,GAAiBX,WAAA,IAAeQ,OAAA;EACtC,MAAMI,YAAA,GAAef,MAAA,CAAOc,cAAc;EAC1C,MAAME,cAAA,GAAiBhB,MAAA,CAAOW,OAAO;EAErCM,mBAAA,CAAoB,MAAM;IACxB,IAAI,CAACD,cAAA,CAAeH,OAAA,IAAWF,OAAA,EAAS;MACtCI,YAAA,CAAaF,OAAA,GAAUC,cAAA;IACzB;IACAE,cAAA,CAAeH,OAAA,GAAUF,OAAA;EAC3B,GAAG,CAACA,OAAA,EAASG,cAAc,CAAC;EAE5B,MAAMI,OAAA,GAAUnB,WAAA,CAAY,MAAM;IAChC,IAAI,CAACY,OAAA,IAAW,CAACC,OAAA,IAAW,CAACG,YAAA,CAAaF,OAAA,EAAS;IACnDE,YAAA,CAAaF,OAAA,GAAU;IAEvB,IAAIlB,QAAA,CAASiB,OAAA,EAASO,QAAA,CAASC,aAA4B,GAAG;IAE9D,IAAIV,QAAA,oBAAAA,QAAA,CAAUG,OAAA,EAAS;MACrBjB,KAAA,CAAMc,QAAA,CAASG,OAAA,EAAS;QAAEX,aAAA;QAAemB,QAAA,EAAU;MAAK,CAAC;IAC3D,OAAO;MACL,MAAMC,WAAA,GAAczB,eAAA,CAAgBe,OAAO;MAC3C,IAAIU,WAAA,CAAYd,MAAA,GAAS,GAAG;QAC1BZ,KAAA,CAAM0B,WAAA,CAAY,CAAC,GAAG;UAAEpB,aAAA;UAAemB,QAAA,EAAU;QAAK,CAAC;MACzD;IACF;EACF,GAAG,CAACV,OAAA,EAAST,aAAA,EAAeU,OAAA,EAASF,QAAQ,CAAC;EAE9Ca,eAAA,CAAgB,MAAM;IACpBL,OAAA,CAAQ;EACV,GAAG,CAACA,OAAO,CAAC;EAEZM,gBAAA,CAAiB,iBAAiBN,OAAA,EAASN,OAAO;AACpD"},"metadata":{},"sourceType":"module","externalDependencies":[]}