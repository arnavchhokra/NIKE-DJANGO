{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RestWalker = void 0;\n\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar gast_1 = require(\"@chevrotain/gast\");\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\n\n\nvar RestWalker =\n/** @class */\nfunction () {\n  function RestWalker() {}\n\n  RestWalker.prototype.walk = function (prod, prevRest) {\n    var _this = this;\n\n    if (prevRest === void 0) {\n      prevRest = [];\n    }\n\n    (0, forEach_1.default)(prod.definition, function (subProd, index) {\n      var currRest = (0, drop_1.default)(prod.definition, index + 1);\n      /* istanbul ignore else */\n\n      if (subProd instanceof gast_1.NonTerminal) {\n        _this.walkProdRef(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Terminal) {\n        _this.walkTerminal(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Alternative) {\n        _this.walkFlat(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Option) {\n        _this.walkOption(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionMandatory) {\n        _this.walkAtLeastOne(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {\n        _this.walkAtLeastOneSep(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.RepetitionWithSeparator) {\n        _this.walkManySep(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Repetition) {\n        _this.walkMany(subProd, currRest, prevRest);\n      } else if (subProd instanceof gast_1.Alternation) {\n        _this.walkOr(subProd, currRest, prevRest);\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    });\n  };\n\n  RestWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {};\n\n  RestWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {};\n\n  RestWalker.prototype.walkFlat = function (flatProd, currRest, prevRest) {\n    // ABCDEF => after the D the rest is EF\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(flatProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    var fullOrRest = currRest.concat(prevRest);\n    this.walk(optionProd, fullOrRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    var fullAtLeastOneRest = [new gast_1.Option({\n      definition: atLeastOneProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\n  };\n\n  RestWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n  };\n\n  RestWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    var fullManyRest = [new gast_1.Option({\n      definition: manyProd.definition\n    })].concat(currRest, prevRest);\n    this.walk(manyProd, fullManyRest);\n  };\n\n  RestWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n    this.walk(manySepProd, fullManySepRest);\n  };\n\n  RestWalker.prototype.walkOr = function (orProd, currRest, prevRest) {\n    var _this = this; // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n\n\n    var fullOrRest = currRest.concat(prevRest); // walk all different alternatives\n\n    (0, forEach_1.default)(orProd.definition, function (alt) {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      var prodWrapper = new gast_1.Alternative({\n        definition: [alt]\n      });\n\n      _this.walk(prodWrapper, fullOrRest);\n    });\n  };\n\n  return RestWalker;\n}();\n\nexports.RestWalker = RestWalker;\n\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n  var repSepRest = [new gast_1.Option({\n    definition: [new gast_1.Terminal({\n      terminalType: repSepProd.separator\n    })].concat(repSepProd.definition)\n  })];\n  var fullRepSepRest = repSepRest.concat(currRest, prevRest);\n  return fullRepSepRest;\n}","map":{"version":3,"mappings":"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","names":["RestWalker","prod","prevRest","definition","subProd","index","currRest","gast_1","_this","walkProdRef","walkTerminal","walkFlat","walkOption","walkAtLeastOne","walkAtLeastOneSep","walkManySep","walkMany","walkOr","Error","terminal","refProd","flatProd","fullOrRest","concat","walk","optionProd","atLeastOneProd","fullAtLeastOneRest","atLeastOneSepProd","fullAtLeastOneSepRest","restForRepetitionWithSeparator","manyProd","fullManyRest","manySepProd","fullManySepRest","orProd","alt","prodWrapper","exports","repSepProd","repSepRest","terminalType","separator","fullRepSepRest"],"sources":["C:\\Users\\Arnav\\Downloads\\l4fycy\\node_modules\\chevrotain\\src\\parse\\grammar\\rest.ts"],"sourcesContent":["import drop from \"lodash/drop\"\nimport forEach from \"lodash/forEach\"\nimport {\n  Alternation,\n  Alternative,\n  NonTerminal,\n  Option,\n  Repetition,\n  RepetitionMandatory,\n  RepetitionMandatoryWithSeparator,\n  RepetitionWithSeparator,\n  Terminal\n} from \"@chevrotain/gast\"\nimport { IProduction } from \"@chevrotain/types\"\n\n/**\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\n */\nexport abstract class RestWalker {\n  walk(prod: { definition: IProduction[] }, prevRest: any[] = []): void {\n    forEach(prod.definition, (subProd: IProduction, index) => {\n      const currRest = drop(prod.definition, index + 1)\n      /* istanbul ignore else */\n      if (subProd instanceof NonTerminal) {\n        this.walkProdRef(subProd, currRest, prevRest)\n      } else if (subProd instanceof Terminal) {\n        this.walkTerminal(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternative) {\n        this.walkFlat(subProd, currRest, prevRest)\n      } else if (subProd instanceof Option) {\n        this.walkOption(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatory) {\n        this.walkAtLeastOne(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n        this.walkAtLeastOneSep(subProd, currRest, prevRest)\n      } else if (subProd instanceof RepetitionWithSeparator) {\n        this.walkManySep(subProd, currRest, prevRest)\n      } else if (subProd instanceof Repetition) {\n        this.walkMany(subProd, currRest, prevRest)\n      } else if (subProd instanceof Alternation) {\n        this.walkOr(subProd, currRest, prevRest)\n      } else {\n        throw Error(\"non exhaustive match\")\n      }\n    })\n  }\n\n  walkTerminal(\n    terminal: Terminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkProdRef(\n    refProd: NonTerminal,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {}\n\n  walkFlat(\n    flatProd: Alternative,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABCDEF => after the D the rest is EF\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(flatProd, <any>fullOrRest)\n  }\n\n  walkOption(\n    optionProd: Option,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)?F => after the (DE)? the rest is F\n    const fullOrRest = currRest.concat(prevRest)\n    this.walk(optionProd, <any>fullOrRest)\n  }\n\n  walkAtLeastOne(\n    atLeastOneProd: RepetitionMandatory,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n    const fullAtLeastOneRest: IProduction[] = [\n      new Option({ definition: atLeastOneProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(atLeastOneProd, fullAtLeastOneRest)\n  }\n\n  walkAtLeastOneSep(\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(\n      atLeastOneSepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest)\n  }\n\n  walkMany(\n    manyProd: Repetition,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n    const fullManyRest: IProduction[] = [\n      new Option({ definition: manyProd.definition })\n    ].concat(<any>currRest, <any>prevRest)\n    this.walk(manyProd, fullManyRest)\n  }\n\n  walkManySep(\n    manySepProd: RepetitionWithSeparator,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n    const fullManySepRest = restForRepetitionWithSeparator(\n      manySepProd,\n      currRest,\n      prevRest\n    )\n    this.walk(manySepProd, fullManySepRest)\n  }\n\n  walkOr(\n    orProd: Alternation,\n    currRest: IProduction[],\n    prevRest: IProduction[]\n  ): void {\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n    const fullOrRest = currRest.concat(prevRest)\n    // walk all different alternatives\n    forEach(orProd.definition, (alt) => {\n      // wrapping each alternative in a single definition wrapper\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\n      const prodWrapper = new Alternative({ definition: [alt] })\n      this.walk(prodWrapper, <any>fullOrRest)\n    })\n  }\n}\n\nfunction restForRepetitionWithSeparator(\n  repSepProd: RepetitionWithSeparator,\n  currRest: IProduction[],\n  prevRest: IProduction[]\n) {\n  const repSepRest = [\n    new Option({\n      definition: [\n        new Terminal({ terminalType: repSepProd.separator }) as IProduction\n      ].concat(repSepProd.definition)\n    }) as IProduction\n  ]\n  const fullRepSepRest: IProduction[] = repSepRest.concat(currRest, prevRest)\n  return fullRepSepRest\n}\n"]},"metadata":{},"sourceType":"script"}