{"ast":null,"code":"import _classCallCheck from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nvar _lwoTree;\n\nvar LWOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LWOLoader, _Loader);\n\n  var _super = _createSuper(LWOLoader);\n\n  function LWOLoader(manager) {\n    var _this;\n\n    var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LWOLoader);\n\n    _this = _super.call(this, manager);\n    _this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n    return _this;\n  }\n\n  _createClass(LWOLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n      var modelName = url.split(path).pop().split('.')[0];\n      var loader = new FileLoader(this.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.load(url, function (buffer) {\n        // console.time( 'Total parsing: ' );\n        try {\n          onLoad(scope.parse(buffer, path, modelName));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        } // console.timeEnd( 'Total parsing: ' );\n\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(iffBuffer, path, modelName) {\n      _lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n      var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n      return new LWOTreeParser(textureLoader).parse(modelName);\n    }\n  }]);\n\n  return LWOLoader;\n}(Loader); // Parse the lwoTree object\n\n\nvar LWOTreeParser = /*#__PURE__*/function () {\n  function LWOTreeParser(textureLoader) {\n    _classCallCheck(this, LWOTreeParser);\n\n    this.textureLoader = textureLoader;\n  }\n\n  _createClass(LWOTreeParser, [{\n    key: \"parse\",\n    value: function parse(modelName) {\n      this.materials = new MaterialParser(this.textureLoader).parse();\n      this.defaultLayerName = modelName;\n      this.meshes = this.parseLayers();\n      return {\n        materials: this.materials,\n        meshes: this.meshes\n      };\n    }\n  }, {\n    key: \"parseLayers\",\n    value: function parseLayers() {\n      // array of all meshes for building hierarchy\n      var meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n      var finalMeshes = [];\n      var geometryParser = new GeometryParser();\n      var scope = this;\n\n      _lwoTree.layers.forEach(function (layer) {\n        var geometry = geometryParser.parse(layer.geometry, layer);\n        var mesh = scope.parseMesh(geometry, layer);\n        meshes[layer.number] = mesh;\n        if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n      });\n\n      this.applyPivots(finalMeshes);\n      return finalMeshes;\n    }\n  }, {\n    key: \"parseMesh\",\n    value: function parseMesh(geometry, layer) {\n      var mesh;\n      var materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n      this.duplicateUVs(geometry, materials);\n      if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n      if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n      mesh.userData.pivot = layer.pivot;\n      return mesh;\n    } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\n  }, {\n    key: \"applyPivots\",\n    value: function applyPivots(meshes) {\n      meshes.forEach(function (mesh) {\n        mesh.traverse(function (child) {\n          var pivot = child.userData.pivot;\n          child.position.x += pivot[0];\n          child.position.y += pivot[1];\n          child.position.z += pivot[2];\n\n          if (child.parent) {\n            var parentPivot = child.parent.userData.pivot;\n            child.position.x -= parentPivot[0];\n            child.position.y -= parentPivot[1];\n            child.position.z -= parentPivot[2];\n          }\n        });\n      });\n    }\n  }, {\n    key: \"getMaterials\",\n    value: function getMaterials(namesArray, type) {\n      var materials = [];\n      var scope = this;\n      namesArray.forEach(function (name, i) {\n        materials[i] = scope.getMaterialByName(name);\n      }); // convert materials to line or point mats if required\n\n      if (type === 'points' || type === 'lines') {\n        materials.forEach(function (mat, i) {\n          var spec = {\n            color: mat.color\n          };\n\n          if (type === 'points') {\n            spec.size = 0.1;\n            spec.map = mat.map;\n            spec.morphTargets = mat.morphTargets;\n            materials[i] = new PointsMaterial(spec);\n          } else if (type === 'lines') {\n            materials[i] = new LineBasicMaterial(spec);\n          }\n        });\n      } // if there is only one material, return that directly instead of array\n\n\n      var filtered = materials.filter(Boolean);\n      if (filtered.length === 1) return filtered[0];\n      return materials;\n    }\n  }, {\n    key: \"getMaterialByName\",\n    value: function getMaterialByName(name) {\n      return this.materials.filter(function (m) {\n        return m.name === name;\n      })[0];\n    } // If the material has an aoMap, duplicate UVs\n\n  }, {\n    key: \"duplicateUVs\",\n    value: function duplicateUVs(geometry, materials) {\n      var duplicateUVs = false;\n\n      if (!Array.isArray(materials)) {\n        if (materials.aoMap) duplicateUVs = true;\n      } else {\n        materials.forEach(function (material) {\n          if (material.aoMap) duplicateUVs = true;\n        });\n      }\n\n      if (!duplicateUVs) return;\n      geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n    }\n  }]);\n\n  return LWOTreeParser;\n}();\n\nvar MaterialParser = /*#__PURE__*/function () {\n  function MaterialParser(textureLoader) {\n    _classCallCheck(this, MaterialParser);\n\n    this.textureLoader = textureLoader;\n  }\n\n  _createClass(MaterialParser, [{\n    key: \"parse\",\n    value: function parse() {\n      var materials = [];\n      this.textures = {};\n\n      for (var name in _lwoTree.materials) {\n        if (_lwoTree.format === 'LWO3') {\n          materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n        } else if (_lwoTree.format === 'LWO2') {\n          materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n        }\n      }\n\n      return materials;\n    }\n  }, {\n    key: \"parseMaterial\",\n    value: function parseMaterial(materialData, name, textures) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var connections = this.parseConnections(materialData.connections, materialData.nodes);\n      var maps = this.parseTextureNodes(connections.maps);\n      this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n      var attributes = this.parseAttributes(connections.attributes, maps);\n      this.parseEnvMap(connections, maps, attributes);\n      params = Object.assign(maps, params);\n      params = Object.assign(params, attributes);\n      var materialType = this.getMaterialType(connections.attributes);\n      return new materialType(params);\n    }\n  }, {\n    key: \"parseMaterialLwo2\",\n    value: function parseMaterialLwo2(materialData, name\n    /*, textures*/\n    ) {\n      var params = {\n        name: name,\n        side: this.getSide(materialData.attributes),\n        flatShading: this.getSmooth(materialData.attributes)\n      };\n      var attributes = this.parseAttributes(materialData.attributes, {});\n      params = Object.assign(params, attributes);\n      return new MeshPhongMaterial(params);\n    } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n    // then switching mat FrontSide -> BackSide\n    // NB: this means that FrontSide and BackSide have been switched!\n\n  }, {\n    key: \"getSide\",\n    value: function getSide(attributes) {\n      if (!attributes.side) return BackSide;\n\n      switch (attributes.side) {\n        case 0:\n        case 1:\n          return BackSide;\n\n        case 2:\n          return FrontSide;\n\n        case 3:\n          return DoubleSide;\n      }\n    }\n  }, {\n    key: \"getSmooth\",\n    value: function getSmooth(attributes) {\n      if (!attributes.smooth) return true;\n      return !attributes.smooth;\n    }\n  }, {\n    key: \"parseConnections\",\n    value: function parseConnections(connections, nodes) {\n      var materialConnections = {\n        maps: {}\n      };\n      var inputName = connections.inputName;\n      var inputNodeName = connections.inputNodeName;\n      var nodeName = connections.nodeName;\n      var scope = this;\n      inputName.forEach(function (name, index) {\n        if (name === 'Material') {\n          var matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n          materialConnections.attributes = matNode.attributes;\n          materialConnections.envMap = matNode.fileName;\n          materialConnections.name = inputNodeName[index];\n        }\n      });\n      nodeName.forEach(function (name, index) {\n        if (name === materialConnections.name) {\n          materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n        }\n      });\n      return materialConnections;\n    }\n  }, {\n    key: \"getNodeByRefName\",\n    value: function getNodeByRefName(refName, nodes) {\n      for (var name in nodes) {\n        if (nodes[name].refName === refName) return nodes[name];\n      }\n    }\n  }, {\n    key: \"parseTextureNodes\",\n    value: function parseTextureNodes(textureNodes) {\n      var maps = {};\n\n      for (var name in textureNodes) {\n        var node = textureNodes[name];\n        var path = node.fileName;\n        if (!path) return;\n        var texture = this.loadTexture(path);\n        if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n        if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 0.5;\n            break;\n\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n\n          case 'Luminous':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Luminous Color':\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 0.5;\n            break;\n\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case 'Normal':\n            maps.normalMap = texture;\n            if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n            break;\n\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n\n      if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n      return maps;\n    } // maps can also be defined on individual material attributes, parse those here\n    // This occurs on Standard (Phong) surfaces\n\n  }, {\n    key: \"parseAttributeImageMaps\",\n    value: function parseAttributeImageMaps(attributes, textures, maps) {\n      for (var name in attributes) {\n        var attribute = attributes[name];\n\n        if (attribute.maps) {\n          var mapData = attribute.maps[0];\n          var path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n          if (!path) return;\n          var texture = this.loadTexture(path);\n          if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n          if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n          switch (name) {\n            case 'Color':\n              maps.map = texture;\n              break;\n\n            case 'Diffuse':\n              maps.aoMap = texture;\n              break;\n\n            case 'Roughness':\n              maps.roughnessMap = texture;\n              maps.roughness = 1;\n              break;\n\n            case 'Specular':\n              maps.specularMap = texture;\n              maps.specular = 0xffffff;\n              break;\n\n            case 'Luminosity':\n              maps.emissiveMap = texture;\n              maps.emissive = 0x808080;\n              break;\n\n            case 'Metallic':\n              maps.metalnessMap = texture;\n              maps.metalness = 1;\n              break;\n\n            case 'Transparency':\n            case 'Alpha':\n              maps.alphaMap = texture;\n              maps.transparent = true;\n              break;\n\n            case 'Normal':\n              maps.normalMap = texture;\n              break;\n\n            case 'Bump':\n              maps.bumpMap = texture;\n              break;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"parseAttributes\",\n    value: function parseAttributes(attributes, maps) {\n      var params = {}; // don't use color data if color map is present\n\n      if (attributes.Color && !maps.map) {\n        params.color = new Color().fromArray(attributes.Color.value);\n      } else {\n        params.color = new Color();\n      }\n\n      if (attributes.Transparency && attributes.Transparency.value !== 0) {\n        params.opacity = 1 - attributes.Transparency.value;\n        params.transparent = true;\n      }\n\n      if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n      if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n      this.parsePhysicalAttributes(params, attributes, maps);\n      this.parseStandardAttributes(params, attributes, maps);\n      this.parsePhongAttributes(params, attributes, maps);\n      return params;\n    }\n  }, {\n    key: \"parsePhysicalAttributes\",\n    value: function parsePhysicalAttributes(params, attributes\n    /*, maps*/\n    ) {\n      if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n        params.clearcoat = attributes.Clearcoat.value;\n\n        if (attributes['Clearcoat Gloss']) {\n          params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n        }\n      }\n    }\n  }, {\n    key: \"parseStandardAttributes\",\n    value: function parseStandardAttributes(params, attributes, maps) {\n      if (attributes.Luminous) {\n        params.emissiveIntensity = attributes.Luminous.value;\n\n        if (attributes['Luminous Color'] && !maps.emissive) {\n          params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n        } else {\n          params.emissive = new Color(0x808080);\n        }\n      }\n\n      if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n      if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n    }\n  }, {\n    key: \"parsePhongAttributes\",\n    value: function parsePhongAttributes(params, attributes, maps) {\n      if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n      if (attributes.Reflection) {\n        params.reflectivity = attributes.Reflection.value;\n        params.combine = AddOperation;\n      }\n\n      if (attributes.Luminosity) {\n        params.emissiveIntensity = attributes.Luminosity.value;\n\n        if (!maps.emissiveMap && !maps.map) {\n          params.emissive = params.color;\n        } else {\n          params.emissive = new Color(0x808080);\n        }\n      } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n\n      if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n        if (attributes['Color Highlight']) {\n          params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n        } else {\n          params.specular = new Color().setScalar(attributes.Specular.value);\n        }\n      }\n\n      if (params.specular && attributes.Glossiness) {\n        params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n      }\n    }\n  }, {\n    key: \"parseEnvMap\",\n    value: function parseEnvMap(connections, maps, attributes) {\n      if (connections.envMap) {\n        var envMap = this.loadTexture(connections.envMap);\n\n        if (attributes.transparent && attributes.opacity < 0.999) {\n          envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n          if (attributes.reflectivity !== undefined) {\n            delete attributes.reflectivity;\n            delete attributes.combine;\n          }\n\n          if (attributes.metalness !== undefined) {\n            delete attributes.metalness;\n          }\n        } else {\n          envMap.mapping = EquirectangularReflectionMapping;\n        }\n\n        maps.envMap = envMap;\n      }\n    } // get texture defined at top level by its index\n\n  }, {\n    key: \"getTexturePathByIndex\",\n    value: function getTexturePathByIndex(index) {\n      var fileName = '';\n      if (!_lwoTree.textures) return fileName;\n\n      _lwoTree.textures.forEach(function (texture) {\n        if (texture.index === index) fileName = texture.fileName;\n      });\n\n      return fileName;\n    }\n  }, {\n    key: \"loadTexture\",\n    value: function loadTexture(path) {\n      if (!path) return null;\n      var texture = this.textureLoader.load(path, undefined, undefined, function () {\n        console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n      });\n      return texture;\n    } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\n  }, {\n    key: \"getWrappingType\",\n    value: function getWrappingType(num) {\n      switch (num) {\n        case 0:\n          console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n          return ClampToEdgeWrapping;\n\n        case 1:\n          return RepeatWrapping;\n\n        case 2:\n          return MirroredRepeatWrapping;\n\n        case 3:\n          return ClampToEdgeWrapping;\n      }\n    }\n  }, {\n    key: \"getMaterialType\",\n    value: function getMaterialType(nodeData) {\n      if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n      if (nodeData.Roughness) return MeshStandardMaterial;\n      return MeshPhongMaterial;\n    }\n  }]);\n\n  return MaterialParser;\n}();\n\nvar GeometryParser = /*#__PURE__*/function () {\n  function GeometryParser() {\n    _classCallCheck(this, GeometryParser);\n  }\n\n  _createClass(GeometryParser, [{\n    key: \"parse\",\n    value: function parse(geoData, layer) {\n      var geometry = new BufferGeometry();\n      geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n      var indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n      geometry.setIndex(indices);\n      this.parseGroups(geometry, geoData);\n      geometry.computeVertexNormals();\n      this.parseUVs(geometry, layer, indices);\n      this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n      geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // let userData = geometry.userData;\n      // geometry = geometry.toNonIndexed()\n      // geometry.userData = userData;\n\n      return geometry;\n    } // split quads into tris\n\n  }, {\n    key: \"splitIndices\",\n    value: function splitIndices(indices, polygonDimensions) {\n      var remappedIndices = [];\n      var i = 0;\n      polygonDimensions.forEach(function (dim) {\n        if (dim < 4) {\n          for (var k = 0; k < dim; k++) {\n            remappedIndices.push(indices[i + k]);\n          }\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n        } else if (dim > 4) {\n          for (var _k = 1; _k < dim - 1; _k++) {\n            remappedIndices.push(indices[i], indices[i + _k], indices[i + _k + 1]);\n          }\n\n          console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n        }\n\n        i += dim;\n      });\n      return remappedIndices;\n    } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\n  }, {\n    key: \"parseGroups\",\n    value: function parseGroups(geometry, geoData) {\n      var tags = _lwoTree.tags;\n      var matNames = [];\n      var elemSize = 3;\n      if (geoData.type === 'lines') elemSize = 2;\n      if (geoData.type === 'points') elemSize = 1;\n      var remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n      var indexNum = 0; // create new indices in numerical order\n\n      var indexPairs = {}; // original indices mapped to numerical indices\n\n      var prevMaterialIndex;\n      var materialIndex;\n      var prevStart = 0;\n      var currentCount = 0;\n\n      for (var i = 0; i < remappedIndices.length; i += 2) {\n        materialIndex = remappedIndices[i + 1];\n        if (i === 0) matNames[indexNum] = tags[materialIndex];\n        if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n\n        if (materialIndex !== prevMaterialIndex) {\n          var currentIndex = void 0;\n\n          if (indexPairs[tags[prevMaterialIndex]]) {\n            currentIndex = indexPairs[tags[prevMaterialIndex]];\n          } else {\n            currentIndex = indexNum;\n            indexPairs[tags[prevMaterialIndex]] = indexNum;\n            matNames[indexNum] = tags[prevMaterialIndex];\n            indexNum++;\n          }\n\n          geometry.addGroup(prevStart, currentCount, currentIndex);\n          prevStart += currentCount;\n          prevMaterialIndex = materialIndex;\n          currentCount = 0;\n        }\n\n        currentCount += elemSize;\n      } // the loop above doesn't add the last group, do that here.\n\n\n      if (geometry.groups.length > 0) {\n        var _currentIndex;\n\n        if (indexPairs[tags[materialIndex]]) {\n          _currentIndex = indexPairs[tags[materialIndex]];\n        } else {\n          _currentIndex = indexNum;\n          indexPairs[tags[materialIndex]] = indexNum;\n          matNames[indexNum] = tags[materialIndex];\n        }\n\n        geometry.addGroup(prevStart, currentCount, _currentIndex);\n      } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n\n      geometry.userData.matNames = matNames;\n    }\n  }, {\n    key: \"splitMaterialIndices\",\n    value: function splitMaterialIndices(polygonDimensions, indices) {\n      var remappedIndices = [];\n      polygonDimensions.forEach(function (dim, i) {\n        if (dim <= 3) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        } else if (dim === 4) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n        } else {\n          // ignore > 4 for now\n          for (var k = 0; k < dim - 2; k++) {\n            remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n          }\n        }\n      });\n      return remappedIndices;\n    } // UV maps:\n    // 1: are defined via index into an array of points, not into a geometry\n    // - the geometry is also defined by an index into this array, but the indexes may not match\n    // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n    // \twith preference given to the first map encountered\n    // 3: UV maps can be partial - that is, defined for only a part of the geometry\n    // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n    // UV maps are defined as partially VMAP and partially VMAD\n    // VMADs are currently not supported\n\n  }, {\n    key: \"parseUVs\",\n    value: function parseUVs(geometry, layer) {\n      // start by creating a UV map set to zero for the whole geometry\n      var remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n        return 0;\n      });\n\n      var _loop = function _loop(name) {\n        var uvs = layer.uvs[name].uvs;\n        var uvIndices = layer.uvs[name].uvIndices;\n        uvIndices.forEach(function (i, j) {\n          remappedUVs[i * 2] = uvs[j * 2];\n          remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n        });\n      };\n\n      for (var name in layer.uvs) {\n        _loop(name);\n      }\n\n      geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n    }\n  }, {\n    key: \"parseMorphTargets\",\n    value: function parseMorphTargets(geometry, layer) {\n      var num = 0;\n\n      var _loop2 = function _loop2(name) {\n        var remappedPoints = geometry.attributes.position.array.slice();\n        if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n        var morphPoints = layer.morphTargets[name].points;\n        var morphIndices = layer.morphTargets[name].indices;\n        var type = layer.morphTargets[name].type;\n        morphIndices.forEach(function (i, j) {\n          if (type === 'relative') {\n            remappedPoints[i * 3] += morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n          } else {\n            remappedPoints[i * 3] = morphPoints[j * 3];\n            remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n            remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n          }\n        });\n        geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n        geometry.morphAttributes.position[num].name = name;\n        num++;\n      };\n\n      for (var name in layer.morphTargets) {\n        _loop2(name);\n      }\n\n      geometry.morphTargetsRelative = false;\n    }\n  }]);\n\n  return GeometryParser;\n}(); // ************** UTILITY FUNCTIONS **************\n\n\nfunction extractParentUrl(url, dir) {\n  var index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\n\nexport { LWOLoader };","map":{"version":3,"names":["Loader","FileLoader","TextureLoader","Points","LineSegments","Mesh","PointsMaterial","LineBasicMaterial","BufferAttribute","MeshPhongMaterial","BackSide","DoubleSide","FrontSide","Vector2","Color","AddOperation","EquirectangularRefractionMapping","EquirectangularReflectionMapping","ClampToEdgeWrapping","MirroredRepeatWrapping","RepeatWrapping","MeshPhysicalMaterial","MeshStandardMaterial","BufferGeometry","Float32BufferAttribute","IFFParser","_lwoTree","LWOLoader","manager","parameters","resourcePath","undefined","url","onLoad","onProgress","onError","scope","path","extractParentUrl","modelName","split","pop","loader","setPath","setResponseType","load","buffer","parse","e","console","error","itemError","iffBuffer","textureLoader","setCrossOrigin","crossOrigin","LWOTreeParser","materials","MaterialParser","defaultLayerName","meshes","parseLayers","finalMeshes","geometryParser","GeometryParser","layers","forEach","layer","geometry","mesh","parseMesh","number","parent","push","add","applyPivots","getMaterials","userData","matNames","type","duplicateUVs","name","pivot","traverse","child","position","x","y","z","parentPivot","namesArray","i","getMaterialByName","mat","spec","color","size","map","morphTargets","filtered","filter","Boolean","length","m","Array","isArray","aoMap","material","setAttribute","attributes","uv","array","textures","format","parseMaterial","parseMaterialLwo2","materialData","params","side","getSide","flatShading","getSmooth","connections","parseConnections","nodes","maps","parseTextureNodes","parseAttributeImageMaps","parseAttributes","parseEnvMap","Object","assign","materialType","getMaterialType","smooth","materialConnections","inputName","inputNodeName","nodeName","index","matNode","getNodeByRefName","envMap","fileName","refName","textureNodes","node","texture","loadTexture","widthWrappingMode","wrapS","getWrappingType","heightWrappingMode","wrapT","roughnessMap","roughness","specularMap","specular","emissiveMap","emissive","metalnessMap","metalness","alphaMap","transparent","normalMap","amplitude","normalScale","bumpMap","attribute","mapData","getTexturePathByIndex","imageIndex","wrap","w","h","fromArray","value","Transparency","opacity","bumpScale","refractionRatio","parsePhysicalAttributes","parseStandardAttributes","parsePhongAttributes","Clearcoat","clearcoat","clearcoatRoughness","Luminous","emissiveIntensity","Roughness","Metallic","Diffuse","multiplyScalar","Reflection","reflectivity","combine","Luminosity","Specular","setScalar","lerp","clone","Glossiness","shininess","Math","pow","mapping","warn","num","nodeData","geoData","points","indices","splitIndices","vertexIndices","polygonDimensions","setIndex","parseGroups","computeVertexNormals","parseUVs","parseMorphTargets","translate","remappedIndices","dim","k","tags","elemSize","splitMaterialIndices","materialIndices","indexNum","indexPairs","prevMaterialIndex","materialIndex","prevStart","currentCount","currentIndex","addGroup","groups","remappedUVs","from","count","uvs","uvIndices","j","remappedPoints","slice","morphAttributes","morphPoints","morphIndices","morphTargetsRelative","dir","indexOf","substr"],"sources":["C:/Users/Arnav/Downloads/l4fycy/node_modules/three-stdlib/loaders/LWOLoader.js"],"sourcesContent":["import { Loader, FileLoader, TextureLoader, Points, LineSegments, Mesh, PointsMaterial, LineBasicMaterial, BufferAttribute, MeshPhongMaterial, BackSide, DoubleSide, FrontSide, Vector2, Color, AddOperation, EquirectangularRefractionMapping, EquirectangularReflectionMapping, ClampToEdgeWrapping, MirroredRepeatWrapping, RepeatWrapping, MeshPhysicalMaterial, MeshStandardMaterial, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { IFFParser } from './lwo/IFFParser.js';\n\n/**\n * @version 1.1.1\n *\n * @desc Load files in LWO3 and LWO2 format on Three.js\n *\n * LWO3 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo3.html\n *\n * LWO2 format specification:\n * \thttp://static.lightwave3d.com/sdk/2018/html/filefmts/lwo2.html\n *\n **/\n\nlet _lwoTree;\n\nclass LWOLoader extends Loader {\n  constructor(manager, parameters = {}) {\n    super(manager);\n    this.resourcePath = parameters.resourcePath !== undefined ? parameters.resourcePath : '';\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? extractParentUrl(url, 'Objects') : scope.path; // give the mesh a default name based on the filename\n\n    const modelName = url.split(path).pop().split('.')[0];\n    const loader = new FileLoader(this.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.load(url, function (buffer) {\n      // console.time( 'Total parsing: ' );\n      try {\n        onLoad(scope.parse(buffer, path, modelName));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      } // console.timeEnd( 'Total parsing: ' );\n\n    }, onProgress, onError);\n  }\n\n  parse(iffBuffer, path, modelName) {\n    _lwoTree = new IFFParser().parse(iffBuffer); // console.log( 'lwoTree', lwoTree );\n\n    const textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    return new LWOTreeParser(textureLoader).parse(modelName);\n  }\n\n} // Parse the lwoTree object\n\n\nclass LWOTreeParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n\n  parse(modelName) {\n    this.materials = new MaterialParser(this.textureLoader).parse();\n    this.defaultLayerName = modelName;\n    this.meshes = this.parseLayers();\n    return {\n      materials: this.materials,\n      meshes: this.meshes\n    };\n  }\n\n  parseLayers() {\n    // array of all meshes for building hierarchy\n    const meshes = []; // final array containing meshes with scene graph hierarchy set up\n\n    const finalMeshes = [];\n    const geometryParser = new GeometryParser();\n    const scope = this;\n\n    _lwoTree.layers.forEach(function (layer) {\n      const geometry = geometryParser.parse(layer.geometry, layer);\n      const mesh = scope.parseMesh(geometry, layer);\n      meshes[layer.number] = mesh;\n      if (layer.parent === -1) finalMeshes.push(mesh);else meshes[layer.parent].add(mesh);\n    });\n\n    this.applyPivots(finalMeshes);\n    return finalMeshes;\n  }\n\n  parseMesh(geometry, layer) {\n    let mesh;\n    const materials = this.getMaterials(geometry.userData.matNames, layer.geometry.type);\n    this.duplicateUVs(geometry, materials);\n    if (layer.geometry.type === 'points') mesh = new Points(geometry, materials);else if (layer.geometry.type === 'lines') mesh = new LineSegments(geometry, materials);else mesh = new Mesh(geometry, materials);\n    if (layer.name) mesh.name = layer.name;else mesh.name = this.defaultLayerName + '_layer_' + layer.number;\n    mesh.userData.pivot = layer.pivot;\n    return mesh;\n  } // TODO: may need to be reversed in z to convert LWO to three.js coordinates\n\n\n  applyPivots(meshes) {\n    meshes.forEach(function (mesh) {\n      mesh.traverse(function (child) {\n        const pivot = child.userData.pivot;\n        child.position.x += pivot[0];\n        child.position.y += pivot[1];\n        child.position.z += pivot[2];\n\n        if (child.parent) {\n          const parentPivot = child.parent.userData.pivot;\n          child.position.x -= parentPivot[0];\n          child.position.y -= parentPivot[1];\n          child.position.z -= parentPivot[2];\n        }\n      });\n    });\n  }\n\n  getMaterials(namesArray, type) {\n    const materials = [];\n    const scope = this;\n    namesArray.forEach(function (name, i) {\n      materials[i] = scope.getMaterialByName(name);\n    }); // convert materials to line or point mats if required\n\n    if (type === 'points' || type === 'lines') {\n      materials.forEach(function (mat, i) {\n        const spec = {\n          color: mat.color\n        };\n\n        if (type === 'points') {\n          spec.size = 0.1;\n          spec.map = mat.map;\n          spec.morphTargets = mat.morphTargets;\n          materials[i] = new PointsMaterial(spec);\n        } else if (type === 'lines') {\n          materials[i] = new LineBasicMaterial(spec);\n        }\n      });\n    } // if there is only one material, return that directly instead of array\n\n\n    const filtered = materials.filter(Boolean);\n    if (filtered.length === 1) return filtered[0];\n    return materials;\n  }\n\n  getMaterialByName(name) {\n    return this.materials.filter(function (m) {\n      return m.name === name;\n    })[0];\n  } // If the material has an aoMap, duplicate UVs\n\n\n  duplicateUVs(geometry, materials) {\n    let duplicateUVs = false;\n\n    if (!Array.isArray(materials)) {\n      if (materials.aoMap) duplicateUVs = true;\n    } else {\n      materials.forEach(function (material) {\n        if (material.aoMap) duplicateUVs = true;\n      });\n    }\n\n    if (!duplicateUVs) return;\n    geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));\n  }\n\n}\n\nclass MaterialParser {\n  constructor(textureLoader) {\n    this.textureLoader = textureLoader;\n  }\n\n  parse() {\n    const materials = [];\n    this.textures = {};\n\n    for (const name in _lwoTree.materials) {\n      if (_lwoTree.format === 'LWO3') {\n        materials.push(this.parseMaterial(_lwoTree.materials[name], name, _lwoTree.textures));\n      } else if (_lwoTree.format === 'LWO2') {\n        materials.push(this.parseMaterialLwo2(_lwoTree.materials[name], name, _lwoTree.textures));\n      }\n    }\n\n    return materials;\n  }\n\n  parseMaterial(materialData, name, textures) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const connections = this.parseConnections(materialData.connections, materialData.nodes);\n    const maps = this.parseTextureNodes(connections.maps);\n    this.parseAttributeImageMaps(connections.attributes, textures, maps, materialData.maps);\n    const attributes = this.parseAttributes(connections.attributes, maps);\n    this.parseEnvMap(connections, maps, attributes);\n    params = Object.assign(maps, params);\n    params = Object.assign(params, attributes);\n    const materialType = this.getMaterialType(connections.attributes);\n    return new materialType(params);\n  }\n\n  parseMaterialLwo2(materialData, name\n  /*, textures*/\n  ) {\n    let params = {\n      name: name,\n      side: this.getSide(materialData.attributes),\n      flatShading: this.getSmooth(materialData.attributes)\n    };\n    const attributes = this.parseAttributes(materialData.attributes, {});\n    params = Object.assign(params, attributes);\n    return new MeshPhongMaterial(params);\n  } // Note: converting from left to right handed coords by switching x -> -x in vertices, and\n  // then switching mat FrontSide -> BackSide\n  // NB: this means that FrontSide and BackSide have been switched!\n\n\n  getSide(attributes) {\n    if (!attributes.side) return BackSide;\n\n    switch (attributes.side) {\n      case 0:\n      case 1:\n        return BackSide;\n\n      case 2:\n        return FrontSide;\n\n      case 3:\n        return DoubleSide;\n    }\n  }\n\n  getSmooth(attributes) {\n    if (!attributes.smooth) return true;\n    return !attributes.smooth;\n  }\n\n  parseConnections(connections, nodes) {\n    const materialConnections = {\n      maps: {}\n    };\n    const inputName = connections.inputName;\n    const inputNodeName = connections.inputNodeName;\n    const nodeName = connections.nodeName;\n    const scope = this;\n    inputName.forEach(function (name, index) {\n      if (name === 'Material') {\n        const matNode = scope.getNodeByRefName(inputNodeName[index], nodes);\n        materialConnections.attributes = matNode.attributes;\n        materialConnections.envMap = matNode.fileName;\n        materialConnections.name = inputNodeName[index];\n      }\n    });\n    nodeName.forEach(function (name, index) {\n      if (name === materialConnections.name) {\n        materialConnections.maps[inputName[index]] = scope.getNodeByRefName(inputNodeName[index], nodes);\n      }\n    });\n    return materialConnections;\n  }\n\n  getNodeByRefName(refName, nodes) {\n    for (const name in nodes) {\n      if (nodes[name].refName === refName) return nodes[name];\n    }\n  }\n\n  parseTextureNodes(textureNodes) {\n    const maps = {};\n\n    for (const name in textureNodes) {\n      const node = textureNodes[name];\n      const path = node.fileName;\n      if (!path) return;\n      const texture = this.loadTexture(path);\n      if (node.widthWrappingMode !== undefined) texture.wrapS = this.getWrappingType(node.widthWrappingMode);\n      if (node.heightWrappingMode !== undefined) texture.wrapT = this.getWrappingType(node.heightWrappingMode);\n\n      switch (name) {\n        case 'Color':\n          maps.map = texture;\n          break;\n\n        case 'Roughness':\n          maps.roughnessMap = texture;\n          maps.roughness = 0.5;\n          break;\n\n        case 'Specular':\n          maps.specularMap = texture;\n          maps.specular = 0xffffff;\n          break;\n\n        case 'Luminous':\n          maps.emissiveMap = texture;\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Luminous Color':\n          maps.emissive = 0x808080;\n          break;\n\n        case 'Metallic':\n          maps.metalnessMap = texture;\n          maps.metalness = 0.5;\n          break;\n\n        case 'Transparency':\n        case 'Alpha':\n          maps.alphaMap = texture;\n          maps.transparent = true;\n          break;\n\n        case 'Normal':\n          maps.normalMap = texture;\n          if (node.amplitude !== undefined) maps.normalScale = new Vector2(node.amplitude, node.amplitude);\n          break;\n\n        case 'Bump':\n          maps.bumpMap = texture;\n          break;\n      }\n    } // LWO BSDF materials can have both spec and rough, but this is not valid in three\n\n\n    if (maps.roughnessMap && maps.specularMap) delete maps.specularMap;\n    return maps;\n  } // maps can also be defined on individual material attributes, parse those here\n  // This occurs on Standard (Phong) surfaces\n\n\n  parseAttributeImageMaps(attributes, textures, maps) {\n    for (const name in attributes) {\n      const attribute = attributes[name];\n\n      if (attribute.maps) {\n        const mapData = attribute.maps[0];\n        const path = this.getTexturePathByIndex(mapData.imageIndex, textures);\n        if (!path) return;\n        const texture = this.loadTexture(path);\n        if (mapData.wrap !== undefined) texture.wrapS = this.getWrappingType(mapData.wrap.w);\n        if (mapData.wrap !== undefined) texture.wrapT = this.getWrappingType(mapData.wrap.h);\n\n        switch (name) {\n          case 'Color':\n            maps.map = texture;\n            break;\n\n          case 'Diffuse':\n            maps.aoMap = texture;\n            break;\n\n          case 'Roughness':\n            maps.roughnessMap = texture;\n            maps.roughness = 1;\n            break;\n\n          case 'Specular':\n            maps.specularMap = texture;\n            maps.specular = 0xffffff;\n            break;\n\n          case 'Luminosity':\n            maps.emissiveMap = texture;\n            maps.emissive = 0x808080;\n            break;\n\n          case 'Metallic':\n            maps.metalnessMap = texture;\n            maps.metalness = 1;\n            break;\n\n          case 'Transparency':\n          case 'Alpha':\n            maps.alphaMap = texture;\n            maps.transparent = true;\n            break;\n\n          case 'Normal':\n            maps.normalMap = texture;\n            break;\n\n          case 'Bump':\n            maps.bumpMap = texture;\n            break;\n        }\n      }\n    }\n  }\n\n  parseAttributes(attributes, maps) {\n    const params = {}; // don't use color data if color map is present\n\n    if (attributes.Color && !maps.map) {\n      params.color = new Color().fromArray(attributes.Color.value);\n    } else {\n      params.color = new Color();\n    }\n\n    if (attributes.Transparency && attributes.Transparency.value !== 0) {\n      params.opacity = 1 - attributes.Transparency.value;\n      params.transparent = true;\n    }\n\n    if (attributes['Bump Height']) params.bumpScale = attributes['Bump Height'].value * 0.1;\n    if (attributes['Refraction Index']) params.refractionRatio = 1 / attributes['Refraction Index'].value;\n    this.parsePhysicalAttributes(params, attributes, maps);\n    this.parseStandardAttributes(params, attributes, maps);\n    this.parsePhongAttributes(params, attributes, maps);\n    return params;\n  }\n\n  parsePhysicalAttributes(params, attributes\n  /*, maps*/\n  ) {\n    if (attributes.Clearcoat && attributes.Clearcoat.value > 0) {\n      params.clearcoat = attributes.Clearcoat.value;\n\n      if (attributes['Clearcoat Gloss']) {\n        params.clearcoatRoughness = 0.5 * (1 - attributes['Clearcoat Gloss'].value);\n      }\n    }\n  }\n\n  parseStandardAttributes(params, attributes, maps) {\n    if (attributes.Luminous) {\n      params.emissiveIntensity = attributes.Luminous.value;\n\n      if (attributes['Luminous Color'] && !maps.emissive) {\n        params.emissive = new Color().fromArray(attributes['Luminous Color'].value);\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    }\n\n    if (attributes.Roughness && !maps.roughnessMap) params.roughness = attributes.Roughness.value;\n    if (attributes.Metallic && !maps.metalnessMap) params.metalness = attributes.Metallic.value;\n  }\n\n  parsePhongAttributes(params, attributes, maps) {\n    if (attributes.Diffuse) params.color.multiplyScalar(attributes.Diffuse.value);\n\n    if (attributes.Reflection) {\n      params.reflectivity = attributes.Reflection.value;\n      params.combine = AddOperation;\n    }\n\n    if (attributes.Luminosity) {\n      params.emissiveIntensity = attributes.Luminosity.value;\n\n      if (!maps.emissiveMap && !maps.map) {\n        params.emissive = params.color;\n      } else {\n        params.emissive = new Color(0x808080);\n      }\n    } // parse specular if there is no roughness - we will interpret the material as 'Phong' in this case\n\n\n    if (!attributes.Roughness && attributes.Specular && !maps.specularMap) {\n      if (attributes['Color Highlight']) {\n        params.specular = new Color().setScalar(attributes.Specular.value).lerp(params.color.clone().multiplyScalar(attributes.Specular.value), attributes['Color Highlight'].value);\n      } else {\n        params.specular = new Color().setScalar(attributes.Specular.value);\n      }\n    }\n\n    if (params.specular && attributes.Glossiness) {\n      params.shininess = 7 + Math.pow(2, attributes.Glossiness.value * 12 + 2);\n    }\n  }\n\n  parseEnvMap(connections, maps, attributes) {\n    if (connections.envMap) {\n      const envMap = this.loadTexture(connections.envMap);\n\n      if (attributes.transparent && attributes.opacity < 0.999) {\n        envMap.mapping = EquirectangularRefractionMapping; // Reflectivity and refraction mapping don't work well together in Phong materials\n\n        if (attributes.reflectivity !== undefined) {\n          delete attributes.reflectivity;\n          delete attributes.combine;\n        }\n\n        if (attributes.metalness !== undefined) {\n          delete attributes.metalness;\n        }\n      } else {\n        envMap.mapping = EquirectangularReflectionMapping;\n      }\n\n      maps.envMap = envMap;\n    }\n  } // get texture defined at top level by its index\n\n\n  getTexturePathByIndex(index) {\n    let fileName = '';\n    if (!_lwoTree.textures) return fileName;\n\n    _lwoTree.textures.forEach(function (texture) {\n      if (texture.index === index) fileName = texture.fileName;\n    });\n\n    return fileName;\n  }\n\n  loadTexture(path) {\n    if (!path) return null;\n    const texture = this.textureLoader.load(path, undefined, undefined, function () {\n      console.warn('LWOLoader: non-standard resource hierarchy. Use `resourcePath` parameter to specify root content directory.');\n    });\n    return texture;\n  } // 0 = Reset, 1 = Repeat, 2 = Mirror, 3 = Edge\n\n\n  getWrappingType(num) {\n    switch (num) {\n      case 0:\n        console.warn('LWOLoader: \"Reset\" texture wrapping type is not supported in three.js');\n        return ClampToEdgeWrapping;\n\n      case 1:\n        return RepeatWrapping;\n\n      case 2:\n        return MirroredRepeatWrapping;\n\n      case 3:\n        return ClampToEdgeWrapping;\n    }\n  }\n\n  getMaterialType(nodeData) {\n    if (nodeData.Clearcoat && nodeData.Clearcoat.value > 0) return MeshPhysicalMaterial;\n    if (nodeData.Roughness) return MeshStandardMaterial;\n    return MeshPhongMaterial;\n  }\n\n}\n\nclass GeometryParser {\n  parse(geoData, layer) {\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new Float32BufferAttribute(geoData.points, 3));\n    const indices = this.splitIndices(geoData.vertexIndices, geoData.polygonDimensions);\n    geometry.setIndex(indices);\n    this.parseGroups(geometry, geoData);\n    geometry.computeVertexNormals();\n    this.parseUVs(geometry, layer, indices);\n    this.parseMorphTargets(geometry, layer, indices); // TODO: z may need to be reversed to account for coordinate system change\n\n    geometry.translate(-layer.pivot[0], -layer.pivot[1], -layer.pivot[2]); // let userData = geometry.userData;\n    // geometry = geometry.toNonIndexed()\n    // geometry.userData = userData;\n\n    return geometry;\n  } // split quads into tris\n\n\n  splitIndices(indices, polygonDimensions) {\n    const remappedIndices = [];\n    let i = 0;\n    polygonDimensions.forEach(function (dim) {\n      if (dim < 4) {\n        for (let k = 0; k < dim; k++) remappedIndices.push(indices[i + k]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i], indices[i + 1], indices[i + 2], indices[i], indices[i + 2], indices[i + 3]);\n      } else if (dim > 4) {\n        for (let k = 1; k < dim - 1; k++) {\n          remappedIndices.push(indices[i], indices[i + k], indices[i + k + 1]);\n        }\n\n        console.warn('LWOLoader: polygons with greater than 4 sides are not supported');\n      }\n\n      i += dim;\n    });\n    return remappedIndices;\n  } // NOTE: currently ignoring poly indices and assuming that they are intelligently ordered\n\n\n  parseGroups(geometry, geoData) {\n    const tags = _lwoTree.tags;\n    const matNames = [];\n    let elemSize = 3;\n    if (geoData.type === 'lines') elemSize = 2;\n    if (geoData.type === 'points') elemSize = 1;\n    const remappedIndices = this.splitMaterialIndices(geoData.polygonDimensions, geoData.materialIndices);\n    let indexNum = 0; // create new indices in numerical order\n\n    const indexPairs = {}; // original indices mapped to numerical indices\n\n    let prevMaterialIndex;\n    let materialIndex;\n    let prevStart = 0;\n    let currentCount = 0;\n\n    for (let i = 0; i < remappedIndices.length; i += 2) {\n      materialIndex = remappedIndices[i + 1];\n      if (i === 0) matNames[indexNum] = tags[materialIndex];\n      if (prevMaterialIndex === undefined) prevMaterialIndex = materialIndex;\n\n      if (materialIndex !== prevMaterialIndex) {\n        let currentIndex;\n\n        if (indexPairs[tags[prevMaterialIndex]]) {\n          currentIndex = indexPairs[tags[prevMaterialIndex]];\n        } else {\n          currentIndex = indexNum;\n          indexPairs[tags[prevMaterialIndex]] = indexNum;\n          matNames[indexNum] = tags[prevMaterialIndex];\n          indexNum++;\n        }\n\n        geometry.addGroup(prevStart, currentCount, currentIndex);\n        prevStart += currentCount;\n        prevMaterialIndex = materialIndex;\n        currentCount = 0;\n      }\n\n      currentCount += elemSize;\n    } // the loop above doesn't add the last group, do that here.\n\n\n    if (geometry.groups.length > 0) {\n      let currentIndex;\n\n      if (indexPairs[tags[materialIndex]]) {\n        currentIndex = indexPairs[tags[materialIndex]];\n      } else {\n        currentIndex = indexNum;\n        indexPairs[tags[materialIndex]] = indexNum;\n        matNames[indexNum] = tags[materialIndex];\n      }\n\n      geometry.addGroup(prevStart, currentCount, currentIndex);\n    } // Mat names from TAGS chunk, used to build up an array of materials for this geometry\n\n\n    geometry.userData.matNames = matNames;\n  }\n\n  splitMaterialIndices(polygonDimensions, indices) {\n    const remappedIndices = [];\n    polygonDimensions.forEach(function (dim, i) {\n      if (dim <= 3) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n      } else if (dim === 4) {\n        remappedIndices.push(indices[i * 2], indices[i * 2 + 1], indices[i * 2], indices[i * 2 + 1]);\n      } else {\n        // ignore > 4 for now\n        for (let k = 0; k < dim - 2; k++) {\n          remappedIndices.push(indices[i * 2], indices[i * 2 + 1]);\n        }\n      }\n    });\n    return remappedIndices;\n  } // UV maps:\n  // 1: are defined via index into an array of points, not into a geometry\n  // - the geometry is also defined by an index into this array, but the indexes may not match\n  // 2: there can be any number of UV maps for a single geometry. Here these are combined,\n  // \twith preference given to the first map encountered\n  // 3: UV maps can be partial - that is, defined for only a part of the geometry\n  // 4: UV maps can be VMAP or VMAD (discontinuous, to allow for seams). In practice, most\n  // UV maps are defined as partially VMAP and partially VMAD\n  // VMADs are currently not supported\n\n\n  parseUVs(geometry, layer) {\n    // start by creating a UV map set to zero for the whole geometry\n    const remappedUVs = Array.from(Array(geometry.attributes.position.count * 2), function () {\n      return 0;\n    });\n\n    for (const name in layer.uvs) {\n      const uvs = layer.uvs[name].uvs;\n      const uvIndices = layer.uvs[name].uvIndices;\n      uvIndices.forEach(function (i, j) {\n        remappedUVs[i * 2] = uvs[j * 2];\n        remappedUVs[i * 2 + 1] = uvs[j * 2 + 1];\n      });\n    }\n\n    geometry.setAttribute('uv', new Float32BufferAttribute(remappedUVs, 2));\n  }\n\n  parseMorphTargets(geometry, layer) {\n    let num = 0;\n\n    for (const name in layer.morphTargets) {\n      const remappedPoints = geometry.attributes.position.array.slice();\n      if (!geometry.morphAttributes.position) geometry.morphAttributes.position = [];\n      const morphPoints = layer.morphTargets[name].points;\n      const morphIndices = layer.morphTargets[name].indices;\n      const type = layer.morphTargets[name].type;\n      morphIndices.forEach(function (i, j) {\n        if (type === 'relative') {\n          remappedPoints[i * 3] += morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] += morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] += morphPoints[j * 3 + 2];\n        } else {\n          remappedPoints[i * 3] = morphPoints[j * 3];\n          remappedPoints[i * 3 + 1] = morphPoints[j * 3 + 1];\n          remappedPoints[i * 3 + 2] = morphPoints[j * 3 + 2];\n        }\n      });\n      geometry.morphAttributes.position[num] = new Float32BufferAttribute(remappedPoints, 3);\n      geometry.morphAttributes.position[num].name = name;\n      num++;\n    }\n\n    geometry.morphTargetsRelative = false;\n  }\n\n} // ************** UTILITY FUNCTIONS **************\n\n\nfunction extractParentUrl(url, dir) {\n  const index = url.indexOf(dir);\n  if (index === -1) return './';\n  return url.substr(0, index);\n}\n\nexport { LWOLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}