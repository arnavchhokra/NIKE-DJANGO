{"ast":null,"code":"import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function AdaptiveToneMappingPass(adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/\n  ) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function reset() {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n  setAdaptive: function setAdaptive(adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function setAdaptionRate(rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function setMinLuminance(minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function setMaxLuminance(maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function setAverageLuminance(avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function setMiddleGrey(middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function dispose() {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\nexport { AdaptiveToneMappingPass };","map":{"version":3,"names":["UniformsUtils","ShaderMaterial","NoBlending","WebGLRenderTarget","LinearMipmapLinearFilter","MeshBasicMaterial","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","LuminosityShader","ToneMapShader","AdaptiveToneMappingPass","adaptive","resolution","undefined","needsInit","luminanceRT","previousLuminanceRT","currentLuminanceRT","console","error","copyShader","copyUniforms","clone","uniforms","materialCopy","vertexShader","fragmentShader","blending","depthTest","materialLuminance","adaptLuminanceShader","defines","MIP_LEVEL_1X1","Math","log","toFixed","lastLum","value","currentLum","minLuminance","delta","tau","join","materialAdaptiveLum","Object","assign","materialToneMap","fsQuad","prototype","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","reset","texture","type","material","tDiffuse","setRenderTarget","renderToScreen","clear","dispose","pars","minFilter","magFilter","format","name","generateMipmaps","luminanceMap","color","needsUpdate","setAdaptive","setAdaptionRate","rate","abs","setMinLuminance","minLum","setMaxLuminance","maxLum","maxLuminance","setAverageLuminance","avgLum","averageLuminance","setMiddleGrey","middleGrey"],"sources":["C:/Users/Arnav/Downloads/l4fycy/node_modules/three-stdlib/postprocessing/AdaptiveToneMappingPass.js"],"sourcesContent":["import { UniformsUtils, ShaderMaterial, NoBlending, WebGLRenderTarget, LinearMipmapLinearFilter, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityShader } from '../shaders/LuminosityShader.js';\nimport { ToneMapShader } from '../shaders/ToneMapShader.js';\n\n/**\n * Generate a texture that represents the luminosity of the current scene, adapted over time\n * to simulate the optic nerve responding to the amount of light it is receiving.\n * Based on a GDC2007 presentation by Wolfgang Engel titled \"Post-Processing Pipeline\"\n *\n * Full-screen tone-mapping shader based on http://www.graphics.cornell.edu/~jaf/publications/sig02_paper.pdf\n */\n\nvar AdaptiveToneMappingPass = function (adaptive, resolution) {\n  this.resolution = resolution !== undefined ? resolution : 256;\n  this.needsInit = true;\n  this.adaptive = adaptive !== undefined ? !!adaptive : true;\n  this.luminanceRT = null;\n  this.previousLuminanceRT = null;\n  this.currentLuminanceRT = null;\n  if (CopyShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on CopyShader');\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: NoBlending,\n    depthTest: false\n  });\n  if (LuminosityShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on LuminosityShader');\n  this.materialLuminance = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(LuminosityShader.uniforms),\n    vertexShader: LuminosityShader.vertexShader,\n    fragmentShader: LuminosityShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.adaptLuminanceShader = {\n    defines: {\n      MIP_LEVEL_1X1: (Math.log(this.resolution) / Math.log(2.0)).toFixed(1)\n    },\n    uniforms: {\n      lastLum: {\n        value: null\n      },\n      currentLum: {\n        value: null\n      },\n      minLuminance: {\n        value: 0.01\n      },\n      delta: {\n        value: 0.016\n      },\n      tau: {\n        value: 1.0\n      }\n    },\n    vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n    fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D lastLum;', 'uniform sampler2D currentLum;', 'uniform float minLuminance;', 'uniform float delta;', 'uniform float tau;', 'void main() {', '\tvec4 lastLum = texture2D( lastLum, vUv, MIP_LEVEL_1X1 );', '\tvec4 currentLum = texture2D( currentLum, vUv, MIP_LEVEL_1X1 );', '\tfloat fLastLum = max( minLuminance, lastLum.r );', '\tfloat fCurrentLum = max( minLuminance, currentLum.r );', //The adaption seems to work better in extreme lighting differences\n    //if the input luminance is squared.\n    '\tfCurrentLum *= fCurrentLum;', // Adapt the luminance using Pattanaik's technique\n    '\tfloat fAdaptedLum = fLastLum + (fCurrentLum - fLastLum) * (1.0 - exp(-delta * tau));', // \"fAdaptedLum = sqrt(fAdaptedLum);\",\n    '\tgl_FragColor.r = fAdaptedLum;', '}'].join('\\n')\n  };\n  this.materialAdaptiveLum = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(this.adaptLuminanceShader.uniforms),\n    vertexShader: this.adaptLuminanceShader.vertexShader,\n    fragmentShader: this.adaptLuminanceShader.fragmentShader,\n    defines: Object.assign({}, this.adaptLuminanceShader.defines),\n    blending: NoBlending\n  });\n  if (ToneMapShader === undefined) console.error('THREE.AdaptiveToneMappingPass relies on ToneMapShader');\n  this.materialToneMap = new ShaderMaterial({\n    uniforms: UniformsUtils.clone(ToneMapShader.uniforms),\n    vertexShader: ToneMapShader.vertexShader,\n    fragmentShader: ToneMapShader.fragmentShader,\n    blending: NoBlending\n  });\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nAdaptiveToneMappingPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: AdaptiveToneMappingPass,\n  render: function (renderer, writeBuffer, readBuffer, deltaTime\n  /*, maskActive*/\n  ) {\n    if (this.needsInit) {\n      this.reset(renderer);\n      this.luminanceRT.texture.type = readBuffer.texture.type;\n      this.previousLuminanceRT.texture.type = readBuffer.texture.type;\n      this.currentLuminanceRT.texture.type = readBuffer.texture.type;\n      this.needsInit = false;\n    }\n\n    if (this.adaptive) {\n      //Render the luminance of the current scene into a render target with mipmapping enabled\n      this.fsQuad.material = this.materialLuminance;\n      this.materialLuminance.uniforms.tDiffuse.value = readBuffer.texture;\n      renderer.setRenderTarget(this.currentLuminanceRT);\n      this.fsQuad.render(renderer); //Use the new luminance values, the previous luminance and the frame delta to\n      //adapt the luminance over time.\n\n      this.fsQuad.material = this.materialAdaptiveLum;\n      this.materialAdaptiveLum.uniforms.delta.value = deltaTime;\n      this.materialAdaptiveLum.uniforms.lastLum.value = this.previousLuminanceRT.texture;\n      this.materialAdaptiveLum.uniforms.currentLum.value = this.currentLuminanceRT.texture;\n      renderer.setRenderTarget(this.luminanceRT);\n      this.fsQuad.render(renderer); //Copy the new adapted luminance value so that it can be used by the next frame.\n\n      this.fsQuad.material = this.materialCopy;\n      this.copyUniforms.tDiffuse.value = this.luminanceRT.texture;\n      renderer.setRenderTarget(this.previousLuminanceRT);\n      this.fsQuad.render(renderer);\n    }\n\n    this.fsQuad.material = this.materialToneMap;\n    this.materialToneMap.uniforms.tDiffuse.value = readBuffer.texture;\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(writeBuffer);\n      if (this.clear) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n  },\n  reset: function () {\n    // render targets\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    var pars = {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      format: RGBAFormat\n    }; // was RGB format. changed to RGBA format. see discussion in #8415 / #8450\n\n    this.luminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.luminanceRT.texture.name = 'AdaptiveToneMappingPass.l';\n    this.luminanceRT.texture.generateMipmaps = false;\n    this.previousLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.previousLuminanceRT.texture.name = 'AdaptiveToneMappingPass.pl';\n    this.previousLuminanceRT.texture.generateMipmaps = false; // We only need mipmapping for the current luminosity because we want a down-sampled version to sample in our adaptive shader\n\n    pars.minFilter = LinearMipmapLinearFilter;\n    pars.generateMipmaps = true;\n    this.currentLuminanceRT = new WebGLRenderTarget(this.resolution, this.resolution, pars);\n    this.currentLuminanceRT.texture.name = 'AdaptiveToneMappingPass.cl';\n\n    if (this.adaptive) {\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } //Put something in the adaptive luminance texture so that the scene can render initially\n\n\n    this.fsQuad.material = new MeshBasicMaterial({\n      color: 0x777777\n    });\n    this.materialLuminance.needsUpdate = true;\n    this.materialAdaptiveLum.needsUpdate = true;\n    this.materialToneMap.needsUpdate = true; // renderer.render( this.scene, this.camera, this.luminanceRT );\n    // renderer.render( this.scene, this.camera, this.previousLuminanceRT );\n    // renderer.render( this.scene, this.camera, this.currentLuminanceRT );\n  },\n  setAdaptive: function (adaptive) {\n    if (adaptive) {\n      this.adaptive = true;\n      this.materialToneMap.defines['ADAPTED_LUMINANCE'] = '';\n      this.materialToneMap.uniforms.luminanceMap.value = this.luminanceRT.texture;\n    } else {\n      this.adaptive = false;\n      delete this.materialToneMap.defines['ADAPTED_LUMINANCE'];\n      this.materialToneMap.uniforms.luminanceMap.value = null;\n    }\n\n    this.materialToneMap.needsUpdate = true;\n  },\n  setAdaptionRate: function (rate) {\n    if (rate) {\n      this.materialAdaptiveLum.uniforms.tau.value = Math.abs(rate);\n    }\n  },\n  setMinLuminance: function (minLum) {\n    if (minLum) {\n      this.materialToneMap.uniforms.minLuminance.value = minLum;\n      this.materialAdaptiveLum.uniforms.minLuminance.value = minLum;\n    }\n  },\n  setMaxLuminance: function (maxLum) {\n    if (maxLum) {\n      this.materialToneMap.uniforms.maxLuminance.value = maxLum;\n    }\n  },\n  setAverageLuminance: function (avgLum) {\n    if (avgLum) {\n      this.materialToneMap.uniforms.averageLuminance.value = avgLum;\n    }\n  },\n  setMiddleGrey: function (middleGrey) {\n    if (middleGrey) {\n      this.materialToneMap.uniforms.middleGrey.value = middleGrey;\n    }\n  },\n  dispose: function () {\n    if (this.luminanceRT) {\n      this.luminanceRT.dispose();\n    }\n\n    if (this.previousLuminanceRT) {\n      this.previousLuminanceRT.dispose();\n    }\n\n    if (this.currentLuminanceRT) {\n      this.currentLuminanceRT.dispose();\n    }\n\n    if (this.materialLuminance) {\n      this.materialLuminance.dispose();\n    }\n\n    if (this.materialAdaptiveLum) {\n      this.materialAdaptiveLum.dispose();\n    }\n\n    if (this.materialCopy) {\n      this.materialCopy.dispose();\n    }\n\n    if (this.materialToneMap) {\n      this.materialToneMap.dispose();\n    }\n  }\n});\n\nexport { AdaptiveToneMappingPass };\n"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,cAAxB,EAAwCC,UAAxC,EAAoDC,iBAApD,EAAuEC,wBAAvE,EAAiGC,iBAAjG,EAAoHC,YAApH,EAAkIC,UAAlI,QAAoJ,OAApJ;AACA,SAASC,cAAT,EAAyBC,IAAzB,QAAqC,WAArC;AACA,SAASC,UAAT,QAA2B,0BAA3B;AACA,SAASC,gBAAT,QAAiC,gCAAjC;AACA,SAASC,aAAT,QAA8B,6BAA9B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,uBAAuB,GAAG,SAA1BA,uBAA0B,CAAUC,QAAV,EAAoBC,UAApB,EAAgC;EAC5D,KAAKA,UAAL,GAAkBA,UAAU,KAAKC,SAAf,GAA2BD,UAA3B,GAAwC,GAA1D;EACA,KAAKE,SAAL,GAAiB,IAAjB;EACA,KAAKH,QAAL,GAAgBA,QAAQ,KAAKE,SAAb,GAAyB,CAAC,CAACF,QAA3B,GAAsC,IAAtD;EACA,KAAKI,WAAL,GAAmB,IAAnB;EACA,KAAKC,mBAAL,GAA2B,IAA3B;EACA,KAAKC,kBAAL,GAA0B,IAA1B;EACA,IAAIV,UAAU,KAAKM,SAAnB,EAA8BK,OAAO,CAACC,KAAR,CAAc,oDAAd;EAC9B,IAAIC,UAAU,GAAGb,UAAjB;EACA,KAAKc,YAAL,GAAoBxB,aAAa,CAACyB,KAAd,CAAoBF,UAAU,CAACG,QAA/B,CAApB;EACA,KAAKC,YAAL,GAAoB,IAAI1B,cAAJ,CAAmB;IACrCyB,QAAQ,EAAE,KAAKF,YADsB;IAErCI,YAAY,EAAEL,UAAU,CAACK,YAFY;IAGrCC,cAAc,EAAEN,UAAU,CAACM,cAHU;IAIrCC,QAAQ,EAAE5B,UAJ2B;IAKrC6B,SAAS,EAAE;EAL0B,CAAnB,CAApB;EAOA,IAAIpB,gBAAgB,KAAKK,SAAzB,EAAoCK,OAAO,CAACC,KAAR,CAAc,0DAAd;EACpC,KAAKU,iBAAL,GAAyB,IAAI/B,cAAJ,CAAmB;IAC1CyB,QAAQ,EAAE1B,aAAa,CAACyB,KAAd,CAAoBd,gBAAgB,CAACe,QAArC,CADgC;IAE1CE,YAAY,EAAEjB,gBAAgB,CAACiB,YAFW;IAG1CC,cAAc,EAAElB,gBAAgB,CAACkB,cAHS;IAI1CC,QAAQ,EAAE5B;EAJgC,CAAnB,CAAzB;EAMA,KAAK+B,oBAAL,GAA4B;IAC1BC,OAAO,EAAE;MACPC,aAAa,EAAE,CAACC,IAAI,CAACC,GAAL,CAAS,KAAKtB,UAAd,IAA4BqB,IAAI,CAACC,GAAL,CAAS,GAAT,CAA7B,EAA4CC,OAA5C,CAAoD,CAApD;IADR,CADiB;IAI1BZ,QAAQ,EAAE;MACRa,OAAO,EAAE;QACPC,KAAK,EAAE;MADA,CADD;MAIRC,UAAU,EAAE;QACVD,KAAK,EAAE;MADG,CAJJ;MAORE,YAAY,EAAE;QACZF,KAAK,EAAE;MADK,CAPN;MAURG,KAAK,EAAE;QACLH,KAAK,EAAE;MADF,CAVC;MAaRI,GAAG,EAAE;QACHJ,KAAK,EAAE;MADJ;IAbG,CAJgB;IAqB1BZ,YAAY,EAAE,CAAC,mBAAD,EAAsB,eAAtB,EAAuC,YAAvC,EAAqD,4EAArD,EAAmI,GAAnI,EAAwIiB,IAAxI,CAA6I,IAA7I,CArBY;IAsB1BhB,cAAc,EAAE,CAAC,mBAAD,EAAsB,4BAAtB,EAAoD,+BAApD,EAAqF,6BAArF,EAAoH,sBAApH,EAA4I,oBAA5I,EAAkK,eAAlK,EAAmL,2DAAnL,EAAgP,iEAAhP,EAAmT,mDAAnT,EAAwW,yDAAxW,EAAma;IACnb;IACA,8BAFgB,EAEgB;IAChC,uFAHgB,EAGyE;IACzF,gCAJgB,EAIkB,GAJlB,EAIuBgB,IAJvB,CAI4B,IAJ5B;EAtBU,CAA5B;EA4BA,KAAKC,mBAAL,GAA2B,IAAI7C,cAAJ,CAAmB;IAC5CyB,QAAQ,EAAE1B,aAAa,CAACyB,KAAd,CAAoB,KAAKQ,oBAAL,CAA0BP,QAA9C,CADkC;IAE5CE,YAAY,EAAE,KAAKK,oBAAL,CAA0BL,YAFI;IAG5CC,cAAc,EAAE,KAAKI,oBAAL,CAA0BJ,cAHE;IAI5CK,OAAO,EAAEa,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKf,oBAAL,CAA0BC,OAA5C,CAJmC;IAK5CJ,QAAQ,EAAE5B;EALkC,CAAnB,CAA3B;EAOA,IAAIU,aAAa,KAAKI,SAAtB,EAAiCK,OAAO,CAACC,KAAR,CAAc,uDAAd;EACjC,KAAK2B,eAAL,GAAuB,IAAIhD,cAAJ,CAAmB;IACxCyB,QAAQ,EAAE1B,aAAa,CAACyB,KAAd,CAAoBb,aAAa,CAACc,QAAlC,CAD8B;IAExCE,YAAY,EAAEhB,aAAa,CAACgB,YAFY;IAGxCC,cAAc,EAAEjB,aAAa,CAACiB,cAHU;IAIxCC,QAAQ,EAAE5B;EAJ8B,CAAnB,CAAvB;EAMA,KAAKgD,MAAL,GAAc,IAAI1C,cAAJ,CAAmB,IAAnB,CAAd;AACD,CAnED;;AAqEAK,uBAAuB,CAACsC,SAAxB,GAAoCJ,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACK,MAAP,CAAc3C,IAAI,CAAC0C,SAAnB,CAAd,EAA6C;EAC/EE,WAAW,EAAExC,uBADkE;EAE/EyC,MAAM,EAAE,gBAAUC,QAAV,EAAoBC,WAApB,EAAiCC,UAAjC,EAA6CC;EACrD;EADQ,EAEN;IACA,IAAI,KAAKzC,SAAT,EAAoB;MAClB,KAAK0C,KAAL,CAAWJ,QAAX;MACA,KAAKrC,WAAL,CAAiB0C,OAAjB,CAAyBC,IAAzB,GAAgCJ,UAAU,CAACG,OAAX,CAAmBC,IAAnD;MACA,KAAK1C,mBAAL,CAAyByC,OAAzB,CAAiCC,IAAjC,GAAwCJ,UAAU,CAACG,OAAX,CAAmBC,IAA3D;MACA,KAAKzC,kBAAL,CAAwBwC,OAAxB,CAAgCC,IAAhC,GAAuCJ,UAAU,CAACG,OAAX,CAAmBC,IAA1D;MACA,KAAK5C,SAAL,GAAiB,KAAjB;IACD;;IAED,IAAI,KAAKH,QAAT,EAAmB;MACjB;MACA,KAAKoC,MAAL,CAAYY,QAAZ,GAAuB,KAAK9B,iBAA5B;MACA,KAAKA,iBAAL,CAAuBN,QAAvB,CAAgCqC,QAAhC,CAAyCvB,KAAzC,GAAiDiB,UAAU,CAACG,OAA5D;MACAL,QAAQ,CAACS,eAAT,CAAyB,KAAK5C,kBAA9B;MACA,KAAK8B,MAAL,CAAYI,MAAZ,CAAmBC,QAAnB,EALiB,CAKa;MAC9B;;MAEA,KAAKL,MAAL,CAAYY,QAAZ,GAAuB,KAAKhB,mBAA5B;MACA,KAAKA,mBAAL,CAAyBpB,QAAzB,CAAkCiB,KAAlC,CAAwCH,KAAxC,GAAgDkB,SAAhD;MACA,KAAKZ,mBAAL,CAAyBpB,QAAzB,CAAkCa,OAAlC,CAA0CC,KAA1C,GAAkD,KAAKrB,mBAAL,CAAyByC,OAA3E;MACA,KAAKd,mBAAL,CAAyBpB,QAAzB,CAAkCe,UAAlC,CAA6CD,KAA7C,GAAqD,KAAKpB,kBAAL,CAAwBwC,OAA7E;MACAL,QAAQ,CAACS,eAAT,CAAyB,KAAK9C,WAA9B;MACA,KAAKgC,MAAL,CAAYI,MAAZ,CAAmBC,QAAnB,EAbiB,CAaa;;MAE9B,KAAKL,MAAL,CAAYY,QAAZ,GAAuB,KAAKnC,YAA5B;MACA,KAAKH,YAAL,CAAkBuC,QAAlB,CAA2BvB,KAA3B,GAAmC,KAAKtB,WAAL,CAAiB0C,OAApD;MACAL,QAAQ,CAACS,eAAT,CAAyB,KAAK7C,mBAA9B;MACA,KAAK+B,MAAL,CAAYI,MAAZ,CAAmBC,QAAnB;IACD;;IAED,KAAKL,MAAL,CAAYY,QAAZ,GAAuB,KAAKb,eAA5B;IACA,KAAKA,eAAL,CAAqBvB,QAArB,CAA8BqC,QAA9B,CAAuCvB,KAAvC,GAA+CiB,UAAU,CAACG,OAA1D;;IAEA,IAAI,KAAKK,cAAT,EAAyB;MACvBV,QAAQ,CAACS,eAAT,CAAyB,IAAzB;MACA,KAAKd,MAAL,CAAYI,MAAZ,CAAmBC,QAAnB;IACD,CAHD,MAGO;MACLA,QAAQ,CAACS,eAAT,CAAyBR,WAAzB;MACA,IAAI,KAAKU,KAAT,EAAgBX,QAAQ,CAACW,KAAT;MAChB,KAAKhB,MAAL,CAAYI,MAAZ,CAAmBC,QAAnB;IACD;EACF,CA7C8E;EA8C/EI,KAAK,EAAE,iBAAY;IACjB;IACA,IAAI,KAAKzC,WAAT,EAAsB;MACpB,KAAKA,WAAL,CAAiBiD,OAAjB;IACD;;IAED,IAAI,KAAK/C,kBAAT,EAA6B;MAC3B,KAAKA,kBAAL,CAAwB+C,OAAxB;IACD;;IAED,IAAI,KAAKhD,mBAAT,EAA8B;MAC5B,KAAKA,mBAAL,CAAyBgD,OAAzB;IACD;;IAED,IAAIC,IAAI,GAAG;MACTC,SAAS,EAAE/D,YADF;MAETgE,SAAS,EAAEhE,YAFF;MAGTiE,MAAM,EAAEhE;IAHC,CAAX,CAdiB,CAkBd;;IAEH,KAAKW,WAAL,GAAmB,IAAIf,iBAAJ,CAAsB,KAAKY,UAA3B,EAAuC,KAAKA,UAA5C,EAAwDqD,IAAxD,CAAnB;IACA,KAAKlD,WAAL,CAAiB0C,OAAjB,CAAyBY,IAAzB,GAAgC,2BAAhC;IACA,KAAKtD,WAAL,CAAiB0C,OAAjB,CAAyBa,eAAzB,GAA2C,KAA3C;IACA,KAAKtD,mBAAL,GAA2B,IAAIhB,iBAAJ,CAAsB,KAAKY,UAA3B,EAAuC,KAAKA,UAA5C,EAAwDqD,IAAxD,CAA3B;IACA,KAAKjD,mBAAL,CAAyByC,OAAzB,CAAiCY,IAAjC,GAAwC,4BAAxC;IACA,KAAKrD,mBAAL,CAAyByC,OAAzB,CAAiCa,eAAjC,GAAmD,KAAnD,CAzBiB,CAyByC;;IAE1DL,IAAI,CAACC,SAAL,GAAiBjE,wBAAjB;IACAgE,IAAI,CAACK,eAAL,GAAuB,IAAvB;IACA,KAAKrD,kBAAL,GAA0B,IAAIjB,iBAAJ,CAAsB,KAAKY,UAA3B,EAAuC,KAAKA,UAA5C,EAAwDqD,IAAxD,CAA1B;IACA,KAAKhD,kBAAL,CAAwBwC,OAAxB,CAAgCY,IAAhC,GAAuC,4BAAvC;;IAEA,IAAI,KAAK1D,QAAT,EAAmB;MACjB,KAAKmC,eAAL,CAAqBf,OAArB,CAA6B,mBAA7B,IAAoD,EAApD;MACA,KAAKe,eAAL,CAAqBvB,QAArB,CAA8BgD,YAA9B,CAA2ClC,KAA3C,GAAmD,KAAKtB,WAAL,CAAiB0C,OAApE;IACD,CAnCgB,CAmCf;;;IAGF,KAAKV,MAAL,CAAYY,QAAZ,GAAuB,IAAIzD,iBAAJ,CAAsB;MAC3CsE,KAAK,EAAE;IADoC,CAAtB,CAAvB;IAGA,KAAK3C,iBAAL,CAAuB4C,WAAvB,GAAqC,IAArC;IACA,KAAK9B,mBAAL,CAAyB8B,WAAzB,GAAuC,IAAvC;IACA,KAAK3B,eAAL,CAAqB2B,WAArB,GAAmC,IAAnC,CA3CiB,CA2CwB;IACzC;IACA;EACD,CA5F8E;EA6F/EC,WAAW,EAAE,qBAAU/D,QAAV,EAAoB;IAC/B,IAAIA,QAAJ,EAAc;MACZ,KAAKA,QAAL,GAAgB,IAAhB;MACA,KAAKmC,eAAL,CAAqBf,OAArB,CAA6B,mBAA7B,IAAoD,EAApD;MACA,KAAKe,eAAL,CAAqBvB,QAArB,CAA8BgD,YAA9B,CAA2ClC,KAA3C,GAAmD,KAAKtB,WAAL,CAAiB0C,OAApE;IACD,CAJD,MAIO;MACL,KAAK9C,QAAL,GAAgB,KAAhB;MACA,OAAO,KAAKmC,eAAL,CAAqBf,OAArB,CAA6B,mBAA7B,CAAP;MACA,KAAKe,eAAL,CAAqBvB,QAArB,CAA8BgD,YAA9B,CAA2ClC,KAA3C,GAAmD,IAAnD;IACD;;IAED,KAAKS,eAAL,CAAqB2B,WAArB,GAAmC,IAAnC;EACD,CAzG8E;EA0G/EE,eAAe,EAAE,yBAAUC,IAAV,EAAgB;IAC/B,IAAIA,IAAJ,EAAU;MACR,KAAKjC,mBAAL,CAAyBpB,QAAzB,CAAkCkB,GAAlC,CAAsCJ,KAAtC,GAA8CJ,IAAI,CAAC4C,GAAL,CAASD,IAAT,CAA9C;IACD;EACF,CA9G8E;EA+G/EE,eAAe,EAAE,yBAAUC,MAAV,EAAkB;IACjC,IAAIA,MAAJ,EAAY;MACV,KAAKjC,eAAL,CAAqBvB,QAArB,CAA8BgB,YAA9B,CAA2CF,KAA3C,GAAmD0C,MAAnD;MACA,KAAKpC,mBAAL,CAAyBpB,QAAzB,CAAkCgB,YAAlC,CAA+CF,KAA/C,GAAuD0C,MAAvD;IACD;EACF,CApH8E;EAqH/EC,eAAe,EAAE,yBAAUC,MAAV,EAAkB;IACjC,IAAIA,MAAJ,EAAY;MACV,KAAKnC,eAAL,CAAqBvB,QAArB,CAA8B2D,YAA9B,CAA2C7C,KAA3C,GAAmD4C,MAAnD;IACD;EACF,CAzH8E;EA0H/EE,mBAAmB,EAAE,6BAAUC,MAAV,EAAkB;IACrC,IAAIA,MAAJ,EAAY;MACV,KAAKtC,eAAL,CAAqBvB,QAArB,CAA8B8D,gBAA9B,CAA+ChD,KAA/C,GAAuD+C,MAAvD;IACD;EACF,CA9H8E;EA+H/EE,aAAa,EAAE,uBAAUC,UAAV,EAAsB;IACnC,IAAIA,UAAJ,EAAgB;MACd,KAAKzC,eAAL,CAAqBvB,QAArB,CAA8BgE,UAA9B,CAAyClD,KAAzC,GAAiDkD,UAAjD;IACD;EACF,CAnI8E;EAoI/EvB,OAAO,EAAE,mBAAY;IACnB,IAAI,KAAKjD,WAAT,EAAsB;MACpB,KAAKA,WAAL,CAAiBiD,OAAjB;IACD;;IAED,IAAI,KAAKhD,mBAAT,EAA8B;MAC5B,KAAKA,mBAAL,CAAyBgD,OAAzB;IACD;;IAED,IAAI,KAAK/C,kBAAT,EAA6B;MAC3B,KAAKA,kBAAL,CAAwB+C,OAAxB;IACD;;IAED,IAAI,KAAKnC,iBAAT,EAA4B;MAC1B,KAAKA,iBAAL,CAAuBmC,OAAvB;IACD;;IAED,IAAI,KAAKrB,mBAAT,EAA8B;MAC5B,KAAKA,mBAAL,CAAyBqB,OAAzB;IACD;;IAED,IAAI,KAAKxC,YAAT,EAAuB;MACrB,KAAKA,YAAL,CAAkBwC,OAAlB;IACD;;IAED,IAAI,KAAKlB,eAAT,EAA0B;MACxB,KAAKA,eAAL,CAAqBkB,OAArB;IACD;EACF;AAhK8E,CAA7C,CAApC;AAmKA,SAAStD,uBAAT"},"metadata":{},"sourceType":"module"}