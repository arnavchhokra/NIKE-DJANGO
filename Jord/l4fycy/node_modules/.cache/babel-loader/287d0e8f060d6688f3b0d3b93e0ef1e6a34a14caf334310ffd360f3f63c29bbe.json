{"ast":null,"code":"class Queue {\n  constructor() {\n    this.order = [];\n    this.scheduled = new Set();\n  }\n  add(process) {\n    if (!this.scheduled.has(process)) {\n      this.scheduled.add(process);\n      this.order.push(process);\n      return true;\n    }\n  }\n  remove(process) {\n    const index = this.order.indexOf(process);\n    if (index !== -1) {\n      this.order.splice(index, 1);\n      this.scheduled.delete(process);\n    }\n  }\n  clear() {\n    this.order.length = 0;\n    this.scheduled.clear();\n  }\n}\nfunction createRenderStep(runNextFrame) {\n  /**\r\n   * We create and reuse two queues, one to queue jobs for the current frame\r\n   * and one for the next. We reuse to avoid triggering GC after x frames.\r\n   */\n  let thisFrame = new Queue();\n  let nextFrame = new Queue();\n  let numToRun = 0;\n  /**\r\n   * Track whether we're currently processing jobs in this step. This way\r\n   * we can decide whether to schedule new jobs for this frame or next.\r\n   */\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\r\n   * A set of processes which were marked keepAlive when scheduled.\r\n   */\n  const toKeepAlive = new WeakSet();\n  const step = {\n    /**\r\n     * Schedule a process to run on the next frame.\r\n     */\n    schedule: function (callback) {\n      let keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n        // If we're adding it to the currently running queue, update its measured size\n        numToRun = thisFrame.order.length;\n      }\n      return callback;\n    },\n    /**\r\n     * Cancel the provided callback from running on the next frame.\r\n     */\n    cancel: callback => {\n      nextFrame.remove(callback);\n      toKeepAlive.delete(callback);\n    },\n    /**\r\n     * Execute all schedule callbacks.\r\n     */\n    process: frameData => {\n      /**\r\n       * If we're already processing we've probably been triggered by a flushSync\r\n       * inside an existing process. Instead of executing, mark flushNextFrame\r\n       * as true and ensure we flush the following frame at the end of this one.\r\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame];\n      // Clear the next frame queue\n      nextFrame.clear();\n      // Execute this frame\n      numToRun = thisFrame.order.length;\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = thisFrame.order[i];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n        }\n      }\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\nexport { createRenderStep };","map":{"version":3,"names":["Queue","constructor","order","scheduled","Set","add","process","has","push","remove","index","indexOf","splice","delete","clear","length","createRenderStep","runNextFrame","thisFrame","nextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","arguments","undefined","immediate","addToCurrentFrame","queue","cancel","frameData","i"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/framer-motion/dist/es/frameloop/render-step.mjs"],"sourcesContent":["class Queue {\r\n    constructor() {\r\n        this.order = [];\r\n        this.scheduled = new Set();\r\n    }\r\n    add(process) {\r\n        if (!this.scheduled.has(process)) {\r\n            this.scheduled.add(process);\r\n            this.order.push(process);\r\n            return true;\r\n        }\r\n    }\r\n    remove(process) {\r\n        const index = this.order.indexOf(process);\r\n        if (index !== -1) {\r\n            this.order.splice(index, 1);\r\n            this.scheduled.delete(process);\r\n        }\r\n    }\r\n    clear() {\r\n        this.order.length = 0;\r\n        this.scheduled.clear();\r\n    }\r\n}\r\nfunction createRenderStep(runNextFrame) {\r\n    /**\r\n     * We create and reuse two queues, one to queue jobs for the current frame\r\n     * and one for the next. We reuse to avoid triggering GC after x frames.\r\n     */\r\n    let thisFrame = new Queue();\r\n    let nextFrame = new Queue();\r\n    let numToRun = 0;\r\n    /**\r\n     * Track whether we're currently processing jobs in this step. This way\r\n     * we can decide whether to schedule new jobs for this frame or next.\r\n     */\r\n    let isProcessing = false;\r\n    let flushNextFrame = false;\r\n    /**\r\n     * A set of processes which were marked keepAlive when scheduled.\r\n     */\r\n    const toKeepAlive = new WeakSet();\r\n    const step = {\r\n        /**\r\n         * Schedule a process to run on the next frame.\r\n         */\r\n        schedule: (callback, keepAlive = false, immediate = false) => {\r\n            const addToCurrentFrame = immediate && isProcessing;\r\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\r\n            if (keepAlive)\r\n                toKeepAlive.add(callback);\r\n            if (queue.add(callback) && addToCurrentFrame && isProcessing) {\r\n                // If we're adding it to the currently running queue, update its measured size\r\n                numToRun = thisFrame.order.length;\r\n            }\r\n            return callback;\r\n        },\r\n        /**\r\n         * Cancel the provided callback from running on the next frame.\r\n         */\r\n        cancel: (callback) => {\r\n            nextFrame.remove(callback);\r\n            toKeepAlive.delete(callback);\r\n        },\r\n        /**\r\n         * Execute all schedule callbacks.\r\n         */\r\n        process: (frameData) => {\r\n            /**\r\n             * If we're already processing we've probably been triggered by a flushSync\r\n             * inside an existing process. Instead of executing, mark flushNextFrame\r\n             * as true and ensure we flush the following frame at the end of this one.\r\n             */\r\n            if (isProcessing) {\r\n                flushNextFrame = true;\r\n                return;\r\n            }\r\n            isProcessing = true;\r\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\r\n            // Clear the next frame queue\r\n            nextFrame.clear();\r\n            // Execute this frame\r\n            numToRun = thisFrame.order.length;\r\n            if (numToRun) {\r\n                for (let i = 0; i < numToRun; i++) {\r\n                    const callback = thisFrame.order[i];\r\n                    callback(frameData);\r\n                    if (toKeepAlive.has(callback)) {\r\n                        step.schedule(callback);\r\n                        runNextFrame();\r\n                    }\r\n                }\r\n            }\r\n            isProcessing = false;\r\n            if (flushNextFrame) {\r\n                flushNextFrame = false;\r\n                step.process(frameData);\r\n            }\r\n        },\r\n    };\r\n    return step;\r\n}\r\n\r\nexport { createRenderStep };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}