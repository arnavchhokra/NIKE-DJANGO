{"ast":null,"code":"import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from 'three';\nimport { getWithKey } from '../types/helpers.js';\n/**\r\n * @param  {Array<BufferGeometry>} geometries\r\n * @param  {Boolean} useGroups\r\n * @return {BufferGeometry}\r\n */\n\nvar mergeBufferGeometries = function mergeBufferGeometries(geometries, useGroups) {\n  var isIndexed = geometries[0].index !== null;\n  var attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  var attributes = {};\n  var morphAttributes = {};\n  var morphTargetsRelative = geometries[0].morphTargetsRelative;\n  var mergedGeometry = new BufferGeometry();\n  var offset = 0;\n  geometries.forEach(function (geom, i) {\n    var attributesCount = 0; // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n      return null;\n    } // gather attributes, exit early if they're different\n\n\n    for (var name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n        return null;\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = [];\n      }\n\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    } // ensure geometries have the same number of attributes\n\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n      return null;\n    } // gather morph attributes, exit early if they're different\n\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n      return null;\n    }\n\n    for (var _name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(_name)) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n        return null;\n      }\n\n      if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];\n\n      morphAttributes[_name].push(geom.morphAttributes[_name]);\n    } // gather .userData\n\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n\n    if (useGroups) {\n      var count;\n\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n        return null;\n      }\n\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  }); // merge indices\n\n  if (isIndexed) {\n    var indexOffset = 0;\n    var mergedIndex = [];\n    geometries.forEach(function (geom) {\n      var index = geom.index;\n\n      for (var j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  } // merge attributes\n\n\n  for (var name in attributes) {\n    var mergedAttribute = mergeBufferAttributes(attributes[name]);\n\n    if (!mergedAttribute) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n      return null;\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  } // merge morph attributes\n\n\n  for (var _name2 in morphAttributes) {\n    var numMorphTargets = morphAttributes[_name2][0].length;\n    if (numMorphTargets === 0) break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[_name2] = [];\n\n    for (var i = 0; i < numMorphTargets; ++i) {\n      var morphAttributesToMerge = [];\n\n      for (var j = 0; j < morphAttributes[_name2].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[_name2][j][i]);\n      }\n\n      var mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n\n      if (!mergedMorphAttribute) {\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + _name2 + ' morphAttribute.');\n        return null;\n      }\n\n      mergedGeometry.morphAttributes[_name2].push(mergedMorphAttribute);\n    }\n  }\n\n  return mergedGeometry;\n};\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {BufferAttribute}\r\n */\n\n\nvar mergeBufferAttributes = function mergeBufferAttributes(attributes) {\n  var TypedArray = undefined;\n  var itemSize = undefined;\n  var normalized = undefined;\n  var arrayLength = 0;\n  attributes.forEach(function (attr) {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor;\n    }\n\n    if (TypedArray !== attr.array.constructor) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n      return null;\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize;\n\n    if (itemSize !== attr.itemSize) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n      return null;\n    }\n\n    if (normalized === undefined) normalized = attr.normalized;\n\n    if (normalized !== attr.normalized) {\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n      return null;\n    }\n\n    arrayLength += attr.array.length;\n  });\n\n  if (TypedArray && itemSize) {\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    var array = new TypedArray(arrayLength);\n    var offset = 0;\n    attributes.forEach(function (attr) {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {Array<InterleavedBufferAttribute>}\r\n */\n\n\nvar interleaveAttributes = function interleaveAttributes(attributes) {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  var TypedArray = undefined;\n  var arrayLength = 0;\n  var stride = 0; // calculate the the length and type of the interleavedBuffer\n\n  for (var i = 0, l = attributes.length; i < l; ++i) {\n    var attribute = attributes[i];\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved');\n      return null;\n    }\n\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  } // Create the set of buffer attributes\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n\n\n  var interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  var offset = 0;\n  var res = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW'];\n  var setters = ['setX', 'setY', 'setZ', 'setW'];\n\n  for (var j = 0, _l = attributes.length; j < _l; j++) {\n    var _attribute = attributes[j];\n    var itemSize = _attribute.itemSize;\n    var count = _attribute.count;\n    var iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, _attribute.normalized);\n    res.push(iba);\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n\n    for (var c = 0; c < count; c++) {\n      for (var k = 0; k < itemSize; k++) {\n        var set = getWithKey(iba, setters[k]);\n        var get = getWithKey(_attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n\n  return res;\n};\n/**\r\n * @param {Array<BufferGeometry>} geometry\r\n * @return {number}\r\n */\n\n\nfunction estimateBytesUsed(geometry) {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  var mem = 0;\n\n  for (var name in geometry.attributes) {\n    var attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n\n  var indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} tolerance\r\n * @return {BufferGeometry>}\r\n */\n\n\nfunction mergeVertices(geometry) {\n  var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n\n  var hashToIndex = {};\n  var indices = geometry.getIndex();\n  var positions = geometry.getAttribute('position');\n  var vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\n\n  var nextIndex = 0; // attributes and new attribute arrays\n\n  var attributeNames = Object.keys(geometry.attributes);\n  var attrArrays = {};\n  var morphAttrsArrays = {};\n  var newIndices = [];\n  var getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\n\n  for (var i = 0, l = attributeNames.length; i < l; i++) {\n    var name = attributeNames[i];\n    attrArrays[name] = [];\n    var morphAttr = geometry.morphAttributes[name];\n\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(function () {\n        return [];\n      });\n    }\n  } // convert the error tolerance to an amount of decimal places to truncate to\n\n\n  var decimalShift = Math.log10(1 / tolerance);\n  var shiftMultiplier = Math.pow(10, decimalShift);\n\n  for (var _i = 0; _i < vertexCount; _i++) {\n    var index = indices ? indices.getX(_i) : _i; // Generate a hash for the vertex attributes at the current index 'i'\n\n    var hash = '';\n\n    for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {\n      var _name3 = attributeNames[j];\n      var attribute = geometry.getAttribute(_name3);\n      var itemSize = attribute.itemSize;\n\n      for (var k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += \"\".concat(~~(attribute[getters[k]](index) * shiftMultiplier), \",\");\n      }\n    } // Add another reference to the vertex if it's already\n    // used by another index\n\n\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (var _j = 0, _l3 = attributeNames.length; _j < _l3; _j++) {\n        var _name4 = attributeNames[_j];\n\n        var _attribute2 = geometry.getAttribute(_name4);\n\n        var _morphAttr = geometry.morphAttributes[_name4];\n        var _itemSize = _attribute2.itemSize;\n        var newarray = attrArrays[_name4];\n        var newMorphArrays = morphAttrsArrays[_name4];\n\n        for (var _k = 0; _k < _itemSize; _k++) {\n          var getterFunc = getters[_k]; // @ts-ignore\n\n          newarray.push(_attribute2[getterFunc](index));\n\n          if (_morphAttr) {\n            for (var m = 0, ml = _morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(_morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  } // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n\n\n  var result = geometry.clone();\n\n  for (var _i2 = 0, _l4 = attributeNames.length; _i2 < _l4; _i2++) {\n    var _name5 = attributeNames[_i2];\n    var oldAttribute = geometry.getAttribute(_name5); //@ts-expect-error  something to do with functions and constructors and new\n\n    var buffer = new oldAttribute.array.constructor(attrArrays[_name5]);\n\n    var _attribute3 = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n\n    result.setAttribute(_name5, _attribute3); // Update the attribute arrays\n\n    if (_name5 in morphAttrsArrays) {\n      for (var _j2 = 0; _j2 < morphAttrsArrays[_name5].length; _j2++) {\n        var oldMorphAttribute = geometry.morphAttributes[_name5][_j2]; //@ts-expect-error something to do with functions and constructors and new\n\n        var _buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[_name5][_j2]);\n\n        var morphAttribute = new BufferAttribute(_buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[_name5][_j2] = morphAttribute;\n      }\n    }\n  } // indices\n\n\n  result.setIndex(newIndices);\n  return result;\n}\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} drawMode\r\n * @return {BufferGeometry}\r\n */\n\n\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n    return geometry;\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    var index = geometry.getIndex(); // generate index if not present\n\n    if (index === null) {\n      var indices = [];\n      var position = geometry.getAttribute('position');\n\n      if (position !== undefined) {\n        for (var i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n        return geometry;\n      }\n    } //\n\n\n    var numberOfTriangles = index.count - 2;\n    var newIndices = [];\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n        for (var _i3 = 1; _i3 <= numberOfTriangles; _i3++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(_i3));\n          newIndices.push(index.getX(_i3 + 1));\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n        for (var _i4 = 0; _i4 < numberOfTriangles; _i4++) {\n          if (_i4 % 2 === 0) {\n            newIndices.push(index.getX(_i4));\n            newIndices.push(index.getX(_i4 + 1));\n            newIndices.push(index.getX(_i4 + 2));\n          } else {\n            newIndices.push(index.getX(_i4 + 2));\n            newIndices.push(index.getX(_i4 + 1));\n            newIndices.push(index.getX(_i4));\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n    } // build final geometry\n\n\n    var newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n    return geometry;\n  }\n}\n/**\r\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\r\n * Helpful for Raytracing or Decals.\r\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\r\n * @return {Object} An Object with original position/normal attributes and morphed ones.\r\n */\n\n\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n    return null;\n  }\n\n  var _vA = new Vector3();\n\n  var _vB = new Vector3();\n\n  var _vC = new Vector3();\n\n  var _tempA = new Vector3();\n\n  var _tempB = new Vector3();\n\n  var _tempC = new Vector3();\n\n  var _morphA = new Vector3();\n\n  var _morphB = new Vector3();\n\n  var _morphC = new Vector3();\n\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a);\n\n    _vB.fromBufferAttribute(attribute, b);\n\n    _vC.fromBufferAttribute(attribute, c);\n\n    var morphInfluences = object.morphTargetInfluences;\n\n    if ( // @ts-expect-error\n    material.morphTargets && morphAttribute && morphInfluences) {\n      _morphA.set(0, 0, 0);\n\n      _morphB.set(0, 0, 0);\n\n      _morphC.set(0, 0, 0);\n\n      for (var _i5 = 0, _il = morphAttribute.length; _i5 < _il; _i5++) {\n        var influence = morphInfluences[_i5];\n        var morph = morphAttribute[_i5];\n        if (influence === 0) continue;\n\n        _tempA.fromBufferAttribute(morph, a);\n\n        _tempB.fromBufferAttribute(morph, b);\n\n        _tempC.fromBufferAttribute(morph, c);\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence);\n\n          _morphB.addScaledVector(_tempB, influence);\n\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n\n      _vA.add(_morphA);\n\n      _vB.add(_morphB);\n\n      _vC.add(_morphC);\n    }\n\n    if (object.isSkinnedMesh) {\n      // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(b, _vB); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\n\n      object.boneTransform(c, _vC);\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\n  }\n\n  var geometry = object.geometry;\n  var material = object.material;\n  var a, b, c;\n  var index = geometry.index;\n  var positionAttribute = geometry.attributes.position;\n  var morphPosition = geometry.morphAttributes.position;\n  var morphTargetsRelative = geometry.morphTargetsRelative;\n  var normalAttribute = geometry.attributes.normal;\n  var morphNormal = geometry.morphAttributes.position;\n  var groups = geometry.groups;\n  var drawRange = geometry.drawRange;\n  var i, j, il, jl;\n  var group, groupMaterial;\n  var start, end;\n  var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n  if (index !== null) {\n    // indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\n\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\n      }\n    }\n  }\n\n  var morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  var morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute\n  };\n}\n\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toTrianglesDrawMode };","map":{"version":3,"names":["BufferGeometry","BufferAttribute","InterleavedBuffer","InterleavedBufferAttribute","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","Vector3","Float32BufferAttribute","getWithKey","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","offset","forEach","geom","i","attributesCount","console","error","name","has","undefined","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","length","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attr","array","constructor","set","interleaveAttributes","stride","l","attribute","interleavedBuffer","res","getters","setters","iba","c","k","get","estimateBytesUsed","geometry","mem","getAttribute","BYTES_PER_ELEMENT","indices","getIndex","mergeVertices","tolerance","Math","max","Number","EPSILON","hashToIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","morphAttr","Array","fill","map","decimalShift","log10","shiftMultiplier","pow","hash","newarray","newMorphArrays","getterFunc","m","ml","result","clone","oldAttribute","buffer","oldMorphAttribute","morphAttribute","toTrianglesDrawMode","drawMode","warn","numberOfTriangles","newGeometry","clearGroups","computeMorphedAttributes","object","isBufferGeometry","_vA","_vB","_vC","_tempA","_tempB","_tempC","_morphA","_morphB","_morphC","_calculateMorphedAttributeData","material","a","b","modifiedAttributeArray","fromBufferAttribute","morphInfluences","morphTargetInfluences","morphTargets","il","influence","morph","addScaledVector","sub","add","isSkinnedMesh","boneTransform","x","y","z","positionAttribute","morphPosition","normalAttribute","normal","morphNormal","groups","drawRange","jl","group","groupMaterial","start","end","modifiedPosition","Float32Array","modifiedNormal","isArray","materialIndex","min","morphedPositionAttribute","morphedNormalAttribute"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/utils/BufferGeometryUtils.js"],"sourcesContent":["import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from 'three';\r\nimport { getWithKey } from '../types/helpers.js';\r\n\r\n/**\r\n * @param  {Array<BufferGeometry>} geometries\r\n * @param  {Boolean} useGroups\r\n * @return {BufferGeometry}\r\n */\r\nconst mergeBufferGeometries = (geometries, useGroups) => {\r\n  const isIndexed = geometries[0].index !== null;\r\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\r\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\r\n  const attributes = {};\r\n  const morphAttributes = {};\r\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\r\n  const mergedGeometry = new BufferGeometry();\r\n  let offset = 0;\r\n  geometries.forEach((geom, i) => {\r\n    let attributesCount = 0; // ensure that all geometries are indexed, or none\r\n\r\n    if (isIndexed !== (geom.index !== null)) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\r\n      return null;\r\n    } // gather attributes, exit early if they're different\r\n\r\n\r\n    for (let name in geom.attributes) {\r\n      if (!attributesUsed.has(name)) {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\r\n        return null;\r\n      }\r\n\r\n      if (attributes[name] === undefined) {\r\n        attributes[name] = [];\r\n      }\r\n\r\n      attributes[name].push(geom.attributes[name]);\r\n      attributesCount++;\r\n    } // ensure geometries have the same number of attributes\r\n\r\n\r\n    if (attributesCount !== attributesUsed.size) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\r\n      return null;\r\n    } // gather morph attributes, exit early if they're different\r\n\r\n\r\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\r\n      return null;\r\n    }\r\n\r\n    for (let name in geom.morphAttributes) {\r\n      if (!morphAttributesUsed.has(name)) {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\r\n        return null;\r\n      }\r\n\r\n      if (morphAttributes[name] === undefined) morphAttributes[name] = [];\r\n      morphAttributes[name].push(geom.morphAttributes[name]);\r\n    } // gather .userData\r\n\r\n\r\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\r\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\r\n\r\n    if (useGroups) {\r\n      let count;\r\n\r\n      if (geom.index) {\r\n        count = geom.index.count;\r\n      } else if (geom.attributes.position !== undefined) {\r\n        count = geom.attributes.position.count;\r\n      } else {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\r\n        return null;\r\n      }\r\n\r\n      mergedGeometry.addGroup(offset, count, i);\r\n      offset += count;\r\n    }\r\n  }); // merge indices\r\n\r\n  if (isIndexed) {\r\n    let indexOffset = 0;\r\n    const mergedIndex = [];\r\n    geometries.forEach(geom => {\r\n      const index = geom.index;\r\n\r\n      for (let j = 0; j < index.count; ++j) {\r\n        mergedIndex.push(index.getX(j) + indexOffset);\r\n      }\r\n\r\n      indexOffset += geom.attributes.position.count;\r\n    });\r\n    mergedGeometry.setIndex(mergedIndex);\r\n  } // merge attributes\r\n\r\n\r\n  for (let name in attributes) {\r\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\r\n\r\n    if (!mergedAttribute) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\r\n      return null;\r\n    }\r\n\r\n    mergedGeometry.setAttribute(name, mergedAttribute);\r\n  } // merge morph attributes\r\n\r\n\r\n  for (let name in morphAttributes) {\r\n    const numMorphTargets = morphAttributes[name][0].length;\r\n    if (numMorphTargets === 0) break;\r\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\r\n    mergedGeometry.morphAttributes[name] = [];\r\n\r\n    for (let i = 0; i < numMorphTargets; ++i) {\r\n      const morphAttributesToMerge = [];\r\n\r\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\r\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\r\n      }\r\n\r\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\r\n\r\n      if (!mergedMorphAttribute) {\r\n        console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\r\n        return null;\r\n      }\r\n\r\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\r\n    }\r\n  }\r\n\r\n  return mergedGeometry;\r\n};\r\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {BufferAttribute}\r\n */\r\n\r\nconst mergeBufferAttributes = attributes => {\r\n  let TypedArray = undefined;\r\n  let itemSize = undefined;\r\n  let normalized = undefined;\r\n  let arrayLength = 0;\r\n  attributes.forEach(attr => {\r\n    if (TypedArray === undefined) {\r\n      TypedArray = attr.array.constructor;\r\n    }\r\n\r\n    if (TypedArray !== attr.array.constructor) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\r\n      return null;\r\n    }\r\n\r\n    if (itemSize === undefined) itemSize = attr.itemSize;\r\n\r\n    if (itemSize !== attr.itemSize) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\r\n      return null;\r\n    }\r\n\r\n    if (normalized === undefined) normalized = attr.normalized;\r\n\r\n    if (normalized !== attr.normalized) {\r\n      console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\r\n      return null;\r\n    }\r\n\r\n    arrayLength += attr.array.length;\r\n  });\r\n\r\n  if (TypedArray && itemSize) {\r\n    // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\r\n    const array = new TypedArray(arrayLength);\r\n    let offset = 0;\r\n    attributes.forEach(attr => {\r\n      array.set(attr.array, offset);\r\n      offset += attr.array.length;\r\n    });\r\n    return new BufferAttribute(array, itemSize, normalized);\r\n  }\r\n};\r\n/**\r\n * @param {Array<BufferAttribute>} attributes\r\n * @return {Array<InterleavedBufferAttribute>}\r\n */\r\n\r\nconst interleaveAttributes = attributes => {\r\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\r\n  // a set of InterleavedBufferAttributes for each attribute\r\n  let TypedArray = undefined;\r\n  let arrayLength = 0;\r\n  let stride = 0; // calculate the the length and type of the interleavedBuffer\r\n\r\n  for (let i = 0, l = attributes.length; i < l; ++i) {\r\n    const attribute = attributes[i];\r\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor;\r\n\r\n    if (TypedArray !== attribute.array.constructor) {\r\n      console.error('AttributeBuffers of different types cannot be interleaved');\r\n      return null;\r\n    }\r\n\r\n    arrayLength += attribute.array.length;\r\n    stride += attribute.itemSize;\r\n  } // Create the set of buffer attributes\r\n  // @ts-expect-error this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\r\n\r\n\r\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\r\n  let offset = 0;\r\n  const res = [];\r\n  const getters = ['getX', 'getY', 'getZ', 'getW'];\r\n  const setters = ['setX', 'setY', 'setZ', 'setW'];\r\n\r\n  for (let j = 0, l = attributes.length; j < l; j++) {\r\n    const attribute = attributes[j];\r\n    const itemSize = attribute.itemSize;\r\n    const count = attribute.count;\r\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\r\n    res.push(iba);\r\n    offset += itemSize; // Move the data for each attribute into the new interleavedBuffer\r\n    // at the appropriate offset\r\n\r\n    for (let c = 0; c < count; c++) {\r\n      for (let k = 0; k < itemSize; k++) {\r\n        const set = getWithKey(iba, setters[k]);\r\n        const get = getWithKey(attribute, getters[k]);\r\n        set(c, get(c));\r\n      }\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n/**\r\n * @param {Array<BufferGeometry>} geometry\r\n * @return {number}\r\n */\r\n\r\nfunction estimateBytesUsed(geometry) {\r\n  // Return the estimated memory used by this geometry in bytes\r\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\r\n  // for InterleavedBufferAttributes.\r\n  let mem = 0;\r\n\r\n  for (let name in geometry.attributes) {\r\n    const attr = geometry.getAttribute(name);\r\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\r\n  }\r\n\r\n  const indices = geometry.getIndex();\r\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\r\n  return mem;\r\n}\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} tolerance\r\n * @return {BufferGeometry>}\r\n */\r\n\r\nfunction mergeVertices(geometry, tolerance = 1e-4) {\r\n  tolerance = Math.max(tolerance, Number.EPSILON); // Generate an index buffer if the geometry doesn't have one, or optimize it\r\n  // if it's already available.\r\n\r\n  const hashToIndex = {};\r\n  const indices = geometry.getIndex();\r\n  const positions = geometry.getAttribute('position');\r\n  const vertexCount = indices ? indices.count : positions.count; // next value for triangle indices\r\n\r\n  let nextIndex = 0; // attributes and new attribute arrays\r\n\r\n  const attributeNames = Object.keys(geometry.attributes);\r\n  const attrArrays = {};\r\n  const morphAttrsArrays = {};\r\n  const newIndices = [];\r\n  const getters = ['getX', 'getY', 'getZ', 'getW']; // initialize the arrays\r\n\r\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\r\n    const name = attributeNames[i];\r\n    attrArrays[name] = [];\r\n    const morphAttr = geometry.morphAttributes[name];\r\n\r\n    if (morphAttr) {\r\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\r\n    }\r\n  } // convert the error tolerance to an amount of decimal places to truncate to\r\n\r\n\r\n  const decimalShift = Math.log10(1 / tolerance);\r\n  const shiftMultiplier = Math.pow(10, decimalShift);\r\n\r\n  for (let i = 0; i < vertexCount; i++) {\r\n    const index = indices ? indices.getX(i) : i; // Generate a hash for the vertex attributes at the current index 'i'\r\n\r\n    let hash = '';\r\n\r\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\r\n      const name = attributeNames[j];\r\n      const attribute = geometry.getAttribute(name);\r\n      const itemSize = attribute.itemSize;\r\n\r\n      for (let k = 0; k < itemSize; k++) {\r\n        // double tilde truncates the decimal value\r\n        // @ts-ignore no\r\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\r\n      }\r\n    } // Add another reference to the vertex if it's already\r\n    // used by another index\r\n\r\n\r\n    if (hash in hashToIndex) {\r\n      newIndices.push(hashToIndex[hash]);\r\n    } else {\r\n      // copy data to the new index in the attribute arrays\r\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\r\n        const name = attributeNames[j];\r\n        const attribute = geometry.getAttribute(name);\r\n        const morphAttr = geometry.morphAttributes[name];\r\n        const itemSize = attribute.itemSize;\r\n        const newarray = attrArrays[name];\r\n        const newMorphArrays = morphAttrsArrays[name];\r\n\r\n        for (let k = 0; k < itemSize; k++) {\r\n          const getterFunc = getters[k]; // @ts-ignore\r\n\r\n          newarray.push(attribute[getterFunc](index));\r\n\r\n          if (morphAttr) {\r\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\r\n              // @ts-ignore\r\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      hashToIndex[hash] = nextIndex;\r\n      newIndices.push(nextIndex);\r\n      nextIndex++;\r\n    }\r\n  } // Generate typed arrays from new attribute arrays and update\r\n  // the attributeBuffers\r\n\r\n\r\n  const result = geometry.clone();\r\n\r\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\r\n    const name = attributeNames[i];\r\n    const oldAttribute = geometry.getAttribute(name); //@ts-expect-error  something to do with functions and constructors and new\r\n\r\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\r\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\r\n    result.setAttribute(name, attribute); // Update the attribute arrays\r\n\r\n    if (name in morphAttrsArrays) {\r\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\r\n        const oldMorphAttribute = geometry.morphAttributes[name][j]; //@ts-expect-error something to do with functions and constructors and new\r\n\r\n        const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\r\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\r\n        result.morphAttributes[name][j] = morphAttribute;\r\n      }\r\n    }\r\n  } // indices\r\n\r\n\r\n  result.setIndex(newIndices);\r\n  return result;\r\n}\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {number} drawMode\r\n * @return {BufferGeometry}\r\n */\r\n\r\nfunction toTrianglesDrawMode(geometry, drawMode) {\r\n  if (drawMode === TrianglesDrawMode) {\r\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\r\n    return geometry;\r\n  }\r\n\r\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\r\n    let index = geometry.getIndex(); // generate index if not present\r\n\r\n    if (index === null) {\r\n      const indices = [];\r\n      const position = geometry.getAttribute('position');\r\n\r\n      if (position !== undefined) {\r\n        for (let i = 0; i < position.count; i++) {\r\n          indices.push(i);\r\n        }\r\n\r\n        geometry.setIndex(indices);\r\n        index = geometry.getIndex();\r\n      } else {\r\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\r\n        return geometry;\r\n      }\r\n    } //\r\n\r\n\r\n    const numberOfTriangles = index.count - 2;\r\n    const newIndices = [];\r\n\r\n    if (index) {\r\n      if (drawMode === TriangleFanDrawMode) {\r\n        // gl.TRIANGLE_FAN\r\n        for (let i = 1; i <= numberOfTriangles; i++) {\r\n          newIndices.push(index.getX(0));\r\n          newIndices.push(index.getX(i));\r\n          newIndices.push(index.getX(i + 1));\r\n        }\r\n      } else {\r\n        // gl.TRIANGLE_STRIP\r\n        for (let i = 0; i < numberOfTriangles; i++) {\r\n          if (i % 2 === 0) {\r\n            newIndices.push(index.getX(i));\r\n            newIndices.push(index.getX(i + 1));\r\n            newIndices.push(index.getX(i + 2));\r\n          } else {\r\n            newIndices.push(index.getX(i + 2));\r\n            newIndices.push(index.getX(i + 1));\r\n            newIndices.push(index.getX(i));\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (newIndices.length / 3 !== numberOfTriangles) {\r\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\r\n    } // build final geometry\r\n\r\n\r\n    const newGeometry = geometry.clone();\r\n    newGeometry.setIndex(newIndices);\r\n    newGeometry.clearGroups();\r\n    return newGeometry;\r\n  } else {\r\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\r\n    return geometry;\r\n  }\r\n}\r\n/**\r\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\r\n * Helpful for Raytracing or Decals.\r\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\r\n * @return {Object} An Object with original position/normal attributes and morphed ones.\r\n */\r\n\r\nfunction computeMorphedAttributes(object) {\r\n  if (object.geometry.isBufferGeometry !== true) {\r\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\r\n    return null;\r\n  }\r\n\r\n  const _vA = new Vector3();\r\n\r\n  const _vB = new Vector3();\r\n\r\n  const _vC = new Vector3();\r\n\r\n  const _tempA = new Vector3();\r\n\r\n  const _tempB = new Vector3();\r\n\r\n  const _tempC = new Vector3();\r\n\r\n  const _morphA = new Vector3();\r\n\r\n  const _morphB = new Vector3();\r\n\r\n  const _morphC = new Vector3();\r\n\r\n  function _calculateMorphedAttributeData(object, material, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {\r\n    _vA.fromBufferAttribute(attribute, a);\r\n\r\n    _vB.fromBufferAttribute(attribute, b);\r\n\r\n    _vC.fromBufferAttribute(attribute, c);\r\n\r\n    const morphInfluences = object.morphTargetInfluences;\r\n\r\n    if ( // @ts-expect-error\r\n    material.morphTargets && morphAttribute && morphInfluences) {\r\n      _morphA.set(0, 0, 0);\r\n\r\n      _morphB.set(0, 0, 0);\r\n\r\n      _morphC.set(0, 0, 0);\r\n\r\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\r\n        const influence = morphInfluences[i];\r\n        const morph = morphAttribute[i];\r\n        if (influence === 0) continue;\r\n\r\n        _tempA.fromBufferAttribute(morph, a);\r\n\r\n        _tempB.fromBufferAttribute(morph, b);\r\n\r\n        _tempC.fromBufferAttribute(morph, c);\r\n\r\n        if (morphTargetsRelative) {\r\n          _morphA.addScaledVector(_tempA, influence);\r\n\r\n          _morphB.addScaledVector(_tempB, influence);\r\n\r\n          _morphC.addScaledVector(_tempC, influence);\r\n        } else {\r\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\r\n\r\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\r\n\r\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\r\n        }\r\n      }\r\n\r\n      _vA.add(_morphA);\r\n\r\n      _vB.add(_morphB);\r\n\r\n      _vC.add(_morphC);\r\n    }\r\n\r\n    if (object.isSkinnedMesh) {\r\n      // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\r\n      object.boneTransform(a, _vA); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\r\n\r\n      object.boneTransform(b, _vB); // @ts-expect-error – https://github.com/three-types/three-ts-types/issues/37\r\n\r\n      object.boneTransform(c, _vC);\r\n    }\r\n\r\n    modifiedAttributeArray[a * 3 + 0] = _vA.x;\r\n    modifiedAttributeArray[a * 3 + 1] = _vA.y;\r\n    modifiedAttributeArray[a * 3 + 2] = _vA.z;\r\n    modifiedAttributeArray[b * 3 + 0] = _vB.x;\r\n    modifiedAttributeArray[b * 3 + 1] = _vB.y;\r\n    modifiedAttributeArray[b * 3 + 2] = _vB.z;\r\n    modifiedAttributeArray[c * 3 + 0] = _vC.x;\r\n    modifiedAttributeArray[c * 3 + 1] = _vC.y;\r\n    modifiedAttributeArray[c * 3 + 2] = _vC.z;\r\n  }\r\n\r\n  const geometry = object.geometry;\r\n  const material = object.material;\r\n  let a, b, c;\r\n  const index = geometry.index;\r\n  const positionAttribute = geometry.attributes.position;\r\n  const morphPosition = geometry.morphAttributes.position;\r\n  const morphTargetsRelative = geometry.morphTargetsRelative;\r\n  const normalAttribute = geometry.attributes.normal;\r\n  const morphNormal = geometry.morphAttributes.position;\r\n  const groups = geometry.groups;\r\n  const drawRange = geometry.drawRange;\r\n  let i, j, il, jl;\r\n  let group, groupMaterial;\r\n  let start, end;\r\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\r\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\r\n\r\n  if (index !== null) {\r\n    // indexed buffer geometry\r\n    if (Array.isArray(material)) {\r\n      for (i = 0, il = groups.length; i < il; i++) {\r\n        group = groups[i];\r\n        groupMaterial = material[group.materialIndex];\r\n        start = Math.max(group.start, drawRange.start);\r\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\r\n\r\n        for (j = start, jl = end; j < jl; j += 3) {\r\n          a = index.getX(j);\r\n          b = index.getX(j + 1);\r\n          c = index.getX(j + 2);\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n        }\r\n      }\r\n    } else {\r\n      start = Math.max(0, drawRange.start);\r\n      end = Math.min(index.count, drawRange.start + drawRange.count);\r\n\r\n      for (i = start, il = end; i < il; i += 3) {\r\n        a = index.getX(i);\r\n        b = index.getX(i + 1);\r\n        c = index.getX(i + 2);\r\n\r\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n      }\r\n    }\r\n  } else if (positionAttribute !== undefined) {\r\n    // non-indexed buffer geometry\r\n    if (Array.isArray(material)) {\r\n      for (i = 0, il = groups.length; i < il; i++) {\r\n        group = groups[i];\r\n        groupMaterial = material[group.materialIndex];\r\n        start = Math.max(group.start, drawRange.start);\r\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\r\n\r\n        for (j = start, jl = end; j < jl; j += 3) {\r\n          a = j;\r\n          b = j + 1;\r\n          c = j + 2;\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n          _calculateMorphedAttributeData(object, groupMaterial, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n        }\r\n      }\r\n    } else {\r\n      start = Math.max(0, drawRange.start);\r\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\r\n\r\n      for (i = start, il = end; i < il; i += 3) {\r\n        a = i;\r\n        b = i + 1;\r\n        c = i + 2;\r\n\r\n        _calculateMorphedAttributeData(object, material, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);\r\n\r\n        _calculateMorphedAttributeData(object, material, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);\r\n      }\r\n    }\r\n  }\r\n\r\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\r\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\r\n  return {\r\n    positionAttribute: positionAttribute,\r\n    normalAttribute: normalAttribute,\r\n    morphedPositionAttribute: morphedPositionAttribute,\r\n    morphedNormalAttribute: morphedNormalAttribute\r\n  };\r\n}\r\n\r\nexport { computeMorphedAttributes, estimateBytesUsed, interleaveAttributes, mergeBufferAttributes, mergeBufferGeometries, mergeVertices, toTrianglesDrawMode };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}