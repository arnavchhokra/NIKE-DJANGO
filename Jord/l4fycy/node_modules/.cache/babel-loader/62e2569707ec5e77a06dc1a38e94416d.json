{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport CodeNode from './CodeNode.js';\nimport FunctionCallNode from './FunctionCallNode.js';\n\nvar FunctionNode = /*#__PURE__*/function (_CodeNode) {\n  _inherits(FunctionNode, _CodeNode);\n\n  var _super = _createSuper(FunctionNode);\n\n  function FunctionNode() {\n    var _this;\n\n    var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n    _classCallCheck(this, FunctionNode);\n\n    _this = _super.call(this, code);\n    _this.keywords = {};\n    return _this;\n  }\n\n  _createClass(FunctionNode, [{\n    key: \"getNodeType\",\n    value: function getNodeType(builder) {\n      return this.getNodeFunction(builder).type;\n    }\n  }, {\n    key: \"getInputs\",\n    value: function getInputs(builder) {\n      return this.getNodeFunction(builder).inputs;\n    }\n  }, {\n    key: \"getNodeFunction\",\n    value: function getNodeFunction(builder) {\n      var nodeData = builder.getDataFromNode(this);\n      var nodeFunction = nodeData.nodeFunction;\n\n      if (nodeFunction === undefined) {\n        nodeFunction = builder.parser.parseFunction(this.code);\n        nodeData.nodeFunction = nodeFunction;\n      }\n\n      return nodeFunction;\n    }\n  }, {\n    key: \"call\",\n    value: function call() {\n      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new FunctionCallNode(this, parameters);\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(builder, output) {\n      _get(_getPrototypeOf(FunctionNode.prototype), \"generate\", this).call(this, builder);\n\n      var nodeFunction = this.getNodeFunction(builder);\n      var name = nodeFunction.name;\n      var type = nodeFunction.type;\n      var nodeCode = builder.getCodeFromNode(this, type);\n\n      if (name !== '') {\n        // use a custom property name\n        nodeCode.name = name;\n      }\n\n      var propertyName = builder.getPropertyName(nodeCode);\n      var code = this.getNodeFunction(builder).getCode(propertyName);\n      var keywords = this.keywords;\n      var keywordsProperties = Object.keys(keywords);\n\n      if (keywordsProperties.length > 0) {\n        var _iterator = _createForOfIteratorHelper(keywordsProperties),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var property = _step.value;\n            var propertyRegExp = new RegExp(\"\\\\b\".concat(property, \"\\\\b\"), 'g');\n            var nodeProperty = keywords[property].build(builder, 'property');\n            code = code.replace(propertyRegExp, nodeProperty);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      nodeCode.code = code;\n\n      if (output === 'property') {\n        return propertyName;\n      } else {\n        return builder.format(\"\".concat(propertyName, \"()\"), type, output);\n      }\n    }\n  }]);\n\n  return FunctionNode;\n}(CodeNode);\n\nexport default FunctionNode;","map":{"version":3,"names":["CodeNode","FunctionCallNode","FunctionNode","code","keywords","builder","getNodeFunction","type","inputs","nodeData","getDataFromNode","nodeFunction","undefined","parser","parseFunction","parameters","output","name","nodeCode","getCodeFromNode","propertyName","getPropertyName","getCode","keywordsProperties","Object","keys","length","property","propertyRegExp","RegExp","nodeProperty","build","replace","format"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/nodes/core/FunctionNode.js"],"sourcesContent":["import CodeNode from './CodeNode.js';\nimport FunctionCallNode from './FunctionCallNode.js';\n\nclass FunctionNode extends CodeNode {\n  constructor(code = '') {\n    super(code);\n    this.keywords = {};\n  }\n\n  getNodeType(builder) {\n    return this.getNodeFunction(builder).type;\n  }\n\n  getInputs(builder) {\n    return this.getNodeFunction(builder).inputs;\n  }\n\n  getNodeFunction(builder) {\n    const nodeData = builder.getDataFromNode(this);\n    let nodeFunction = nodeData.nodeFunction;\n\n    if (nodeFunction === undefined) {\n      nodeFunction = builder.parser.parseFunction(this.code);\n      nodeData.nodeFunction = nodeFunction;\n    }\n\n    return nodeFunction;\n  }\n\n  call(parameters = {}) {\n    return new FunctionCallNode(this, parameters);\n  }\n\n  generate(builder, output) {\n    super.generate(builder);\n    const nodeFunction = this.getNodeFunction(builder);\n    const name = nodeFunction.name;\n    const type = nodeFunction.type;\n    const nodeCode = builder.getCodeFromNode(this, type);\n\n    if (name !== '') {\n      // use a custom property name\n      nodeCode.name = name;\n    }\n\n    const propertyName = builder.getPropertyName(nodeCode);\n    let code = this.getNodeFunction(builder).getCode(propertyName);\n    const keywords = this.keywords;\n    const keywordsProperties = Object.keys(keywords);\n\n    if (keywordsProperties.length > 0) {\n      for (const property of keywordsProperties) {\n        const propertyRegExp = new RegExp(`\\\\b${property}\\\\b`, 'g');\n        const nodeProperty = keywords[property].build(builder, 'property');\n        code = code.replace(propertyRegExp, nodeProperty);\n      }\n    }\n\n    nodeCode.code = code;\n\n    if (output === 'property') {\n      return propertyName;\n    } else {\n      return builder.format(`${propertyName}()`, type, output);\n    }\n  }\n\n}\n\nexport default FunctionNode;\n"],"mappings":";;;;;;;AAAA,OAAOA,QAAP,MAAqB,eAArB;AACA,OAAOC,gBAAP,MAA6B,uBAA7B;;IAEMC,Y;;;;;EACJ,wBAAuB;IAAA;;IAAA,IAAXC,IAAW,uEAAJ,EAAI;;IAAA;;IACrB,0BAAMA,IAAN;IACA,MAAKC,QAAL,GAAgB,EAAhB;IAFqB;EAGtB;;;;WAED,qBAAYC,OAAZ,EAAqB;MACnB,OAAO,KAAKC,eAAL,CAAqBD,OAArB,EAA8BE,IAArC;IACD;;;WAED,mBAAUF,OAAV,EAAmB;MACjB,OAAO,KAAKC,eAAL,CAAqBD,OAArB,EAA8BG,MAArC;IACD;;;WAED,yBAAgBH,OAAhB,EAAyB;MACvB,IAAMI,QAAQ,GAAGJ,OAAO,CAACK,eAAR,CAAwB,IAAxB,CAAjB;MACA,IAAIC,YAAY,GAAGF,QAAQ,CAACE,YAA5B;;MAEA,IAAIA,YAAY,KAAKC,SAArB,EAAgC;QAC9BD,YAAY,GAAGN,OAAO,CAACQ,MAAR,CAAeC,aAAf,CAA6B,KAAKX,IAAlC,CAAf;QACAM,QAAQ,CAACE,YAAT,GAAwBA,YAAxB;MACD;;MAED,OAAOA,YAAP;IACD;;;WAED,gBAAsB;MAAA,IAAjBI,UAAiB,uEAAJ,EAAI;MACpB,OAAO,IAAId,gBAAJ,CAAqB,IAArB,EAA2Bc,UAA3B,CAAP;IACD;;;WAED,kBAASV,OAAT,EAAkBW,MAAlB,EAA0B;MACxB,2EAAeX,OAAf;;MACA,IAAMM,YAAY,GAAG,KAAKL,eAAL,CAAqBD,OAArB,CAArB;MACA,IAAMY,IAAI,GAAGN,YAAY,CAACM,IAA1B;MACA,IAAMV,IAAI,GAAGI,YAAY,CAACJ,IAA1B;MACA,IAAMW,QAAQ,GAAGb,OAAO,CAACc,eAAR,CAAwB,IAAxB,EAA8BZ,IAA9B,CAAjB;;MAEA,IAAIU,IAAI,KAAK,EAAb,EAAiB;QACf;QACAC,QAAQ,CAACD,IAAT,GAAgBA,IAAhB;MACD;;MAED,IAAMG,YAAY,GAAGf,OAAO,CAACgB,eAAR,CAAwBH,QAAxB,CAArB;MACA,IAAIf,IAAI,GAAG,KAAKG,eAAL,CAAqBD,OAArB,EAA8BiB,OAA9B,CAAsCF,YAAtC,CAAX;MACA,IAAMhB,QAAQ,GAAG,KAAKA,QAAtB;MACA,IAAMmB,kBAAkB,GAAGC,MAAM,CAACC,IAAP,CAAYrB,QAAZ,CAA3B;;MAEA,IAAImB,kBAAkB,CAACG,MAAnB,GAA4B,CAAhC,EAAmC;QAAA,2CACVH,kBADU;QAAA;;QAAA;UACjC,oDAA2C;YAAA,IAAhCI,QAAgC;YACzC,IAAMC,cAAc,GAAG,IAAIC,MAAJ,cAAiBF,QAAjB,UAAgC,GAAhC,CAAvB;YACA,IAAMG,YAAY,GAAG1B,QAAQ,CAACuB,QAAD,CAAR,CAAmBI,KAAnB,CAAyB1B,OAAzB,EAAkC,UAAlC,CAArB;YACAF,IAAI,GAAGA,IAAI,CAAC6B,OAAL,CAAaJ,cAAb,EAA6BE,YAA7B,CAAP;UACD;QALgC;UAAA;QAAA;UAAA;QAAA;MAMlC;;MAEDZ,QAAQ,CAACf,IAAT,GAAgBA,IAAhB;;MAEA,IAAIa,MAAM,KAAK,UAAf,EAA2B;QACzB,OAAOI,YAAP;MACD,CAFD,MAEO;QACL,OAAOf,OAAO,CAAC4B,MAAR,WAAkBb,YAAlB,SAAoCb,IAApC,EAA0CS,MAA1C,CAAP;MACD;IACF;;;;EA9DwBhB,Q;;AAkE3B,eAAeE,YAAf"},"metadata":{},"sourceType":"module"}