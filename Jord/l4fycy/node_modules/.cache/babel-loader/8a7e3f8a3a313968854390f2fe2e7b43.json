{"ast":null,"code":"function SDFGenerator() {\n  var exports = function (exports) {\n    /**\n     * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n     */\n    function pointOnQuadraticBezier(x0, y0, x1, y1, x2, y2, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n      pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n    }\n    /**\n     * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n     */\n\n\n    function pointOnCubicBezier(x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n      var t2 = 1 - t;\n      pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n      pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n    }\n    /**\n     * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(\n     *   command: 'L'|'Q'|'C',\n     *   startX: number,\n     *   startY: number,\n     *   endX: number,\n     *   endY: number,\n     *   ctrl1X?: number,\n     *   ctrl1Y?: number,\n     *   ctrl2X?: number,\n     *   ctrl2Y?: number\n     * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n     *                      command identifier (only L/Q/C commands) and its numeric arguments.\n     */\n\n\n    function forEachPathCommand(pathString, commandCallback) {\n      var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n      var match, firstX, firstY, prevX, prevY;\n\n      while (match = segmentRE.exec(pathString)) {\n        var args = match[2].replace(/^\\s*|\\s*$/g, '').split(/[,\\s]+/).map(function (v) {\n          return parseFloat(v);\n        });\n\n        switch (match[1]) {\n          case 'M':\n            prevX = firstX = args[0];\n            prevY = firstY = args[1];\n            break;\n\n          case 'L':\n            if (args[0] !== prevX || args[1] !== prevY) {\n              // yup, some fonts have zero-length line commands\n              commandCallback('L', prevX, prevY, prevX = args[0], prevY = args[1]);\n            }\n\n            break;\n\n          case 'Q':\n            {\n              commandCallback('Q', prevX, prevY, prevX = args[2], prevY = args[3], args[0], args[1]);\n              break;\n            }\n\n          case 'C':\n            {\n              commandCallback('C', prevX, prevY, prevX = args[4], prevY = args[5], args[0], args[1], args[2], args[3]);\n              break;\n            }\n\n          case 'Z':\n            if (prevX !== firstX || prevY !== firstY) {\n              commandCallback('L', prevX, prevY, firstX, firstY);\n            }\n\n            break;\n        }\n      }\n    }\n    /**\n     * Convert a path string to a series of straight line segments\n     * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n     * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n     *        function that will be called once for every line segment\n     * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n     *        bezier curve in the path. Defaults to 16.\n     */\n\n\n    function pathToLineSegments(pathString, segmentCallback, curvePoints) {\n      if (curvePoints === void 0) curvePoints = 16;\n      var tempPoint = {\n        x: 0,\n        y: 0\n      };\n      forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n        switch (command) {\n          case 'L':\n            segmentCallback(startX, startY, endX, endY);\n            break;\n\n          case 'Q':\n            {\n              var prevCurveX = startX;\n              var prevCurveY = startY;\n\n              for (var i = 1; i < curvePoints; i++) {\n                pointOnQuadraticBezier(startX, startY, ctrl1X, ctrl1Y, endX, endY, i / (curvePoints - 1), tempPoint);\n                segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n                prevCurveX = tempPoint.x;\n                prevCurveY = tempPoint.y;\n              }\n\n              break;\n            }\n\n          case 'C':\n            {\n              var prevCurveX$1 = startX;\n              var prevCurveY$1 = startY;\n\n              for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n                pointOnCubicBezier(startX, startY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y, endX, endY, i$1 / (curvePoints - 1), tempPoint);\n                segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n                prevCurveX$1 = tempPoint.x;\n                prevCurveY$1 = tempPoint.y;\n              }\n\n              break;\n            }\n        }\n      });\n    }\n\n    var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n    var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n    var cache = new WeakMap();\n    var glContextParams = {\n      premultipliedAlpha: false,\n      preserveDrawingBuffer: true,\n      antialias: false,\n      depth: false\n    };\n    /**\n     * This is a little helper library for WebGL. It assists with state management for a GL context.\n     * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n     *\n     * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n     * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n     */\n\n    function withWebGLContext(glOrCanvas, callback) {\n      var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n      var wrapper = cache.get(gl);\n\n      if (!wrapper) {\n        var getExtension = function getExtension(name) {\n          var ext = extensions[name];\n\n          if (!ext) {\n            ext = extensions[name] = gl.getExtension(name);\n\n            if (!ext) {\n              throw new Error(name + \" not supported\");\n            }\n          }\n\n          return ext;\n        };\n\n        var compileShader = function compileShader(src, type) {\n          var shader = gl.createShader(type);\n          gl.shaderSource(shader, src);\n          gl.compileShader(shader); // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n          // if (!status && !gl.isContextLost()) {\n          //   throw new Error(gl.getShaderInfoLog(shader).trim())\n          // }\n\n          return shader;\n        };\n\n        var withProgram = function withProgram(name, vert, frag, func) {\n          if (!programs[name]) {\n            var attributes = {};\n            var uniforms = {};\n            var program = gl.createProgram();\n            gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n            gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n            gl.linkProgram(program);\n            programs[name] = {\n              program: program,\n              transaction: function transaction(func) {\n                gl.useProgram(program);\n                func({\n                  setUniform: function setUniform(type, name) {\n                    var values = [],\n                        len = arguments.length - 2;\n\n                    while (len-- > 0) {\n                      values[len] = arguments[len + 2];\n                    }\n\n                    var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                    gl[\"uniform\" + type].apply(gl, [uniformLoc].concat(values));\n                  },\n                  setAttribute: function setAttribute(name, size, usage, instancingDivisor, data) {\n                    var attr = attributes[name];\n\n                    if (!attr) {\n                      attr = attributes[name] = {\n                        buf: gl.createBuffer(),\n                        // TODO should we destroy our buffers?\n                        loc: gl.getAttribLocation(program, name),\n                        data: null\n                      };\n                    }\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                    gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                    gl.enableVertexAttribArray(attr.loc);\n\n                    if (isWebGL2) {\n                      gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                    } else {\n                      getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                    }\n\n                    if (data !== attr.data) {\n                      gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                      attr.data = data;\n                    }\n                  }\n                });\n              }\n            };\n          }\n\n          programs[name].transaction(func);\n        };\n\n        var withTexture = function withTexture(name, func) {\n          textureUnit++;\n\n          try {\n            gl.activeTexture(gl.TEXTURE0 + textureUnit);\n            var texture = textures[name];\n\n            if (!texture) {\n              texture = textures[name] = gl.createTexture();\n              gl.bindTexture(gl.TEXTURE_2D, texture);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            }\n\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            func(texture, textureUnit);\n          } finally {\n            textureUnit--;\n          }\n        };\n\n        var withTextureFramebuffer = function withTextureFramebuffer(texture, textureUnit, func) {\n          var framebuffer = gl.createFramebuffer();\n          framebufferStack.push(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n          try {\n            func(framebuffer);\n          } finally {\n            gl.deleteFramebuffer(framebuffer);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n          }\n        };\n\n        var handleContextLoss = function handleContextLoss() {\n          extensions = {};\n          programs = {};\n          textures = {};\n          textureUnit = -1;\n          framebufferStack.length = 0;\n        };\n\n        var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n        var extensions = {};\n        var programs = {};\n        var textures = {};\n        var textureUnit = -1;\n        var framebufferStack = [];\n        gl.canvas.addEventListener('webglcontextlost', function (e) {\n          handleContextLoss();\n          e.preventDefault();\n        }, false);\n        cache.set(gl, wrapper = {\n          gl: gl,\n          isWebGL2: isWebGL2,\n          getExtension: getExtension,\n          withProgram: withProgram,\n          withTexture: withTexture,\n          withTextureFramebuffer: withTextureFramebuffer,\n          handleContextLoss: handleContextLoss\n        });\n      }\n\n      callback(wrapper);\n    }\n\n    function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n      if (channels === void 0) channels = 15;\n      if (framebuffer === void 0) framebuffer = null;\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        withTexture('copy', function (tex, texUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n          withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n            var setUniform = ref.setUniform;\n            var setAttribute = ref.setAttribute;\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n            setUniform('1i', 'image', texUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n            gl.viewport(x, y, width, height);\n            gl.scissor(x, y, width, height);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        });\n      });\n    }\n    /**\n     * Resizing a canvas clears its contents; this utility copies the previous contents over.\n     * @param canvas\n     * @param newWidth\n     * @param newHeight\n     */\n\n\n    function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n      var width = canvas.width;\n      var height = canvas.height;\n      withWebGLContext(canvas, function (ref) {\n        var gl = ref.gl;\n        var data = new Uint8Array(width * height * 4);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n        canvas.width = newWidth;\n        canvas.height = newHeight;\n        renderImageData(gl, data, 0, 0, width, height);\n      });\n    }\n\n    var webglUtils = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      withWebGLContext: withWebGLContext,\n      renderImageData: renderImageData,\n      resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n    });\n\n    function generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      var textureData = new Uint8Array(sdfWidth * sdfHeight);\n      var viewBoxWidth = viewBox[2] - viewBox[0];\n      var viewBoxHeight = viewBox[3] - viewBox[1]; // Decompose all paths into straight line segments and add them to an index\n\n      var segments = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        segments.push({\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          minX: Math.min(x1, x2),\n          minY: Math.min(y1, y2),\n          maxX: Math.max(x1, x2),\n          maxY: Math.max(y1, y2)\n        });\n      }); // Sort segments by maxX, this will let us short-circuit some loops below\n\n      segments.sort(function (a, b) {\n        return a.maxX - b.maxX;\n      }); // For each target SDF texel, find the distance from its center to its nearest line segment,\n      // map that distance to an alpha value, and write that alpha to the texel\n\n      for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n        for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n          var signedDist = findNearestSignedDistance(viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth, viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight); // Use an exponential scale to ensure the texels very near the glyph path have adequate\n          // precision, while allowing the distance field to cover the entire texture, given that\n          // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n\n          var alpha = Math.pow(1 - Math.abs(signedDist) / maxDistance, sdfExponent) / 2;\n\n          if (signedDist < 0) {\n            alpha = 1 - alpha;\n          }\n\n          alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n\n          textureData[sdfY * sdfWidth + sdfX] = alpha;\n        }\n      }\n\n      return textureData;\n      /**\n       * For a given x/y, search the index for the closest line segment and return\n       * its signed distance. Negative = inside, positive = outside, zero = on edge\n       * @param x\n       * @param y\n       * @returns {number}\n       */\n\n      function findNearestSignedDistance(x, y) {\n        var closestDistSq = Infinity;\n        var closestDist = Infinity;\n\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n\n          if (seg.maxX + closestDist <= x) {\n            break;\n          } //sorting by maxX means no more can be closer, so we can short-circuit\n\n\n          if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n            var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n\n            if (distSq < closestDistSq) {\n              closestDistSq = distSq;\n              closestDist = Math.sqrt(closestDistSq);\n            }\n          }\n        } // Flip to negative distance if inside the poly\n\n\n        if (isPointInPoly(x, y)) {\n          closestDist = -closestDist;\n        }\n\n        return closestDist;\n      }\n      /**\n       * Determine whether the given point lies inside or outside the glyph. Uses a simple\n       * winding-number ray casting algorithm using a ray pointing east from the point.\n       */\n\n\n      function isPointInPoly(x, y) {\n        var winding = 0;\n\n        for (var i = segments.length; i--;) {\n          var seg = segments[i];\n\n          if (seg.maxX <= x) {\n            break;\n          } //sorting by maxX means no more can cross, so we can short-circuit\n\n\n          var intersects = seg.y1 > y !== seg.y2 > y && x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1;\n\n          if (intersects) {\n            winding += seg.y1 < seg.y2 ? 1 : -1;\n          }\n        }\n\n        return winding !== 0;\n      }\n    }\n\n    function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent); // Expand single-channel data to rbga\n\n      var rgbaData = new Uint8Array(data.length * 4);\n\n      for (var i = 0; i < data.length; i++) {\n        rgbaData[i * 4 + channel] = data[i];\n      }\n\n      renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << 3 - channel, framebuffer);\n    }\n    /**\n     * Find the absolute distance from a point to a line segment at closest approach\n     */\n\n\n    function absSquareDistanceToLineSegment(x, y, lineX0, lineY0, lineX1, lineY1) {\n      var ldx = lineX1 - lineX0;\n      var ldy = lineY1 - lineY0;\n      var lengthSq = ldx * ldx + ldy * ldy;\n      var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n      var dx = x - (lineX0 + t * ldx);\n      var dy = y - (lineY0 + t * ldy);\n      return dx * dx + dy * dy;\n    }\n\n    var javascript = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$2,\n      generateIntoCanvas: generateIntoCanvas$2,\n      generateIntoFramebuffer: generateIntoFramebuffer$1\n    });\n    var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n    var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n    var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\"; // Single triangle covering viewport\n\n    var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    var implicitContext = null;\n    var isTestingSupport = false;\n    var NULL_OBJECT = {};\n    var supportByCanvas = new WeakMap(); // canvas -> bool\n\n    function validateSupport(glOrCanvas) {\n      if (!isTestingSupport && !isSupported(glOrCanvas)) {\n        throw new Error('WebGL generation not supported');\n      }\n    }\n\n    function generate$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (glOrCanvas === void 0) glOrCanvas = null;\n\n      if (!glOrCanvas) {\n        glOrCanvas = implicitContext;\n\n        if (!glOrCanvas) {\n          var canvas = typeof OffscreenCanvas === 'function' ? new OffscreenCanvas(1, 1) : typeof document !== 'undefined' ? document.createElement('canvas') : null;\n\n          if (!canvas) {\n            throw new Error('OffscreenCanvas or DOM canvas not supported');\n          }\n\n          glOrCanvas = implicitContext = canvas.getContext('webgl', {\n            depth: false\n          });\n        }\n      }\n\n      validateSupport(glOrCanvas);\n      var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n      // Render into a background texture framebuffer\n\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        withTexture('readable', function (texture, textureUnit) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n          withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n            generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, gl, framebuffer, 0, 0, 0 // red channel\n            );\n            gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n          });\n        });\n      }); // Throw away all but the red channel\n\n      var data = new Uint8Array(sdfWidth * sdfHeight);\n\n      for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n        data[j++] = rgbaData[i];\n      }\n\n      return data;\n    }\n\n    function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n      generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n    }\n\n    function generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0; // Verify support\n\n      validateSupport(glOrCanvas); // Compute path segments\n\n      var lineSegmentCoords = [];\n      pathToLineSegments(path, function (x1, y1, x2, y2) {\n        lineSegmentCoords.push(x1, y1, x2, y2);\n      });\n      lineSegmentCoords = new Float32Array(lineSegmentCoords);\n      withWebGLContext(glOrCanvas, function (ref) {\n        var gl = ref.gl;\n        var isWebGL2 = ref.isWebGL2;\n        var getExtension = ref.getExtension;\n        var withProgram = ref.withProgram;\n        var withTexture = ref.withTexture;\n        var withTextureFramebuffer = ref.withTextureFramebuffer;\n        var handleContextLoss = ref.handleContextLoss;\n        withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n          if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, intermediateTexture._lastWidth = sdfWidth, intermediateTexture._lastHeight = sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n          } // Unsigned distance pass\n\n\n          withProgram('main', mainVertex, mainFragment, function (ref) {\n            var setAttribute = ref.setAttribute;\n            var setUniform = ref.setUniform; // Init extensions\n\n            var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n            var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax'); // Init/update attributes\n\n            setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords); // Init/update uniforms\n\n            setUniform.apply(void 0, ['4f', 'uGlyphBounds'].concat(viewBox));\n            setUniform('1f', 'uMaxDistance', maxDistance);\n            setUniform('1f', 'uExponent', sdfExponent); // Render initial unsigned distance / winding number info to a texture\n\n            withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n              gl.enable(gl.BLEND);\n              gl.colorMask(true, true, true, true);\n              gl.viewport(0, 0, sdfWidth, sdfHeight);\n              gl.scissor(0, 0, sdfWidth, sdfHeight);\n              gl.blendFunc(gl.ONE, gl.ONE); // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n              // Alpha holds the closest (MAX) unsigned distance.\n\n              gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n              gl.clear(gl.COLOR_BUFFER_BIT);\n\n              if (isWebGL2) {\n                gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              } else {\n                instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n              } // Debug\n              // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n              // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n              // console.log('intermediate texture data: ', debug)\n\n            });\n          }); // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n\n          withProgram('post', viewportQuadVertex, postFragment, function (program) {\n            program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n            program.setUniform('1i', 'tex', intermediateTextureUnit);\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n            gl.disable(gl.BLEND);\n            gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n            gl.viewport(x, y, sdfWidth, sdfHeight);\n            gl.scissor(x, y, sdfWidth, sdfHeight);\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n          });\n        }); // Handle context loss occurring during any of the above calls\n\n        if (gl.isContextLost()) {\n          handleContextLoss();\n          throw new Error('webgl context lost');\n        }\n      });\n    }\n\n    function isSupported(glOrCanvas) {\n      var key = !glOrCanvas || glOrCanvas === implicitContext ? NULL_OBJECT : glOrCanvas.canvas || glOrCanvas;\n      var supported = supportByCanvas.get(key);\n\n      if (supported === undefined) {\n        isTestingSupport = true;\n        var failReason = null;\n\n        try {\n          // Since we can't detect all failure modes up front, let's just do a trial run of a\n          // simple path and compare what we get back to the correct expected result. This will\n          // also serve to prime the shader compilation.\n          var expectedResult = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97];\n          var testResult = generate$1(4, 4, 'M8,8L16,8L24,24L16,24Z', [0, 0, 32, 32], 24, 1, glOrCanvas);\n          supported = testResult && expectedResult.length === testResult.length && testResult.every(function (val, i) {\n            return val === expectedResult[i];\n          });\n\n          if (!supported) {\n            failReason = 'bad trial run results';\n            console.info(expectedResult, testResult);\n          }\n        } catch (err) {\n          // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n          supported = false;\n          failReason = err.message;\n        }\n\n        if (failReason) {\n          console.warn('WebGL SDF generation not supported:', failReason);\n        }\n\n        isTestingSupport = false;\n        supportByCanvas.set(key, supported);\n      }\n\n      return supported;\n    }\n\n    var webgl = /*#__PURE__*/Object.freeze({\n      __proto__: null,\n      generate: generate$1,\n      generateIntoCanvas: generateIntoCanvas$1,\n      generateIntoFramebuffer: generateIntoFramebuffer,\n      isSupported: isSupported\n    });\n    /**\n     * Generate an SDF texture image for a 2D path.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @return {Uint8Array}\n     */\n\n    function generate(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if (sdfExponent === void 0) sdfExponent = 1;\n\n      try {\n        return generate$1.apply(webgl, arguments);\n      } catch (e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generate$2.apply(javascript, arguments);\n      }\n    }\n    /**\n     * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n     * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n     * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n     *\n     * @param {number} sdfWidth - width of the SDF output image in pixels.\n     * @param {number} sdfHeight - height of the SDF output image in pixels.\n     * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n     * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n     * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n     *        to half the maximum viewBox dimension.\n     * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n     *        will give greater precision nearer the glyph's path.\n     * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n     *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n     *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n     * @param {number} x - the x position at which to render the SDF.\n     * @param {number} y - the y position at which to render the SDF.\n     * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n     * @return {Uint8Array}\n     */\n\n\n    function generateIntoCanvas(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n      if (maxDistance === void 0) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n      if (sdfExponent === void 0) sdfExponent = 1;\n      if (x === void 0) x = 0;\n      if (y === void 0) y = 0;\n      if (channel === void 0) channel = 0;\n\n      try {\n        return generateIntoCanvas$1.apply(webgl, arguments);\n      } catch (e) {\n        console.info('WebGL SDF generation failed, falling back to JS', e);\n        return generateIntoCanvas$2.apply(javascript, arguments);\n      }\n    }\n\n    exports.forEachPathCommand = forEachPathCommand;\n    exports.generate = generate;\n    exports.generateIntoCanvas = generateIntoCanvas;\n    exports.javascript = javascript;\n    exports.pathToLineSegments = pathToLineSegments;\n    exports.webgl = webgl;\n    exports.webglUtils = webglUtils;\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    return exports;\n  }({});\n\n  return exports;\n}\n\nexport { SDFGenerator as default };","map":{"version":3,"names":["SDFGenerator","exports","pointOnQuadraticBezier","x0","y0","x1","y1","x2","y2","t","pointOut","t2","x","y","pointOnCubicBezier","x3","y3","forEachPathCommand","pathString","commandCallback","segmentRE","match","firstX","firstY","prevX","prevY","exec","args","replace","split","map","v","parseFloat","pathToLineSegments","segmentCallback","curvePoints","tempPoint","command","startX","startY","endX","endY","ctrl1X","ctrl1Y","ctrl2X","ctrl2Y","prevCurveX","prevCurveY","i","prevCurveX$1","prevCurveY$1","i$1","viewportQuadVertex","copyTexFragment","cache","WeakMap","glContextParams","premultipliedAlpha","preserveDrawingBuffer","antialias","depth","withWebGLContext","glOrCanvas","callback","gl","getContext","wrapper","get","getExtension","name","ext","extensions","Error","compileShader","src","type","shader","createShader","shaderSource","withProgram","vert","frag","func","programs","attributes","uniforms","program","createProgram","attachShader","VERTEX_SHADER","FRAGMENT_SHADER","linkProgram","transaction","useProgram","setUniform","values","len","arguments","length","uniformLoc","getUniformLocation","apply","concat","setAttribute","size","usage","instancingDivisor","data","attr","buf","createBuffer","loc","getAttribLocation","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","enableVertexAttribArray","isWebGL2","vertexAttribDivisor","vertexAttribDivisorANGLE","bufferData","withTexture","textureUnit","activeTexture","TEXTURE0","texture","textures","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","withTextureFramebuffer","framebuffer","createFramebuffer","framebufferStack","push","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","deleteFramebuffer","handleContextLoss","WebGL2RenderingContext","canvas","addEventListener","e","preventDefault","set","renderImageData","imageData","width","height","channels","ref","tex","texUnit","texImage2D","RGBA","UNSIGNED_BYTE","STATIC_DRAW","Float32Array","disable","BLEND","colorMask","viewport","scissor","drawArrays","TRIANGLES","resizeWebGLCanvasWithoutClearing","newWidth","newHeight","Uint8Array","readPixels","webglUtils","Object","freeze","__proto__","generate$2","sdfWidth","sdfHeight","path","viewBox","maxDistance","sdfExponent","textureData","viewBoxWidth","viewBoxHeight","segments","minX","Math","min","minY","maxX","max","maxY","sort","a","b","sdfX","sdfY","signedDist","findNearestSignedDistance","alpha","pow","abs","round","closestDistSq","Infinity","closestDist","seg","distSq","absSquareDistanceToLineSegment","sqrt","isPointInPoly","winding","intersects","generateIntoCanvas$2","channel","generateIntoFramebuffer$1","rgbaData","lineX0","lineY0","lineX1","lineY1","ldx","ldy","lengthSq","dx","dy","javascript","generate","generateIntoCanvas","generateIntoFramebuffer","mainVertex","mainFragment","postFragment","viewportUVs","implicitContext","isTestingSupport","NULL_OBJECT","supportByCanvas","validateSupport","isSupported","generate$1","OffscreenCanvas","document","createElement","j","generateIntoCanvas$1","lineSegmentCoords","intermediateTexture","intermediateTextureUnit","_lastWidth","_lastHeight","instancingExtension","blendMinMaxExtension","DYNAMIC_DRAW","enable","blendFunc","ONE","blendEquationSeparate","FUNC_ADD","MAX","MAX_EXT","clear","COLOR_BUFFER_BIT","drawArraysInstanced","drawArraysInstancedANGLE","isContextLost","key","supported","undefined","failReason","expectedResult","testResult","every","val","console","info","err","message","warn","webgl","defineProperty","value","default"],"sources":["D:/Jord/l4fycy/node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs"],"sourcesContent":["function SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\nexport { SDFGenerator as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}