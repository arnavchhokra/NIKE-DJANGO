{"ast":null,"code":"import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\nimport { FullScreenQuad, Pass } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n/**\r\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\r\n * mip map chain of bloom textures and blurs them with different radii. Because\r\n * of the weighted combination of mips, and because larger blurs are done on\r\n * higher mips, this effect provides good quality and performance.\r\n *\r\n * Reference:\r\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\n\nvar UnrealBloomPass = function UnrealBloomPass(resolution, strength, radius, threshold) {\n  this.strength = strength !== undefined ? strength : 1;\n  this.radius = radius;\n  this.threshold = threshold;\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\n\n  this.clearColor = new Color(0, 0, 0); // render targets\n\n  var pars = {\n    minFilter: LinearFilter,\n    magFilter: LinearFilter,\n    format: RGBAFormat\n  };\n  this.renderTargetsHorizontal = [];\n  this.renderTargetsVertical = [];\n  this.nMips = 5;\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n  this.renderTargetBright.texture.generateMipmaps = false;\n\n  for (var i = 0; i < this.nMips; i++) {\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n    renderTargetHorizonal.texture.generateMipmaps = false;\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n    renderTargetVertical.texture.generateMipmaps = false;\n    this.renderTargetsVertical.push(renderTargetVertical);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // luminosity high pass material\n\n\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\n  var highPassShader = LuminosityHighPassShader;\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\n  this.highPassUniforms['smoothWidth'].value = 0.01;\n  this.materialHighPassFilter = new ShaderMaterial({\n    uniforms: this.highPassUniforms,\n    vertexShader: highPassShader.vertexShader,\n    fragmentShader: highPassShader.fragmentShader,\n    defines: {}\n  }); // Gaussian Blur Materials\n\n  this.separableBlurMaterials = [];\n  var kernelSizeArray = [3, 5, 7, 9, 11];\n  var resx = Math.round(this.resolution.x / 2);\n  var resy = Math.round(this.resolution.y / 2);\n\n  for (var _i = 0; _i < this.nMips; _i++) {\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[_i]));\n    this.separableBlurMaterials[_i].uniforms['texSize'].value = new Vector2(resx, resy);\n    resx = Math.round(resx / 2);\n    resy = Math.round(resy / 2);\n  } // Composite material\n\n\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\n  this.compositeMaterial.needsUpdate = true;\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\n\n  if (CopyShader === undefined) {\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\n  }\n\n  var copyShader = CopyShader;\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n  this.copyUniforms['opacity'].value = 1.0;\n  this.materialCopy = new ShaderMaterial({\n    uniforms: this.copyUniforms,\n    vertexShader: copyShader.vertexShader,\n    fragmentShader: copyShader.fragmentShader,\n    blending: AdditiveBlending,\n    depthTest: false,\n    depthWrite: false,\n    transparent: true\n  });\n  this.enabled = true;\n  this.needsSwap = false;\n  this._oldClearColor = new Color();\n  this.oldClearAlpha = 1;\n  this.basic = new MeshBasicMaterial();\n  this.fsQuad = new FullScreenQuad(null);\n};\n\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\n  constructor: UnrealBloomPass,\n  dispose: function dispose() {\n    for (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n      this.renderTargetsHorizontal[i].dispose();\n    }\n\n    for (var _i2 = 0; _i2 < this.renderTargetsVertical.length; _i2++) {\n      this.renderTargetsVertical[_i2].dispose();\n    }\n\n    this.renderTargetBright.dispose();\n  },\n  setSize: function setSize(width, height) {\n    var resx = Math.round(width / 2);\n    var resy = Math.round(height / 2);\n    this.renderTargetBright.setSize(resx, resy);\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\n      this.renderTargetsVertical[i].setSize(resx, resy);\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n    }\n  },\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n    renderer.getClearColor(this._oldClearColor);\n    this.oldClearAlpha = renderer.getClearAlpha();\n    var oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    renderer.setClearColor(this.clearColor, 0);\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\n\n    if (this.renderToScreen) {\n      this.fsQuad.material = this.basic;\n      this.basic.map = readBuffer.texture;\n      renderer.setRenderTarget(null);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    } // 1. Extract Bright Areas\n\n\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\n    this.fsQuad.material = this.materialHighPassFilter;\n    renderer.setRenderTarget(this.renderTargetBright);\n    renderer.clear();\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\n\n    var inputRenderTarget = this.renderTargetBright;\n\n    for (var i = 0; i < this.nMips; i++) {\n      this.fsQuad.material = this.separableBlurMaterials[i];\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n      inputRenderTarget = this.renderTargetsVertical[i];\n    } // Composite All the mips\n\n\n    this.fsQuad.material = this.compositeMaterial;\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n    renderer.clear();\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n    this.fsQuad.material = this.materialCopy;\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\n\n    if (this.renderToScreen) {\n      renderer.setRenderTarget(null);\n      this.fsQuad.render(renderer);\n    } else {\n      renderer.setRenderTarget(readBuffer);\n      this.fsQuad.render(renderer);\n    } // Restore renderer settings\n\n\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n    renderer.autoClear = oldAutoClear;\n  },\n  getSeperableBlurMaterial: function getSeperableBlurMaterial(kernelRadius) {\n    return new ShaderMaterial({\n      defines: {\n        KERNEL_RADIUS: kernelRadius,\n        SIGMA: kernelRadius\n      },\n      uniforms: {\n        colorTexture: {\n          value: null\n        },\n        texSize: {\n          value: new Vector2(0.5, 0.5)\n        },\n        direction: {\n          value: new Vector2(0.5, 0.5)\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}',\n      fragmentShader: '#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat x = float(i);\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\r\n\t\t\t\t}'\n    });\n  },\n  getCompositeMaterial: function getCompositeMaterial(nMips) {\n    return new ShaderMaterial({\n      defines: {\n        NUM_MIPS: nMips\n      },\n      uniforms: {\n        blurTexture1: {\n          value: null\n        },\n        blurTexture2: {\n          value: null\n        },\n        blurTexture3: {\n          value: null\n        },\n        blurTexture4: {\n          value: null\n        },\n        blurTexture5: {\n          value: null\n        },\n        dirtTexture: {\n          value: null\n        },\n        bloomStrength: {\n          value: 1.0\n        },\n        bloomFactors: {\n          value: null\n        },\n        bloomTintColors: {\n          value: null\n        },\n        bloomRadius: {\n          value: 0.0\n        }\n      },\n      vertexShader: 'varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}',\n      fragmentShader: 'varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D blurTexture1;\\\r\n\t\t\t\tuniform sampler2D blurTexture2;\\\r\n\t\t\t\tuniform sampler2D blurTexture3;\\\r\n\t\t\t\tuniform sampler2D blurTexture4;\\\r\n\t\t\t\tuniform sampler2D blurTexture5;\\\r\n\t\t\t\tuniform sampler2D dirtTexture;\\\r\n\t\t\t\tuniform float bloomStrength;\\\r\n\t\t\t\tuniform float bloomRadius;\\\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\r\n\t\t\t\t}\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\r\n\t\t\t\t}'\n    });\n  }\n});\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\nexport { UnrealBloomPass };","map":{"version":3,"names":["Vector2","Color","WebGLRenderTarget","UniformsUtils","ShaderMaterial","Vector3","AdditiveBlending","MeshBasicMaterial","LinearFilter","RGBAFormat","FullScreenQuad","Pass","CopyShader","LuminosityHighPassShader","UnrealBloomPass","resolution","strength","radius","threshold","undefined","x","y","clearColor","pars","minFilter","magFilter","format","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","console","error","highPassShader","highPassUniforms","clone","uniforms","value","materialHighPassFilter","vertexShader","fragmentShader","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomFactors","bloomTintColors","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","basic","fsQuad","prototype","Object","assign","create","constructor","dispose","length","setSize","width","height","render","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","renderToScreen","material","map","setRenderTarget","clear","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius","KERNEL_RADIUS","SIGMA","colorTexture","texSize","direction","NUM_MIPS","blurTexture1","blurTexture2","blurTexture3","blurTexture4","blurTexture5","dirtTexture","bloomStrength","bloomRadius"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/postprocessing/UnrealBloomPass.js"],"sourcesContent":["import { Vector2, Color, WebGLRenderTarget, UniformsUtils, ShaderMaterial, Vector3, AdditiveBlending, MeshBasicMaterial, LinearFilter, RGBAFormat } from 'three';\r\nimport { FullScreenQuad, Pass } from './Pass.js';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\r\n\r\n/**\r\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\r\n * mip map chain of bloom textures and blurs them with different radii. Because\r\n * of the weighted combination of mips, and because larger blurs are done on\r\n * higher mips, this effect provides good quality and performance.\r\n *\r\n * Reference:\r\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\r\n\r\nvar UnrealBloomPass = function (resolution, strength, radius, threshold) {\r\n  this.strength = strength !== undefined ? strength : 1;\r\n  this.radius = radius;\r\n  this.threshold = threshold;\r\n  this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256); // create color only once here, reuse it later inside the render function\r\n\r\n  this.clearColor = new Color(0, 0, 0); // render targets\r\n\r\n  var pars = {\r\n    minFilter: LinearFilter,\r\n    magFilter: LinearFilter,\r\n    format: RGBAFormat\r\n  };\r\n  this.renderTargetsHorizontal = [];\r\n  this.renderTargetsVertical = [];\r\n  this.nMips = 5;\r\n  var resx = Math.round(this.resolution.x / 2);\r\n  var resy = Math.round(this.resolution.y / 2);\r\n  this.renderTargetBright = new WebGLRenderTarget(resx, resy, pars);\r\n  this.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\r\n  this.renderTargetBright.texture.generateMipmaps = false;\r\n\r\n  for (let i = 0; i < this.nMips; i++) {\r\n    var renderTargetHorizonal = new WebGLRenderTarget(resx, resy, pars);\r\n    renderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\r\n    renderTargetHorizonal.texture.generateMipmaps = false;\r\n    this.renderTargetsHorizontal.push(renderTargetHorizonal);\r\n    var renderTargetVertical = new WebGLRenderTarget(resx, resy, pars);\r\n    renderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\r\n    renderTargetVertical.texture.generateMipmaps = false;\r\n    this.renderTargetsVertical.push(renderTargetVertical);\r\n    resx = Math.round(resx / 2);\r\n    resy = Math.round(resy / 2);\r\n  } // luminosity high pass material\r\n\r\n\r\n  if (LuminosityHighPassShader === undefined) console.error('THREE.UnrealBloomPass relies on LuminosityHighPassShader');\r\n  var highPassShader = LuminosityHighPassShader;\r\n  this.highPassUniforms = UniformsUtils.clone(highPassShader.uniforms);\r\n  this.highPassUniforms['luminosityThreshold'].value = threshold;\r\n  this.highPassUniforms['smoothWidth'].value = 0.01;\r\n  this.materialHighPassFilter = new ShaderMaterial({\r\n    uniforms: this.highPassUniforms,\r\n    vertexShader: highPassShader.vertexShader,\r\n    fragmentShader: highPassShader.fragmentShader,\r\n    defines: {}\r\n  }); // Gaussian Blur Materials\r\n\r\n  this.separableBlurMaterials = [];\r\n  var kernelSizeArray = [3, 5, 7, 9, 11];\r\n  var resx = Math.round(this.resolution.x / 2);\r\n  var resy = Math.round(this.resolution.y / 2);\r\n\r\n  for (let i = 0; i < this.nMips; i++) {\r\n    this.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\r\n    this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\r\n    resx = Math.round(resx / 2);\r\n    resy = Math.round(resy / 2);\r\n  } // Composite material\r\n\r\n\r\n  this.compositeMaterial = this.getCompositeMaterial(this.nMips);\r\n  this.compositeMaterial.uniforms['blurTexture1'].value = this.renderTargetsVertical[0].texture;\r\n  this.compositeMaterial.uniforms['blurTexture2'].value = this.renderTargetsVertical[1].texture;\r\n  this.compositeMaterial.uniforms['blurTexture3'].value = this.renderTargetsVertical[2].texture;\r\n  this.compositeMaterial.uniforms['blurTexture4'].value = this.renderTargetsVertical[3].texture;\r\n  this.compositeMaterial.uniforms['blurTexture5'].value = this.renderTargetsVertical[4].texture;\r\n  this.compositeMaterial.uniforms['bloomStrength'].value = strength;\r\n  this.compositeMaterial.uniforms['bloomRadius'].value = 0.1;\r\n  this.compositeMaterial.needsUpdate = true;\r\n  var bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\r\n  this.compositeMaterial.uniforms['bloomFactors'].value = bloomFactors;\r\n  this.bloomTintColors = [new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1), new Vector3(1, 1, 1)];\r\n  this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors; // copy material\r\n\r\n  if (CopyShader === undefined) {\r\n    console.error('THREE.UnrealBloomPass relies on CopyShader');\r\n  }\r\n\r\n  var copyShader = CopyShader;\r\n  this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\r\n  this.copyUniforms['opacity'].value = 1.0;\r\n  this.materialCopy = new ShaderMaterial({\r\n    uniforms: this.copyUniforms,\r\n    vertexShader: copyShader.vertexShader,\r\n    fragmentShader: copyShader.fragmentShader,\r\n    blending: AdditiveBlending,\r\n    depthTest: false,\r\n    depthWrite: false,\r\n    transparent: true\r\n  });\r\n  this.enabled = true;\r\n  this.needsSwap = false;\r\n  this._oldClearColor = new Color();\r\n  this.oldClearAlpha = 1;\r\n  this.basic = new MeshBasicMaterial();\r\n  this.fsQuad = new FullScreenQuad(null);\r\n};\r\n\r\nUnrealBloomPass.prototype = Object.assign(Object.create(Pass.prototype), {\r\n  constructor: UnrealBloomPass,\r\n  dispose: function () {\r\n    for (let i = 0; i < this.renderTargetsHorizontal.length; i++) {\r\n      this.renderTargetsHorizontal[i].dispose();\r\n    }\r\n\r\n    for (let i = 0; i < this.renderTargetsVertical.length; i++) {\r\n      this.renderTargetsVertical[i].dispose();\r\n    }\r\n\r\n    this.renderTargetBright.dispose();\r\n  },\r\n  setSize: function (width, height) {\r\n    var resx = Math.round(width / 2);\r\n    var resy = Math.round(height / 2);\r\n    this.renderTargetBright.setSize(resx, resy);\r\n\r\n    for (let i = 0; i < this.nMips; i++) {\r\n      this.renderTargetsHorizontal[i].setSize(resx, resy);\r\n      this.renderTargetsVertical[i].setSize(resx, resy);\r\n      this.separableBlurMaterials[i].uniforms['texSize'].value = new Vector2(resx, resy);\r\n      resx = Math.round(resx / 2);\r\n      resy = Math.round(resy / 2);\r\n    }\r\n  },\r\n  render: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\r\n    renderer.getClearColor(this._oldClearColor);\r\n    this.oldClearAlpha = renderer.getClearAlpha();\r\n    var oldAutoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    renderer.setClearColor(this.clearColor, 0);\r\n    if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render input to screen\r\n\r\n    if (this.renderToScreen) {\r\n      this.fsQuad.material = this.basic;\r\n      this.basic.map = readBuffer.texture;\r\n      renderer.setRenderTarget(null);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n    } // 1. Extract Bright Areas\r\n\r\n\r\n    this.highPassUniforms['tDiffuse'].value = readBuffer.texture;\r\n    this.highPassUniforms['luminosityThreshold'].value = this.threshold;\r\n    this.fsQuad.material = this.materialHighPassFilter;\r\n    renderer.setRenderTarget(this.renderTargetBright);\r\n    renderer.clear();\r\n    this.fsQuad.render(renderer); // 2. Blur All the mips progressively\r\n\r\n    var inputRenderTarget = this.renderTargetBright;\r\n\r\n    for (let i = 0; i < this.nMips; i++) {\r\n      this.fsQuad.material = this.separableBlurMaterials[i];\r\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = inputRenderTarget.texture;\r\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionX;\r\n      renderer.setRenderTarget(this.renderTargetsHorizontal[i]);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n      this.separableBlurMaterials[i].uniforms['colorTexture'].value = this.renderTargetsHorizontal[i].texture;\r\n      this.separableBlurMaterials[i].uniforms['direction'].value = UnrealBloomPass.BlurDirectionY;\r\n      renderer.setRenderTarget(this.renderTargetsVertical[i]);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n      inputRenderTarget = this.renderTargetsVertical[i];\r\n    } // Composite All the mips\r\n\r\n\r\n    this.fsQuad.material = this.compositeMaterial;\r\n    this.compositeMaterial.uniforms['bloomStrength'].value = this.strength;\r\n    this.compositeMaterial.uniforms['bloomRadius'].value = this.radius;\r\n    this.compositeMaterial.uniforms['bloomTintColors'].value = this.bloomTintColors;\r\n    renderer.setRenderTarget(this.renderTargetsHorizontal[0]);\r\n    renderer.clear();\r\n    this.fsQuad.render(renderer); // Blend it additively over the input texture\r\n\r\n    this.fsQuad.material = this.materialCopy;\r\n    this.copyUniforms['tDiffuse'].value = this.renderTargetsHorizontal[0].texture;\r\n    if (maskActive) renderer.state.buffers.stencil.setTest(true);\r\n\r\n    if (this.renderToScreen) {\r\n      renderer.setRenderTarget(null);\r\n      this.fsQuad.render(renderer);\r\n    } else {\r\n      renderer.setRenderTarget(readBuffer);\r\n      this.fsQuad.render(renderer);\r\n    } // Restore renderer settings\r\n\r\n\r\n    renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\r\n    renderer.autoClear = oldAutoClear;\r\n  },\r\n  getSeperableBlurMaterial: function (kernelRadius) {\r\n    return new ShaderMaterial({\r\n      defines: {\r\n        KERNEL_RADIUS: kernelRadius,\r\n        SIGMA: kernelRadius\r\n      },\r\n      uniforms: {\r\n        colorTexture: {\r\n          value: null\r\n        },\r\n        texSize: {\r\n          value: new Vector2(0.5, 0.5)\r\n        },\r\n        direction: {\r\n          value: new Vector2(0.5, 0.5)\r\n        }\r\n      },\r\n      vertexShader: 'varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}',\r\n      fragmentShader: '#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat x = float(i);\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\r\n\t\t\t\t}'\r\n    });\r\n  },\r\n  getCompositeMaterial: function (nMips) {\r\n    return new ShaderMaterial({\r\n      defines: {\r\n        NUM_MIPS: nMips\r\n      },\r\n      uniforms: {\r\n        blurTexture1: {\r\n          value: null\r\n        },\r\n        blurTexture2: {\r\n          value: null\r\n        },\r\n        blurTexture3: {\r\n          value: null\r\n        },\r\n        blurTexture4: {\r\n          value: null\r\n        },\r\n        blurTexture5: {\r\n          value: null\r\n        },\r\n        dirtTexture: {\r\n          value: null\r\n        },\r\n        bloomStrength: {\r\n          value: 1.0\r\n        },\r\n        bloomFactors: {\r\n          value: null\r\n        },\r\n        bloomTintColors: {\r\n          value: null\r\n        },\r\n        bloomRadius: {\r\n          value: 0.0\r\n        }\r\n      },\r\n      vertexShader: 'varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}',\r\n      fragmentShader: 'varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D blurTexture1;\\\r\n\t\t\t\tuniform sampler2D blurTexture2;\\\r\n\t\t\t\tuniform sampler2D blurTexture3;\\\r\n\t\t\t\tuniform sampler2D blurTexture4;\\\r\n\t\t\t\tuniform sampler2D blurTexture5;\\\r\n\t\t\t\tuniform sampler2D dirtTexture;\\\r\n\t\t\t\tuniform float bloomStrength;\\\r\n\t\t\t\tuniform float bloomRadius;\\\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\r\n\t\t\t\t}\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\r\n\t\t\t\t}'\r\n    });\r\n  }\r\n});\r\nUnrealBloomPass.BlurDirectionX = new Vector2(1.0, 0.0);\r\nUnrealBloomPass.BlurDirectionY = new Vector2(0.0, 1.0);\r\n\r\nexport { UnrealBloomPass };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}