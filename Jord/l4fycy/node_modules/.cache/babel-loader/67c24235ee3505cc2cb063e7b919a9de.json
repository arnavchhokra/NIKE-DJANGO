{"ast":null,"code":"import _slicedToArray from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nvar _excluded = [\"children\", \"width\", \"height\", \"renderPriority\", \"eventPriority\", \"frames\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nvar RenderTexture = /*#__PURE__*/React.forwardRef(function (_ref, forwardRef) {\n  var children = _ref.children,\n      width = _ref.width,\n      height = _ref.height,\n      _ref$renderPriority = _ref.renderPriority,\n      renderPriority = _ref$renderPriority === void 0 ? 0 : _ref$renderPriority,\n      _ref$eventPriority = _ref.eventPriority,\n      eventPriority = _ref$eventPriority === void 0 ? 0 : _ref$eventPriority,\n      _ref$frames = _ref.frames,\n      frames = _ref$frames === void 0 ? Infinity : _ref$frames,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var _useThree = useThree(),\n      size = _useThree.size,\n      viewport = _useThree.viewport;\n\n  var fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\n    samples: 8\n  });\n\n  var _React$useState = React.useState(function () {\n    return new THREE.Scene();\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 1),\n      vScene = _React$useState2[0];\n\n  var compute = React.useCallback(function (event, state, previous) {\n    var _fbo$texture, _previous$previousRoo; // Since this is only a texture it does not have an easy way to obtain the parent, which we\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\n    // next Object3D.\n\n\n    var parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;\n\n    while (parent && !(parent instanceof THREE.Object3D)) {\n      parent = parent.__r3f.parent;\n    }\n\n    if (!parent) return false; // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\n\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState()); // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\n\n    var _previous$raycaster$i = previous.raycaster.intersectObject(parent),\n        _previous$raycaster$i2 = _slicedToArray(_previous$raycaster$i, 1),\n        intersection = _previous$raycaster$i2[0];\n\n    if (!intersection) return false; // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\n\n    var uv = intersection.uv;\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\n  }, []);\n  React.useImperativeHandle(forwardRef, function () {\n    return fbo.texture;\n  }, [fbo]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\n    renderPriority: renderPriority,\n    frames: frames,\n    fbo: fbo\n  }, children), vScene, {\n    events: {\n      compute: compute,\n      priority: eventPriority\n    }\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    object: fbo.texture\n  }, props)));\n}); // The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\n// it would return the default state.\n\nfunction Container(_ref2) {\n  var frames = _ref2.frames,\n      renderPriority = _ref2.renderPriority,\n      children = _ref2.children,\n      fbo = _ref2.fbo;\n  var count = 0;\n  useFrame(function (state) {\n    if (frames === Infinity || count < frames) {\n      state.gl.setRenderTarget(fbo);\n      state.gl.render(state.scene, state.camera);\n      state.gl.setRenderTarget(null);\n      count++;\n    }\n  }, renderPriority);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\n}\n\nexport { RenderTexture };","map":{"version":3,"names":["_extends","THREE","React","useThree","createPortal","useFrame","useFBO","RenderTexture","forwardRef","children","width","height","renderPriority","eventPriority","frames","Infinity","props","size","viewport","fbo","dpr","samples","useState","Scene","vScene","compute","useCallback","event","state","previous","_fbo$texture","_previous$previousRoo","parent","texture","__r3f","Object3D","raycaster","camera","events","previousRoot","getState","intersectObject","intersection","uv","setFromCamera","pointer","set","x","y","useImperativeHandle","createElement","Fragment","Container","priority","object","count","gl","setRenderTarget","render","scene"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@react-three/drei/core/RenderTexture.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\r\nimport * as THREE from 'three';\r\nimport * as React from 'react';\r\nimport { useThree, createPortal, useFrame } from '@react-three/fiber';\r\nimport { useFBO } from './useFBO.js';\r\n\r\nconst RenderTexture = /*#__PURE__*/React.forwardRef(({\r\n  children,\r\n  width,\r\n  height,\r\n  renderPriority = 0,\r\n  eventPriority = 0,\r\n  frames = Infinity,\r\n  ...props\r\n}, forwardRef) => {\r\n  const {\r\n    size,\r\n    viewport\r\n  } = useThree();\r\n  const fbo = useFBO((width || size.width) * viewport.dpr, (height || size.height) * viewport.dpr, {\r\n    samples: 8\r\n  });\r\n  const [vScene] = React.useState(() => new THREE.Scene());\r\n  const compute = React.useCallback((event, state, previous) => {\r\n    var _fbo$texture, _previous$previousRoo;\r\n\r\n    // Since this is only a texture it does not have an easy way to obtain the parent, which we\r\n    // need to transform event coordinates to local coordinates. We use r3f internals to find the\r\n    // next Object3D.\r\n    let parent = (_fbo$texture = fbo.texture) == null ? void 0 : _fbo$texture.__r3f.parent;\r\n\r\n    while (parent && !(parent instanceof THREE.Object3D)) {\r\n      parent = parent.__r3f.parent;\r\n    }\r\n\r\n    if (!parent) return false; // First we call the previous state-onion-layers compute, this is what makes it possible to nest portals\r\n\r\n    if (!previous.raycaster.camera) previous.events.compute(event, previous, (_previous$previousRoo = previous.previousRoot) == null ? void 0 : _previous$previousRoo.getState()); // We run a quick check against the parent, if it isn't hit there's no need to raycast at all\r\n\r\n    const [intersection] = previous.raycaster.intersectObject(parent);\r\n    if (!intersection) return false; // We take that hits uv coords, set up this layers raycaster, et voilà, we have raycasting on arbitrary surfaces\r\n\r\n    const uv = intersection.uv;\r\n    state.raycaster.setFromCamera(state.pointer.set(uv.x * 2 - 1, uv.y * 2 - 1), state.camera);\r\n  }, []);\r\n  React.useImperativeHandle(forwardRef, () => fbo.texture, [fbo]);\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(Container, {\r\n    renderPriority: renderPriority,\r\n    frames: frames,\r\n    fbo: fbo\r\n  }, children), vScene, {\r\n    events: {\r\n      compute,\r\n      priority: eventPriority\r\n    }\r\n  }), /*#__PURE__*/React.createElement(\"primitive\", _extends({\r\n    object: fbo.texture\r\n  }, props)));\r\n}); // The container component has to be separate, it can not be inlined because \"useFrame(state\" when run inside createPortal will return\r\n// the portals own state which includes user-land overrides (custom cameras etc), but if it is executed in <RenderTexture>'s render function\r\n// it would return the default state.\r\n\r\nfunction Container({\r\n  frames,\r\n  renderPriority,\r\n  children,\r\n  fbo\r\n}) {\r\n  let count = 0;\r\n  useFrame(state => {\r\n    if (frames === Infinity || count < frames) {\r\n      state.gl.setRenderTarget(fbo);\r\n      state.gl.render(state.scene, state.camera);\r\n      state.gl.setRenderTarget(null);\r\n      count++;\r\n    }\r\n  }, renderPriority);\r\n  return /*#__PURE__*/React.createElement(React.Fragment, null, children);\r\n}\r\n\r\nexport { RenderTexture };\r\n"],"mappings":";;;AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,QAAT,EAAmBC,YAAnB,EAAiCC,QAAjC,QAAiD,oBAAjD;AACA,SAASC,MAAT,QAAuB,aAAvB;AAEA,IAAMC,aAAa,GAAG,aAAaL,KAAK,CAACM,UAAN,CAAiB,gBAQjDA,UARiD,EAQlC;EAAA,IAPhBC,QAOgB,QAPhBA,QAOgB;EAAA,IANhBC,KAMgB,QANhBA,KAMgB;EAAA,IALhBC,MAKgB,QALhBA,MAKgB;EAAA,+BAJhBC,cAIgB;EAAA,IAJhBA,cAIgB,oCAJC,CAID;EAAA,8BAHhBC,aAGgB;EAAA,IAHhBA,aAGgB,mCAHA,CAGA;EAAA,uBAFhBC,MAEgB;EAAA,IAFhBA,MAEgB,4BAFPC,QAEO;EAAA,IADbC,KACa;;EAChB,gBAGIb,QAAQ,EAHZ;EAAA,IACEc,IADF,aACEA,IADF;EAAA,IAEEC,QAFF,aAEEA,QAFF;;EAIA,IAAMC,GAAG,GAAGb,MAAM,CAAC,CAACI,KAAK,IAAIO,IAAI,CAACP,KAAf,IAAwBQ,QAAQ,CAACE,GAAlC,EAAuC,CAACT,MAAM,IAAIM,IAAI,CAACN,MAAhB,IAA0BO,QAAQ,CAACE,GAA1E,EAA+E;IAC/FC,OAAO,EAAE;EADsF,CAA/E,CAAlB;;EAGA,sBAAiBnB,KAAK,CAACoB,QAAN,CAAe;IAAA,OAAM,IAAIrB,KAAK,CAACsB,KAAV,EAAN;EAAA,CAAf,CAAjB;EAAA;EAAA,IAAOC,MAAP;;EACA,IAAMC,OAAO,GAAGvB,KAAK,CAACwB,WAAN,CAAkB,UAACC,KAAD,EAAQC,KAAR,EAAeC,QAAf,EAA4B;IAC5D,IAAIC,YAAJ,EAAkBC,qBAAlB,CAD4D,CAG5D;IACA;IACA;;;IACA,IAAIC,MAAM,GAAG,CAACF,YAAY,GAAGX,GAAG,CAACc,OAApB,KAAgC,IAAhC,GAAuC,KAAK,CAA5C,GAAgDH,YAAY,CAACI,KAAb,CAAmBF,MAAhF;;IAEA,OAAOA,MAAM,IAAI,EAAEA,MAAM,YAAY/B,KAAK,CAACkC,QAA1B,CAAjB,EAAsD;MACpDH,MAAM,GAAGA,MAAM,CAACE,KAAP,CAAaF,MAAtB;IACD;;IAED,IAAI,CAACA,MAAL,EAAa,OAAO,KAAP,CAZ+C,CAYjC;;IAE3B,IAAI,CAACH,QAAQ,CAACO,SAAT,CAAmBC,MAAxB,EAAgCR,QAAQ,CAACS,MAAT,CAAgBb,OAAhB,CAAwBE,KAAxB,EAA+BE,QAA/B,EAAyC,CAACE,qBAAqB,GAAGF,QAAQ,CAACU,YAAlC,KAAmD,IAAnD,GAA0D,KAAK,CAA/D,GAAmER,qBAAqB,CAACS,QAAtB,EAA5G,EAd4B,CAcmH;;IAE/K,4BAAuBX,QAAQ,CAACO,SAAT,CAAmBK,eAAnB,CAAmCT,MAAnC,CAAvB;IAAA;IAAA,IAAOU,YAAP;;IACA,IAAI,CAACA,YAAL,EAAmB,OAAO,KAAP,CAjByC,CAiB3B;;IAEjC,IAAMC,EAAE,GAAGD,YAAY,CAACC,EAAxB;IACAf,KAAK,CAACQ,SAAN,CAAgBQ,aAAhB,CAA8BhB,KAAK,CAACiB,OAAN,CAAcC,GAAd,CAAkBH,EAAE,CAACI,CAAH,GAAO,CAAP,GAAW,CAA7B,EAAgCJ,EAAE,CAACK,CAAH,GAAO,CAAP,GAAW,CAA3C,CAA9B,EAA6EpB,KAAK,CAACS,MAAnF;EACD,CArBe,EAqBb,EArBa,CAAhB;EAsBAnC,KAAK,CAAC+C,mBAAN,CAA0BzC,UAA1B,EAAsC;IAAA,OAAMW,GAAG,CAACc,OAAV;EAAA,CAAtC,EAAyD,CAACd,GAAD,CAAzD;EACA,OAAO,aAAajB,KAAK,CAACgD,aAAN,CAAoBhD,KAAK,CAACiD,QAA1B,EAAoC,IAApC,EAA0C/C,YAAY,EAAE,aAAaF,KAAK,CAACgD,aAAN,CAAoBE,SAApB,EAA+B;IACtHxC,cAAc,EAAEA,cADsG;IAEtHE,MAAM,EAAEA,MAF8G;IAGtHK,GAAG,EAAEA;EAHiH,CAA/B,EAItFV,QAJsF,CAAf,EAI5De,MAJ4D,EAIpD;IACpBc,MAAM,EAAE;MACNb,OAAO,EAAPA,OADM;MAEN4B,QAAQ,EAAExC;IAFJ;EADY,CAJoD,CAAtD,EAShB,aAAaX,KAAK,CAACgD,aAAN,CAAoB,WAApB,EAAiClD,QAAQ,CAAC;IACzDsD,MAAM,EAAEnC,GAAG,CAACc;EAD6C,CAAD,EAEvDjB,KAFuD,CAAzC,CATG,CAApB;AAYD,CApDkC,CAAnC,C,CAoDI;AACJ;AACA;;AAEA,SAASoC,SAAT,QAKG;EAAA,IAJDtC,MAIC,SAJDA,MAIC;EAAA,IAHDF,cAGC,SAHDA,cAGC;EAAA,IAFDH,QAEC,SAFDA,QAEC;EAAA,IADDU,GACC,SADDA,GACC;EACD,IAAIoC,KAAK,GAAG,CAAZ;EACAlD,QAAQ,CAAC,UAAAuB,KAAK,EAAI;IAChB,IAAId,MAAM,KAAKC,QAAX,IAAuBwC,KAAK,GAAGzC,MAAnC,EAA2C;MACzCc,KAAK,CAAC4B,EAAN,CAASC,eAAT,CAAyBtC,GAAzB;MACAS,KAAK,CAAC4B,EAAN,CAASE,MAAT,CAAgB9B,KAAK,CAAC+B,KAAtB,EAA6B/B,KAAK,CAACS,MAAnC;MACAT,KAAK,CAAC4B,EAAN,CAASC,eAAT,CAAyB,IAAzB;MACAF,KAAK;IACN;EACF,CAPO,EAOL3C,cAPK,CAAR;EAQA,OAAO,aAAaV,KAAK,CAACgD,aAAN,CAAoBhD,KAAK,CAACiD,QAA1B,EAAoC,IAApC,EAA0C1C,QAA1C,CAApB;AACD;;AAED,SAASF,aAAT"},"metadata":{},"sourceType":"module"}