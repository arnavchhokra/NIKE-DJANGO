{"ast":null,"code":"import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect(bvh) {\n  let nodeIndices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (nodeIndices && Array.isArray(nodeIndices)) {\n    nodeIndices = new Set(nodeIndices);\n  }\n  const geometry = bvh.geometry;\n  const indexArr = geometry.index ? geometry.index.array : null;\n  const posAttr = geometry.attributes.position;\n  let buffer, uint32Array, uint16Array, float32Array;\n  let byteOffset = 0;\n  const roots = bvh._roots;\n  for (let i = 0, l = roots.length; i < l; i++) {\n    buffer = roots[i];\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    float32Array = new Float32Array(buffer);\n    _traverse(0, byteOffset);\n    byteOffset += buffer.byteLength;\n  }\n  function _traverse(node32Index, byteOffset) {\n    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const node16Index = node32Index * 2;\n    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n    if (isLeaf) {\n      const offset = uint32Array[node32Index + 6];\n      const count = uint16Array[node16Index + 14];\n      let minx = Infinity;\n      let miny = Infinity;\n      let minz = Infinity;\n      let maxx = -Infinity;\n      let maxy = -Infinity;\n      let maxz = -Infinity;\n      for (let i = offset, l = offset + count; i < l; i++) {\n        const t = 3 * bvh.resolveTriangleIndex(i);\n        for (let j = 0; j < 3; j++) {\n          let index = t + j;\n          index = indexArr ? indexArr[index] : index;\n          const x = posAttr.getX(index);\n          const y = posAttr.getY(index);\n          const z = posAttr.getZ(index);\n          if (x < minx) minx = x;\n          if (x > maxx) maxx = x;\n          if (y < miny) miny = y;\n          if (y > maxy) maxy = y;\n          if (z < minz) minz = z;\n          if (z > maxz) maxz = z;\n        }\n      }\n      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n        float32Array[node32Index + 0] = minx;\n        float32Array[node32Index + 1] = miny;\n        float32Array[node32Index + 2] = minz;\n        float32Array[node32Index + 3] = maxx;\n        float32Array[node32Index + 4] = maxy;\n        float32Array[node32Index + 5] = maxz;\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      const left = node32Index + 8;\n      const right = uint32Array[node32Index + 6];\n\n      // the identifying node indices provided by the shapecast function include offsets of all\n      // root buffers to guarantee they're unique between roots so offset left and right indices here.\n      const offsetLeft = left + byteOffset;\n      const offsetRight = right + byteOffset;\n      let forceChildren = force;\n      let includesLeft = false;\n      let includesRight = false;\n      if (nodeIndices) {\n        // if we see that neither the left or right child are included in the set that need to be updated\n        // then we assume that all children need to be updated.\n        if (!forceChildren) {\n          includesLeft = nodeIndices.has(offsetLeft);\n          includesRight = nodeIndices.has(offsetRight);\n          forceChildren = !includesLeft && !includesRight;\n        }\n      } else {\n        includesLeft = true;\n        includesRight = true;\n      }\n      const traverseLeft = forceChildren || includesLeft;\n      const traverseRight = forceChildren || includesRight;\n      let leftChange = false;\n      if (traverseLeft) {\n        leftChange = _traverse(left, byteOffset, forceChildren);\n      }\n      let rightChange = false;\n      if (traverseRight) {\n        rightChange = _traverse(right, byteOffset, forceChildren);\n      }\n      const didChange = leftChange || rightChange;\n      if (didChange) {\n        for (let i = 0; i < 3; i++) {\n          const lefti = left + i;\n          const righti = right + i;\n          const minLeftValue = float32Array[lefti];\n          const maxLeftValue = float32Array[lefti + 3];\n          const minRightValue = float32Array[righti];\n          const maxRightValue = float32Array[righti + 3];\n          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n        }\n      }\n      return didChange;\n    }\n  }\n}\nexport { refit_indirect };","map":{"version":3,"names":["IS_LEAFNODE_FLAG","refit_indirect","bvh","nodeIndices","arguments","length","undefined","Array","isArray","Set","geometry","indexArr","index","array","posAttr","attributes","position","buffer","uint32Array","uint16Array","float32Array","byteOffset","roots","_roots","i","l","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","offset","count","minx","Infinity","miny","minz","maxx","maxy","maxz","t","resolveTriangleIndex","j","x","getX","y","getY","z","getZ","left","right","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js"],"sourcesContent":["import { IS_LEAFNODE_FLAG } from '../Constants.js';\r\n\r\n/****************************************************/\r\n/* This file is generated from \"refit.template.js\". */\r\n/****************************************************/\r\n\r\nfunction refit_indirect( bvh, nodeIndices = null ) {\r\n\r\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t}\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tconst indexArr = geometry.index ? geometry.index.array : null;\r\n\tconst posAttr = geometry.attributes.position;\r\n\r\n\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\tlet byteOffset = 0;\r\n\tconst roots = bvh._roots;\r\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\tbuffer = roots[ i ];\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t_traverse( 0, byteOffset );\r\n\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t}\r\n\r\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\tconst node16Index = node32Index * 2;\r\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\tlet minx = Infinity;\r\n\t\t\tlet miny = Infinity;\r\n\t\t\tlet minz = Infinity;\r\n\t\t\tlet maxx = - Infinity;\r\n\t\t\tlet maxy = - Infinity;\r\n\t\t\tlet maxz = - Infinity;\r\n\r\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\r\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tlet index = t + j;\r\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\r\n\r\n\t\t\t\t\tconst x = posAttr.getX( index );\r\n\t\t\t\t\tconst y = posAttr.getY( index );\r\n\t\t\t\t\tconst z = posAttr.getZ( index );\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (\r\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t) {\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node32Index + 8;\r\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\tlet forceChildren = force;\r\n\t\t\tlet includesLeft = false;\r\n\t\t\tlet includesRight = false;\r\n\r\n\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tincludesLeft = true;\r\n\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\tlet leftChange = false;\r\n\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet rightChange = false;\r\n\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn didChange;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { refit_indirect };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}