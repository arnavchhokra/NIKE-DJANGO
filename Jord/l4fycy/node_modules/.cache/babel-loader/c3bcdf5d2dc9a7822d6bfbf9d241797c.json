{"ast":null,"code":"import _createClass from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial, Color } from 'three';\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nvar LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  \"\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_vertex>\\n\\t\\t#include <fog_pars_vertex>\\n\\t\\t#include <logdepthbuf_pars_vertex>\\n\\t\\t#include <clipping_planes_pars_vertex>\\n\\n\\t\\tuniform float linewidth;\\n\\t\\tuniform vec2 resolution;\\n\\n\\t\\tattribute vec3 instanceStart;\\n\\t\\tattribute vec3 instanceEnd;\\n\\n\\t\\tattribute vec3 instanceColorStart;\\n\\t\\tattribute vec3 instanceColorEnd;\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashScale;\\n\\t\\t\\tattribute float instanceDistanceStart;\\n\\t\\t\\tattribute float instanceDistanceEnd;\\n\\t\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#endif\\n\\n\\t\\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\\n\\n\\t\\t\\t// trim end segment so it terminates between the camera plane and the near plane\\n\\n\\t\\t\\t// conservative estimate of the near plane\\n\\t\\t\\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\\n\\t\\t\\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\\n\\t\\t\\tfloat nearEstimate = - 0.5 * b / a;\\n\\n\\t\\t\\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\\n\\n\\t\\t\\tend.xyz = mix( start.xyz, end.xyz, alpha );\\n\\n\\t\\t}\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#ifdef USE_COLOR\\n\\n\\t\\t\\t\\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat aspect = resolution.x / resolution.y;\\n\\n\\t\\t\\tvUv = uv;\\n\\n\\t\\t\\t// camera space\\n\\t\\t\\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\\n\\t\\t\\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\\n\\n\\t\\t\\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\\n\\t\\t\\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\\n\\t\\t\\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\\n\\t\\t\\t// perhaps there is a more elegant solution -- WestLangley\\n\\n\\t\\t\\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\\n\\n\\t\\t\\tif ( perspective ) {\\n\\n\\t\\t\\t\\tif ( start.z < 0.0 && end.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( start, end );\\n\\n\\t\\t\\t\\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\\n\\n\\t\\t\\t\\t\\ttrimSegment( end, start );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip space\\n\\t\\t\\tvec4 clipStart = projectionMatrix * start;\\n\\t\\t\\tvec4 clipEnd = projectionMatrix * end;\\n\\n\\t\\t\\t// ndc space\\n\\t\\t\\tvec2 ndcStart = clipStart.xy / clipStart.w;\\n\\t\\t\\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\\n\\n\\t\\t\\t// direction\\n\\t\\t\\tvec2 dir = ndcEnd - ndcStart;\\n\\n\\t\\t\\t// account for clip-space aspect ratio\\n\\t\\t\\tdir.x *= aspect;\\n\\t\\t\\tdir = normalize( dir );\\n\\n\\t\\t\\t// perpendicular to dir\\n\\t\\t\\tvec2 offset = vec2( dir.y, - dir.x );\\n\\n\\t\\t\\t// undo aspect ratio adjustment\\n\\t\\t\\tdir.x /= aspect;\\n\\t\\t\\toffset.x /= aspect;\\n\\n\\t\\t\\t// sign flip\\n\\t\\t\\tif ( position.x < 0.0 ) offset *= - 1.0;\\n\\n\\t\\t\\t// endcaps\\n\\t\\t\\tif ( position.y < 0.0 ) {\\n\\n\\t\\t\\t\\toffset += - dir;\\n\\n\\t\\t\\t} else if ( position.y > 1.0 ) {\\n\\n\\t\\t\\t\\toffset += dir;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// adjust for linewidth\\n\\t\\t\\toffset *= linewidth;\\n\\n\\t\\t\\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\\n\\t\\t\\toffset /= resolution.y;\\n\\n\\t\\t\\t// select end\\n\\t\\t\\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\\n\\n\\t\\t\\t// back to clip space\\n\\t\\t\\toffset *= clip.w;\\n\\n\\t\\t\\tclip.xy += offset;\\n\\n\\t\\t\\tgl_Position = clip;\\n\\n\\t\\t\\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\\n\\n\\t\\t\\t#include <logdepthbuf_vertex>\\n\\t\\t\\t#include <clipping_planes_vertex>\\n\\t\\t\\t#include <fog_vertex>\\n\\n\\t\\t}\\n\\t\\t\",\n  fragmentShader:\n  /* glsl */\n  \"\\n\\t\\tuniform vec3 diffuse;\\n\\t\\tuniform float opacity;\\n\\n\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\tuniform float dashSize;\\n\\t\\t\\tuniform float dashOffset;\\n\\t\\t\\tuniform float gapSize;\\n\\n\\t\\t#endif\\n\\n\\t\\tvarying float vLineDistance;\\n\\n\\t\\t#include <common>\\n\\t\\t#include <color_pars_fragment>\\n\\t\\t#include <fog_pars_fragment>\\n\\t\\t#include <logdepthbuf_pars_fragment>\\n\\t\\t#include <clipping_planes_pars_fragment>\\n\\n\\t\\tvarying vec2 vUv;\\n\\n\\t\\tvoid main() {\\n\\n\\t\\t\\t#include <clipping_planes_fragment>\\n\\n\\t\\t\\t#ifdef USE_DASH\\n\\n\\t\\t\\t\\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\\n\\n\\t\\t\\t\\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tfloat alpha = opacity;\\n\\n\\t\\t\\t#ifdef ALPHA_TO_COVERAGE\\n\\n\\t\\t\\t// artifacts appear on some hardware if a derivative is taken within a conditional\\n\\t\\t\\tfloat a = vUv.x;\\n\\t\\t\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\tfloat len2 = a * a + b * b;\\n\\t\\t\\tfloat dlen = fwidth( len2 );\\n\\n\\t\\t\\tif ( abs( vUv.y ) > 1.0 ) {\\n\\n\\t\\t\\t\\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#else\\n\\n\\t\\t\\tif ( abs( vUv.y ) > 1.0 ) {\\n\\n\\t\\t\\t\\tfloat a = vUv.x;\\n\\t\\t\\t\\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\\n\\t\\t\\t\\tfloat len2 = a * a + b * b;\\n\\n\\t\\t\\t\\tif ( len2 > 1.0 ) discard;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t#endif\\n\\n\\t\\t\\tvec4 diffuseColor = vec4( diffuse, alpha );\\n\\n\\t\\t\\t#include <logdepthbuf_fragment>\\n\\t\\t\\t#include <color_fragment>\\n\\n\\t\\t\\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\\n\\n\\t\\t\\t#include <tonemapping_fragment>\\n\\t\\t\\t#include <encodings_fragment>\\n\\t\\t\\t#include <fog_fragment>\\n\\t\\t\\t#include <premultiplied_alpha_fragment>\\n\\n\\t\\t}\\n\\t\\t\"\n};\n\nvar LineMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(LineMaterial, _ShaderMaterial);\n\n  var _super = _createSuper(LineMaterial);\n\n  function LineMaterial() {\n    var _this;\n\n    var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, LineMaterial);\n\n    _this = _super.call(this, {\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(_assertThisInitialized(_this), \"isLineMaterial\", true);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashed\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"color\", new Color(0x000000));\n\n    _defineProperty(_assertThisInitialized(_this), \"lineWidth\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashScale\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashOffset\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dashSize\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"opacity\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"resolution\", new Vector2());\n\n    _defineProperty(_assertThisInitialized(_this), \"alphaToCoverage\", false);\n\n    Object.defineProperties(_assertThisInitialized(_this), {\n      color: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        },\n        set: function set(value) {\n          var colorObj = new Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.linewidth.value;\n        },\n        set: function set(value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashScale.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashSize.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function set(value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.gapSize.value;\n        },\n        set: function set(value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function get() {\n          return this.uniforms.resolution.value;\n        },\n        set: function set(value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function get() {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function set(value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function get() {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function set(value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n\n    _this.setValues(parameters);\n\n    return _this;\n  }\n\n  return _createClass(LineMaterial);\n}(ShaderMaterial);\n\nexport { LineMaterial };","map":{"version":3,"names":["_defineProperty","Vector2","ShaderLib","UniformsUtils","UniformsLib","ShaderMaterial","Color","LineUniforms","linewidth","value","resolution","dashScale","dashSize","dashOffset","gapSize","opacity","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","colorObj","getHex","copy","alphaToCoverage","Boolean","defines","needsUpdate","ALPHA_TO_COVERAGE","extensions","derivatives","dashed","USE_DASH","setValues"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/lines/LineMaterial.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial, Color } from 'three';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters = {}) {\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(this, \"isLineMaterial\", true);\n\n    _defineProperty(this, \"dashed\", false);\n\n    _defineProperty(this, \"color\", new Color(0x000000));\n\n    _defineProperty(this, \"lineWidth\", 0);\n\n    _defineProperty(this, \"dashScale\", 0);\n\n    _defineProperty(this, \"dashOffset\", 0);\n\n    _defineProperty(this, \"dashSize\", 0);\n\n    _defineProperty(this, \"opacity\", 0);\n\n    _defineProperty(this, \"resolution\", new Vector2());\n\n    _defineProperty(this, \"alphaToCoverage\", false);\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          const colorObj = new Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}