{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { strToU8, zipSync } from \"fflate\";\nimport { Mesh, MeshPhysicalMaterial } from \"three\";\nclass USDZExporter {\n  constructor() {\n    __publicField(this, \"PRECISION\", 7);\n    __publicField(this, \"materials\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"files\");\n    this.materials = {};\n    this.textures = {};\n    this.files = {};\n  }\n  async parse(scene) {\n    const modelFileName = \"model.usda\";\n    this.files[modelFileName] = null;\n    let output = this.buildHeader();\n    scene.traverseVisible(object => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry = object.geometry;\n        const material = object.material;\n        const geometryFileName = \"geometries/Geometry_\" + geometry.id + \".usd\";\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry);\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject);\n        }\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material;\n        }\n        output += this.buildXform(object, geometry, material);\n      }\n    });\n    output += this.buildMaterials(this.materials);\n    this.files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in this.textures) {\n      const texture = this.textures[id];\n      const color = id.split(\"_\")[1];\n      const isRGBA = texture.format === 1023;\n      const canvas = this.imageToCanvas(texture.image, color);\n      const blob = await new Promise(resolve => canvas == null ? void 0 : canvas.toBlob(resolve, isRGBA ? \"image/png\" : \"image/jpeg\", 1));\n      if (blob) {\n        this.files[\"textures/Texture_\".concat(id, \".\").concat(isRGBA ? \"png\" : \"jpg\")] = new Uint8Array(await blob.arrayBuffer());\n      }\n    }\n    let offset = 0;\n    for (const filename in this.files) {\n      const file = this.files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        this.files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      if (file && typeof file.length === \"number\") {\n        offset = file.length;\n      }\n    }\n    return zipSync(this.files, {\n      level: 0\n    });\n  }\n  imageToCanvas(image, color) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== \"undefined\" && image instanceof OffscreenCanvas || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      const scale = 1024 / Math.max(image.width, image.height);\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = image.width * Math.min(1, scale);\n      canvas.height = image.height * Math.min(1, scale);\n      const context = canvas.getContext(\"2d\");\n      context == null ? void 0 : context.drawImage(image, 0, 0, canvas.width, canvas.height);\n      if (color !== void 0) {\n        const hex = parseInt(color, 16);\n        const r = (hex >> 16 & 255) / 255;\n        const g = (hex >> 8 & 255) / 255;\n        const b = (hex & 255) / 255;\n        const imagedata = context == null ? void 0 : context.getImageData(0, 0, canvas.width, canvas.height);\n        if (imagedata) {\n          const data = imagedata == null ? void 0 : imagedata.data;\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r;\n            data[i + 1] = data[i + 1] * g;\n            data[i + 2] = data[i + 2] * b;\n          }\n          context == null ? void 0 : context.putImageData(imagedata, 0, 0);\n        }\n      }\n      return canvas;\n    }\n  }\n  buildHeader() {\n    return \"#usda 1.0\\n(\\n    customLayerData = {\\n        string creator = \\\"Three.js USDZExporter\\\"\\n    }\\n    metersPerUnit = 1\\n    upAxis = \\\"Y\\\"\\n)\\n\";\n  }\n  buildUSDFileAsString(dataToInsert) {\n    let output = this.buildHeader();\n    output += dataToInsert;\n    return strToU8(output);\n  }\n  // Xform\n  buildXform(object, geometry, material) {\n    const name = \"Object_\" + object.id;\n    const transform = this.buildMatrix(object.matrixWorld);\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn(\"THREE.USDZExporter: USDZ does not support negative scales\", object);\n    }\n    return \"def Xform \\\"\".concat(name, \"\\\" (\\n    prepend references = @./geometries/Geometry_\").concat(geometry.id, \".usd@</Geometry>\\n)\\n{\\n    matrix4d xformOp:transform = \").concat(transform, \"\\n    uniform token[] xformOpOrder = [\\\"xformOp:transform\\\"]\\n    rel material:binding = </Materials/Material_\").concat(material.id, \">\\n}\\n\");\n  }\n  buildMatrix(matrix) {\n    const array = matrix.elements;\n    return \"( \".concat(this.buildMatrixRow(array, 0), \", \").concat(this.buildMatrixRow(array, 4), \", \").concat(this.buildMatrixRow(array, 8), \", \").concat(this.buildMatrixRow(array, 12), \" )\");\n  }\n  buildMatrixRow(array, offset) {\n    return \"(\".concat(array[offset + 0], \", \").concat(array[offset + 1], \", \").concat(array[offset + 2], \", \").concat(array[offset + 3], \")\");\n  }\n  // Mesh\n  buildMeshObject(geometry) {\n    const mesh = this.buildMesh(geometry);\n    return \"\\ndef \\\"Geometry\\\"\\n{\\n  \".concat(mesh, \"\\n}\\n\");\n  }\n  buildMesh(geometry) {\n    const name = \"Geometry\";\n    const attributes = geometry.attributes;\n    const count = attributes.position.count;\n    return \"\\n    def Mesh \\\"\".concat(name, \"\\\"\\n    {\\n        int[] faceVertexCounts = [\").concat(this.buildMeshVertexCount(geometry), \"]\\n        int[] faceVertexIndices = [\").concat(this.buildMeshVertexIndices(geometry), \"]\\n        normal3f[] normals = [\").concat(this.buildVector3Array(attributes.normal, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        point3f[] points = [\").concat(this.buildVector3Array(attributes.position, count), \"]\\n        float2[] primvars:st = [\").concat(this.buildVector2Array(attributes.uv, count), \"] (\\n            interpolation = \\\"vertex\\\"\\n        )\\n        uniform token subdivisionScheme = \\\"none\\\"\\n    }\\n\");\n  }\n  buildMeshVertexCount(geometry) {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count;\n    return Array(count / 3).fill(3).join(\", \");\n  }\n  buildMeshVertexIndices(geometry) {\n    if (geometry.index !== null) {\n      return geometry.index.array.join(\", \");\n    }\n    const array = [];\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n    return array.join(\", \");\n  }\n  buildVector3Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: Normals missing.\");\n      return Array(count).fill(\"(0, 0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(data[i + 1].toPrecision(this.PRECISION), \", \").concat(data[i + 2].toPrecision(this.PRECISION), \")\"));\n    }\n    return array.join(\", \");\n  }\n  buildVector2Array(attribute, count) {\n    if (attribute === void 0) {\n      console.warn(\"USDZExporter: UVs missing.\");\n      return Array(count).fill(\"(0, 0)\").join(\", \");\n    }\n    const array = [];\n    const data = attribute.array;\n    for (let i = 0; i < data.length; i += 2) {\n      array.push(\"(\".concat(data[i + 0].toPrecision(this.PRECISION), \", \").concat(1 - data[i + 1].toPrecision(this.PRECISION), \")\"));\n    }\n    return array.join(\", \");\n  }\n  // Materials\n  buildMaterials(materials) {\n    const array = [];\n    for (const uuid in materials) {\n      const material = materials[uuid];\n      array.push(this.buildMaterial(material));\n    }\n    return \"def \\\"Materials\\\"\\n{\\n\".concat(array.join(\"\"), \"\\n}\\n\");\n  }\n  buildMaterial(material) {\n    const pad = \"            \";\n    const inputs = [];\n    const samplers = [];\n    if (material.map !== null) {\n      inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.map.id, \"_diffuse.outputs:rgb>\"));\n      samplers.push(this.buildTexture(material, material.map, \"diffuse\", material.color));\n    } else {\n      inputs.push(\"\".concat(pad, \"color3f inputs:diffuseColor = \").concat(this.buildColor(material.color)));\n    }\n    if (material.emissiveMap !== null) {\n      inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.emissiveMap.id, \"_emissive.outputs:rgb>\"));\n      samplers.push(this.buildTexture(material, material.emissiveMap, \"emissive\"));\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(\"\".concat(pad, \"color3f inputs:emissiveColor = \").concat(this.buildColor(material.emissive)));\n    }\n    if (material.normalMap !== null) {\n      inputs.push(\"\".concat(pad, \"normal3f inputs:normal.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.normalMap.id, \"_normal.outputs:rgb>\"));\n      samplers.push(this.buildTexture(material, material.normalMap, \"normal\"));\n    }\n    if (material.aoMap !== null) {\n      inputs.push(\"\".concat(pad, \"float inputs:occlusion.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.aoMap.id, \"_occlusion.outputs:r>\"));\n      samplers.push(this.buildTexture(material, material.aoMap, \"occlusion\"));\n    }\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(\"\".concat(pad, \"float inputs:roughness.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.roughnessMap.id, \"_roughness.outputs:g>\"));\n      samplers.push(this.buildTexture(material, material.roughnessMap, \"roughness\"));\n    } else {\n      inputs.push(\"\".concat(pad, \"float inputs:roughness = \").concat(material.roughness));\n    }\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(\"\".concat(pad, \"float inputs:metallic.connect = </Materials/Material_\").concat(material.id, \"/Texture_\").concat(material.metalnessMap.id, \"_metallic.outputs:b>\"));\n      samplers.push(this.buildTexture(material, material.metalnessMap, \"metallic\"));\n    } else {\n      inputs.push(\"\".concat(pad, \"float inputs:metallic = \").concat(material.metalness));\n    }\n    inputs.push(\"\".concat(pad, \"float inputs:opacity = \").concat(material.opacity));\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(\"\".concat(pad, \"float inputs:clearcoat = \").concat(material.clearcoat));\n      inputs.push(\"\".concat(pad, \"float inputs:clearcoatRoughness = \").concat(material.clearcoatRoughness));\n      inputs.push(\"\".concat(pad, \"float inputs:ior = \").concat(material.ior));\n    }\n    return \"\\n    def Material \\\"Material_\".concat(material.id, \"\\\"\\n    {\\n        def Shader \\\"PreviewSurface\\\"\\n        {\\n            uniform token info:id = \\\"UsdPreviewSurface\\\"\\n\").concat(inputs.join(\"\\n\"), \"\\n            int inputs:useSpecularWorkflow = 0\\n            token outputs:surface\\n        }\\n        token outputs:surface.connect = </Materials/Material_\").concat(material.id, \"/PreviewSurface.outputs:surface>\\n        token inputs:frame:stPrimvarName = \\\"st\\\"\\n        def Shader \\\"uvReader_st\\\"\\n        {\\n            uniform token info:id = \\\"UsdPrimvarReader_float2\\\"\\n            token inputs:varname.connect = </Materials/Material_\").concat(material.id, \".inputs:frame:stPrimvarName>\\n            float2 inputs:fallback = (0.0, 0.0)\\n            float2 outputs:result\\n        }\\n\").concat(samplers.join(\"\\n\"), \"\\n    }\\n\");\n  }\n  buildTexture(material, texture, mapType, color) {\n    const id = texture.id + (color ? \"_\" + color.getHexString() : \"\");\n    const isRGBA = texture.format === 1023;\n    this.textures[id] = texture;\n    return \"\\n      def Shader \\\"Transform2d_\".concat(mapType, \"\\\" (\\n          sdrMetadata = {\\n              string role = \\\"math\\\"\\n          }\\n      )\\n      {\\n          uniform token info:id = \\\"UsdTransform2d\\\"\\n          float2 inputs:in.connect = </Materials/Material_\").concat(material.id, \"/uvReader_st.outputs:result>\\n          float2 inputs:scale = \").concat(this.buildVector2(texture.repeat), \"\\n          float2 inputs:translation = \").concat(this.buildVector2(texture.offset), \"\\n          float2 outputs:result\\n      }\\n      def Shader \\\"Texture_\").concat(texture.id, \"_\").concat(mapType, \"\\\"\\n      {\\n          uniform token info:id = \\\"UsdUVTexture\\\"\\n          asset inputs:file = @textures/Texture_\").concat(id, \".\").concat(isRGBA ? \"png\" : \"jpg\", \"@\\n          float2 inputs:st.connect = </Materials/Material_\").concat(material.id, \"/Transform2d_\").concat(mapType, \".outputs:result>\\n          token inputs:wrapS = \\\"repeat\\\"\\n          token inputs:wrapT = \\\"repeat\\\"\\n          float outputs:r\\n          float outputs:g\\n          float outputs:b\\n          float3 outputs:rgb\\n      }\");\n  }\n  buildColor(color) {\n    return \"(\".concat(color.r, \", \").concat(color.g, \", \").concat(color.b, \")\");\n  }\n  buildVector2(vector) {\n    return \"(\".concat(vector.x, \", \").concat(vector.y, \")\");\n  }\n}\nexport { USDZExporter };","map":{"version":3,"names":["USDZExporter","constructor","__publicField","materials","textures","files","parse","scene","modelFileName","output","buildHeader","traverseVisible","object","Mesh","isMesh","material","isMeshStandardMaterial","geometry","geometryFileName","id","meshObject","buildMeshObject","buildUSDFileAsString","uuid","buildXform","buildMaterials","strToU8","texture","color","split","isRGBA","format","canvas","imageToCanvas","image","blob","Promise","resolve","toBlob","concat","Uint8Array","arrayBuffer","offset","filename","file","headerSize","length","offsetMod64","padLength","padding","extra","zipSync","level","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","scale","Math","max","width","height","document","createElement","min","context","getContext","drawImage","hex","parseInt","r","g","b","imagedata","getImageData","data","i","putImageData","dataToInsert","name","transform","buildMatrix","matrixWorld","determinant","console","warn","matrix","array","elements","buildMatrixRow","mesh","buildMesh","attributes","count","position","buildMeshVertexCount","buildMeshVertexIndices","buildVector3Array","normal","buildVector2Array","uv","index","Array","fill","join","push","attribute","toPrecision","PRECISION","buildMaterial","pad","inputs","samplers","map","buildTexture","buildColor","emissiveMap","emissive","getHex","normalMap","aoMap","roughnessMap","roughness","metalnessMap","metalness","opacity","MeshPhysicalMaterial","clearcoat","clearcoatRoughness","ior","mapType","getHexString","buildVector2","repeat","vector","x","y"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\src\\exporters\\USDZExporter.ts"],"sourcesContent":["import { zipSync, strToU8, Zippable } from 'fflate'\nimport {\n  BufferGeometry,\n  Color,\n  Matrix4,\n  Mesh,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  Object3D,\n  Texture,\n  Vector2,\n} from 'three'\nimport { Nullable } from '../types/utils'\n\ntype MaterialRepresentaion = MeshStandardMaterial | MeshPhysicalMaterial\n\nclass USDZExporter {\n  private readonly PRECISION = 7\n\n  private materials: { [key: string]: MaterialRepresentaion }\n  private textures: { [key: string]: Texture }\n\n  private files: Nullable<Zippable>\n\n  constructor() {\n    this.materials = {}\n    this.textures = {}\n\n    this.files = {}\n  }\n\n  public async parse(scene: Object3D): Promise<Uint8Array> {\n    const modelFileName = 'model.usda'\n\n    // model file should be first in USDZ archive so we init it here\n    this.files[modelFileName] = null\n\n    let output: string | null = this.buildHeader()\n\n    scene.traverseVisible((object) => {\n      if (object instanceof Mesh && object.isMesh && object.material.isMeshStandardMaterial) {\n        const geometry: BufferGeometry = object.geometry\n        const material: MaterialRepresentaion = object.material\n\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usd'\n\n        if (!(geometryFileName in this.files)) {\n          const meshObject = this.buildMeshObject(geometry)\n          this.files[geometryFileName] = this.buildUSDFileAsString(meshObject)\n        }\n\n        if (!(material.uuid in this.materials)) {\n          this.materials[material.uuid] = material\n        }\n\n        output += this.buildXform(object, geometry, material)\n      }\n    })\n\n    output += this.buildMaterials(this.materials)\n\n    this.files[modelFileName] = strToU8(output)\n    output = null\n\n    for (const id in this.textures) {\n      const texture = this.textures[id]\n      const color = id.split('_')[1]\n      const isRGBA = texture.format === 1023\n\n      const canvas = this.imageToCanvas(texture.image, color)\n      const blob = await new Promise<Blob | null>((resolve) =>\n        canvas?.toBlob(resolve, isRGBA ? 'image/png' : 'image/jpeg', 1),\n      )\n\n      if (blob) {\n        this.files[`textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}`] = new Uint8Array(await blob.arrayBuffer())\n      }\n    }\n\n    // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0\n\n    for (const filename in this.files) {\n      const file = this.files[filename]\n      const headerSize = 34 + filename.length\n\n      offset += headerSize\n\n      const offsetMod64 = offset & 63\n\n      if (offsetMod64 !== 4 && file !== null && file instanceof Uint8Array) {\n        const padLength = 64 - offsetMod64\n        const padding = new Uint8Array(padLength)\n\n        this.files[filename] = [file, { extra: { 12345: padding } }]\n      }\n\n      if (file && typeof file.length === 'number') {\n        offset = file.length\n      }\n    }\n\n    return zipSync(this.files as Zippable, { level: 0 })\n  }\n\n  private imageToCanvas(\n    image: HTMLImageElement | HTMLCanvasElement | OffscreenCanvas | ImageBitmap,\n    color: string,\n  ): HTMLCanvasElement | undefined {\n    if (\n      (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||\n      (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||\n      (typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas) ||\n      (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)\n    ) {\n      const scale = 1024 / Math.max(image.width, image.height)\n\n      const canvas = document.createElement('canvas')\n      canvas.width = image.width * Math.min(1, scale)\n      canvas.height = image.height * Math.min(1, scale)\n\n      const context = canvas.getContext('2d')\n      context?.drawImage(image, 0, 0, canvas.width, canvas.height)\n\n      if (color !== undefined) {\n        const hex = parseInt(color, 16)\n\n        const r = ((hex >> 16) & 255) / 255\n        const g = ((hex >> 8) & 255) / 255\n        const b = (hex & 255) / 255\n\n        const imagedata = context?.getImageData(0, 0, canvas.width, canvas.height)\n        if (imagedata) {\n          const data = imagedata?.data\n\n          for (let i = 0; i < data.length; i += 4) {\n            data[i + 0] = data[i + 0] * r\n            data[i + 1] = data[i + 1] * g\n            data[i + 2] = data[i + 2] * b\n          }\n\n          context?.putImageData(imagedata, 0, 0)\n        }\n      }\n\n      return canvas\n    }\n  }\n\n  private buildHeader(): string {\n    return `#usda 1.0\n(\n    customLayerData = {\n        string creator = \"Three.js USDZExporter\"\n    }\n    metersPerUnit = 1\n    upAxis = \"Y\"\n)\n`\n  }\n\n  private buildUSDFileAsString(dataToInsert: string): Uint8Array {\n    let output = this.buildHeader()\n    output += dataToInsert\n    return strToU8(output)\n  }\n\n  // Xform\n  private buildXform(object: Object3D, geometry: BufferGeometry, material: MaterialRepresentaion): string {\n    const name = 'Object_' + object.id\n    const transform = this.buildMatrix(object.matrixWorld)\n\n    if (object.matrixWorld.determinant() < 0) {\n      console.warn('THREE.USDZExporter: USDZ does not support negative scales', object)\n    }\n\n    return `def Xform \"${name}\" (\n    prepend references = @./geometries/Geometry_${geometry.id}.usd@</Geometry>\n)\n{\n    matrix4d xformOp:transform = ${transform}\n    uniform token[] xformOpOrder = [\"xformOp:transform\"]\n    rel material:binding = </Materials/Material_${material.id}>\n}\n`\n  }\n\n  private buildMatrix(matrix: Matrix4): string {\n    const array = matrix.elements\n\n    return `( ${this.buildMatrixRow(array, 0)}, ${this.buildMatrixRow(array, 4)}, ${this.buildMatrixRow(\n      array,\n      8,\n    )}, ${this.buildMatrixRow(array, 12)} )`\n  }\n\n  private buildMatrixRow(array: number[], offset: number): string {\n    return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`\n  }\n\n  // Mesh\n  private buildMeshObject(geometry: BufferGeometry): string {\n    const mesh = this.buildMesh(geometry)\n    return `\ndef \"Geometry\"\n{\n  ${mesh}\n}\n`\n  }\n\n  private buildMesh(geometry: BufferGeometry): string {\n    const name = 'Geometry'\n    const attributes = geometry.attributes\n    const count = attributes.position.count\n\n    return `\n    def Mesh \"${name}\"\n    {\n        int[] faceVertexCounts = [${this.buildMeshVertexCount(geometry)}]\n        int[] faceVertexIndices = [${this.buildMeshVertexIndices(geometry)}]\n        normal3f[] normals = [${this.buildVector3Array(attributes.normal, count)}] (\n            interpolation = \"vertex\"\n        )\n        point3f[] points = [${this.buildVector3Array(attributes.position, count)}]\n        float2[] primvars:st = [${this.buildVector2Array(attributes.uv, count)}] (\n            interpolation = \"vertex\"\n        )\n        uniform token subdivisionScheme = \"none\"\n    }\n`\n  }\n\n  private buildMeshVertexCount(geometry: BufferGeometry): string {\n    const count = geometry.index !== null ? geometry.index.array.length : geometry.attributes.position.count\n\n    return Array(count / 3)\n      .fill(3)\n      .join(', ')\n  }\n\n  private buildMeshVertexIndices(geometry: BufferGeometry): string {\n    if (geometry.index !== null) {\n      // @ts-ignore\n      return geometry.index.array.join(', ')\n    }\n\n    const array: number[] = []\n    const length = geometry.attributes.position.count\n\n    for (let i = 0; i < length; i++) {\n      array.push(i)\n    }\n\n    return array.join(', ')\n  }\n\n  private buildVector3Array(attribute: BufferGeometry['attributes'][number], count: number): string {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: Normals missing.')\n      return Array(count).fill('(0, 0, 0)').join(', ')\n    }\n\n    const array: string[] = []\n    const data = attribute.array\n\n    for (let i = 0; i < data.length; i += 3) {\n      array.push(\n        `(${data[i + 0].toPrecision(this.PRECISION)}, ${data[i + 1].toPrecision(this.PRECISION)}, ${data[\n          i + 2\n        ].toPrecision(this.PRECISION)})`,\n      )\n    }\n\n    return array.join(', ')\n  }\n\n  private buildVector2Array(attribute: BufferGeometry['attributes'][number], count: number): string {\n    if (attribute === undefined) {\n      console.warn('USDZExporter: UVs missing.')\n      return Array(count).fill('(0, 0)').join(', ')\n    }\n\n    const array: string[] = []\n    const data = attribute.array\n\n    for (let i = 0; i < data.length; i += 2) {\n      // @ts-ignore\n      array.push(`(${data[i + 0].toPrecision(this.PRECISION)}, ${1 - data[i + 1].toPrecision(this.PRECISION)})`)\n    }\n\n    return array.join(', ')\n  }\n\n  // Materials\n  private buildMaterials(materials: USDZExporter['materials']): string {\n    const array: string[] = []\n\n    for (const uuid in materials) {\n      const material = materials[uuid]\n\n      array.push(this.buildMaterial(material))\n    }\n\n    return `def \"Materials\"\n{\n${array.join('')}\n}\n`\n  }\n\n  private buildMaterial(material: MaterialRepresentaion): string {\n    // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n    const pad = '            '\n    const inputs = []\n    const samplers = []\n\n    if (material.map !== null) {\n      inputs.push(\n        `${pad}color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.map, 'diffuse', material.color))\n    } else {\n      inputs.push(`${pad}color3f inputs:diffuseColor = ${this.buildColor(material.color)}`)\n    }\n\n    if (material.emissiveMap !== null) {\n      inputs.push(\n        `${pad}color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.emissiveMap, 'emissive'))\n    } else if (material.emissive.getHex() > 0) {\n      inputs.push(`${pad}color3f inputs:emissiveColor = ${this.buildColor(material.emissive)}`)\n    }\n\n    if (material.normalMap !== null) {\n      inputs.push(\n        `${pad}normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.normalMap, 'normal'))\n    }\n\n    if (material.aoMap !== null) {\n      inputs.push(\n        `${pad}float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.aoMap, 'occlusion'))\n    }\n\n    if (material.roughnessMap !== null && material.roughness === 1) {\n      inputs.push(\n        `${pad}float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.roughnessMap, 'roughness'))\n    } else {\n      inputs.push(`${pad}float inputs:roughness = ${material.roughness}`)\n    }\n\n    if (material.metalnessMap !== null && material.metalness === 1) {\n      inputs.push(\n        `${pad}float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`,\n      )\n\n      samplers.push(this.buildTexture(material, material.metalnessMap, 'metallic'))\n    } else {\n      inputs.push(`${pad}float inputs:metallic = ${material.metalness}`)\n    }\n\n    inputs.push(`${pad}float inputs:opacity = ${material.opacity}`)\n\n    if (material instanceof MeshPhysicalMaterial) {\n      inputs.push(`${pad}float inputs:clearcoat = ${material.clearcoat}`)\n      inputs.push(`${pad}float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`)\n      inputs.push(`${pad}float inputs:ior = ${material.ior}`)\n    }\n\n    return `\n    def Material \"Material_${material.id}\"\n    {\n        def Shader \"PreviewSurface\"\n        {\n            uniform token info:id = \"UsdPreviewSurface\"\n${inputs.join('\\n')}\n            int inputs:useSpecularWorkflow = 0\n            token outputs:surface\n        }\n        token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>\n        token inputs:frame:stPrimvarName = \"st\"\n        def Shader \"uvReader_st\"\n        {\n            uniform token info:id = \"UsdPrimvarReader_float2\"\n            token inputs:varname.connect = </Materials/Material_${material.id}.inputs:frame:stPrimvarName>\n            float2 inputs:fallback = (0.0, 0.0)\n            float2 outputs:result\n        }\n${samplers.join('\\n')}\n    }\n`\n  }\n\n  private buildTexture(material: MaterialRepresentaion, texture: Texture, mapType: string, color?: Color): string {\n    const id = texture.id + (color ? '_' + color.getHexString() : '')\n    const isRGBA = texture.format === 1023\n\n    this.textures[id] = texture\n\n    return `\n      def Shader \"Transform2d_${mapType}\" (\n          sdrMetadata = {\n              string role = \"math\"\n          }\n      )\n      {\n          uniform token info:id = \"UsdTransform2d\"\n          float2 inputs:in.connect = </Materials/Material_${material.id}/uvReader_st.outputs:result>\n          float2 inputs:scale = ${this.buildVector2(texture.repeat)}\n          float2 inputs:translation = ${this.buildVector2(texture.offset)}\n          float2 outputs:result\n      }\n      def Shader \"Texture_${texture.id}_${mapType}\"\n      {\n          uniform token info:id = \"UsdUVTexture\"\n          asset inputs:file = @textures/Texture_${id}.${isRGBA ? 'png' : 'jpg'}@\n          float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>\n          token inputs:wrapS = \"repeat\"\n          token inputs:wrapT = \"repeat\"\n          float outputs:r\n          float outputs:g\n          float outputs:b\n          float3 outputs:rgb\n      }`\n  }\n\n  private buildColor(color: Color): string {\n    return `(${color.r}, ${color.g}, ${color.b})`\n  }\n\n  private buildVector2(vector: Vector2): string {\n    return `(${vector.x}, ${vector.y})`\n  }\n}\n\nexport { USDZExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}