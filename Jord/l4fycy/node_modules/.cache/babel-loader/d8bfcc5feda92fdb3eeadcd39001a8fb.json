{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPrefixAlternativesAmbiguities = exports.validateSomeNonEmptyLookaheadPath = exports.validateTooManyAlts = exports.RepetitionCollector = exports.validateAmbiguousAlternationAlternatives = exports.validateEmptyOrAlternative = exports.getFirstNoneTerminal = exports.validateNoLeftRecursion = exports.validateRuleIsOverridden = exports.validateRuleDoesNotAlreadyExist = exports.OccurrenceValidationCollector = exports.identifyProductionForDuplicates = exports.validateGrammar = void 0;\n\nvar first_1 = __importDefault(require(\"lodash/first\"));\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\n\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\n\nvar reject_1 = __importDefault(require(\"lodash/reject\"));\n\nvar difference_1 = __importDefault(require(\"lodash/difference\"));\n\nvar map_1 = __importDefault(require(\"lodash/map\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar groupBy_1 = __importDefault(require(\"lodash/groupBy\"));\n\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\n\nvar values_1 = __importDefault(require(\"lodash/values\"));\n\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\n\nvar flatMap_1 = __importDefault(require(\"lodash/flatMap\"));\n\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\n\nvar parser_1 = require(\"../parser/parser\");\n\nvar gast_1 = require(\"@chevrotain/gast\");\n\nvar lookahead_1 = require(\"./lookahead\");\n\nvar interpreter_1 = require(\"./interpreter\");\n\nvar gast_2 = require(\"@chevrotain/gast\");\n\nvar gast_3 = require(\"@chevrotain/gast\");\n\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\n\nvar compact_1 = __importDefault(require(\"lodash/compact\"));\n\nvar tokens_1 = require(\"../../scan/tokens\");\n\nfunction validateGrammar(topLevels, globalMaxLookahead, tokenTypes, errMsgProvider, grammarName) {\n  var duplicateErrors = (0, flatMap_1.default)(topLevels, function (currTopLevel) {\n    return validateDuplicateProductions(currTopLevel, errMsgProvider);\n  });\n  var leftRecursionErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n    return validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider);\n  });\n  var emptyAltErrors = [];\n  var ambiguousAltsErrors = [];\n  var emptyRepetitionErrors = []; // left recursion could cause infinite loops in the following validations.\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\n\n  if ((0, isEmpty_1.default)(leftRecursionErrors)) {\n    emptyAltErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n      return validateEmptyOrAlternative(currTopRule, errMsgProvider);\n    });\n    ambiguousAltsErrors = (0, flatMap_1.default)(topLevels, function (currTopRule) {\n      return validateAmbiguousAlternationAlternatives(currTopRule, globalMaxLookahead, errMsgProvider);\n    });\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(topLevels, globalMaxLookahead, errMsgProvider);\n  }\n\n  var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n  var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateTooManyAlts(curRule, errMsgProvider);\n  });\n  var duplicateRulesError = (0, flatMap_1.default)(topLevels, function (curRule) {\n    return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);\n  });\n  return duplicateErrors.concat(emptyRepetitionErrors, leftRecursionErrors, emptyAltErrors, ambiguousAltsErrors, termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\n\nexports.validateGrammar = validateGrammar;\n\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n  var collectorVisitor = new OccurrenceValidationCollector();\n  topLevelRule.accept(collectorVisitor);\n  var allRuleProductions = collectorVisitor.allProductions;\n  var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);\n  var duplicates = (0, pickBy_1.default)(productionGroups, function (currGroup) {\n    return currGroup.length > 1;\n  });\n  var errors = (0, map_1.default)((0, values_1.default)(duplicates), function (currDuplicates) {\n    var firstProd = (0, first_1.default)(currDuplicates);\n    var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n    var dslName = (0, gast_1.getProductionDslName)(firstProd);\n    var defError = {\n      message: msg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n      ruleName: topLevelRule.name,\n      dslName: dslName,\n      occurrence: firstProd.idx\n    };\n    var param = getExtraProductionArgument(firstProd);\n\n    if (param) {\n      defError.parameter = param;\n    }\n\n    return defError;\n  });\n  return errors;\n}\n\nfunction identifyProductionForDuplicates(prod) {\n  return \"\".concat((0, gast_1.getProductionDslName)(prod), \"_#_\").concat(prod.idx, \"_#_\").concat(getExtraProductionArgument(prod));\n}\n\nexports.identifyProductionForDuplicates = identifyProductionForDuplicates;\n\nfunction getExtraProductionArgument(prod) {\n  if (prod instanceof gast_2.Terminal) {\n    return prod.terminalType.name;\n  } else if (prod instanceof gast_2.NonTerminal) {\n    return prod.nonTerminalName;\n  } else {\n    return \"\";\n  }\n}\n\nvar OccurrenceValidationCollector =\n/** @class */\nfunction (_super) {\n  __extends(OccurrenceValidationCollector, _super);\n\n  function OccurrenceValidationCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  OccurrenceValidationCollector.prototype.visitNonTerminal = function (subrule) {\n    this.allProductions.push(subrule);\n  };\n\n  OccurrenceValidationCollector.prototype.visitOption = function (option) {\n    this.allProductions.push(option);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  OccurrenceValidationCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  OccurrenceValidationCollector.prototype.visitAlternation = function (or) {\n    this.allProductions.push(or);\n  };\n\n  OccurrenceValidationCollector.prototype.visitTerminal = function (terminal) {\n    this.allProductions.push(terminal);\n  };\n\n  return OccurrenceValidationCollector;\n}(gast_3.GAstVisitor);\n\nexports.OccurrenceValidationCollector = OccurrenceValidationCollector;\n\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n  var errors = [];\n  var occurrences = (0, reduce_1.default)(allRules, function (result, curRule) {\n    if (curRule.name === rule.name) {\n      return result + 1;\n    }\n\n    return result;\n  }, 0);\n\n  if (occurrences > 1) {\n    var errMsg = errMsgProvider.buildDuplicateRuleNameError({\n      topLevelRule: rule,\n      grammarName: className\n    });\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n      ruleName: rule.name\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist; // TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\n\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n  var errors = [];\n  var errMsg;\n\n  if (!(0, includes_1.default)(definedRulesNames, ruleName)) {\n    errMsg = \"Invalid rule override, rule: ->\".concat(ruleName, \"<- cannot be overridden in the grammar: ->\").concat(className, \"<-\") + \"as it is not defined in any of the super grammars \";\n    errors.push({\n      message: errMsg,\n      type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n      ruleName: ruleName\n    });\n  }\n\n  return errors;\n}\n\nexports.validateRuleIsOverridden = validateRuleIsOverridden;\n\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path) {\n  if (path === void 0) {\n    path = [];\n  }\n\n  var errors = [];\n  var nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n\n  if ((0, isEmpty_1.default)(nextNonTerminals)) {\n    return [];\n  } else {\n    var ruleName = topRule.name;\n    var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);\n\n    if (foundLeftRecursion) {\n      errors.push({\n        message: errMsgProvider.buildLeftRecursionError({\n          topLevelRule: topRule,\n          leftRecursionPath: path\n        }),\n        type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,\n        ruleName: ruleName\n      });\n    } // we are only looking for cyclic paths leading back to the specific topRule\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n\n\n    var validNextSteps = (0, difference_1.default)(nextNonTerminals, path.concat([topRule]));\n    var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function (currRefRule) {\n      var newPath = (0, clone_1.default)(path);\n      newPath.push(currRefRule);\n      return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n    });\n    return errors.concat(errorsFromNextSteps);\n  }\n}\n\nexports.validateNoLeftRecursion = validateNoLeftRecursion;\n\nfunction getFirstNoneTerminal(definition) {\n  var result = [];\n\n  if ((0, isEmpty_1.default)(definition)) {\n    return result;\n  }\n\n  var firstProd = (0, first_1.default)(definition);\n  /* istanbul ignore else */\n\n  if (firstProd instanceof gast_2.NonTerminal) {\n    result.push(firstProd.referencedRule);\n  } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {\n    result = result.concat(getFirstNoneTerminal(firstProd.definition));\n  } else if (firstProd instanceof gast_2.Alternation) {\n    // each sub definition in alternation is a FLAT\n    result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function (currSubDef) {\n      return getFirstNoneTerminal(currSubDef.definition);\n    }));\n  } else if (firstProd instanceof gast_2.Terminal) {// nothing to see, move along\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n\n  var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);\n  var hasMore = definition.length > 1;\n\n  if (isFirstOptional && hasMore) {\n    var rest = (0, drop_1.default)(definition);\n    return result.concat(getFirstNoneTerminal(rest));\n  } else {\n    return result;\n  }\n}\n\nexports.getFirstNoneTerminal = getFirstNoneTerminal;\n\nvar OrCollector =\n/** @class */\nfunction (_super) {\n  __extends(OrCollector, _super);\n\n  function OrCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.alternations = [];\n    return _this;\n  }\n\n  OrCollector.prototype.visitAlternation = function (node) {\n    this.alternations.push(node);\n  };\n\n  return OrCollector;\n}(gast_3.GAstVisitor);\n\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var exceptLast = (0, dropRight_1.default)(currOr.definition);\n    return (0, flatMap_1.default)(exceptLast, function (currAlternative, currAltIdx) {\n      var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);\n\n      if ((0, isEmpty_1.default)(possibleFirstInAlt)) {\n        return [{\n          message: errMsgProvider.buildEmptyAlternationError({\n            topLevelRule: topLevelRule,\n            alternation: currOr,\n            emptyChoiceIdx: currAltIdx\n          }),\n          type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n          ruleName: topLevelRule.name,\n          occurrence: currOr.idx,\n          alternative: currAltIdx + 1\n        }];\n      } else {\n        return [];\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateEmptyOrAlternative = validateEmptyOrAlternative;\n\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations; // New Handling of ignoring ambiguities\n  // - https://github.com/chevrotain/chevrotain/issues/869\n\n  ors = (0, reject_1.default)(ors, function (currOr) {\n    return currOr.ignoreAmbiguities === true;\n  });\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    var currOccurrence = currOr.idx;\n    var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n    var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n    var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n  });\n  return errors;\n}\n\nexports.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;\n\nvar RepetitionCollector =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionCollector, _super);\n\n  function RepetitionCollector() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.allProductions = [];\n    return _this;\n  }\n\n  RepetitionCollector.prototype.visitRepetitionWithSeparator = function (manySep) {\n    this.allProductions.push(manySep);\n  };\n\n  RepetitionCollector.prototype.visitRepetitionMandatory = function (atLeastOne) {\n    this.allProductions.push(atLeastOne);\n  };\n\n  RepetitionCollector.prototype.visitRepetitionMandatoryWithSeparator = function (atLeastOneSep) {\n    this.allProductions.push(atLeastOneSep);\n  };\n\n  RepetitionCollector.prototype.visitRepetition = function (many) {\n    this.allProductions.push(many);\n  };\n\n  return RepetitionCollector;\n}(gast_3.GAstVisitor);\n\nexports.RepetitionCollector = RepetitionCollector;\n\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n  var orCollector = new OrCollector();\n  topLevelRule.accept(orCollector);\n  var ors = orCollector.alternations;\n  var errors = (0, flatMap_1.default)(ors, function (currOr) {\n    if (currOr.definition.length > 255) {\n      return [{\n        message: errMsgProvider.buildTooManyAlternativesError({\n          topLevelRule: topLevelRule,\n          alternation: currOr\n        }),\n        type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,\n        ruleName: topLevelRule.name,\n        occurrence: currOr.idx\n      }];\n    } else {\n      return [];\n    }\n  });\n  return errors;\n}\n\nexports.validateTooManyAlts = validateTooManyAlts;\n\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n  var errors = [];\n  (0, forEach_1.default)(topLevelRules, function (currTopRule) {\n    var collectorVisitor = new RepetitionCollector();\n    currTopRule.accept(collectorVisitor);\n    var allRuleProductions = collectorVisitor.allProductions;\n    (0, forEach_1.default)(allRuleProductions, function (currProd) {\n      var prodType = (0, lookahead_1.getProdType)(currProd);\n      var actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n      var currOccurrence = currProd.idx;\n      var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n      var pathsInsideProduction = paths[0];\n\n      if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {\n        var errMsg = errMsgProvider.buildEmptyRepetitionError({\n          topLevelRule: currTopRule,\n          repetition: currProd\n        });\n        errors.push({\n          message: errMsg,\n          type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n          ruleName: currTopRule.name\n        });\n      }\n    });\n  });\n  return errors;\n}\n\nexports.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;\n\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  var foundAmbiguousPaths = [];\n  var identicalAmbiguities = (0, reduce_1.default)(alternatives, function (result, currAlt, currAltIdx) {\n    // ignore (skip) ambiguities with this alternative\n    if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n      return result;\n    }\n\n    (0, forEach_1.default)(currAlt, function (currPath) {\n      var altsCurrPathAppearsIn = [currAltIdx];\n      (0, forEach_1.default)(alternatives, function (currOtherAlt, currOtherAltIdx) {\n        if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n          altsCurrPathAppearsIn.push(currOtherAltIdx);\n        }\n      });\n\n      if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {\n        foundAmbiguousPaths.push(currPath);\n        result.push({\n          alts: altsCurrPathAppearsIn,\n          path: currPath\n        });\n      }\n    });\n    return result;\n  }, []);\n  var currErrors = (0, map_1.default)(identicalAmbiguities, function (currAmbDescriptor) {\n    var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function (currAltIdx) {\n      return currAltIdx + 1;\n    });\n    var currMessage = errMsgProvider.buildAlternationAmbiguityError({\n      topLevelRule: rule,\n      alternation: alternation,\n      ambiguityIndices: ambgIndices,\n      prefixPath: currAmbDescriptor.path\n    });\n    return {\n      message: currMessage,\n      type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n      ruleName: rule.name,\n      occurrence: alternation.idx,\n      alternatives: currAmbDescriptor.alts\n    };\n  });\n  return currErrors;\n}\n\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n  // flatten\n  var pathsAndIndices = (0, reduce_1.default)(alternatives, function (result, currAlt, idx) {\n    var currPathsAndIdx = (0, map_1.default)(currAlt, function (currPath) {\n      return {\n        idx: idx,\n        path: currPath\n      };\n    });\n    return result.concat(currPathsAndIdx);\n  }, []);\n  var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function (currPathAndIdx) {\n    var alternativeGast = alternation.definition[currPathAndIdx.idx]; // ignore (skip) ambiguities with this alternative\n\n    if (alternativeGast.ignoreAmbiguities === true) {\n      return [];\n    }\n\n    var targetIdx = currPathAndIdx.idx;\n    var targetPath = currPathAndIdx.path;\n    var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function (searchPathAndIdx) {\n      // prefix ambiguity can only be created from lower idx (higher priority) path\n      return (// ignore (skip) ambiguities with this \"other\" alternative\n        alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads\n        // will be be detected using a different validation.\n        (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)\n      );\n    });\n    var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function (currAmbPathAndIdx) {\n      var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n      var occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\n      var message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n        topLevelRule: rule,\n        alternation: alternation,\n        ambiguityIndices: ambgIndices,\n        prefixPath: currAmbPathAndIdx.path\n      });\n      return {\n        message: message,\n        type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n        ruleName: rule.name,\n        occurrence: occurrence,\n        alternatives: ambgIndices\n      };\n    });\n    return currPathPrefixErrors;\n  }));\n  return errors;\n}\n\nexports.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;\n\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n  var errors = [];\n  var tokenNames = (0, map_1.default)(tokenTypes, function (currToken) {\n    return currToken.name;\n  });\n  (0, forEach_1.default)(topLevels, function (currRule) {\n    var currRuleName = currRule.name;\n\n    if ((0, includes_1.default)(tokenNames, currRuleName)) {\n      var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n      errors.push({\n        message: errMsg,\n        type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n        ruleName: currRuleName\n      });\n    }\n  });\n  return errors;\n}","map":{"version":3,"mappings":"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","names":["validateGrammar","topLevels","globalMaxLookahead","tokenTypes","errMsgProvider","grammarName","duplicateErrors","currTopLevel","leftRecursionErrors","currTopRule","emptyAltErrors","ambiguousAltsErrors","emptyRepetitionErrors","validateSomeNonEmptyLookaheadPath","termsNamespaceConflictErrors","checkTerminalAndNoneTerminalsNameSpace","tooManyAltsErrors","curRule","duplicateRulesError","concat","exports","validateDuplicateProductions","topLevelRule","collectorVisitor","OccurrenceValidationCollector","accept","allRuleProductions","allProductions","productionGroups","identifyProductionForDuplicates","duplicates","currGroup","length","errors","currDuplicates","firstProd","msg","buildDuplicateFoundError","dslName","defError","message","type","parser_1","DUPLICATE_PRODUCTIONS","ruleName","name","occurrence","idx","param","getExtraProductionArgument","parameter","prod","gast_2","terminalType","nonTerminalName","__extends","_this","subrule","push","option","manySep","atLeastOne","atLeastOneSep","many","or","terminal","gast_3","validateRuleDoesNotAlreadyExist","rule","allRules","className","occurrences","result","errMsg","buildDuplicateRuleNameError","DUPLICATE_RULE_NAME","validateRuleIsOverridden","definedRulesNames","INVALID_RULE_OVERRIDE","validateNoLeftRecursion","topRule","currRule","path","nextNonTerminals","getFirstNoneTerminal","definition","foundLeftRecursion","buildLeftRecursionError","leftRecursionPath","LEFT_RECURSION","validNextSteps","errorsFromNextSteps","currRefRule","newPath","referencedRule","currSubDef","Error","isFirstOptional","hasMore","rest","OrCollector","node","alternations","validateEmptyOrAlternative","orCollector","ors","currOr","exceptLast","currAlternative","currAltIdx","possibleFirstInAlt","tokens_1","buildEmptyAlternationError","alternation","emptyChoiceIdx","NONE_LAST_EMPTY_ALT","alternative","validateAmbiguousAlternationAlternatives","ignoreAmbiguities","currOccurrence","actualMaxLookahead","maxLookahead","alternatives","altsAmbiguityErrors","checkAlternativesAmbiguities","altsPrefixAmbiguityErrors","checkPrefixAlternativesAmbiguities","RepetitionCollector","validateTooManyAlts","buildTooManyAlternativesError","TOO_MANY_ALTS","topLevelRules","currProd","prodType","paths","pathsInsideProduction","buildEmptyRepetitionError","repetition","NO_NON_EMPTY_LOOKAHEAD","foundAmbiguousPaths","identicalAmbiguities","currAlt","currPath","altsCurrPathAppearsIn","currOtherAlt","currOtherAltIdx","alts","currErrors","currAmbDescriptor","ambgIndices","currMessage","buildAlternationAmbiguityError","ambiguityIndices","prefixPath","AMBIGUOUS_ALTS","pathsAndIndices","currPathsAndIdx","currPathAndIdx","alternativeGast","targetIdx","targetPath","prefixAmbiguitiesPathsAndIndices","searchPathAndIdx","currPathPrefixErrors","currAmbPathAndIdx","buildAlternationPrefixAmbiguityError","AMBIGUOUS_PREFIX_ALTS","tokenNames","currToken","currRuleName","buildNamespaceConflictError","CONFLICT_TOKENS_RULES_NAMESPACE"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\chevrotain\\src\\parse\\grammar\\checks.ts"],"sourcesContent":["import first from \"lodash/first\"\r\nimport isEmpty from \"lodash/isEmpty\"\r\nimport drop from \"lodash/drop\"\r\nimport flatten from \"lodash/flatten\"\r\nimport filter from \"lodash/filter\"\r\nimport reject from \"lodash/reject\"\r\nimport difference from \"lodash/difference\"\r\nimport map from \"lodash/map\"\r\nimport forEach from \"lodash/forEach\"\r\nimport groupBy from \"lodash/groupBy\"\r\nimport reduce from \"lodash/reduce\"\r\nimport pickBy from \"lodash/pickBy\"\r\nimport values from \"lodash/values\"\r\nimport includes from \"lodash/includes\"\r\nimport flatMap from \"lodash/flatMap\"\r\nimport clone from \"lodash/clone\"\r\nimport {\r\n  IParserAmbiguousAlternativesDefinitionError,\r\n  IParserDuplicatesDefinitionError,\r\n  IParserEmptyAlternativeDefinitionError,\r\n  ParserDefinitionErrorType\r\n} from \"../parser/parser\"\r\nimport { getProductionDslName, isOptionalProd } from \"@chevrotain/gast\"\r\nimport {\r\n  Alternative,\r\n  containsPath,\r\n  getLookaheadPathsForOptionalProd,\r\n  getLookaheadPathsForOr,\r\n  getProdType,\r\n  isStrictPrefixOfPath\r\n} from \"./lookahead\"\r\nimport { nextPossibleTokensAfter } from \"./interpreter\"\r\nimport {\r\n  Alternation,\r\n  Alternative as AlternativeGAST,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule,\r\n  Terminal\r\n} from \"@chevrotain/gast\"\r\nimport { GAstVisitor } from \"@chevrotain/gast\"\r\nimport {\r\n  IProduction,\r\n  IProductionWithOccurrence,\r\n  TokenType\r\n} from \"@chevrotain/types\"\r\nimport {\r\n  IGrammarValidatorErrorMessageProvider,\r\n  IParserDefinitionError\r\n} from \"./types\"\r\nimport dropRight from \"lodash/dropRight\"\r\nimport compact from \"lodash/compact\"\r\nimport { tokenStructuredMatcher } from \"../../scan/tokens\"\r\n\r\nexport function validateGrammar(\r\n  topLevels: Rule[],\r\n  globalMaxLookahead: number,\r\n  tokenTypes: TokenType[],\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n  grammarName: string\r\n): IParserDefinitionError[] {\r\n  const duplicateErrors = flatMap(topLevels, (currTopLevel) =>\r\n    validateDuplicateProductions(currTopLevel, errMsgProvider)\r\n  )\r\n  const leftRecursionErrors = flatMap(topLevels, (currTopRule) =>\r\n    validateNoLeftRecursion(currTopRule, currTopRule, errMsgProvider)\r\n  )\r\n\r\n  let emptyAltErrors: IParserEmptyAlternativeDefinitionError[] = []\r\n  let ambiguousAltsErrors: IParserAmbiguousAlternativesDefinitionError[] = []\r\n  let emptyRepetitionErrors: IParserDefinitionError[] = []\r\n\r\n  // left recursion could cause infinite loops in the following validations.\r\n  // It is safest to first have the user fix the left recursion errors first and only then examine Further issues.\r\n  if (isEmpty(leftRecursionErrors)) {\r\n    emptyAltErrors = flatMap(topLevels, (currTopRule) =>\r\n      validateEmptyOrAlternative(currTopRule, errMsgProvider)\r\n    )\r\n    ambiguousAltsErrors = flatMap(topLevels, (currTopRule) =>\r\n      validateAmbiguousAlternationAlternatives(\r\n        currTopRule,\r\n        globalMaxLookahead,\r\n        errMsgProvider\r\n      )\r\n    )\r\n\r\n    emptyRepetitionErrors = validateSomeNonEmptyLookaheadPath(\r\n      topLevels,\r\n      globalMaxLookahead,\r\n      errMsgProvider\r\n    )\r\n  }\r\n\r\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\r\n    topLevels,\r\n    tokenTypes,\r\n    errMsgProvider\r\n  )\r\n\r\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\r\n    validateTooManyAlts(curRule, errMsgProvider)\r\n  )\r\n\r\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\r\n    validateRuleDoesNotAlreadyExist(\r\n      curRule,\r\n      topLevels,\r\n      grammarName,\r\n      errMsgProvider\r\n    )\r\n  )\r\n\r\n  return (duplicateErrors as IParserDefinitionError[]).concat(\r\n    emptyRepetitionErrors,\r\n    leftRecursionErrors,\r\n    emptyAltErrors,\r\n    ambiguousAltsErrors,\r\n    termsNamespaceConflictErrors,\r\n    tooManyAltsErrors,\r\n    duplicateRulesError\r\n  )\r\n}\r\n\r\nfunction validateDuplicateProductions(\r\n  topLevelRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserDuplicatesDefinitionError[] {\r\n  const collectorVisitor = new OccurrenceValidationCollector()\r\n  topLevelRule.accept(collectorVisitor)\r\n  const allRuleProductions = collectorVisitor.allProductions\r\n\r\n  const productionGroups = groupBy(\r\n    allRuleProductions,\r\n    identifyProductionForDuplicates\r\n  )\r\n\r\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\r\n    return currGroup.length > 1\r\n  })\r\n\r\n  const errors = map(values(duplicates), (currDuplicates: any) => {\r\n    const firstProd: any = first(currDuplicates)\r\n    const msg = errMsgProvider.buildDuplicateFoundError(\r\n      topLevelRule,\r\n      currDuplicates\r\n    )\r\n    const dslName = getProductionDslName(firstProd)\r\n    const defError: IParserDuplicatesDefinitionError = {\r\n      message: msg,\r\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\r\n      ruleName: topLevelRule.name,\r\n      dslName: dslName,\r\n      occurrence: firstProd.idx\r\n    }\r\n\r\n    const param = getExtraProductionArgument(firstProd)\r\n    if (param) {\r\n      defError.parameter = param\r\n    }\r\n\r\n    return defError\r\n  })\r\n  return errors\r\n}\r\n\r\nexport function identifyProductionForDuplicates(\r\n  prod: IProductionWithOccurrence\r\n): string {\r\n  return `${getProductionDslName(prod)}_#_${\r\n    prod.idx\r\n  }_#_${getExtraProductionArgument(prod)}`\r\n}\r\n\r\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\r\n  if (prod instanceof Terminal) {\r\n    return prod.terminalType.name\r\n  } else if (prod instanceof NonTerminal) {\r\n    return prod.nonTerminalName\r\n  } else {\r\n    return \"\"\r\n  }\r\n}\r\n\r\nexport class OccurrenceValidationCollector extends GAstVisitor {\r\n  public allProductions: IProductionWithOccurrence[] = []\r\n\r\n  public visitNonTerminal(subrule: NonTerminal): void {\r\n    this.allProductions.push(subrule)\r\n  }\r\n\r\n  public visitOption(option: Option): void {\r\n    this.allProductions.push(option)\r\n  }\r\n\r\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\r\n    this.allProductions.push(manySep)\r\n  }\r\n\r\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\r\n    this.allProductions.push(atLeastOne)\r\n  }\r\n\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    atLeastOneSep: RepetitionMandatoryWithSeparator\r\n  ): void {\r\n    this.allProductions.push(atLeastOneSep)\r\n  }\r\n\r\n  public visitRepetition(many: Repetition): void {\r\n    this.allProductions.push(many)\r\n  }\r\n\r\n  public visitAlternation(or: Alternation): void {\r\n    this.allProductions.push(or)\r\n  }\r\n\r\n  public visitTerminal(terminal: Terminal): void {\r\n    this.allProductions.push(terminal)\r\n  }\r\n}\r\n\r\nexport function validateRuleDoesNotAlreadyExist(\r\n  rule: Rule,\r\n  allRules: Rule[],\r\n  className: string,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserDefinitionError[] {\r\n  const errors = []\r\n  const occurrences = reduce(\r\n    allRules,\r\n    (result, curRule) => {\r\n      if (curRule.name === rule.name) {\r\n        return result + 1\r\n      }\r\n      return result\r\n    },\r\n    0\r\n  )\r\n  if (occurrences > 1) {\r\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\r\n      topLevelRule: rule,\r\n      grammarName: className\r\n    })\r\n    errors.push({\r\n      message: errMsg,\r\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\r\n      ruleName: rule.name\r\n    })\r\n  }\r\n\r\n  return errors\r\n}\r\n\r\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\r\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\r\n// The grammar structure, only at runtime.\r\nexport function validateRuleIsOverridden(\r\n  ruleName: string,\r\n  definedRulesNames: string[],\r\n  className: string\r\n): IParserDefinitionError[] {\r\n  const errors = []\r\n  let errMsg\r\n\r\n  if (!includes(definedRulesNames, ruleName)) {\r\n    errMsg =\r\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\r\n      `as it is not defined in any of the super grammars `\r\n    errors.push({\r\n      message: errMsg,\r\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\r\n      ruleName: ruleName\r\n    })\r\n  }\r\n\r\n  return errors\r\n}\r\n\r\nexport function validateNoLeftRecursion(\r\n  topRule: Rule,\r\n  currRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n  path: Rule[] = []\r\n): IParserDefinitionError[] {\r\n  const errors: IParserDefinitionError[] = []\r\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition)\r\n  if (isEmpty(nextNonTerminals)) {\r\n    return []\r\n  } else {\r\n    const ruleName = topRule.name\r\n    const foundLeftRecursion = includes(<any>nextNonTerminals, topRule)\r\n    if (foundLeftRecursion) {\r\n      errors.push({\r\n        message: errMsgProvider.buildLeftRecursionError({\r\n          topLevelRule: topRule,\r\n          leftRecursionPath: path\r\n        }),\r\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\r\n        ruleName: ruleName\r\n      })\r\n    }\r\n\r\n    // we are only looking for cyclic paths leading back to the specific topRule\r\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\r\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]))\r\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\r\n      const newPath = clone(path)\r\n      newPath.push(currRefRule)\r\n      return validateNoLeftRecursion(\r\n        topRule,\r\n        currRefRule,\r\n        errMsgProvider,\r\n        newPath\r\n      )\r\n    })\r\n\r\n    return errors.concat(errorsFromNextSteps)\r\n  }\r\n}\r\n\r\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\r\n  let result: Rule[] = []\r\n  if (isEmpty(definition)) {\r\n    return result\r\n  }\r\n  const firstProd = first(definition)\r\n\r\n  /* istanbul ignore else */\r\n  if (firstProd instanceof NonTerminal) {\r\n    result.push(firstProd.referencedRule)\r\n  } else if (\r\n    firstProd instanceof AlternativeGAST ||\r\n    firstProd instanceof Option ||\r\n    firstProd instanceof RepetitionMandatory ||\r\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\r\n    firstProd instanceof RepetitionWithSeparator ||\r\n    firstProd instanceof Repetition\r\n  ) {\r\n    result = result.concat(\r\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition)\r\n    )\r\n  } else if (firstProd instanceof Alternation) {\r\n    // each sub definition in alternation is a FLAT\r\n    result = flatten(\r\n      map(firstProd.definition, (currSubDef) =>\r\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition)\r\n      )\r\n    )\r\n  } else if (firstProd instanceof Terminal) {\r\n    // nothing to see, move along\r\n  } else {\r\n    throw Error(\"non exhaustive match\")\r\n  }\r\n\r\n  const isFirstOptional = isOptionalProd(firstProd)\r\n  const hasMore = definition.length > 1\r\n  if (isFirstOptional && hasMore) {\r\n    const rest = drop(definition)\r\n    return result.concat(getFirstNoneTerminal(rest))\r\n  } else {\r\n    return result\r\n  }\r\n}\r\n\r\nclass OrCollector extends GAstVisitor {\r\n  public alternations: Alternation[] = []\r\n\r\n  public visitAlternation(node: Alternation): void {\r\n    this.alternations.push(node)\r\n  }\r\n}\r\n\r\nexport function validateEmptyOrAlternative(\r\n  topLevelRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserEmptyAlternativeDefinitionError[] {\r\n  const orCollector = new OrCollector()\r\n  topLevelRule.accept(orCollector)\r\n  const ors = orCollector.alternations\r\n\r\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\r\n    ors,\r\n    (currOr) => {\r\n      const exceptLast = dropRight(currOr.definition)\r\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\r\n        const possibleFirstInAlt = nextPossibleTokensAfter(\r\n          [currAlternative],\r\n          [],\r\n          tokenStructuredMatcher,\r\n          1\r\n        )\r\n        if (isEmpty(possibleFirstInAlt)) {\r\n          return [\r\n            {\r\n              message: errMsgProvider.buildEmptyAlternationError({\r\n                topLevelRule: topLevelRule,\r\n                alternation: currOr,\r\n                emptyChoiceIdx: currAltIdx\r\n              }),\r\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\r\n              ruleName: topLevelRule.name,\r\n              occurrence: currOr.idx,\r\n              alternative: currAltIdx + 1\r\n            }\r\n          ]\r\n        } else {\r\n          return []\r\n        }\r\n      })\r\n    }\r\n  )\r\n\r\n  return errors\r\n}\r\n\r\nexport function validateAmbiguousAlternationAlternatives(\r\n  topLevelRule: Rule,\r\n  globalMaxLookahead: number,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserAmbiguousAlternativesDefinitionError[] {\r\n  const orCollector = new OrCollector()\r\n  topLevelRule.accept(orCollector)\r\n  let ors = orCollector.alternations\r\n\r\n  // New Handling of ignoring ambiguities\r\n  // - https://github.com/chevrotain/chevrotain/issues/869\r\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true)\r\n\r\n  const errors = flatMap(ors, (currOr: Alternation) => {\r\n    const currOccurrence = currOr.idx\r\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead\r\n    const alternatives = getLookaheadPathsForOr(\r\n      currOccurrence,\r\n      topLevelRule,\r\n      actualMaxLookahead,\r\n      currOr\r\n    )\r\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\r\n      alternatives,\r\n      currOr,\r\n      topLevelRule,\r\n      errMsgProvider\r\n    )\r\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\r\n      alternatives,\r\n      currOr,\r\n      topLevelRule,\r\n      errMsgProvider\r\n    )\r\n\r\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors)\r\n  })\r\n\r\n  return errors\r\n}\r\n\r\nexport class RepetitionCollector extends GAstVisitor {\r\n  public allProductions: (IProductionWithOccurrence & {\r\n    maxLookahead?: number\r\n  })[] = []\r\n\r\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\r\n    this.allProductions.push(manySep)\r\n  }\r\n\r\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\r\n    this.allProductions.push(atLeastOne)\r\n  }\r\n\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    atLeastOneSep: RepetitionMandatoryWithSeparator\r\n  ): void {\r\n    this.allProductions.push(atLeastOneSep)\r\n  }\r\n\r\n  public visitRepetition(many: Repetition): void {\r\n    this.allProductions.push(many)\r\n  }\r\n}\r\n\r\nexport function validateTooManyAlts(\r\n  topLevelRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserDefinitionError[] {\r\n  const orCollector = new OrCollector()\r\n  topLevelRule.accept(orCollector)\r\n  const ors = orCollector.alternations\r\n\r\n  const errors = flatMap(ors, (currOr) => {\r\n    if (currOr.definition.length > 255) {\r\n      return [\r\n        {\r\n          message: errMsgProvider.buildTooManyAlternativesError({\r\n            topLevelRule: topLevelRule,\r\n            alternation: currOr\r\n          }),\r\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\r\n          ruleName: topLevelRule.name,\r\n          occurrence: currOr.idx\r\n        }\r\n      ]\r\n    } else {\r\n      return []\r\n    }\r\n  })\r\n\r\n  return errors\r\n}\r\n\r\nexport function validateSomeNonEmptyLookaheadPath(\r\n  topLevelRules: Rule[],\r\n  maxLookahead: number,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserDefinitionError[] {\r\n  const errors: IParserDefinitionError[] = []\r\n  forEach(topLevelRules, (currTopRule) => {\r\n    const collectorVisitor = new RepetitionCollector()\r\n    currTopRule.accept(collectorVisitor)\r\n    const allRuleProductions = collectorVisitor.allProductions\r\n    forEach(allRuleProductions, (currProd) => {\r\n      const prodType = getProdType(currProd)\r\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead\r\n      const currOccurrence = currProd.idx\r\n      const paths = getLookaheadPathsForOptionalProd(\r\n        currOccurrence,\r\n        currTopRule,\r\n        prodType,\r\n        actualMaxLookahead\r\n      )\r\n      const pathsInsideProduction = paths[0]\r\n      if (isEmpty(flatten(pathsInsideProduction))) {\r\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\r\n          topLevelRule: currTopRule,\r\n          repetition: currProd\r\n        })\r\n        errors.push({\r\n          message: errMsg,\r\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\r\n          ruleName: currTopRule.name\r\n        })\r\n      }\r\n    })\r\n  })\r\n\r\n  return errors\r\n}\r\n\r\nexport interface IAmbiguityDescriptor {\r\n  alts: number[]\r\n  path: TokenType[]\r\n}\r\n\r\nfunction checkAlternativesAmbiguities(\r\n  alternatives: Alternative[],\r\n  alternation: Alternation,\r\n  rule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserAmbiguousAlternativesDefinitionError[] {\r\n  const foundAmbiguousPaths: Alternative = []\r\n  const identicalAmbiguities = reduce(\r\n    alternatives,\r\n    (result, currAlt, currAltIdx) => {\r\n      // ignore (skip) ambiguities with this alternative\r\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\r\n        return result\r\n      }\r\n\r\n      forEach(currAlt, (currPath) => {\r\n        const altsCurrPathAppearsIn = [currAltIdx]\r\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\r\n          if (\r\n            currAltIdx !== currOtherAltIdx &&\r\n            containsPath(currOtherAlt, currPath) &&\r\n            // ignore (skip) ambiguities with this \"other\" alternative\r\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\r\n          ) {\r\n            altsCurrPathAppearsIn.push(currOtherAltIdx)\r\n          }\r\n        })\r\n\r\n        if (\r\n          altsCurrPathAppearsIn.length > 1 &&\r\n          !containsPath(foundAmbiguousPaths, currPath)\r\n        ) {\r\n          foundAmbiguousPaths.push(currPath)\r\n          result.push({\r\n            alts: altsCurrPathAppearsIn,\r\n            path: currPath\r\n          })\r\n        }\r\n      })\r\n      return result\r\n    },\r\n    [] as { alts: number[]; path: TokenType[] }[]\r\n  )\r\n\r\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\r\n    const ambgIndices = map(\r\n      currAmbDescriptor.alts,\r\n      (currAltIdx) => currAltIdx + 1\r\n    )\r\n\r\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\r\n      topLevelRule: rule,\r\n      alternation: alternation,\r\n      ambiguityIndices: ambgIndices,\r\n      prefixPath: currAmbDescriptor.path\r\n    })\r\n\r\n    return {\r\n      message: currMessage,\r\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\r\n      ruleName: rule.name,\r\n      occurrence: alternation.idx,\r\n      alternatives: currAmbDescriptor.alts\r\n    }\r\n  })\r\n\r\n  return currErrors\r\n}\r\n\r\nexport function checkPrefixAlternativesAmbiguities(\r\n  alternatives: Alternative[],\r\n  alternation: Alternation,\r\n  rule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserAmbiguousAlternativesDefinitionError[] {\r\n  // flatten\r\n  const pathsAndIndices = reduce(\r\n    alternatives,\r\n    (result, currAlt, idx) => {\r\n      const currPathsAndIdx = map(currAlt, (currPath) => {\r\n        return { idx: idx, path: currPath }\r\n      })\r\n      return result.concat(currPathsAndIdx)\r\n    },\r\n    [] as { idx: number; path: TokenType[] }[]\r\n  )\r\n\r\n  const errors = compact(\r\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\r\n      const alternativeGast = alternation.definition[currPathAndIdx.idx]\r\n      // ignore (skip) ambiguities with this alternative\r\n      if (alternativeGast.ignoreAmbiguities === true) {\r\n        return []\r\n      }\r\n      const targetIdx = currPathAndIdx.idx\r\n      const targetPath = currPathAndIdx.path\r\n\r\n      const prefixAmbiguitiesPathsAndIndices = filter(\r\n        pathsAndIndices,\r\n        (searchPathAndIdx) => {\r\n          // prefix ambiguity can only be created from lower idx (higher priority) path\r\n          return (\r\n            // ignore (skip) ambiguities with this \"other\" alternative\r\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\r\n              true &&\r\n            searchPathAndIdx.idx < targetIdx &&\r\n            // checking for strict prefix because identical lookaheads\r\n            // will be be detected using a different validation.\r\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\r\n          )\r\n        }\r\n      )\r\n\r\n      const currPathPrefixErrors = map(\r\n        prefixAmbiguitiesPathsAndIndices,\r\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\r\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1]\r\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx\r\n\r\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\r\n            topLevelRule: rule,\r\n            alternation: alternation,\r\n            ambiguityIndices: ambgIndices,\r\n            prefixPath: currAmbPathAndIdx.path\r\n          })\r\n          return {\r\n            message: message,\r\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\r\n            ruleName: rule.name,\r\n            occurrence: occurrence,\r\n            alternatives: ambgIndices\r\n          }\r\n        }\r\n      )\r\n\r\n      return currPathPrefixErrors\r\n    })\r\n  )\r\n\r\n  return errors\r\n}\r\n\r\nfunction checkTerminalAndNoneTerminalsNameSpace(\r\n  topLevels: Rule[],\r\n  tokenTypes: TokenType[],\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider\r\n): IParserDefinitionError[] {\r\n  const errors: IParserDefinitionError[] = []\r\n\r\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name)\r\n\r\n  forEach(topLevels, (currRule) => {\r\n    const currRuleName = currRule.name\r\n    if (includes(tokenNames, currRuleName)) {\r\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule)\r\n\r\n      errors.push({\r\n        message: errMsg,\r\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\r\n        ruleName: currRuleName\r\n      })\r\n    }\r\n  })\r\n\r\n  return errors\r\n}\r\n"]},"metadata":{},"sourceType":"script"}