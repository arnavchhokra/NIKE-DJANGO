{"ast":null,"code":"import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */new Matrix4();\nconst obb = /* @__PURE__ */new OrientedBox();\nconst obb2 = /* @__PURE__ */new OrientedBox();\nconst temp1 = /* @__PURE__ */new Vector3();\nconst temp2 = /* @__PURE__ */new Vector3();\nconst temp3 = /* @__PURE__ */new Vector3();\nconst temp4 = /* @__PURE__ */new Vector3();\nfunction closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh) {\n  let target1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let target2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  let minThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  let maxThreshold = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Infinity;\n  if (!otherGeometry.boundingBox) {\n    otherGeometry.computeBoundingBox();\n  }\n  obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n  obb.needsUpdate = true;\n  const geometry = bvh.geometry;\n  const pos = geometry.attributes.position;\n  const index = geometry.index;\n  const otherPos = otherGeometry.attributes.position;\n  const otherIndex = otherGeometry.index;\n  const triangle = ExtendedTrianglePool.getPrimitive();\n  const triangle2 = ExtendedTrianglePool.getPrimitive();\n  let tempTarget1 = temp1;\n  let tempTargetDest1 = temp2;\n  let tempTarget2 = null;\n  let tempTargetDest2 = null;\n  if (target2) {\n    tempTarget2 = temp3;\n    tempTargetDest2 = temp4;\n  }\n  let closestDistance = Infinity;\n  let closestDistanceTriIndex = null;\n  let closestDistanceOtherTriIndex = null;\n  tempMatrix.copy(geometryToBvh).invert();\n  obb2.matrix.copy(tempMatrix);\n  bvh.shapecast({\n    boundsTraverseOrder: box => {\n      return obb.distanceToBox(box);\n    },\n    intersectsBounds: (box, isLeaf, score) => {\n      if (score < closestDistance && score < maxThreshold) {\n        // if we know the triangles of this bounds will be intersected next then\n        // save the bounds to use during triangle checks.\n        if (isLeaf) {\n          obb2.min.copy(box.min);\n          obb2.max.copy(box.max);\n          obb2.needsUpdate = true;\n        }\n        return true;\n      }\n      return false;\n    },\n    intersectsRange: (offset, count) => {\n      if (otherGeometry.boundsTree) {\n        // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n        // the closest bounds in the other geometry to check.\n        const otherBvh = otherGeometry.boundsTree;\n        return otherBvh.shapecast({\n          boundsTraverseOrder: box => {\n            return obb2.distanceToBox(box);\n          },\n          intersectsBounds: (box, isLeaf, score) => {\n            return score < closestDistance && score < maxThreshold;\n          },\n          intersectsRange: (otherOffset, otherCount) => {\n            for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {\n              const ti2 = otherBvh.resolveTriangleIndex(i2);\n              setTriangle(triangle2, 3 * ti2, otherIndex, otherPos);\n              triangle2.a.applyMatrix4(geometryToBvh);\n              triangle2.b.applyMatrix4(geometryToBvh);\n              triangle2.c.applyMatrix4(geometryToBvh);\n              triangle2.needsUpdate = true;\n              for (let i = offset, l = offset + count; i < l; i++) {\n                const ti = bvh.resolveTriangleIndex(i);\n                setTriangle(triangle, 3 * ti, index, pos);\n                triangle.needsUpdate = true;\n                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                if (dist < closestDistance) {\n                  tempTargetDest1.copy(tempTarget1);\n                  if (tempTargetDest2) {\n                    tempTargetDest2.copy(tempTarget2);\n                  }\n                  closestDistance = dist;\n                  closestDistanceTriIndex = i;\n                  closestDistanceOtherTriIndex = i2;\n                }\n\n                // stop traversal if we find a point that's under the given threshold\n                if (dist < minThreshold) {\n                  return true;\n                }\n              }\n            }\n          }\n        });\n      } else {\n        // If no bounds tree then we'll just check every triangle.\n        const triCount = getTriCount(otherGeometry);\n        for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {\n          setTriangle(triangle2, 3 * i2, otherIndex, otherPos);\n          triangle2.a.applyMatrix4(geometryToBvh);\n          triangle2.b.applyMatrix4(geometryToBvh);\n          triangle2.c.applyMatrix4(geometryToBvh);\n          triangle2.needsUpdate = true;\n          for (let i = offset, l = offset + count; i < l; i++) {\n            const ti = bvh.resolveTriangleIndex(i);\n            setTriangle(triangle, 3 * ti, index, pos);\n            triangle.needsUpdate = true;\n            const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n            if (dist < closestDistance) {\n              tempTargetDest1.copy(tempTarget1);\n              if (tempTargetDest2) {\n                tempTargetDest2.copy(tempTarget2);\n              }\n              closestDistance = dist;\n              closestDistanceTriIndex = i;\n              closestDistanceOtherTriIndex = i2;\n            }\n\n            // stop traversal if we find a point that's under the given threshold\n            if (dist < minThreshold) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  });\n  ExtendedTrianglePool.releasePrimitive(triangle);\n  ExtendedTrianglePool.releasePrimitive(triangle2);\n  if (closestDistance === Infinity) {\n    return null;\n  }\n  if (!target1.point) {\n    target1.point = tempTargetDest1.clone();\n  } else {\n    target1.point.copy(tempTargetDest1);\n  }\n  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n  if (target2) {\n    if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n    target2.point.applyMatrix4(tempMatrix);\n    tempTargetDest1.applyMatrix4(tempMatrix);\n    target2.distance = tempTargetDest1.sub(target2.point).length();\n    target2.faceIndex = closestDistanceOtherTriIndex;\n  }\n  return target1;\n}\nexport { closestPointToGeometry_indirect };","map":{"version":3,"names":["Matrix4","Vector3","OrientedBox","setTriangle","getTriCount","ExtendedTrianglePool","tempMatrix","obb","obb2","temp1","temp2","temp3","temp4","closestPointToGeometry_indirect","bvh","otherGeometry","geometryToBvh","target1","arguments","length","undefined","target2","minThreshold","maxThreshold","Infinity","boundingBox","computeBoundingBox","set","min","max","needsUpdate","geometry","pos","attributes","position","index","otherPos","otherIndex","triangle","getPrimitive","triangle2","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","copy","invert","matrix","shapecast","boundsTraverseOrder","box","distanceToBox","intersectsBounds","isLeaf","score","intersectsRange","offset","count","boundsTree","otherBvh","otherOffset","otherCount","i2","l2","ti2","resolveTriangleIndex","a","applyMatrix4","b","c","i","l","ti","dist","distanceToTriangle","triCount","releasePrimitive","point","clone","distance","faceIndex","sub"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js"],"sourcesContent":["import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}