{"ast":null,"code":"export const common_functions = /* glsl */\"\\n\\n// A stack of uint32 indices can can store the indices for\\n// a perfectly balanced tree with a depth up to 31. Lower stack\\n// depth gets higher performance.\\n//\\n// However not all trees are balanced. Best value to set this to\\n// is the trees max depth.\\n#ifndef BVH_STACK_DEPTH\\n#define BVH_STACK_DEPTH 60\\n#endif\\n\\n#ifndef INFINITY\\n#define INFINITY 1e20\\n#endif\\n\\n// Utilities\\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\\n\\n\\tuint width = uint( textureSize( tex, 0 ).x );\\n\\tuvec2 uv;\\n\\tuv.x = index % width;\\n\\tuv.y = index / width;\\n\\n\\treturn texelFetch( tex, ivec2( uv ), 0 );\\n\\n}\\n\\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\\n\\n\\tuint width = uint( textureSize( tex, 0 ).x );\\n\\tuvec2 uv;\\n\\tuv.x = index % width;\\n\\tuv.y = index / width;\\n\\n\\treturn texelFetch( tex, ivec2( uv ), 0 );\\n\\n}\\n\\nvec4 texelFetch1D( sampler2D tex, uint index ) {\\n\\n\\tuint width = uint( textureSize( tex, 0 ).x );\\n\\tuvec2 uv;\\n\\tuv.x = index % width;\\n\\tuv.y = index / width;\\n\\n\\treturn texelFetch( tex, ivec2( uv ), 0 );\\n\\n}\\n\\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\\n\\n\\treturn\\n\\t\\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\\n\\t\\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\\n\\t\\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\\n\\n}\\n\\nvoid ndcToCameraRay(\\n\\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\\n\\tout vec3 rayOrigin, out vec3 rayDirection\\n) {\\n\\n\\t// get camera look direction and near plane for camera clipping\\n\\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\\n\\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\\n\\tfloat near = abs( nearVector.z / nearVector.w );\\n\\n\\t// get the camera direction and position from camera matrices\\n\\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\\n\\tdirection /= direction.w;\\n\\tdirection = cameraWorld * direction - origin;\\n\\n\\t// slide the origin along the ray until it sits at the near clip plane position\\n\\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\\n\\n\\trayOrigin = origin.xyz;\\n\\trayDirection = direction.xyz;\\n\\n}\\n\";","map":{"version":3,"names":["common_functions"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js"],"sourcesContent":["export const common_functions = /* glsl */`\r\n\r\n// A stack of uint32 indices can can store the indices for\r\n// a perfectly balanced tree with a depth up to 31. Lower stack\r\n// depth gets higher performance.\r\n//\r\n// However not all trees are balanced. Best value to set this to\r\n// is the trees max depth.\r\n#ifndef BVH_STACK_DEPTH\r\n#define BVH_STACK_DEPTH 60\r\n#endif\r\n\r\n#ifndef INFINITY\r\n#define INFINITY 1e20\r\n#endif\r\n\r\n// Utilities\r\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 texelFetch1D( sampler2D tex, uint index ) {\r\n\r\n\tuint width = uint( textureSize( tex, 0 ).x );\r\n\tuvec2 uv;\r\n\tuv.x = index % width;\r\n\tuv.y = index / width;\r\n\r\n\treturn texelFetch( tex, ivec2( uv ), 0 );\r\n\r\n}\r\n\r\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\treturn\r\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\r\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\r\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\r\n\r\n}\r\n\r\nvoid ndcToCameraRay(\r\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\r\n\tout vec3 rayOrigin, out vec3 rayDirection\r\n) {\r\n\r\n\t// get camera look direction and near plane for camera clipping\r\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\r\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\r\n\tfloat near = abs( nearVector.z / nearVector.w );\r\n\r\n\t// get the camera direction and position from camera matrices\r\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\r\n\tdirection /= direction.w;\r\n\tdirection = cameraWorld * direction - origin;\r\n\r\n\t// slide the origin along the ray until it sits at the near clip plane position\r\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\r\n\r\n\trayOrigin = origin.xyz;\r\n\trayDirection = direction.xyz;\r\n\r\n}\r\n`;\r\n"],"mappings":"AAAA,OAAO,MAAMA,gBAAgB,GAAG,4qEAkF/B"},"metadata":{},"sourceType":"module","externalDependencies":[]}