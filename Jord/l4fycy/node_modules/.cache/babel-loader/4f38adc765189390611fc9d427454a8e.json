{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\n\nvar GLTFExporter = /*#__PURE__*/function () {\n  function GLTFExporter() {\n    _classCallCheck(this, GLTFExporter);\n\n    _defineProperty(this, \"pluginCallbacks\", void 0);\n\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n  }\n\n  _createClass(GLTFExporter, [{\n    key: \"register\",\n    value: function register(callback) {\n      if (this.pluginCallbacks.indexOf(callback) === -1) {\n        this.pluginCallbacks.push(callback);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unregister\",\n    value: function unregister(callback) {\n      if (this.pluginCallbacks.indexOf(callback) !== -1) {\n        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(input, onDone, options) {\n      var writer = new GLTFWriter();\n      var plugins = [];\n\n      for (var i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n        plugins.push(this.pluginCallbacks[i](writer));\n      }\n\n      writer.setPlugins(plugins);\n      writer.write(input, onDone, options);\n    }\n    /**\r\n     * Static utility functions\r\n     */\n\n  }]);\n\n  return GLTFExporter;\n}(); //------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n\n_defineProperty(GLTFExporter, \"Utils\", {\n  insertKeyframe: function insertKeyframe(track, time) {\n    var tolerance = 0.001; // 1ms\n\n    var valueSize = track.getValueSize(); // @ts-expect-error\n\n    var times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\n\n    var values = new track.ValueBufferType(track.values.length + valueSize);\n    /**\r\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\r\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\r\n     */\n    // @ts-expect-error\n\n    var interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    var index;\n\n    if (track.times.length === 0) {\n      times[0] = time;\n\n      for (var i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (var _i = 0; _i < track.times.length; _i++) {\n        if (Math.abs(track.times[_i] - time) < tolerance) return _i;\n\n        if (track.times[_i] < time && track.times[_i + 1] > time) {\n          times.set(track.times.slice(0, _i + 1), 0);\n          times[_i + 1] = time;\n          times.set(track.times.slice(_i + 1), _i + 2);\n          values.set(track.values.slice(0, (_i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (_i + 1) * valueSize);\n          values.set(track.values.slice((_i + 1) * valueSize), (_i + 2) * valueSize);\n          index = _i + 1;\n          break;\n        }\n      }\n    }\n\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function mergeMorphTargetTracks(clip, root) {\n    var tracks = [];\n    var mergedTracks = {};\n    var sourceTracks = clip.tracks;\n\n    for (var i = 0; i < sourceTracks.length; ++i) {\n      var sourceTrack = sourceTracks[i];\n      var sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      var sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n\n      if ( // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        // @ts-expect-error\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n\n      var targetCount = sourceTrackNode.morphTargetInfluences.length;\n      var targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n\n      var mergedTrack = void 0; // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\n\n        var values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n\n        for (var j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        } // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n\n\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      } // @ts-expect-error\n\n\n      var sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n\n      for (var _j = 0; _j < mergedTrack.times.length; _j++) {\n        mergedTrack.values[_j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[_j]);\n      } // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n\n\n      for (var _j2 = 0; _j2 < sourceTrack.times.length; _j2++) {\n        var keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[_j2]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[_j2];\n      }\n    }\n\n    clip.tracks = tracks;\n    return clip;\n  }\n});\n\nvar WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  UNSIGNED_BYTE: 0x1401,\n  UNSIGNED_SHORT: 0x1403,\n  FLOAT: 0x1406,\n  UNSIGNED_INT: 0x1405,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nvar THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nvar PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n}; // GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nvar GLB_HEADER_BYTES = 12;\nvar GLB_HEADER_MAGIC = 0x46546c67;\nvar GLB_VERSION = 2;\nvar GLB_CHUNK_PREFIX_BYTES = 8;\nvar GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nvar GLB_CHUNK_TYPE_BIN = 0x004e4942;\n/**\r\n * Writer\r\n */\n\nvar GLTFWriter = /*#__PURE__*/function () {\n  function GLTFWriter() {\n    _classCallCheck(this, GLTFWriter);\n\n    _defineProperty(this, \"plugins\", void 0);\n\n    _defineProperty(this, \"options\", void 0);\n\n    _defineProperty(this, \"pending\", void 0);\n\n    _defineProperty(this, \"buffers\", void 0);\n\n    _defineProperty(this, \"byteOffset\", void 0);\n\n    _defineProperty(this, \"nodeMap\", void 0);\n\n    _defineProperty(this, \"skins\", void 0);\n\n    _defineProperty(this, \"extensionsUsed\", void 0);\n\n    _defineProperty(this, \"uids\", void 0);\n\n    _defineProperty(this, \"uid\", void 0);\n\n    _defineProperty(this, \"json\", void 0);\n\n    _defineProperty(this, \"cache\", void 0);\n\n    _defineProperty(this, \"cachedCanvas\", void 0);\n\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter'\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.cachedCanvas = null;\n  }\n\n  _createClass(GLTFWriter, [{\n    key: \"setPlugins\",\n    value: function setPlugins(plugins) {\n      this.plugins = plugins;\n    }\n    /**\r\n     * Parse scenes and generate GLTF output\r\n     * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n     * @param  {Function} onDone  Callback on completed\r\n     * @param  {Object} options options\r\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(input, onDone, options) {\n      var _this = this;\n\n      this.options = Object.assign({}, {\n        // default options\n        binary: false,\n        trs: false,\n        onlyVisible: true,\n        truncateDrawRange: true,\n        embedImages: true,\n        maxTextureSize: Infinity,\n        animations: [],\n        includeCustomExtensions: false\n      }, options);\n\n      if (this.options.animations !== undefined && this.options.animations.length > 0) {\n        // Only TRS properties, and not matrices, may be targeted by animation.\n        this.options.trs = true;\n      }\n\n      this.processInput(input);\n      var writer = this;\n      Promise.all(this.pending).then(function () {\n        var buffers = writer.buffers;\n        var json = writer.json;\n        var options = writer.options;\n        var extensionsUsed = writer.extensionsUsed; // Merge buffers.\n\n        var blob = new Blob(buffers, {\n          type: 'application/octet-stream'\n        }); // Declare extensions.\n\n        var extensionsUsedList = Object.keys(extensionsUsed);\n        if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\n\n        if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n\n        if (options.binary) {\n          // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n          var reader = new window.FileReader();\n          reader.readAsArrayBuffer(blob);\n\n          reader.onloadend = function () {\n            if (reader.result !== null && typeof reader.result !== 'string') {\n              // Binary chunk.\n              var binaryChunk = _this.getPaddedArrayBuffer(reader.result);\n\n              var binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n              binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n              binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\n\n              var jsonChunk = _this.getPaddedArrayBuffer(_this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\n\n              var jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n              jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n              jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\n\n              var header = new ArrayBuffer(GLB_HEADER_BYTES);\n              var headerView = new DataView(header);\n              headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n              headerView.setUint32(4, GLB_VERSION, true);\n              var totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n              headerView.setUint32(8, totalByteLength, true);\n              var glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n                type: 'application/octet-stream'\n              });\n              var glbReader = new window.FileReader();\n              glbReader.readAsArrayBuffer(glbBlob);\n\n              glbReader.onloadend = function () {\n                if (glbReader.result !== null && typeof glbReader.result !== 'string') {\n                  onDone(glbReader.result);\n                }\n              };\n            }\n          };\n        } else {\n          if (json.buffers && json.buffers.length > 0) {\n            var _reader = new window.FileReader();\n\n            _reader.readAsDataURL(blob);\n\n            _reader.onloadend = function () {\n              var base64data = _reader.result;\n\n              if (json.buffers !== undefined && base64data !== null) {\n                json.buffers[0].uri = base64data;\n                onDone(json);\n              }\n            };\n          } else {\n            onDone(json);\n          }\n        }\n      });\n    }\n    /**\r\n     * Serializes a userData.\r\n     *\r\n     * @param {THREE.Object3D|THREE.Material} object\r\n     * @param {Object} objectDef\r\n     */\n\n  }, {\n    key: \"serializeUserData\",\n    value: function serializeUserData(object, objectDef) {\n      if (Object.keys(object.userData).length === 0) return;\n      var options = this.options;\n      var extensionsUsed = this.extensionsUsed;\n\n      try {\n        var json = JSON.parse(JSON.stringify(object.userData));\n\n        if (options.includeCustomExtensions && json.gltfExtensions) {\n          if (objectDef.extensions === undefined) objectDef.extensions = {};\n\n          for (var extensionName in json.gltfExtensions) {\n            objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n            extensionsUsed[extensionName] = true;\n          }\n\n          delete json.gltfExtensions;\n        }\n\n        if (Object.keys(json).length > 0) objectDef.extras = json;\n      } catch (error) {\n        if (error instanceof Error) {\n          console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\n        }\n      }\n    }\n    /**\r\n     * Assign and return a temporal unique id for an object\r\n     * especially which doesn't have .uuid\r\n     * @param  {Object} object\r\n     * @return {Integer}\r\n     */\n\n  }, {\n    key: \"getUID\",\n    value: function getUID(object) {\n      if (!this.uids.has(object)) this.uids.set(object, this.uid++);\n      return this.uids.get(object);\n    }\n    /**\r\n     * Checks if normal attribute values are normalized.\r\n     *\r\n     * @param {BufferAttribute} normal\r\n     * @returns {Boolean}\r\n     */\n\n  }, {\n    key: \"isNormalizedNormalAttribute\",\n    value: function isNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return false;\n      var v = new Vector3();\n\n      for (var i = 0, il = normal.count; i < il; i++) {\n        // 0.0005 is from glTF-validator\n        if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n      }\n\n      return true;\n    }\n    /**\r\n     * Creates normalized normal buffer attribute.\r\n     *\r\n     * @param {BufferAttribute} normal\r\n     * @returns {BufferAttribute}\r\n     *\r\n     */\n\n  }, {\n    key: \"createNormalizedNormalAttribute\",\n    value: function createNormalizedNormalAttribute(normal) {\n      var cache = this.cache;\n      if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n      var attribute = normal.clone();\n      var v = new Vector3();\n\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        v.fromBufferAttribute(attribute, i);\n\n        if (v.x === 0 && v.y === 0 && v.z === 0) {\n          // if values can't be normalized set (1, 0, 0)\n          v.setX(1.0);\n        } else {\n          v.normalize();\n        }\n\n        attribute.setXYZ(i, v.x, v.y, v.z);\n      }\n\n      cache.attributesNormalized.set(normal, attribute);\n      return attribute;\n    }\n    /**\r\n     * Applies a texture transform, if present, to the map definition. Requires\r\n     * the KHR_texture_transform extension.\r\n     *\r\n     * @param {Object} mapDef\r\n     * @param {THREE.Texture} texture\r\n     */\n\n  }, {\n    key: \"applyTextureTransform\",\n    value: function applyTextureTransform(mapDef, texture) {\n      var didTransform = false;\n      var transformDef = {};\n\n      if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n        transformDef.offset = texture.offset.toArray();\n        didTransform = true;\n      }\n\n      if (texture.rotation !== 0) {\n        transformDef.rotation = texture.rotation;\n        didTransform = true;\n      }\n\n      if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n        transformDef.scale = texture.repeat.toArray();\n        didTransform = true;\n      }\n\n      if (didTransform) {\n        mapDef.extensions = mapDef.extensions || {};\n        mapDef.extensions['KHR_texture_transform'] = transformDef;\n        this.extensionsUsed['KHR_texture_transform'] = true;\n      }\n    }\n    /**\r\n     * Process a buffer to append to the default one.\r\n     * @param  {ArrayBuffer} buffer\r\n     * @return {Integer}\r\n     */\n\n  }, {\n    key: \"processBuffer\",\n    value: function processBuffer(buffer) {\n      var json = this.json;\n      var buffers = this.buffers;\n      if (!json.buffers) json.buffers = [{\n        byteLength: 0\n      }]; // All buffers are merged before export.\n\n      buffers.push(buffer);\n      return 0;\n    }\n    /**\r\n     * Process and generate a BufferView\r\n     * @param  {BufferAttribute} attribute\r\n     * @param  {number} componentType\r\n     * @param  {number} start\r\n     * @param  {number} count\r\n     * @param  {number} target (Optional) Target usage of the BufferView\r\n     * @return {Object}\r\n     */\n\n  }, {\n    key: \"processBufferView\",\n    value: function processBufferView(attribute, componentType, start, count, target) {\n      var json = this.json;\n      if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\n\n      var componentSize;\n\n      if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n        componentSize = 1;\n      } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n        componentSize = 2;\n      } else {\n        componentSize = 4;\n      }\n\n      var byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\n      var dataView = new DataView(new ArrayBuffer(byteLength));\n      var offset = 0;\n\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n\n          if (value !== undefined) {\n            if (componentType === WEBGL_CONSTANTS.FLOAT) {\n              dataView.setFloat32(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n              dataView.setUint32(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n              dataView.setUint16(offset, value, true);\n            } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n              dataView.setUint8(offset, value);\n            }\n          }\n\n          offset += componentSize;\n        }\n      }\n\n      var bufferViewDef = {\n        buffer: this.processBuffer(dataView.buffer),\n        byteOffset: this.byteOffset,\n        byteLength: byteLength\n      };\n      if (target !== undefined) bufferViewDef.target = target;\n\n      if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n        // Only define byteStride for vertex attributes.\n        bufferViewDef.byteStride = attribute.itemSize * componentSize;\n      }\n\n      this.byteOffset += byteLength;\n      json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\n\n      var output = {\n        id: json.bufferViews.length - 1,\n        byteLength: 0\n      };\n      return output;\n    }\n    /**\r\n     * Process and generate a BufferView from an image Blob.\r\n     * @param {Blob} blob\r\n     * @return {Promise<Integer>}\r\n     */\n\n  }, {\n    key: \"processBufferViewImage\",\n    value: function processBufferViewImage(blob) {\n      var _this2 = this;\n\n      var writer = this;\n      var json = writer.json;\n      if (!json.bufferViews) json.bufferViews = [];\n      return new Promise(function (resolve) {\n        var reader = new window.FileReader();\n        reader.readAsArrayBuffer(blob);\n\n        reader.onloadend = function () {\n          if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\n            var buffer = _this2.getPaddedArrayBuffer(reader.result);\n\n            var bufferViewDef = {\n              buffer: writer.processBuffer(buffer),\n              byteOffset: writer.byteOffset,\n              byteLength: buffer.byteLength\n            };\n            writer.byteOffset += buffer.byteLength;\n            resolve(json.bufferViews.push(bufferViewDef) - 1);\n          }\n        };\n      });\n    }\n    /**\r\n     * Process attribute to generate an accessor\r\n     * @param  {BufferAttribute} attribute Attribute to process\r\n     * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n     * @param  {Integer} start (Optional)\r\n     * @param  {Integer} count (Optional)\r\n     * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n     */\n\n  }, {\n    key: \"processAccessor\",\n    value: function processAccessor(attribute, geometry, start, count) {\n      var options = this.options;\n      var json = this.json;\n      var types = {\n        1: 'SCALAR',\n        2: 'VEC2',\n        3: 'VEC3',\n        4: 'VEC4',\n        16: 'MAT4'\n      };\n      var componentType; // Detect the component type of the attribute array (float, uint or ushort)\n\n      if (attribute.array.constructor === Float32Array) {\n        componentType = WEBGL_CONSTANTS.FLOAT;\n      } else if (attribute.array.constructor === Uint32Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n      } else if (attribute.array.constructor === Uint16Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n      } else if (attribute.array.constructor === Uint8Array) {\n        componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n      } else {\n        throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\n      }\n\n      if (start === undefined) start = 0;\n      if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\n\n      if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\n        var end = start + count;\n        var end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\n        start = Math.max(start, geometry.drawRange.start);\n        count = Math.min(end, end2) - start;\n        if (count < 0) count = 0;\n      } // Skip creating an accessor if the attribute doesn't have data to export\n\n\n      if (count === 0) return null;\n      var minMax = this.getMinMax(attribute, start, count);\n      var bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\n      // animation samplers, target must not be set.\n\n      if (geometry !== undefined) {\n        bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n      }\n\n      if (bufferViewTarget !== undefined) {\n        var bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n        var accessorDef = {\n          bufferView: bufferView.id,\n          byteOffset: bufferView.byteOffset,\n          componentType: componentType,\n          count: count,\n          max: minMax.max,\n          min: minMax.min,\n          type: types[attribute.itemSize]\n        };\n        if (attribute.normalized) accessorDef.normalized = true;\n        if (!json.accessors) json.accessors = [];\n        return json.accessors.push(accessorDef) - 1;\n      }\n    }\n    /**\r\n     * Process image\r\n     * @param  {Image} image to process\r\n     * @param  {Integer} format of the image (RGBAFormat)\r\n     * @param  {Boolean} flipY before writing out the image\r\n     * @return {Integer}     Index of the processed texture in the \"images\" array\r\n     */\n\n  }, {\n    key: \"processImage\",\n    value: function processImage(image, format, flipY) {\n      var writer = this;\n      var cache = writer.cache;\n      var json = writer.json;\n      var options = writer.options;\n      var pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      var cachedImages = cache.images.get(image);\n      var mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\n      var key = mimeType + ':flipY/' + flipY.toString();\n      if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      var imageDef = {\n        mimeType: mimeType\n      };\n\n      if (options.embedImages && options.maxTextureSize !== undefined) {\n        var canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\n        canvas.width = Math.min(image.width, options.maxTextureSize);\n        canvas.height = Math.min(image.height, options.maxTextureSize);\n        var ctx = canvas.getContext('2d');\n\n        if (flipY) {\n          ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\n          ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\n        }\n\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n          ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          if (format !== RGBAFormat) {\n            console.error('GLTFExporter: Only RGBA format is supported.');\n          }\n\n          if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n            console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n          }\n\n          var data = new Uint8ClampedArray(image.height * image.width * 4);\n\n          if (image instanceof ImageData) {\n            for (var i = 0; i < data.length; i += 4) {\n              data[i + 0] = image.data[i + 0];\n              data[i + 1] = image.data[i + 1];\n              data[i + 2] = image.data[i + 2];\n              data[i + 3] = image.data[i + 3];\n            }\n          }\n\n          ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n        }\n\n        if (options.binary) {\n          pending.push(new Promise(function (resolve) {\n            canvas.toBlob(function (blob) {\n              if (blob !== null) {\n                writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\n                  imageDef.bufferView = bufferViewIndex; // @ts-expect-error\n\n                  resolve();\n                });\n              }\n            }, mimeType);\n          }));\n        } else {\n          imageDef.uri = canvas.toDataURL(mimeType);\n        }\n      } else if (image instanceof Image) {\n        imageDef.uri = image.src;\n      }\n\n      var index = json.images.push(imageDef) - 1;\n      if (cachedImages !== undefined) cachedImages[key] = index;\n      return index;\n    }\n    /**\r\n     * Process sampler\r\n     * @param  {Texture} map Texture to process\r\n     * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n     */\n\n  }, {\n    key: \"processSampler\",\n    value: function processSampler(map) {\n      var json = this.json;\n      if (!json.samplers) json.samplers = [];\n      var samplerDef = {\n        magFilter: THREE_TO_WEBGL[map.magFilter],\n        minFilter: THREE_TO_WEBGL[map.minFilter],\n        wrapS: THREE_TO_WEBGL[map.wrapS],\n        wrapT: THREE_TO_WEBGL[map.wrapT]\n      };\n      return json.samplers.push(samplerDef) - 1;\n    }\n    /**\r\n     * Process texture\r\n     * @param  {Texture} map Map to process\r\n     * @return {Integer} Index of the processed texture in the \"textures\" array\r\n     */\n\n  }, {\n    key: \"processTexture\",\n    value: function processTexture(map) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.textures.has(map)) return cache.textures.get(map);\n      if (!json.textures) json.textures = [];\n      var textureDef = {\n        sampler: this.processSampler(map),\n        source: this.processImage(map.image, map.format, map.flipY)\n      };\n      if (map.name) textureDef.name = map.name;\n\n      this._invokeAll(function (ext) {\n        ext.writeTexture && ext.writeTexture(map, textureDef);\n      });\n\n      var index = json.textures.push(textureDef) - 1;\n      cache.textures.set(map, index);\n      return index;\n    }\n    /**\r\n     * Process material\r\n     * @param  {THREE.Material} material Material to process\r\n     * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n     */\n\n  }, {\n    key: \"processMaterial\",\n    value: function processMaterial(material) {\n      var cache = this.cache;\n      var json = this.json;\n      if (cache.materials.has(material)) return cache.materials.get(material);\n\n      if (material instanceof ShaderMaterial && material.isShaderMaterial) {\n        console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n        return null;\n      }\n\n      if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\n\n      var materialDef = {\n        pbrMetallicRoughness: {}\n      };\n\n      if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error\n      material.isMeshBasicMaterial)) {\n        console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n      }\n\n      if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\n        // pbrMetallicRoughness.baseColorFactor\n        var color = material.color.toArray().concat([material.opacity]);\n\n        if (!this.equalArray(color, [1, 1, 1, 1])) {\n          materialDef.pbrMetallicRoughness.baseColorFactor = color;\n        }\n      }\n\n      if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\n        materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n        materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n      } else {\n        materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n        materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n      } // pbrMetallicRoughness.metallicRoughnessTexture\n\n\n      if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\n        if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\n          var metalRoughMapDef = {\n            index: this.processTexture(material.metalnessMap)\n          };\n          this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\n          materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n        } else {\n          console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\n        }\n      } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\n\n      if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\n        var baseColorMapDef = {\n          index: this.processTexture(material.map)\n        };\n        this.applyTextureTransform(baseColorMapDef, material.map);\n        materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n      }\n\n      if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\n        // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n        var emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\n        var maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n\n        if (maxEmissiveComponent > 1) {\n          emissive.multiplyScalar(1 / maxEmissiveComponent);\n          console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\n        }\n\n        if (maxEmissiveComponent > 0) {\n          materialDef.emissiveFactor = emissive.toArray();\n        } // emissiveTexture\n\n\n        if (material.emissiveMap) {\n          var emissiveMapDef = {\n            index: this.processTexture(material.emissiveMap)\n          };\n          this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n          materialDef.emissiveTexture = emissiveMapDef;\n        }\n      } // normalTexture\n\n\n      if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\n        var normalMapDef = {\n          index: this.processTexture(material.normalMap)\n        };\n\n        if (material.normalScale && material.normalScale.x !== 1) {\n          // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n          // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n          normalMapDef.scale = material.normalScale.x;\n        }\n\n        this.applyTextureTransform(normalMapDef, material.normalMap);\n        materialDef.normalTexture = normalMapDef;\n      } // occlusionTexture\n\n\n      if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\n        var occlusionMapDef = {\n          index: this.processTexture(material.aoMap),\n          texCoord: 1\n        };\n\n        if (material.aoMapIntensity !== 1.0) {\n          occlusionMapDef.strength = material.aoMapIntensity;\n        }\n\n        this.applyTextureTransform(occlusionMapDef, material.aoMap);\n        materialDef.occlusionTexture = occlusionMapDef;\n      } // alphaMode\n\n\n      if (material.transparent) {\n        materialDef.alphaMode = 'BLEND';\n      } else {\n        if (material.alphaTest > 0.0) {\n          materialDef.alphaMode = 'MASK';\n          materialDef.alphaCutoff = material.alphaTest;\n        }\n      } // doubleSided\n\n\n      if (material.side === DoubleSide) materialDef.doubleSided = true;\n      if (material.name !== '') materialDef.name = material.name;\n      this.serializeUserData(material, materialDef);\n\n      this._invokeAll(function (ext) {\n        ext.writeMaterial && ext.writeMaterial(material, materialDef);\n      });\n\n      var index = json.materials.push(materialDef) - 1;\n      cache.materials.set(material, index);\n      return index;\n    }\n    /**\r\n     * Process mesh\r\n     * @param  {THREE.Mesh} mesh Mesh to process\r\n     * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n     */\n\n  }, {\n    key: \"processMesh\",\n    value: function processMesh(mesh) {\n      var cache = this.cache;\n      var json = this.json;\n      var meshCacheKeyParts = [mesh.geometry.uuid];\n\n      if (Array.isArray(mesh.material)) {\n        for (var i = 0, l = mesh.material.length; i < l; i++) {\n          meshCacheKeyParts.push(mesh.material[i].uuid);\n        }\n      } else {\n        meshCacheKeyParts.push(mesh.material.uuid);\n      }\n\n      var meshCacheKey = meshCacheKeyParts.join(':');\n      if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n      var geometry = mesh.geometry;\n      var mode; // Use the correct mode\n\n      if (mesh instanceof LineSegments && mesh.isLineSegments) {\n        mode = WEBGL_CONSTANTS.LINES;\n      } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\n        mode = WEBGL_CONSTANTS.LINE_LOOP;\n      } else if (mesh instanceof Line && mesh.isLine) {\n        mode = WEBGL_CONSTANTS.LINE_STRIP;\n      } else if (mesh instanceof Points && mesh.isPoints) {\n        mode = WEBGL_CONSTANTS.POINTS;\n      } else {\n        mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n      }\n\n      if (!geometry.isBufferGeometry) {\n        throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\n      }\n\n      var meshDef = {};\n      var attributes = {};\n      var primitives = [];\n      var targets = []; // Conversion between attributes names in threejs and gltf spec\n\n      var nameConversion = {\n        uv: 'TEXCOORD_0',\n        uv2: 'TEXCOORD_1',\n        color: 'COLOR_0',\n        skinWeight: 'WEIGHTS_0',\n        skinIndex: 'JOINTS_0'\n      };\n      var originalNormal = geometry.getAttribute('normal');\n\n      if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\n        console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n        geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n      } // @QUESTION Detect if .vertexColors = true?\n      // For every attribute create an accessor\n\n\n      var modifiedAttribute = null;\n\n      for (var attributeName in geometry.attributes) {\n        // Ignore morph target attributes, which are exported later.\n        if (attributeName.substr(0, 5) === 'morph') continue;\n        var attribute = geometry.attributes[attributeName];\n        attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\n        // listed in the spec; non-spec attributes are considered custom.\n\n        var validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n        if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n\n        if (cache.attributes.has(this.getUID(attribute))) {\n          attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n          continue;\n        } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\n\n        modifiedAttribute = null;\n        var array = attribute.array;\n\n        if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n          console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n          modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n        }\n\n        var accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\n\n        if (accessor) {\n          attributes[attributeName] = accessor;\n          cache.attributes.set(this.getUID(attribute), accessor);\n        }\n      }\n\n      if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\n\n      if (Object.keys(attributes).length === 0) return null; // Morph targets\n\n      if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n        var weights = [];\n        var targetNames = [];\n        var reverseDictionary = {};\n\n        if (mesh.morphTargetDictionary !== undefined) {\n          for (var key in mesh.morphTargetDictionary) {\n            reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n          }\n        }\n\n        for (var _i2 = 0; _i2 < mesh.morphTargetInfluences.length; ++_i2) {\n          var target = {};\n          var warned = false;\n\n          for (var _attributeName in geometry.morphAttributes) {\n            // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n            // Three.js doesn't support TANGENT yet.\n            if (_attributeName !== 'position' && _attributeName !== 'normal') {\n              if (!warned) {\n                console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n                warned = true;\n              }\n\n              continue;\n            }\n\n            var _attribute = geometry.morphAttributes[_attributeName][_i2];\n\n            var gltfAttributeName = _attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\n            //\n            // glTF 2.0 Specification:\n            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\n            var baseAttribute = geometry.attributes[_attributeName];\n\n            if (cache.attributes.has(this.getUID(_attribute))) {\n              target[gltfAttributeName] = cache.attributes.get(this.getUID(_attribute));\n              continue;\n            } // Clones attribute not to override\n\n\n            var relativeAttribute = _attribute.clone();\n\n            if (!geometry.morphTargetsRelative) {\n              for (var j = 0, jl = _attribute.count; j < jl; j++) {\n                relativeAttribute.setXYZ(j, _attribute.getX(j) - baseAttribute.getX(j), _attribute.getY(j) - baseAttribute.getY(j), _attribute.getZ(j) - baseAttribute.getZ(j));\n              }\n            }\n\n            var _accessor = this.processAccessor(relativeAttribute, geometry);\n\n            if (_accessor != undefined) {\n              target[gltfAttributeName] = _accessor;\n            }\n\n            cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\n          }\n\n          targets.push(target);\n          weights.push(mesh.morphTargetInfluences[_i2]);\n          if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[_i2]);\n        }\n\n        meshDef.weights = weights;\n\n        if (targetNames.length > 0) {\n          meshDef.extras = {};\n          meshDef.extras.targetNames = targetNames;\n        }\n      }\n\n      var isMultiMaterial = Array.isArray(mesh.material);\n      if (isMultiMaterial && geometry.groups.length === 0) return null;\n      var materials = isMultiMaterial ? mesh.material : [mesh.material];\n      var groups = isMultiMaterial ? geometry.groups : [{\n        materialIndex: 0,\n        start: undefined,\n        count: undefined\n      }];\n\n      for (var _i3 = 0, il = groups.length; _i3 < il; _i3++) {\n        var primitive = {\n          mode: mode,\n          attributes: attributes\n        };\n\n        if (geometry instanceof Object3D || geometry instanceof Material) {\n          this.serializeUserData(geometry, primitive);\n        }\n\n        if (targets.length > 0) primitive.targets = targets;\n\n        if (geometry.index !== null) {\n          var cacheKey = this.getUID(geometry.index);\n\n          if (groups[_i3].start !== undefined || groups[_i3].count !== undefined) {\n            // @ts-expect-error\n            cacheKey += \":\".concat(groups[_i3].start, \":\").concat(groups[_i3].count);\n          }\n\n          if (cache.attributes.has(cacheKey)) {\n            primitive.indices = cache.attributes.get(cacheKey);\n          } else {\n            primitive.indices = this.processAccessor(geometry.index, geometry, groups[_i3].start, groups[_i3].count);\n            cache.attributes.set(cacheKey, primitive.indices);\n          }\n\n          if (primitive.indices === null) delete primitive.indices;\n        }\n\n        var materialIndex = groups[_i3].materialIndex;\n\n        if (materialIndex !== undefined && Array.isArray(materials)) {\n          var targetMaterials = materials[materialIndex];\n\n          if (!Array.isArray(targetMaterials)) {\n            var material = this.processMaterial(targetMaterials);\n            if (material !== null) primitive.material = material;\n            primitives.push(primitive);\n          }\n        }\n      }\n\n      meshDef.primitives = primitives;\n      if (!json.meshes) json.meshes = [];\n\n      this._invokeAll(function (ext) {\n        ext.writeMesh && ext.writeMesh(mesh, meshDef);\n      });\n\n      var index = json.meshes.push(meshDef) - 1;\n      cache.meshes.set(meshCacheKey, index);\n      return index;\n    }\n    /**\r\n     * Process camera\r\n     * @param  {THREE.Camera} camera Camera to process\r\n     * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n     */\n\n  }, {\n    key: \"processCamera\",\n    value: function processCamera(camera) {\n      var json = this.json;\n      if (!json.cameras) json.cameras = [];\n      var isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\n      var cameraDef = {\n        type: isOrtho ? 'orthographic' : 'perspective'\n      };\n\n      if (camera instanceof OrthographicCamera && isOrtho) {\n        cameraDef.orthographic = {\n          xmag: camera.right * 2,\n          ymag: camera.top * 2,\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } else if (camera instanceof PerspectiveCamera) {\n        cameraDef.perspective = {\n          aspectRatio: camera.aspect,\n          yfov: MathUtils.degToRad(camera.fov),\n          zfar: camera.far <= 0 ? 0.001 : camera.far,\n          znear: camera.near < 0 ? 0 : camera.near\n        };\n      } // Question: Is saving \"type\" as name intentional?\n\n\n      if (camera.name !== '') cameraDef.name = camera.type;\n      return json.cameras.push(cameraDef) - 1;\n    }\n    /**\r\n     * Creates glTF animation entry from AnimationClip object.\r\n     *\r\n     * Status:\r\n     * - Only properties listed in PATH_PROPERTIES may be animated.\r\n     *\r\n     * @param {THREE.AnimationClip} clip\r\n     * @param {THREE.Object3D} root\r\n     * @return {number|null}\r\n     */\n\n  }, {\n    key: \"processAnimation\",\n    value: function processAnimation(clip, root) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n      if (!json.animations) json.animations = [];\n      clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n      var tracks = clip.tracks;\n      var channels = [];\n      var samplers = [];\n\n      for (var i = 0; i < tracks.length; ++i) {\n        var track = tracks[i];\n        var trackBinding = PropertyBinding.parseTrackName(track.name);\n        var trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n        var trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n\n        if (trackBinding.objectName === 'bones') {\n          if (trackNode.isSkinnedMesh) {\n            trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n          } else {\n            trackNode = undefined;\n          }\n        }\n\n        if (!trackNode || !trackProperty) {\n          console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n          return null;\n        }\n\n        var inputItemSize = 1;\n        var outputItemSize = track.values.length / track.times.length;\n\n        if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n          outputItemSize /= trackNode.morphTargetInfluences.length;\n        }\n\n        var interpolation = void 0; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n        // Detecting glTF cubic spline interpolant by checking factory method's special property\n        // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n        // valid value from .getInterpolation().\n        // @ts-expect-error\n\n        if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\n          // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n          // but needs to be stored as VEC3 so dividing by 3 here.\n\n          outputItemSize /= 3;\n        } else if (track.getInterpolation() === InterpolateDiscrete) {\n          interpolation = 'STEP';\n        } else {\n          interpolation = 'LINEAR';\n        }\n\n        samplers.push({\n          input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n          output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n          interpolation: interpolation\n        });\n        channels.push({\n          sampler: samplers.length - 1,\n          target: {\n            node: nodeMap.get(trackNode),\n            path: trackProperty\n          }\n        });\n      }\n\n      json.animations.push({\n        name: clip.name || 'clip_' + json.animations.length,\n        samplers: samplers,\n        channels: channels\n      });\n      return json.animations.length - 1;\n    }\n    /**\r\n     * @param {THREE.Object3D} object\r\n     * @return {number|null}\r\n     */\n\n  }, {\n    key: \"processSkin\",\n    value: function processSkin(object) {\n      var json = this.json;\n      var nodeMap = this.nodeMap;\n\n      if (json.nodes !== undefined && object instanceof SkinnedMesh) {\n        var node = json.nodes[nodeMap.get(object)];\n        var skeleton = object.skeleton;\n        if (skeleton === undefined) return null;\n        var rootJoint = object.skeleton.bones[0];\n        if (rootJoint === undefined) return null;\n        var joints = [];\n        var inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n        var temporaryBoneInverse = new Matrix4();\n\n        for (var i = 0; i < skeleton.bones.length; ++i) {\n          joints.push(nodeMap.get(skeleton.bones[i]));\n          temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n          temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n        }\n\n        if (json.skins === undefined) json.skins = [];\n        json.skins.push({\n          inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n          joints: joints,\n          skeleton: nodeMap.get(rootJoint)\n        });\n        var skinIndex = node.skin = json.skins.length - 1;\n        return skinIndex;\n      } else {\n        return null;\n      }\n    }\n    /**\r\n     * Process Object3D node\r\n     * @param  {THREE.Object3D} node Object3D to processNode\r\n     * @return {Integer} Index of the node in the nodes list\r\n     */\n\n  }, {\n    key: \"processNode\",\n    value: function processNode(object) {\n      var json = this.json;\n      var options = this.options;\n      var nodeMap = this.nodeMap;\n      if (!json.nodes) json.nodes = [];\n      var nodeDef = {};\n\n      if (options.trs) {\n        var rotation = object.quaternion.toArray();\n        var position = object.position.toArray();\n        var scale = object.scale.toArray();\n\n        if (!this.equalArray(rotation, [0, 0, 0, 1])) {\n          nodeDef.rotation = rotation;\n        }\n\n        if (!this.equalArray(position, [0, 0, 0])) {\n          nodeDef.translation = position;\n        }\n\n        if (!this.equalArray(scale, [1, 1, 1])) {\n          nodeDef.scale = scale;\n        }\n      } else {\n        if (object.matrixAutoUpdate) {\n          object.updateMatrix();\n        }\n\n        if (!this.isIdentityMatrix(object.matrix)) {\n          nodeDef.matrix = object.matrix.elements;\n        }\n      } // We don't export empty strings name because it represents no-name in Three.js.\n\n\n      if (object.name !== '') nodeDef.name = String(object.name);\n      this.serializeUserData(object, nodeDef);\n\n      if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\n        var meshIndex = this.processMesh(object);\n        if (meshIndex !== null) nodeDef.mesh = meshIndex;\n      } else if (object instanceof Camera && object.isCamera) {\n        nodeDef.camera = this.processCamera(object);\n      }\n\n      if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\n\n      if (object.children.length > 0) {\n        var children = [];\n\n        for (var i = 0, l = object.children.length; i < l; i++) {\n          var child = object.children[i];\n\n          if (child.visible || !options.onlyVisible) {\n            var _nodeIndex = this.processNode(child);\n\n            if (_nodeIndex !== null) children.push(_nodeIndex);\n          }\n        }\n\n        if (children.length > 0) nodeDef.children = children;\n      }\n\n      this._invokeAll(function (ext) {\n        ext.writeNode && ext.writeNode(object, nodeDef);\n      });\n\n      var nodeIndex = json.nodes.push(nodeDef) - 1;\n      nodeMap.set(object, nodeIndex);\n      return nodeIndex;\n    }\n    /**\r\n     * Process Scene\r\n     * @param  {Scene} node Scene to process\r\n     */\n\n  }, {\n    key: \"processScene\",\n    value: function processScene(scene) {\n      var json = this.json;\n      var options = this.options;\n\n      if (!json.scenes) {\n        json.scenes = [];\n        json.scene = 0;\n      }\n\n      var sceneDef = {};\n      if (scene.name !== '') sceneDef.name = scene.name;\n      json.scenes.push(sceneDef);\n      var nodes = [];\n\n      for (var i = 0, l = scene.children.length; i < l; i++) {\n        var child = scene.children[i];\n\n        if (child.visible || !options.onlyVisible) {\n          var nodeIndex = this.processNode(child);\n          if (nodeIndex !== null) nodes.push(nodeIndex);\n        }\n      }\n\n      if (nodes.length > 0) sceneDef.nodes = nodes;\n      this.serializeUserData(scene, sceneDef);\n    }\n  }, {\n    key: \"processObjects\",\n    value: function processObjects(objects) {\n      var scene = new Scene();\n      scene.name = 'AuxScene';\n\n      for (var i = 0; i < objects.length; i++) {\n        // We push directly to children instead of calling `add` to prevent\n        // modify the .parent and break its original scene and hierarchy\n        scene.children.push(objects[i]);\n      }\n\n      this.processScene(scene);\n    }\n    /**\r\n     * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n     */\n\n  }, {\n    key: \"processInput\",\n    value: function processInput(input) {\n      var options = this.options;\n      input = input instanceof Array ? input : [input];\n\n      this._invokeAll(function (ext) {\n        ext.beforeParse && ext.beforeParse(input);\n      });\n\n      var objectsWithoutScene = [];\n\n      for (var i = 0; i < input.length; i++) {\n        var inputScene = input[i];\n\n        if (inputScene instanceof Scene) {\n          this.processScene(inputScene);\n        } else {\n          objectsWithoutScene.push(input[i]);\n        }\n      }\n\n      if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\n\n      for (var _i4 = 0; _i4 < this.skins.length; ++_i4) {\n        this.processSkin(this.skins[_i4]);\n      }\n\n      for (var _i5 = 0; options.animations !== undefined && _i5 < options.animations.length; ++_i5) {\n        this.processAnimation(options.animations[_i5], input[0]);\n      }\n\n      this._invokeAll(function (ext) {\n        ext.afterParse && ext.afterParse(input);\n      });\n    }\n  }, {\n    key: \"_invokeAll\",\n    value: function _invokeAll(func) {\n      for (var i = 0, il = this.plugins.length; i < il; i++) {\n        func(this.plugins[i]);\n      }\n    } //------------------------------------------------------------------------------\n    // Utility functions\n    //------------------------------------------------------------------------------\n\n    /**\r\n     * Compare two arrays\r\n     * @param  {Array} array1 Array 1 to compare\r\n     * @param  {Array} array2 Array 2 to compare\r\n     * @return {Boolean}        Returns true if both arrays are equal\r\n     */\n\n  }, {\n    key: \"equalArray\",\n    value: function equalArray(array1, array2) {\n      return array1.length === array2.length && array1.every(function (element, index) {\n        return element === array2[index];\n      });\n    }\n    /**\r\n     * Converts a string to an ArrayBuffer.\r\n     * @param  {string} text\r\n     * @return {ArrayBuffer}\r\n     */\n\n  }, {\n    key: \"stringToArrayBuffer\",\n    value: function stringToArrayBuffer(text) {\n      if (window.TextEncoder !== undefined) {\n        return new TextEncoder().encode(text).buffer;\n      }\n\n      var array = new Uint8Array(new ArrayBuffer(text.length));\n\n      for (var i = 0, il = text.length; i < il; i++) {\n        var value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\n\n        array[i] = value > 0xff ? 0x20 : value;\n      }\n\n      return array.buffer;\n    }\n  }, {\n    key: \"isIdentityMatrix\",\n    value: function isIdentityMatrix(matrix) {\n      return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    }\n  }, {\n    key: \"getMinMax\",\n    value: function getMinMax(attribute, start, count) {\n      var output = {\n        min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n        max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n      };\n\n      for (var i = start; i < start + count; i++) {\n        for (var a = 0; a < attribute.itemSize; a++) {\n          var value = void 0;\n\n          if (attribute.itemSize > 4) {\n            // no support for interleaved data for itemSize > 4\n            value = attribute.array[i * attribute.itemSize + a];\n          } else {\n            if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          }\n\n          if (value !== undefined) {\n            output.min[a] = Math.min(output.min[a], value);\n            output.max[a] = Math.max(output.max[a], value);\n          }\n        }\n      }\n\n      return output;\n    }\n    /**\r\n     * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n     * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n     */\n\n  }, {\n    key: \"getPaddedBufferSize\",\n    value: function getPaddedBufferSize(bufferSize) {\n      return Math.ceil(bufferSize / 4) * 4;\n    }\n    /**\r\n     * Returns a buffer aligned to 4-byte boundary.\r\n     *\r\n     * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n     * @param {Integer} paddingByte (Optional)\r\n     * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n     */\n\n  }, {\n    key: \"getPaddedArrayBuffer\",\n    value: function getPaddedArrayBuffer(arrayBuffer) {\n      var paddingByte = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\n\n      if (paddedLength !== arrayBuffer.byteLength) {\n        var array = new Uint8Array(paddedLength);\n        array.set(new Uint8Array(arrayBuffer));\n\n        if (paddingByte !== 0) {\n          for (var i = arrayBuffer.byteLength; i < paddedLength; i++) {\n            array[i] = paddingByte;\n          }\n        }\n\n        return array.buffer;\n      }\n\n      return arrayBuffer;\n    }\n  }]);\n\n  return GLTFWriter;\n}();\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\n\n\nvar GLTFLightExtension = /*#__PURE__*/function () {\n  function GLTFLightExtension(writer) {\n    _classCallCheck(this, GLTFLightExtension);\n\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n\n  _createClass(GLTFLightExtension, [{\n    key: \"writeNode\",\n    value: function writeNode(light, nodeDef) {\n      if (!light.isLight) return;\n\n      if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error\n      !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\n        console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n        return;\n      }\n\n      var writer = this.writer;\n      var json = writer.json;\n      var extensionsUsed = writer.extensionsUsed;\n      var lightDef = {};\n      if (light.name) lightDef.name = light.name;\n      lightDef.color = light.color.toArray();\n      lightDef.intensity = light.intensity;\n\n      if (light instanceof DirectionalLight && light.isDirectionalLight) {\n        lightDef.type = 'directional';\n      } else if (light instanceof PointLight && // @ts-expect-error\n      light.isPointLight) {\n        lightDef.type = 'point';\n        if (light.distance > 0) lightDef.range = light.distance;\n      } else if (light instanceof SpotLight && light.isSpotLight) {\n        lightDef.type = 'spot';\n        if (light.distance > 0) lightDef.range = light.distance;\n        lightDef.spot = {};\n        lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\n        lightDef.spot.outerConeAngle = light.angle;\n      }\n\n      if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\n        console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n      }\n\n      if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n        console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n      }\n\n      if (!extensionsUsed[this.name]) {\n        json.extensions = json.extensions || {};\n        json.extensions[this.name] = {\n          lights: []\n        };\n        extensionsUsed[this.name] = true;\n      }\n\n      if (json.extensions !== undefined) {\n        var lights = json.extensions[this.name].lights;\n        lights.push(lightDef);\n        nodeDef.extensions = nodeDef.extensions || {};\n        nodeDef.extensions[this.name] = {\n          light: lights.length - 1\n        };\n      }\n    }\n  }]);\n\n  return GLTFLightExtension;\n}();\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\n\n\nvar GLTFMaterialsUnlitExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsUnlitExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsUnlitExtension);\n\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n\n  _createClass(GLTFMaterialsUnlitExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshBasicMaterial && // @ts-expect-error\n      material.isMeshBasicMaterial)) {\n        return;\n      }\n\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = {};\n      extensionsUsed[this.name] = true;\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n    }\n  }]);\n\n  return GLTFMaterialsUnlitExtension;\n}();\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n */\n\n\nvar GLTFMaterialsPBRSpecularGlossiness = /*#__PURE__*/function () {\n  function GLTFMaterialsPBRSpecularGlossiness(writer) {\n    _classCallCheck(this, GLTFMaterialsPBRSpecularGlossiness);\n\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\n  }\n\n  _createClass(GLTFMaterialsPBRSpecularGlossiness, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      // @ts-expect-error\n      if (!material.isGLTFSpecularGlossinessMaterial) return;\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n\n      if (materialDef.pbrMetallicRoughness.baseColorFactor) {\n        extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n      }\n\n      if (material instanceof MeshPhongMaterial) {\n        var specularFactor = [1, 1, 1];\n        material.specular.toArray(specularFactor, 0);\n        extensionDef.specularFactor = specularFactor;\n        extensionDef.glossinessFactor = // @ts-expect-error\n        material.glossiness;\n      }\n\n      if (materialDef.pbrMetallicRoughness.baseColorTexture) {\n        extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n      }\n\n      if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\n        var specularMapDef = {\n          index: writer.processTexture(material.specularMap)\n        };\n        writer.applyTextureTransform(specularMapDef, material.specularMap);\n        extensionDef.specularGlossinessTexture = specularMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsPBRSpecularGlossiness;\n}();\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n */\n\n\nvar GLTFMaterialsTransmissionExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsTransmissionExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsTransmissionExtension);\n\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n\n  _createClass(GLTFMaterialsTransmissionExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n      material.isMeshPhysicalMaterial) || material.transmission === 0) {\n        return;\n      }\n\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.transmissionFactor = material.transmission;\n\n      if (material.transmissionMap) {\n        var transmissionMapDef = {\n          index: writer.processTexture(material.transmissionMap)\n        };\n        writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n        extensionDef.transmissionTexture = transmissionMapDef;\n      }\n\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsTransmissionExtension;\n}();\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\n\n\nvar GLTFMaterialsVolumeExtension = /*#__PURE__*/function () {\n  function GLTFMaterialsVolumeExtension(writer) {\n    _classCallCheck(this, GLTFMaterialsVolumeExtension);\n\n    _defineProperty(this, \"writer\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n\n  _createClass(GLTFMaterialsVolumeExtension, [{\n    key: \"writeMaterial\",\n    value: function writeMaterial(material, materialDef) {\n      if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\n      material.isMeshPhysicalMaterial) || material.thickness === 0) {\n        return;\n      }\n\n      var writer = this.writer;\n      var extensionsUsed = writer.extensionsUsed;\n      var extensionDef = {};\n      extensionDef.thickness = material.thickness;\n\n      if (material.thicknessMap) {\n        var thicknessMapDef = {\n          index: writer.processTexture(material.thicknessMap)\n        };\n        writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n        extensionDef.thicknessTexture = thicknessMapDef;\n      }\n\n      extensionDef.attenuationDistance = material.attenuationDistance;\n      extensionDef.attenuationColor = //@ts-expect-error\n      material.attenuationTint.toArray();\n      materialDef.extensions = materialDef.extensions || {};\n      materialDef.extensions[this.name] = extensionDef;\n      extensionsUsed[this.name] = true;\n    }\n  }]);\n\n  return GLTFMaterialsVolumeExtension;\n}();\n\nexport { GLTFExporter };","map":{"version":3,"names":["_defineProperty","PropertyBinding","InterpolateLinear","Vector3","RGBAFormat","ShaderMaterial","MeshStandardMaterial","MeshBasicMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","MeshNormalMaterial","MeshPhongMaterial","MeshToonMaterial","MeshLambertMaterial","DoubleSide","LineSegments","LineLoop","Line","Points","MeshDepthMaterial","InterleavedBufferAttribute","BufferAttribute","Object3D","Material","OrthographicCamera","PerspectiveCamera","MathUtils","InterpolateDiscrete","SkinnedMesh","Matrix4","Mesh","Camera","Scene","DirectionalLight","PointLight","SpotLight","NearestFilter","NearestMipmapNearestFilter","NearestMipmapLinearFilter","LinearFilter","LinearMipmapNearestFilter","LinearMipmapLinearFilter","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","GLTFExporter","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsPBRSpecularGlossiness","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","callback","indexOf","push","splice","input","onDone","options","GLTFWriter","plugins","i","il","length","setPlugins","write","insertKeyframe","track","time","tolerance","valueSize","getValueSize","times","TimeBufferType","values","ValueBufferType","interpolant","createInterpolant","index","Math","abs","set","evaluate","slice","mergeMorphTargetTracks","clip","root","tracks","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","parseTrackName","name","sourceTrackNode","findNode","nodeName","propertyName","propertyIndex","undefined","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","isInterpolantFactoryMethodGLTFCubicSpline","Error","console","warn","clone","setInterpolation","targetCount","morphTargetInfluences","targetIndex","morphTargetDictionary","mergedTrack","uuid","j","sourceInterpolant","keyframeIndex","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","UNSIGNED_BYTE","UNSIGNED_SHORT","FLOAT","UNSIGNED_INT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","cachedCanvas","Object","assign","binary","trs","onlyVisible","truncateDrawRange","embedImages","maxTextureSize","Infinity","animations","includeCustomExtensions","processInput","Promise","all","then","blob","Blob","type","extensionsUsedList","keys","byteLength","size","reader","window","FileReader","readAsArrayBuffer","onloadend","result","binaryChunk","getPaddedArrayBuffer","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","stringToArrayBuffer","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","object","objectDef","userData","parse","gltfExtensions","extensions","extensionName","extras","error","message","has","get","normal","v","count","fromBufferAttribute","attribute","x","y","z","setX","normalize","setXYZ","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","buffer","componentType","start","target","bufferViews","componentSize","getPaddedBufferSize","itemSize","dataView","a","value","array","getX","getY","getZ","getW","setFloat32","setUint16","setUint8","bufferViewDef","processBuffer","byteStride","output","id","resolve","geometry","types","constructor","Float32Array","Uint32Array","Uint16Array","Uint8Array","end","end2","drawRange","max","min","minMax","getMinMax","bufferViewTarget","bufferView","processBufferView","accessorDef","normalized","accessors","image","format","flipY","cachedImages","mimeType","key","toString","imageDef","canvas","document","createElement","width","height","ctx","getContext","translate","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","drawImage","data","Uint8ClampedArray","ImageData","putImageData","toBlob","processBufferViewImage","bufferViewIndex","toDataURL","Image","src","map","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","textureDef","sampler","processSampler","source","processImage","_invokeAll","ext","writeTexture","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","equalArray","baseColorFactor","metallicFactor","metalness","roughnessFactor","roughness","metalnessMap","roughnessMap","metalRoughMapDef","processTexture","applyTextureTransform","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","multiplyScalar","emissiveIntensity","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","texCoord","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","serializeUserData","writeMaterial","mesh","meshCacheKeyParts","Array","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","isBufferGeometry","meshDef","primitives","targets","nameConversion","uv","uv2","skinWeight","skinIndex","originalNormal","getAttribute","isNormalizedNormalAttribute","setAttribute","createNormalizedNormalAttribute","modifiedAttribute","attributeName","substr","toUpperCase","validVertexAttributes","test","getUID","accessor","processAccessor","weights","targetNames","reverseDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","jl","isMultiMaterial","groups","materialIndex","primitive","cacheKey","indices","targetMaterials","processMaterial","writeMesh","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","Utils","channels","trackBinding","trackNode","trackProperty","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","interpolation","getInterpolation","node","path","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","nodeDef","translation","matrixAutoUpdate","updateMatrix","isIdentityMatrix","matrix","elements","String","isMesh","meshIndex","processMesh","isCamera","processCamera","children","child","visible","nodeIndex","processNode","writeNode","scene","scenes","sceneDef","objects","processScene","beforeParse","objectsWithoutScene","inputScene","processObjects","processSkin","processAnimation","afterParse","func","array1","array2","every","element","text","TextEncoder","encode","charCodeAt","fill","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","bufferSize","ceil","arrayBuffer","paddingByte","paddedLength","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isGLTFSpecularGlossinessMaterial","extensionDef","diffuseFactor","specularFactor","specular","glossinessFactor","glossiness","diffuseTexture","specularMap","specularMapDef","specularGlossinessTexture","isMeshPhysicalMaterial","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","attenuationTint"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/exporters/GLTFExporter.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { PropertyBinding, InterpolateLinear, Vector3, RGBAFormat, ShaderMaterial, MeshStandardMaterial, MeshBasicMaterial, MeshPhysicalMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshLambertMaterial, DoubleSide, LineSegments, LineLoop, Line, Points, MeshDepthMaterial, InterleavedBufferAttribute, BufferAttribute, Object3D, Material, OrthographicCamera, PerspectiveCamera, MathUtils, InterpolateDiscrete, SkinnedMesh, Matrix4, Mesh, Camera, Scene, DirectionalLight, PointLight, SpotLight, NearestFilter, NearestMipmapNearestFilter, NearestMipmapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipmapLinearFilter, ClampToEdgeWrapping, RepeatWrapping, MirroredRepeatWrapping } from 'three';\r\n\r\nclass GLTFExporter {\r\n  constructor() {\r\n    _defineProperty(this, \"pluginCallbacks\", void 0);\r\n\r\n    this.pluginCallbacks = [];\r\n    this.register(function (writer) {\r\n      return new GLTFLightExtension(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsUnlitExtension(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsPBRSpecularGlossiness(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsTransmissionExtension(writer);\r\n    });\r\n    this.register(function (writer) {\r\n      return new GLTFMaterialsVolumeExtension(writer);\r\n    });\r\n  }\r\n\r\n  register(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\r\n      this.pluginCallbacks.push(callback);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  unregister(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\r\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  parse(input, onDone, options) {\r\n    const writer = new GLTFWriter();\r\n    const plugins = [];\r\n\r\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\r\n      plugins.push(this.pluginCallbacks[i](writer));\r\n    }\r\n\r\n    writer.setPlugins(plugins);\r\n    writer.write(input, onDone, options);\r\n  }\r\n  /**\r\n   * Static utility functions\r\n   */\r\n\r\n\r\n} //------------------------------------------------------------------------------\r\n// Constants\r\n//------------------------------------------------------------------------------\r\n\r\n\r\n_defineProperty(GLTFExporter, \"Utils\", {\r\n  insertKeyframe: function (track, time) {\r\n    const tolerance = 0.001; // 1ms\r\n\r\n    const valueSize = track.getValueSize(); // @ts-expect-error\r\n\r\n    const times = new track.TimeBufferType(track.times.length + 1); // @ts-expect-error\r\n\r\n    const values = new track.ValueBufferType(track.values.length + valueSize);\r\n    /**\r\n     * NOTE: createInterpolant does not exist in the type, but it does exist as a property of the class\r\n     * https://github.com/mrdoob/three.js/blob/77480d339d737b7505b335101ffd3cf29a30738d/src/animation/KeyframeTrack.js#L117\r\n     */\r\n    // @ts-expect-error\r\n\r\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\r\n    let index;\r\n\r\n    if (track.times.length === 0) {\r\n      times[0] = time;\r\n\r\n      for (let i = 0; i < valueSize; i++) {\r\n        values[i] = 0;\r\n      }\r\n\r\n      index = 0;\r\n    } else if (time < track.times[0]) {\r\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\r\n      times[0] = time;\r\n      times.set(track.times, 1);\r\n      values.set(interpolant.evaluate(time), 0);\r\n      values.set(track.values, valueSize);\r\n      index = 0;\r\n    } else if (time > track.times[track.times.length - 1]) {\r\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\r\n        return track.times.length - 1;\r\n      }\r\n\r\n      times[times.length - 1] = time;\r\n      times.set(track.times, 0);\r\n      values.set(track.values, 0);\r\n      values.set(interpolant.evaluate(time), track.values.length);\r\n      index = times.length - 1;\r\n    } else {\r\n      for (let i = 0; i < track.times.length; i++) {\r\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\r\n\r\n        if (track.times[i] < time && track.times[i + 1] > time) {\r\n          times.set(track.times.slice(0, i + 1), 0);\r\n          times[i + 1] = time;\r\n          times.set(track.times.slice(i + 1), i + 2);\r\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\r\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\r\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\r\n          index = i + 1;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    track.times = times;\r\n    track.values = values;\r\n    return index;\r\n  },\r\n  mergeMorphTargetTracks: function (clip, root) {\r\n    const tracks = [];\r\n    const mergedTracks = {};\r\n    const sourceTracks = clip.tracks;\r\n\r\n    for (let i = 0; i < sourceTracks.length; ++i) {\r\n      let sourceTrack = sourceTracks[i];\r\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\r\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\r\n\r\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\r\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\r\n        tracks.push(sourceTrack);\r\n        continue;\r\n      }\r\n\r\n      if ( // @ts-expect-error\r\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && // @ts-expect-error\r\n      sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\r\n        // @ts-expect-error\r\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\r\n          // This should never happen, because glTF morph target animations\r\n          // affect all targets already.\r\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\r\n        }\r\n\r\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\r\n        sourceTrack = sourceTrack.clone();\r\n        sourceTrack.setInterpolation(InterpolateLinear);\r\n      }\r\n\r\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\r\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\r\n\r\n      if (targetIndex === undefined) {\r\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\r\n      }\r\n\r\n      let mergedTrack; // If this is the first time we've seen this object, create a new\r\n      // track to store merged keyframe data for each morph target.\r\n\r\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\r\n        mergedTrack = sourceTrack.clone(); // @ts-expect-error\r\n\r\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\r\n\r\n        for (let j = 0; j < mergedTrack.times.length; j++) {\r\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\r\n        } // We need to take into consideration the intended target node\r\n        // of our original un-merged morphTarget animation.\r\n\r\n\r\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\r\n        mergedTrack.values = values;\r\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\r\n        tracks.push(mergedTrack);\r\n        continue;\r\n      } // @ts-expect-error\r\n\r\n\r\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\r\n      mergedTrack = mergedTracks[sourceTrackNode.uuid]; // For every existing keyframe of the merged track, write a (possibly\r\n      // interpolated) value from the source track.\r\n\r\n      for (let j = 0; j < mergedTrack.times.length; j++) {\r\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\r\n      } // For every existing keyframe of the source track, write a (possibly\r\n      // new) keyframe to the merged track. Values from the previous loop may\r\n      // be written again, but keyframes are de-duplicated.\r\n\r\n\r\n      for (let j = 0; j < sourceTrack.times.length; j++) {\r\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\r\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\r\n      }\r\n    }\r\n\r\n    clip.tracks = tracks;\r\n    return clip;\r\n  }\r\n});\r\n\r\nconst WEBGL_CONSTANTS = {\r\n  POINTS: 0x0000,\r\n  LINES: 0x0001,\r\n  LINE_LOOP: 0x0002,\r\n  LINE_STRIP: 0x0003,\r\n  TRIANGLES: 0x0004,\r\n  TRIANGLE_STRIP: 0x0005,\r\n  TRIANGLE_FAN: 0x0006,\r\n  UNSIGNED_BYTE: 0x1401,\r\n  UNSIGNED_SHORT: 0x1403,\r\n  FLOAT: 0x1406,\r\n  UNSIGNED_INT: 0x1405,\r\n  ARRAY_BUFFER: 0x8892,\r\n  ELEMENT_ARRAY_BUFFER: 0x8893,\r\n  NEAREST: 0x2600,\r\n  LINEAR: 0x2601,\r\n  NEAREST_MIPMAP_NEAREST: 0x2700,\r\n  LINEAR_MIPMAP_NEAREST: 0x2701,\r\n  NEAREST_MIPMAP_LINEAR: 0x2702,\r\n  LINEAR_MIPMAP_LINEAR: 0x2703,\r\n  CLAMP_TO_EDGE: 33071,\r\n  MIRRORED_REPEAT: 33648,\r\n  REPEAT: 10497\r\n};\r\nconst THREE_TO_WEBGL = {};\r\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\r\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\r\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\r\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\r\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\r\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\r\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\r\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\r\nconst PATH_PROPERTIES = {\r\n  scale: 'scale',\r\n  position: 'translation',\r\n  quaternion: 'rotation',\r\n  morphTargetInfluences: 'weights'\r\n}; // GLB constants\r\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n\r\nconst GLB_HEADER_BYTES = 12;\r\nconst GLB_HEADER_MAGIC = 0x46546c67;\r\nconst GLB_VERSION = 2;\r\nconst GLB_CHUNK_PREFIX_BYTES = 8;\r\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\r\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\r\n/**\r\n * Writer\r\n */\r\n\r\nclass GLTFWriter {\r\n  constructor() {\r\n    _defineProperty(this, \"plugins\", void 0);\r\n\r\n    _defineProperty(this, \"options\", void 0);\r\n\r\n    _defineProperty(this, \"pending\", void 0);\r\n\r\n    _defineProperty(this, \"buffers\", void 0);\r\n\r\n    _defineProperty(this, \"byteOffset\", void 0);\r\n\r\n    _defineProperty(this, \"nodeMap\", void 0);\r\n\r\n    _defineProperty(this, \"skins\", void 0);\r\n\r\n    _defineProperty(this, \"extensionsUsed\", void 0);\r\n\r\n    _defineProperty(this, \"uids\", void 0);\r\n\r\n    _defineProperty(this, \"uid\", void 0);\r\n\r\n    _defineProperty(this, \"json\", void 0);\r\n\r\n    _defineProperty(this, \"cache\", void 0);\r\n\r\n    _defineProperty(this, \"cachedCanvas\", void 0);\r\n\r\n    this.plugins = [];\r\n    this.options = {};\r\n    this.pending = [];\r\n    this.buffers = [];\r\n    this.byteOffset = 0;\r\n    this.nodeMap = new Map();\r\n    this.skins = [];\r\n    this.extensionsUsed = {};\r\n    this.uids = new Map();\r\n    this.uid = 0;\r\n    this.json = {\r\n      asset: {\r\n        version: '2.0',\r\n        generator: 'THREE.GLTFExporter'\r\n      }\r\n    };\r\n    this.cache = {\r\n      meshes: new Map(),\r\n      attributes: new Map(),\r\n      attributesNormalized: new Map(),\r\n      materials: new Map(),\r\n      textures: new Map(),\r\n      images: new Map()\r\n    };\r\n    this.cachedCanvas = null;\r\n  }\r\n\r\n  setPlugins(plugins) {\r\n    this.plugins = plugins;\r\n  }\r\n  /**\r\n   * Parse scenes and generate GLTF output\r\n   * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\r\n   * @param  {Function} onDone  Callback on completed\r\n   * @param  {Object} options options\r\n   */\r\n\r\n\r\n  write(input, onDone, options) {\r\n    this.options = Object.assign({}, {\r\n      // default options\r\n      binary: false,\r\n      trs: false,\r\n      onlyVisible: true,\r\n      truncateDrawRange: true,\r\n      embedImages: true,\r\n      maxTextureSize: Infinity,\r\n      animations: [],\r\n      includeCustomExtensions: false\r\n    }, options);\r\n\r\n    if (this.options.animations !== undefined && this.options.animations.length > 0) {\r\n      // Only TRS properties, and not matrices, may be targeted by animation.\r\n      this.options.trs = true;\r\n    }\r\n\r\n    this.processInput(input);\r\n    const writer = this;\r\n    Promise.all(this.pending).then(() => {\r\n      const buffers = writer.buffers;\r\n      const json = writer.json;\r\n      const options = writer.options;\r\n      const extensionsUsed = writer.extensionsUsed; // Merge buffers.\r\n\r\n      const blob = new Blob(buffers, {\r\n        type: 'application/octet-stream'\r\n      }); // Declare extensions.\r\n\r\n      const extensionsUsedList = Object.keys(extensionsUsed);\r\n      if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList; // Update bytelength of the single buffer.\r\n\r\n      if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\r\n\r\n      if (options.binary) {\r\n        // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\r\n        const reader = new window.FileReader();\r\n        reader.readAsArrayBuffer(blob);\r\n\r\n        reader.onloadend = () => {\r\n          if (reader.result !== null && typeof reader.result !== 'string') {\r\n            // Binary chunk.\r\n            const binaryChunk = this.getPaddedArrayBuffer(reader.result);\r\n            const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n            binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\r\n            binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true); // JSON chunk.\r\n\r\n            const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(json)), 0x20);\r\n            const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\r\n            jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\r\n            jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true); // GLB header.\r\n\r\n            const header = new ArrayBuffer(GLB_HEADER_BYTES);\r\n            const headerView = new DataView(header);\r\n            headerView.setUint32(0, GLB_HEADER_MAGIC, true);\r\n            headerView.setUint32(4, GLB_VERSION, true);\r\n            const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\r\n            headerView.setUint32(8, totalByteLength, true);\r\n            const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\r\n              type: 'application/octet-stream'\r\n            });\r\n            const glbReader = new window.FileReader();\r\n            glbReader.readAsArrayBuffer(glbBlob);\r\n\r\n            glbReader.onloadend = function () {\r\n              if (glbReader.result !== null && typeof glbReader.result !== 'string') {\r\n                onDone(glbReader.result);\r\n              }\r\n            };\r\n          }\r\n        };\r\n      } else {\r\n        if (json.buffers && json.buffers.length > 0) {\r\n          const reader = new window.FileReader();\r\n          reader.readAsDataURL(blob);\r\n\r\n          reader.onloadend = function () {\r\n            const base64data = reader.result;\r\n\r\n            if (json.buffers !== undefined && base64data !== null) {\r\n              json.buffers[0].uri = base64data;\r\n              onDone(json);\r\n            }\r\n          };\r\n        } else {\r\n          onDone(json);\r\n        }\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Serializes a userData.\r\n   *\r\n   * @param {THREE.Object3D|THREE.Material} object\r\n   * @param {Object} objectDef\r\n   */\r\n\r\n\r\n  serializeUserData(object, objectDef) {\r\n    if (Object.keys(object.userData).length === 0) return;\r\n    const options = this.options;\r\n    const extensionsUsed = this.extensionsUsed;\r\n\r\n    try {\r\n      const json = JSON.parse(JSON.stringify(object.userData));\r\n\r\n      if (options.includeCustomExtensions && json.gltfExtensions) {\r\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\r\n\r\n        for (const extensionName in json.gltfExtensions) {\r\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\r\n          extensionsUsed[extensionName] = true;\r\n        }\r\n\r\n        delete json.gltfExtensions;\r\n      }\r\n\r\n      if (Object.keys(json).length > 0) objectDef.extras = json;\r\n    } catch (error) {\r\n      if (error instanceof Error) {\r\n        console.warn(\"THREE.GLTFExporter: userData of '\" + object.name + \"' \" + \"won't be serialized because of JSON.stringify error - \" + error.message);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Assign and return a temporal unique id for an object\r\n   * especially which doesn't have .uuid\r\n   * @param  {Object} object\r\n   * @return {Integer}\r\n   */\r\n\r\n\r\n  getUID(object) {\r\n    if (!this.uids.has(object)) this.uids.set(object, this.uid++);\r\n    return this.uids.get(object);\r\n  }\r\n  /**\r\n   * Checks if normal attribute values are normalized.\r\n   *\r\n   * @param {BufferAttribute} normal\r\n   * @returns {Boolean}\r\n   */\r\n\r\n\r\n  isNormalizedNormalAttribute(normal) {\r\n    const cache = this.cache;\r\n    if (cache.attributesNormalized.has(normal)) return false;\r\n    const v = new Vector3();\r\n\r\n    for (let i = 0, il = normal.count; i < il; i++) {\r\n      // 0.0005 is from glTF-validator\r\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * Creates normalized normal buffer attribute.\r\n   *\r\n   * @param {BufferAttribute} normal\r\n   * @returns {BufferAttribute}\r\n   *\r\n   */\r\n\r\n\r\n  createNormalizedNormalAttribute(normal) {\r\n    const cache = this.cache;\r\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\r\n    const attribute = normal.clone();\r\n    const v = new Vector3();\r\n\r\n    for (let i = 0, il = attribute.count; i < il; i++) {\r\n      v.fromBufferAttribute(attribute, i);\r\n\r\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\r\n        // if values can't be normalized set (1, 0, 0)\r\n        v.setX(1.0);\r\n      } else {\r\n        v.normalize();\r\n      }\r\n\r\n      attribute.setXYZ(i, v.x, v.y, v.z);\r\n    }\r\n\r\n    cache.attributesNormalized.set(normal, attribute);\r\n    return attribute;\r\n  }\r\n  /**\r\n   * Applies a texture transform, if present, to the map definition. Requires\r\n   * the KHR_texture_transform extension.\r\n   *\r\n   * @param {Object} mapDef\r\n   * @param {THREE.Texture} texture\r\n   */\r\n\r\n\r\n  applyTextureTransform(mapDef, texture) {\r\n    let didTransform = false;\r\n    const transformDef = {};\r\n\r\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\r\n      transformDef.offset = texture.offset.toArray();\r\n      didTransform = true;\r\n    }\r\n\r\n    if (texture.rotation !== 0) {\r\n      transformDef.rotation = texture.rotation;\r\n      didTransform = true;\r\n    }\r\n\r\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\r\n      transformDef.scale = texture.repeat.toArray();\r\n      didTransform = true;\r\n    }\r\n\r\n    if (didTransform) {\r\n      mapDef.extensions = mapDef.extensions || {};\r\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\r\n      this.extensionsUsed['KHR_texture_transform'] = true;\r\n    }\r\n  }\r\n  /**\r\n   * Process a buffer to append to the default one.\r\n   * @param  {ArrayBuffer} buffer\r\n   * @return {Integer}\r\n   */\r\n\r\n\r\n  processBuffer(buffer) {\r\n    const json = this.json;\r\n    const buffers = this.buffers;\r\n    if (!json.buffers) json.buffers = [{\r\n      byteLength: 0\r\n    }]; // All buffers are merged before export.\r\n\r\n    buffers.push(buffer);\r\n    return 0;\r\n  }\r\n  /**\r\n   * Process and generate a BufferView\r\n   * @param  {BufferAttribute} attribute\r\n   * @param  {number} componentType\r\n   * @param  {number} start\r\n   * @param  {number} count\r\n   * @param  {number} target (Optional) Target usage of the BufferView\r\n   * @return {Object}\r\n   */\r\n\r\n\r\n  processBufferView(attribute, componentType, start, count, target) {\r\n    const json = this.json;\r\n    if (!json.bufferViews) json.bufferViews = []; // Create a new dataview and dump the attribute's array into it\r\n\r\n    let componentSize;\r\n\r\n    if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n      componentSize = 1;\r\n    } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n      componentSize = 2;\r\n    } else {\r\n      componentSize = 4;\r\n    }\r\n\r\n    const byteLength = this.getPaddedBufferSize(count * attribute.itemSize * componentSize);\r\n    const dataView = new DataView(new ArrayBuffer(byteLength));\r\n    let offset = 0;\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      for (let a = 0; a < attribute.itemSize; a++) {\r\n        let value;\r\n\r\n        if (attribute.itemSize > 4) {\r\n          // no support for interleaved data for itemSize > 4\r\n          value = attribute.array[i * attribute.itemSize + a];\r\n        } else {\r\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\r\n        }\r\n\r\n        if (value !== undefined) {\r\n          if (componentType === WEBGL_CONSTANTS.FLOAT) {\r\n            dataView.setFloat32(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\r\n            dataView.setUint32(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\r\n            dataView.setUint16(offset, value, true);\r\n          } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\r\n            dataView.setUint8(offset, value);\r\n          }\r\n        }\r\n\r\n        offset += componentSize;\r\n      }\r\n    }\r\n\r\n    const bufferViewDef = {\r\n      buffer: this.processBuffer(dataView.buffer),\r\n      byteOffset: this.byteOffset,\r\n      byteLength: byteLength\r\n    };\r\n    if (target !== undefined) bufferViewDef.target = target;\r\n\r\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\r\n      // Only define byteStride for vertex attributes.\r\n      bufferViewDef.byteStride = attribute.itemSize * componentSize;\r\n    }\r\n\r\n    this.byteOffset += byteLength;\r\n    json.bufferViews.push(bufferViewDef); // @TODO Merge bufferViews where possible.\r\n\r\n    const output = {\r\n      id: json.bufferViews.length - 1,\r\n      byteLength: 0\r\n    };\r\n    return output;\r\n  }\r\n  /**\r\n   * Process and generate a BufferView from an image Blob.\r\n   * @param {Blob} blob\r\n   * @return {Promise<Integer>}\r\n   */\r\n\r\n\r\n  processBufferViewImage(blob) {\r\n    const writer = this;\r\n    const json = writer.json;\r\n    if (!json.bufferViews) json.bufferViews = [];\r\n    return new Promise(resolve => {\r\n      const reader = new window.FileReader();\r\n      reader.readAsArrayBuffer(blob);\r\n\r\n      reader.onloadend = () => {\r\n        if (reader.result !== null && typeof reader.result !== 'string' && json.bufferViews !== undefined) {\r\n          const buffer = this.getPaddedArrayBuffer(reader.result);\r\n          const bufferViewDef = {\r\n            buffer: writer.processBuffer(buffer),\r\n            byteOffset: writer.byteOffset,\r\n            byteLength: buffer.byteLength\r\n          };\r\n          writer.byteOffset += buffer.byteLength;\r\n          resolve(json.bufferViews.push(bufferViewDef) - 1);\r\n        }\r\n      };\r\n    });\r\n  }\r\n  /**\r\n   * Process attribute to generate an accessor\r\n   * @param  {BufferAttribute} attribute Attribute to process\r\n   * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\r\n   * @param  {Integer} start (Optional)\r\n   * @param  {Integer} count (Optional)\r\n   * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\r\n   */\r\n\r\n\r\n  processAccessor(attribute, geometry, start, count) {\r\n    const options = this.options;\r\n    const json = this.json;\r\n    const types = {\r\n      1: 'SCALAR',\r\n      2: 'VEC2',\r\n      3: 'VEC3',\r\n      4: 'VEC4',\r\n      16: 'MAT4'\r\n    };\r\n    let componentType; // Detect the component type of the attribute array (float, uint or ushort)\r\n\r\n    if (attribute.array.constructor === Float32Array) {\r\n      componentType = WEBGL_CONSTANTS.FLOAT;\r\n    } else if (attribute.array.constructor === Uint32Array) {\r\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\r\n    } else if (attribute.array.constructor === Uint16Array) {\r\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\r\n    } else if (attribute.array.constructor === Uint8Array) {\r\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\r\n    } else {\r\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type.');\r\n    }\r\n\r\n    if (start === undefined) start = 0;\r\n    if (count === undefined) count = attribute.count; // @TODO Indexed buffer geometry with drawRange not supported yet\r\n\r\n    if (options.truncateDrawRange && geometry !== undefined && geometry.index === null) {\r\n      const end = start + count;\r\n      const end2 = geometry.drawRange.count === Infinity ? attribute.count : geometry.drawRange.start + geometry.drawRange.count;\r\n      start = Math.max(start, geometry.drawRange.start);\r\n      count = Math.min(end, end2) - start;\r\n      if (count < 0) count = 0;\r\n    } // Skip creating an accessor if the attribute doesn't have data to export\r\n\r\n\r\n    if (count === 0) return null;\r\n    const minMax = this.getMinMax(attribute, start, count);\r\n    let bufferViewTarget; // If geometry isn't provided, don't infer the target usage of the bufferView. For\r\n    // animation samplers, target must not be set.\r\n\r\n    if (geometry !== undefined) {\r\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\r\n    }\r\n\r\n    if (bufferViewTarget !== undefined) {\r\n      const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\r\n      const accessorDef = {\r\n        bufferView: bufferView.id,\r\n        byteOffset: bufferView.byteOffset,\r\n        componentType: componentType,\r\n        count: count,\r\n        max: minMax.max,\r\n        min: minMax.min,\r\n        type: types[attribute.itemSize]\r\n      };\r\n      if (attribute.normalized) accessorDef.normalized = true;\r\n      if (!json.accessors) json.accessors = [];\r\n      return json.accessors.push(accessorDef) - 1;\r\n    }\r\n  }\r\n  /**\r\n   * Process image\r\n   * @param  {Image} image to process\r\n   * @param  {Integer} format of the image (RGBAFormat)\r\n   * @param  {Boolean} flipY before writing out the image\r\n   * @return {Integer}     Index of the processed texture in the \"images\" array\r\n   */\r\n\r\n\r\n  processImage(image, format, flipY) {\r\n    const writer = this;\r\n    const cache = writer.cache;\r\n    const json = writer.json;\r\n    const options = writer.options;\r\n    const pending = writer.pending;\r\n    if (!cache.images.has(image)) cache.images.set(image, {});\r\n    const cachedImages = cache.images.get(image);\r\n    const mimeType = format === RGBAFormat ? 'image/png' : 'image/jpeg';\r\n    const key = mimeType + ':flipY/' + flipY.toString();\r\n    if (cachedImages !== undefined && cachedImages[key] !== undefined) return cachedImages[key];\r\n    if (!json.images) json.images = [];\r\n    const imageDef = {\r\n      mimeType: mimeType\r\n    };\r\n\r\n    if (options.embedImages && options.maxTextureSize !== undefined) {\r\n      const canvas = this.cachedCanvas = this.cachedCanvas || document.createElement('canvas');\r\n      canvas.width = Math.min(image.width, options.maxTextureSize);\r\n      canvas.height = Math.min(image.height, options.maxTextureSize);\r\n      const ctx = canvas.getContext('2d');\r\n\r\n      if (flipY) {\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.translate(0, canvas.height);\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.scale(1, -1);\r\n      }\r\n\r\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\r\n      } else {\r\n        if (format !== RGBAFormat) {\r\n          console.error('GLTFExporter: Only RGBA format is supported.');\r\n        }\r\n\r\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\r\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\r\n        }\r\n\r\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\r\n\r\n        if (image instanceof ImageData) {\r\n          for (let i = 0; i < data.length; i += 4) {\r\n            data[i + 0] = image.data[i + 0];\r\n            data[i + 1] = image.data[i + 1];\r\n            data[i + 2] = image.data[i + 2];\r\n            data[i + 3] = image.data[i + 3];\r\n          }\r\n        }\r\n\r\n        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\r\n      }\r\n\r\n      if (options.binary) {\r\n        pending.push(new Promise(function (resolve) {\r\n          canvas.toBlob(function (blob) {\r\n            if (blob !== null) {\r\n              writer.processBufferViewImage(blob).then(function (bufferViewIndex) {\r\n                imageDef.bufferView = bufferViewIndex; // @ts-expect-error\r\n\r\n                resolve();\r\n              });\r\n            }\r\n          }, mimeType);\r\n        }));\r\n      } else {\r\n        imageDef.uri = canvas.toDataURL(mimeType);\r\n      }\r\n    } else if (image instanceof Image) {\r\n      imageDef.uri = image.src;\r\n    }\r\n\r\n    const index = json.images.push(imageDef) - 1;\r\n    if (cachedImages !== undefined) cachedImages[key] = index;\r\n    return index;\r\n  }\r\n  /**\r\n   * Process sampler\r\n   * @param  {Texture} map Texture to process\r\n   * @return {Integer}     Index of the processed texture in the \"samplers\" array\r\n   */\r\n\r\n\r\n  processSampler(map) {\r\n    const json = this.json;\r\n    if (!json.samplers) json.samplers = [];\r\n    const samplerDef = {\r\n      magFilter: THREE_TO_WEBGL[map.magFilter],\r\n      minFilter: THREE_TO_WEBGL[map.minFilter],\r\n      wrapS: THREE_TO_WEBGL[map.wrapS],\r\n      wrapT: THREE_TO_WEBGL[map.wrapT]\r\n    };\r\n    return json.samplers.push(samplerDef) - 1;\r\n  }\r\n  /**\r\n   * Process texture\r\n   * @param  {Texture} map Map to process\r\n   * @return {Integer} Index of the processed texture in the \"textures\" array\r\n   */\r\n\r\n\r\n  processTexture(map) {\r\n    const cache = this.cache;\r\n    const json = this.json;\r\n    if (cache.textures.has(map)) return cache.textures.get(map);\r\n    if (!json.textures) json.textures = [];\r\n    const textureDef = {\r\n      sampler: this.processSampler(map),\r\n      source: this.processImage(map.image, map.format, map.flipY)\r\n    };\r\n    if (map.name) textureDef.name = map.name;\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeTexture && ext.writeTexture(map, textureDef);\r\n    });\r\n\r\n    const index = json.textures.push(textureDef) - 1;\r\n    cache.textures.set(map, index);\r\n    return index;\r\n  }\r\n  /**\r\n   * Process material\r\n   * @param  {THREE.Material} material Material to process\r\n   * @return {Integer|null} Index of the processed material in the \"materials\" array\r\n   */\r\n\r\n\r\n  processMaterial(material) {\r\n    const cache = this.cache;\r\n    const json = this.json;\r\n    if (cache.materials.has(material)) return cache.materials.get(material);\r\n\r\n    if (material instanceof ShaderMaterial && material.isShaderMaterial) {\r\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\r\n      return null;\r\n    }\r\n\r\n    if (!json.materials) json.materials = []; // @QUESTION Should we avoid including any attribute that has the default value?\r\n\r\n    const materialDef = {\r\n      pbrMetallicRoughness: {}\r\n    };\r\n\r\n    if (!(material instanceof MeshStandardMaterial && material.isMeshStandardMaterial && material instanceof MeshBasicMaterial && // @ts-expect-error\r\n    material.isMeshBasicMaterial)) {\r\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\r\n    }\r\n\r\n    if (material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) {\r\n      // pbrMetallicRoughness.baseColorFactor\r\n      const color = material.color.toArray().concat([material.opacity]);\r\n\r\n      if (!this.equalArray(color, [1, 1, 1, 1])) {\r\n        materialDef.pbrMetallicRoughness.baseColorFactor = color;\r\n      }\r\n    }\r\n\r\n    if (material instanceof MeshStandardMaterial && material.isMeshStandardMaterial) {\r\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\r\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\r\n    } else {\r\n      materialDef.pbrMetallicRoughness.metallicFactor = 0.5;\r\n      materialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\r\n    } // pbrMetallicRoughness.metallicRoughnessTexture\r\n\r\n\r\n    if (material instanceof MeshStandardMaterial && material.metalnessMap || material instanceof MeshStandardMaterial && material.roughnessMap) {\r\n      if (material.metalnessMap === material.roughnessMap && material.metalnessMap !== null) {\r\n        const metalRoughMapDef = {\r\n          index: this.processTexture(material.metalnessMap)\r\n        };\r\n        this.applyTextureTransform(metalRoughMapDef, material.metalnessMap);\r\n        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\r\n      } else {\r\n        console.warn('THREE.GLTFExporter: Ignoring metalnessMap and roughnessMap because they are not the same Texture.');\r\n      }\r\n    } // pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\r\n\r\n\r\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.map) {\r\n      const baseColorMapDef = {\r\n        index: this.processTexture(material.map)\r\n      };\r\n      this.applyTextureTransform(baseColorMapDef, material.map);\r\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\r\n    }\r\n\r\n    if ((material instanceof MeshStandardMaterial || material instanceof MeshPhysicalMaterial) && material.emissive) {\r\n      // note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\r\n      const emissive = material.emissive.clone().multiplyScalar(material.emissiveIntensity);\r\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\r\n\r\n      if (maxEmissiveComponent > 1) {\r\n        emissive.multiplyScalar(1 / maxEmissiveComponent);\r\n        console.warn('THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited');\r\n      }\r\n\r\n      if (maxEmissiveComponent > 0) {\r\n        materialDef.emissiveFactor = emissive.toArray();\r\n      } // emissiveTexture\r\n\r\n\r\n      if (material.emissiveMap) {\r\n        const emissiveMapDef = {\r\n          index: this.processTexture(material.emissiveMap)\r\n        };\r\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\r\n        materialDef.emissiveTexture = emissiveMapDef;\r\n      }\r\n    } // normalTexture\r\n\r\n\r\n    if ((material instanceof MeshMatcapMaterial || material instanceof MeshNormalMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.normalMap) {\r\n      const normalMapDef = {\r\n        index: this.processTexture(material.normalMap)\r\n      };\r\n\r\n      if (material.normalScale && material.normalScale.x !== 1) {\r\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\r\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n        normalMapDef.scale = material.normalScale.x;\r\n      }\r\n\r\n      this.applyTextureTransform(normalMapDef, material.normalMap);\r\n      materialDef.normalTexture = normalMapDef;\r\n    } // occlusionTexture\r\n\r\n\r\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial || material instanceof MeshStandardMaterial || material instanceof MeshToonMaterial) && material.aoMap) {\r\n      const occlusionMapDef = {\r\n        index: this.processTexture(material.aoMap),\r\n        texCoord: 1\r\n      };\r\n\r\n      if (material.aoMapIntensity !== 1.0) {\r\n        occlusionMapDef.strength = material.aoMapIntensity;\r\n      }\r\n\r\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\r\n      materialDef.occlusionTexture = occlusionMapDef;\r\n    } // alphaMode\r\n\r\n\r\n    if (material.transparent) {\r\n      materialDef.alphaMode = 'BLEND';\r\n    } else {\r\n      if (material.alphaTest > 0.0) {\r\n        materialDef.alphaMode = 'MASK';\r\n        materialDef.alphaCutoff = material.alphaTest;\r\n      }\r\n    } // doubleSided\r\n\r\n\r\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\r\n    if (material.name !== '') materialDef.name = material.name;\r\n    this.serializeUserData(material, materialDef);\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeMaterial && ext.writeMaterial(material, materialDef);\r\n    });\r\n\r\n    const index = json.materials.push(materialDef) - 1;\r\n    cache.materials.set(material, index);\r\n    return index;\r\n  }\r\n  /**\r\n   * Process mesh\r\n   * @param  {THREE.Mesh} mesh Mesh to process\r\n   * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\r\n   */\r\n\r\n\r\n  processMesh(mesh) {\r\n    const cache = this.cache;\r\n    const json = this.json;\r\n    const meshCacheKeyParts = [mesh.geometry.uuid];\r\n\r\n    if (Array.isArray(mesh.material)) {\r\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\r\n        meshCacheKeyParts.push(mesh.material[i].uuid);\r\n      }\r\n    } else {\r\n      meshCacheKeyParts.push(mesh.material.uuid);\r\n    }\r\n\r\n    const meshCacheKey = meshCacheKeyParts.join(':');\r\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\r\n    const geometry = mesh.geometry;\r\n    let mode; // Use the correct mode\r\n\r\n    if (mesh instanceof LineSegments && mesh.isLineSegments) {\r\n      mode = WEBGL_CONSTANTS.LINES;\r\n    } else if (mesh instanceof LineLoop && mesh.isLineLoop) {\r\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\r\n    } else if (mesh instanceof Line && mesh.isLine) {\r\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\r\n    } else if (mesh instanceof Points && mesh.isPoints) {\r\n      mode = WEBGL_CONSTANTS.POINTS;\r\n    } else {\r\n      mode = (mesh.material instanceof MeshBasicMaterial || mesh.material instanceof MeshDepthMaterial || mesh.material instanceof MeshLambertMaterial || mesh.material instanceof MeshNormalMaterial || mesh.material instanceof MeshPhongMaterial || mesh.material instanceof MeshStandardMaterial || mesh.material instanceof MeshToonMaterial || mesh.material instanceof ShaderMaterial) && mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\r\n    }\r\n\r\n    if (!geometry.isBufferGeometry) {\r\n      throw new Error('THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.');\r\n    }\r\n\r\n    const meshDef = {};\r\n    const attributes = {};\r\n    const primitives = [];\r\n    const targets = []; // Conversion between attributes names in threejs and gltf spec\r\n\r\n    const nameConversion = {\r\n      uv: 'TEXCOORD_0',\r\n      uv2: 'TEXCOORD_1',\r\n      color: 'COLOR_0',\r\n      skinWeight: 'WEIGHTS_0',\r\n      skinIndex: 'JOINTS_0'\r\n    };\r\n    const originalNormal = geometry.getAttribute('normal');\r\n\r\n    if (originalNormal !== undefined && !(originalNormal instanceof InterleavedBufferAttribute) && !this.isNormalizedNormalAttribute(originalNormal)) {\r\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\r\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\r\n    } // @QUESTION Detect if .vertexColors = true?\r\n    // For every attribute create an accessor\r\n\r\n\r\n    let modifiedAttribute = null;\r\n\r\n    for (let attributeName in geometry.attributes) {\r\n      // Ignore morph target attributes, which are exported later.\r\n      if (attributeName.substr(0, 5) === 'morph') continue;\r\n      const attribute = geometry.attributes[attributeName];\r\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase(); // Prefix all geometry attributes except the ones specifically\r\n      // listed in the spec; non-spec attributes are considered custom.\r\n\r\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\r\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\r\n\r\n      if (cache.attributes.has(this.getUID(attribute))) {\r\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\r\n        continue;\r\n      } // JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\r\n\r\n\r\n      modifiedAttribute = null;\r\n      const array = attribute.array;\r\n\r\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\r\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\r\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\r\n      }\r\n\r\n      const accessor = modifiedAttribute !== null && this.processAccessor(modifiedAttribute || attribute, geometry);\r\n\r\n      if (accessor) {\r\n        attributes[attributeName] = accessor;\r\n        cache.attributes.set(this.getUID(attribute), accessor);\r\n      }\r\n    }\r\n\r\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal); // Skip if no exportable attributes found\r\n\r\n    if (Object.keys(attributes).length === 0) return null; // Morph targets\r\n\r\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\r\n      const weights = [];\r\n      const targetNames = [];\r\n      const reverseDictionary = {};\r\n\r\n      if (mesh.morphTargetDictionary !== undefined) {\r\n        for (const key in mesh.morphTargetDictionary) {\r\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\r\n        const target = {};\r\n        let warned = false;\r\n\r\n        for (const attributeName in geometry.morphAttributes) {\r\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\r\n          // Three.js doesn't support TANGENT yet.\r\n          if (attributeName !== 'position' && attributeName !== 'normal') {\r\n            if (!warned) {\r\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\r\n              warned = true;\r\n            }\r\n\r\n            continue;\r\n          }\r\n\r\n          const attribute = geometry.morphAttributes[attributeName][i];\r\n          const gltfAttributeName = attributeName.toUpperCase(); // Three.js morph attribute has absolute values while the one of glTF has relative values.\r\n          //\r\n          // glTF 2.0 Specification:\r\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\r\n\r\n          const baseAttribute = geometry.attributes[attributeName];\r\n\r\n          if (cache.attributes.has(this.getUID(attribute))) {\r\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute));\r\n            continue;\r\n          } // Clones attribute not to override\r\n\r\n\r\n          const relativeAttribute = attribute.clone();\r\n\r\n          if (!geometry.morphTargetsRelative) {\r\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\r\n              relativeAttribute.setXYZ(j, attribute.getX(j) - baseAttribute.getX(j), attribute.getY(j) - baseAttribute.getY(j), attribute.getZ(j) - baseAttribute.getZ(j));\r\n            }\r\n          }\r\n\r\n          const accessor = this.processAccessor(relativeAttribute, geometry);\r\n\r\n          if (accessor != undefined) {\r\n            target[gltfAttributeName] = accessor;\r\n          }\r\n\r\n          cache.attributes.set(this.getUID(baseAttribute), target[gltfAttributeName]);\r\n        }\r\n\r\n        targets.push(target);\r\n        weights.push(mesh.morphTargetInfluences[i]);\r\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\r\n      }\r\n\r\n      meshDef.weights = weights;\r\n\r\n      if (targetNames.length > 0) {\r\n        meshDef.extras = {};\r\n        meshDef.extras.targetNames = targetNames;\r\n      }\r\n    }\r\n\r\n    const isMultiMaterial = Array.isArray(mesh.material);\r\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\r\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\r\n    const groups = isMultiMaterial ? geometry.groups : [{\r\n      materialIndex: 0,\r\n      start: undefined,\r\n      count: undefined\r\n    }];\r\n\r\n    for (let i = 0, il = groups.length; i < il; i++) {\r\n      const primitive = {\r\n        mode: mode,\r\n        attributes: attributes\r\n      };\r\n\r\n      if (geometry instanceof Object3D || geometry instanceof Material) {\r\n        this.serializeUserData(geometry, primitive);\r\n      }\r\n\r\n      if (targets.length > 0) primitive.targets = targets;\r\n\r\n      if (geometry.index !== null) {\r\n        let cacheKey = this.getUID(geometry.index);\r\n\r\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\r\n          // @ts-expect-error\r\n          cacheKey += `:${groups[i].start}:${groups[i].count}`;\r\n        }\r\n\r\n        if (cache.attributes.has(cacheKey)) {\r\n          primitive.indices = cache.attributes.get(cacheKey);\r\n        } else {\r\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\r\n          cache.attributes.set(cacheKey, primitive.indices);\r\n        }\r\n\r\n        if (primitive.indices === null) delete primitive.indices;\r\n      }\r\n\r\n      const materialIndex = groups[i].materialIndex;\r\n\r\n      if (materialIndex !== undefined && Array.isArray(materials)) {\r\n        const targetMaterials = materials[materialIndex];\r\n\r\n        if (!Array.isArray(targetMaterials)) {\r\n          const material = this.processMaterial(targetMaterials);\r\n          if (material !== null) primitive.material = material;\r\n          primitives.push(primitive);\r\n        }\r\n      }\r\n    }\r\n\r\n    meshDef.primitives = primitives;\r\n    if (!json.meshes) json.meshes = [];\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\r\n    });\r\n\r\n    const index = json.meshes.push(meshDef) - 1;\r\n    cache.meshes.set(meshCacheKey, index);\r\n    return index;\r\n  }\r\n  /**\r\n   * Process camera\r\n   * @param  {THREE.Camera} camera Camera to process\r\n   * @return {Integer}      Index of the processed mesh in the \"camera\" array\r\n   */\r\n\r\n\r\n  processCamera(camera) {\r\n    const json = this.json;\r\n    if (!json.cameras) json.cameras = [];\r\n    const isOrtho = camera instanceof OrthographicCamera && camera.isOrthographicCamera;\r\n    const cameraDef = {\r\n      type: isOrtho ? 'orthographic' : 'perspective'\r\n    };\r\n\r\n    if (camera instanceof OrthographicCamera && isOrtho) {\r\n      cameraDef.orthographic = {\r\n        xmag: camera.right * 2,\r\n        ymag: camera.top * 2,\r\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n        znear: camera.near < 0 ? 0 : camera.near\r\n      };\r\n    } else if (camera instanceof PerspectiveCamera) {\r\n      cameraDef.perspective = {\r\n        aspectRatio: camera.aspect,\r\n        yfov: MathUtils.degToRad(camera.fov),\r\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\r\n        znear: camera.near < 0 ? 0 : camera.near\r\n      };\r\n    } // Question: Is saving \"type\" as name intentional?\r\n\r\n\r\n    if (camera.name !== '') cameraDef.name = camera.type;\r\n    return json.cameras.push(cameraDef) - 1;\r\n  }\r\n  /**\r\n   * Creates glTF animation entry from AnimationClip object.\r\n   *\r\n   * Status:\r\n   * - Only properties listed in PATH_PROPERTIES may be animated.\r\n   *\r\n   * @param {THREE.AnimationClip} clip\r\n   * @param {THREE.Object3D} root\r\n   * @return {number|null}\r\n   */\r\n\r\n\r\n  processAnimation(clip, root) {\r\n    const json = this.json;\r\n    const nodeMap = this.nodeMap;\r\n    if (!json.animations) json.animations = [];\r\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\r\n    const tracks = clip.tracks;\r\n    const channels = [];\r\n    const samplers = [];\r\n\r\n    for (let i = 0; i < tracks.length; ++i) {\r\n      const track = tracks[i];\r\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\r\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\r\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\r\n\r\n      if (trackBinding.objectName === 'bones') {\r\n        if (trackNode.isSkinnedMesh) {\r\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\r\n        } else {\r\n          trackNode = undefined;\r\n        }\r\n      }\r\n\r\n      if (!trackNode || !trackProperty) {\r\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\r\n        return null;\r\n      }\r\n\r\n      const inputItemSize = 1;\r\n      let outputItemSize = track.values.length / track.times.length;\r\n\r\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\r\n        outputItemSize /= trackNode.morphTargetInfluences.length;\r\n      }\r\n\r\n      let interpolation; // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\r\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\r\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\r\n      // valid value from .getInterpolation().\r\n      // @ts-expect-error\r\n\r\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\r\n        interpolation = 'CUBICSPLINE'; // itemSize of CUBICSPLINE keyframe is 9\r\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\r\n        // but needs to be stored as VEC3 so dividing by 3 here.\r\n\r\n        outputItemSize /= 3;\r\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\r\n        interpolation = 'STEP';\r\n      } else {\r\n        interpolation = 'LINEAR';\r\n      }\r\n\r\n      samplers.push({\r\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\r\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\r\n        interpolation: interpolation\r\n      });\r\n      channels.push({\r\n        sampler: samplers.length - 1,\r\n        target: {\r\n          node: nodeMap.get(trackNode),\r\n          path: trackProperty\r\n        }\r\n      });\r\n    }\r\n\r\n    json.animations.push({\r\n      name: clip.name || 'clip_' + json.animations.length,\r\n      samplers: samplers,\r\n      channels: channels\r\n    });\r\n    return json.animations.length - 1;\r\n  }\r\n  /**\r\n   * @param {THREE.Object3D} object\r\n   * @return {number|null}\r\n   */\r\n\r\n\r\n  processSkin(object) {\r\n    const json = this.json;\r\n    const nodeMap = this.nodeMap;\r\n\r\n    if (json.nodes !== undefined && object instanceof SkinnedMesh) {\r\n      const node = json.nodes[nodeMap.get(object)];\r\n      const skeleton = object.skeleton;\r\n      if (skeleton === undefined) return null;\r\n      const rootJoint = object.skeleton.bones[0];\r\n      if (rootJoint === undefined) return null;\r\n      const joints = [];\r\n      const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\r\n      const temporaryBoneInverse = new Matrix4();\r\n\r\n      for (let i = 0; i < skeleton.bones.length; ++i) {\r\n        joints.push(nodeMap.get(skeleton.bones[i]));\r\n        temporaryBoneInverse.copy(skeleton.boneInverses[i]);\r\n        temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\r\n      }\r\n\r\n      if (json.skins === undefined) json.skins = [];\r\n      json.skins.push({\r\n        inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\r\n        joints: joints,\r\n        skeleton: nodeMap.get(rootJoint)\r\n      });\r\n      const skinIndex = node.skin = json.skins.length - 1;\r\n      return skinIndex;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  /**\r\n   * Process Object3D node\r\n   * @param  {THREE.Object3D} node Object3D to processNode\r\n   * @return {Integer} Index of the node in the nodes list\r\n   */\r\n\r\n\r\n  processNode(object) {\r\n    const json = this.json;\r\n    const options = this.options;\r\n    const nodeMap = this.nodeMap;\r\n    if (!json.nodes) json.nodes = [];\r\n    const nodeDef = {};\r\n\r\n    if (options.trs) {\r\n      const rotation = object.quaternion.toArray();\r\n      const position = object.position.toArray();\r\n      const scale = object.scale.toArray();\r\n\r\n      if (!this.equalArray(rotation, [0, 0, 0, 1])) {\r\n        nodeDef.rotation = rotation;\r\n      }\r\n\r\n      if (!this.equalArray(position, [0, 0, 0])) {\r\n        nodeDef.translation = position;\r\n      }\r\n\r\n      if (!this.equalArray(scale, [1, 1, 1])) {\r\n        nodeDef.scale = scale;\r\n      }\r\n    } else {\r\n      if (object.matrixAutoUpdate) {\r\n        object.updateMatrix();\r\n      }\r\n\r\n      if (!this.isIdentityMatrix(object.matrix)) {\r\n        nodeDef.matrix = object.matrix.elements;\r\n      }\r\n    } // We don't export empty strings name because it represents no-name in Three.js.\r\n\r\n\r\n    if (object.name !== '') nodeDef.name = String(object.name);\r\n    this.serializeUserData(object, nodeDef);\r\n\r\n    if ((object instanceof Mesh && object.isMesh || object instanceof Line && object.isLine || object instanceof Points && object.isPoints) && object instanceof Mesh) {\r\n      const meshIndex = this.processMesh(object);\r\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\r\n    } else if (object instanceof Camera && object.isCamera) {\r\n      nodeDef.camera = this.processCamera(object);\r\n    }\r\n\r\n    if (object instanceof SkinnedMesh && object.isSkinnedMesh) this.skins.push(object);\r\n\r\n    if (object.children.length > 0) {\r\n      const children = [];\r\n\r\n      for (let i = 0, l = object.children.length; i < l; i++) {\r\n        const child = object.children[i];\r\n\r\n        if (child.visible || !options.onlyVisible) {\r\n          const nodeIndex = this.processNode(child);\r\n          if (nodeIndex !== null) children.push(nodeIndex);\r\n        }\r\n      }\r\n\r\n      if (children.length > 0) nodeDef.children = children;\r\n    }\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.writeNode && ext.writeNode(object, nodeDef);\r\n    });\r\n\r\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\r\n    nodeMap.set(object, nodeIndex);\r\n    return nodeIndex;\r\n  }\r\n  /**\r\n   * Process Scene\r\n   * @param  {Scene} node Scene to process\r\n   */\r\n\r\n\r\n  processScene(scene) {\r\n    const json = this.json;\r\n    const options = this.options;\r\n\r\n    if (!json.scenes) {\r\n      json.scenes = [];\r\n      json.scene = 0;\r\n    }\r\n\r\n    const sceneDef = {};\r\n    if (scene.name !== '') sceneDef.name = scene.name;\r\n    json.scenes.push(sceneDef);\r\n    const nodes = [];\r\n\r\n    for (let i = 0, l = scene.children.length; i < l; i++) {\r\n      const child = scene.children[i];\r\n\r\n      if (child.visible || !options.onlyVisible) {\r\n        const nodeIndex = this.processNode(child);\r\n        if (nodeIndex !== null) nodes.push(nodeIndex);\r\n      }\r\n    }\r\n\r\n    if (nodes.length > 0) sceneDef.nodes = nodes;\r\n    this.serializeUserData(scene, sceneDef);\r\n  }\r\n\r\n  processObjects(objects) {\r\n    const scene = new Scene();\r\n    scene.name = 'AuxScene';\r\n\r\n    for (let i = 0; i < objects.length; i++) {\r\n      // We push directly to children instead of calling `add` to prevent\r\n      // modify the .parent and break its original scene and hierarchy\r\n      scene.children.push(objects[i]);\r\n    }\r\n\r\n    this.processScene(scene);\r\n  }\r\n  /**\r\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\r\n   */\r\n\r\n\r\n  processInput(input) {\r\n    const options = this.options;\r\n    input = input instanceof Array ? input : [input];\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.beforeParse && ext.beforeParse(input);\r\n    });\r\n\r\n    const objectsWithoutScene = [];\r\n\r\n    for (let i = 0; i < input.length; i++) {\r\n      const inputScene = input[i];\r\n\r\n      if (inputScene instanceof Scene) {\r\n        this.processScene(inputScene);\r\n      } else {\r\n        objectsWithoutScene.push(input[i]);\r\n      }\r\n    }\r\n\r\n    if (objectsWithoutScene.length > 0) this.processObjects(objectsWithoutScene);\r\n\r\n    for (let i = 0; i < this.skins.length; ++i) {\r\n      this.processSkin(this.skins[i]);\r\n    }\r\n\r\n    for (let i = 0; options.animations !== undefined && i < options.animations.length; ++i) {\r\n      this.processAnimation(options.animations[i], input[0]);\r\n    }\r\n\r\n    this._invokeAll(function (ext) {\r\n      ext.afterParse && ext.afterParse(input);\r\n    });\r\n  }\r\n\r\n  _invokeAll(func) {\r\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\r\n      func(this.plugins[i]);\r\n    }\r\n  } //------------------------------------------------------------------------------\r\n  // Utility functions\r\n  //------------------------------------------------------------------------------\r\n\r\n  /**\r\n   * Compare two arrays\r\n   * @param  {Array} array1 Array 1 to compare\r\n   * @param  {Array} array2 Array 2 to compare\r\n   * @return {Boolean}        Returns true if both arrays are equal\r\n   */\r\n\r\n\r\n  equalArray(array1, array2) {\r\n    return array1.length === array2.length && array1.every(function (element, index) {\r\n      return element === array2[index];\r\n    });\r\n  }\r\n  /**\r\n   * Converts a string to an ArrayBuffer.\r\n   * @param  {string} text\r\n   * @return {ArrayBuffer}\r\n   */\r\n\r\n\r\n  stringToArrayBuffer(text) {\r\n    if (window.TextEncoder !== undefined) {\r\n      return new TextEncoder().encode(text).buffer;\r\n    }\r\n\r\n    const array = new Uint8Array(new ArrayBuffer(text.length));\r\n\r\n    for (let i = 0, il = text.length; i < il; i++) {\r\n      const value = text.charCodeAt(i); // Replacing multi-byte character with space(0x20).\r\n\r\n      array[i] = value > 0xff ? 0x20 : value;\r\n    }\r\n\r\n    return array.buffer;\r\n  }\r\n\r\n  isIdentityMatrix(matrix) {\r\n    return this.equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\r\n  }\r\n\r\n  getMinMax(attribute, start, count) {\r\n    const output = {\r\n      min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\r\n      max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\r\n    };\r\n\r\n    for (let i = start; i < start + count; i++) {\r\n      for (let a = 0; a < attribute.itemSize; a++) {\r\n        let value;\r\n\r\n        if (attribute.itemSize > 4) {\r\n          // no support for interleaved data for itemSize > 4\r\n          value = attribute.array[i * attribute.itemSize + a];\r\n        } else {\r\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\r\n        }\r\n\r\n        if (value !== undefined) {\r\n          output.min[a] = Math.min(output.min[a], value);\r\n          output.max[a] = Math.max(output.max[a], value);\r\n        }\r\n      }\r\n    }\r\n\r\n    return output;\r\n  }\r\n  /**\r\n   * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\r\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\r\n   */\r\n\r\n\r\n  getPaddedBufferSize(bufferSize) {\r\n    return Math.ceil(bufferSize / 4) * 4;\r\n  }\r\n  /**\r\n   * Returns a buffer aligned to 4-byte boundary.\r\n   *\r\n   * @param {ArrayBuffer} arrayBuffer Buffer to pad\r\n   * @param {Integer} paddingByte (Optional)\r\n   * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\r\n   */\r\n\r\n\r\n  getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\r\n    const paddedLength = this.getPaddedBufferSize(arrayBuffer.byteLength);\r\n\r\n    if (paddedLength !== arrayBuffer.byteLength) {\r\n      const array = new Uint8Array(paddedLength);\r\n      array.set(new Uint8Array(arrayBuffer));\r\n\r\n      if (paddingByte !== 0) {\r\n        for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\r\n          array[i] = paddingByte;\r\n        }\r\n      }\r\n\r\n      return array.buffer;\r\n    }\r\n\r\n    return arrayBuffer;\r\n  }\r\n\r\n}\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\n\r\n\r\nclass GLTFLightExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_lights_punctual';\r\n  }\r\n\r\n  writeNode(light, nodeDef) {\r\n    if (!light.isLight) return;\r\n\r\n    if (!(light instanceof DirectionalLight && light.isDirectionalLight) && // @ts-expect-error\r\n    !(light instanceof PointLight && light.isPointLight) && !(light instanceof SpotLight && light.isSpotLight)) {\r\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const json = writer.json;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const lightDef = {};\r\n    if (light.name) lightDef.name = light.name;\r\n    lightDef.color = light.color.toArray();\r\n    lightDef.intensity = light.intensity;\r\n\r\n    if (light instanceof DirectionalLight && light.isDirectionalLight) {\r\n      lightDef.type = 'directional';\r\n    } else if (light instanceof PointLight && // @ts-expect-error\r\n    light.isPointLight) {\r\n      lightDef.type = 'point';\r\n      if (light.distance > 0) lightDef.range = light.distance;\r\n    } else if (light instanceof SpotLight && light.isSpotLight) {\r\n      lightDef.type = 'spot';\r\n      if (light.distance > 0) lightDef.range = light.distance;\r\n      lightDef.spot = {};\r\n      lightDef.spot.innerConeAngle = (light.penumbra - 1.0) * light.angle * -1.0;\r\n      lightDef.spot.outerConeAngle = light.angle;\r\n    }\r\n\r\n    if (!(light instanceof DirectionalLight) && light.decay !== undefined && light.decay !== 2) {\r\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\r\n    }\r\n\r\n    if (!(light instanceof PointLight) && light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\r\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\r\n    }\r\n\r\n    if (!extensionsUsed[this.name]) {\r\n      json.extensions = json.extensions || {};\r\n      json.extensions[this.name] = {\r\n        lights: []\r\n      };\r\n      extensionsUsed[this.name] = true;\r\n    }\r\n\r\n    if (json.extensions !== undefined) {\r\n      const lights = json.extensions[this.name].lights;\r\n      lights.push(lightDef);\r\n      nodeDef.extensions = nodeDef.extensions || {};\r\n      nodeDef.extensions[this.name] = {\r\n        light: lights.length - 1\r\n      };\r\n    }\r\n  }\r\n\r\n}\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\n\r\n\r\nclass GLTFMaterialsUnlitExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_unlit';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    if (!(material instanceof MeshBasicMaterial && // @ts-expect-error\r\n    material.isMeshBasicMaterial)) {\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = {};\r\n    extensionsUsed[this.name] = true;\r\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\r\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\r\n  }\r\n\r\n}\r\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n */\r\n\r\n\r\nclass GLTFMaterialsPBRSpecularGlossiness {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_pbrSpecularGlossiness';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    // @ts-expect-error\r\n    if (!material.isGLTFSpecularGlossinessMaterial) return;\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const extensionDef = {};\r\n\r\n    if (materialDef.pbrMetallicRoughness.baseColorFactor) {\r\n      extensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\r\n    }\r\n\r\n    if (material instanceof MeshPhongMaterial) {\r\n      const specularFactor = [1, 1, 1];\r\n      material.specular.toArray(specularFactor, 0);\r\n      extensionDef.specularFactor = specularFactor;\r\n      extensionDef.glossinessFactor = // @ts-expect-error\r\n      material.glossiness;\r\n    }\r\n\r\n    if (materialDef.pbrMetallicRoughness.baseColorTexture) {\r\n      extensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\r\n    }\r\n\r\n    if ((material instanceof MeshBasicMaterial || material instanceof MeshLambertMaterial || material instanceof MeshPhongMaterial) && material.specularMap) {\r\n      const specularMapDef = {\r\n        index: writer.processTexture(material.specularMap)\r\n      };\r\n      writer.applyTextureTransform(specularMapDef, material.specularMap);\r\n      extensionDef.specularGlossinessTexture = specularMapDef;\r\n    }\r\n\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = extensionDef;\r\n    extensionsUsed[this.name] = true;\r\n  }\r\n\r\n}\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n */\r\n\r\n\r\nclass GLTFMaterialsTransmissionExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_transmission';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\r\n    material.isMeshPhysicalMaterial) || material.transmission === 0) {\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const extensionDef = {};\r\n    extensionDef.transmissionFactor = material.transmission;\r\n\r\n    if (material.transmissionMap) {\r\n      const transmissionMapDef = {\r\n        index: writer.processTexture(material.transmissionMap)\r\n      };\r\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\r\n      extensionDef.transmissionTexture = transmissionMapDef;\r\n    }\r\n\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = extensionDef;\r\n    extensionsUsed[this.name] = true;\r\n  }\r\n\r\n}\r\n/**\r\n * Materials Volume Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\r\n */\r\n\r\n\r\nclass GLTFMaterialsVolumeExtension {\r\n  constructor(writer) {\r\n    _defineProperty(this, \"writer\", void 0);\r\n\r\n    _defineProperty(this, \"name\", void 0);\r\n\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_volume';\r\n  }\r\n\r\n  writeMaterial(material, materialDef) {\r\n    if (!(material instanceof MeshPhysicalMaterial && // @ts-expect-error\r\n    material.isMeshPhysicalMaterial) || material.thickness === 0) {\r\n      return;\r\n    }\r\n\r\n    const writer = this.writer;\r\n    const extensionsUsed = writer.extensionsUsed;\r\n    const extensionDef = {};\r\n    extensionDef.thickness = material.thickness;\r\n\r\n    if (material.thicknessMap) {\r\n      const thicknessMapDef = {\r\n        index: writer.processTexture(material.thicknessMap)\r\n      };\r\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\r\n      extensionDef.thicknessTexture = thicknessMapDef;\r\n    }\r\n\r\n    extensionDef.attenuationDistance = material.attenuationDistance;\r\n    extensionDef.attenuationColor = //@ts-expect-error\r\n    material.attenuationTint.toArray();\r\n    materialDef.extensions = materialDef.extensions || {};\r\n    materialDef.extensions[this.name] = extensionDef;\r\n    extensionsUsed[this.name] = true;\r\n  }\r\n\r\n}\r\n\r\nexport { GLTFExporter };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}