{"ast":null,"code":"import { WebGLRenderTarget } from 'three';\nimport { SSAARenderPass } from './SSAARenderPass.js';\n/**\r\n *\r\n * Temporal Anti-Aliasing Render Pass\r\n *\r\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\r\n *\r\n * References:\r\n *\r\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\r\n *\r\n */\n\nvar TAARenderPass = function TAARenderPass(scene, camera, clearColor, clearAlpha) {\n  if (SSAARenderPass === undefined) {\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\n  }\n\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\n  this.sampleLevel = 0;\n  this.accumulate = false;\n};\n\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\n  constructor: TAARenderPass,\n  render: function render(renderer, writeBuffer, readBuffer, deltaTime) {\n    if (!this.accumulate) {\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\n      this.accumulateIndex = -1;\n      return;\n    }\n\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\n\n    if (!this.sampleRenderTarget) {\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\n    }\n\n    if (!this.holdRenderTarget) {\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\n    }\n\n    if (this.accumulate && this.accumulateIndex === -1) {\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\n      this.accumulateIndex = 0;\n    }\n\n    var autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    var sampleWeight = 1.0 / jitterOffsets.length;\n\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\n      this.copyUniforms['opacity'].value = sampleWeight;\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\n\n      for (var i = 0; i < numSamplesPerFrame; i++) {\n        var j = this.accumulateIndex;\n        var jitterOffset = jitterOffsets[j];\n\n        if (this.camera.setViewOffset) {\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\n          readBuffer.width, readBuffer.height);\n        }\n\n        renderer.setRenderTarget(writeBuffer);\n        renderer.clear();\n        renderer.render(this.scene, this.camera);\n        renderer.setRenderTarget(this.sampleRenderTarget);\n        if (this.accumulateIndex === 0) renderer.clear();\n        this.fsQuad.render(renderer);\n        this.accumulateIndex++;\n        if (this.accumulateIndex >= jitterOffsets.length) break;\n      }\n\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\n    }\n\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\n\n    if (accumulationWeight > 0) {\n      this.copyUniforms['opacity'].value = 1.0;\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    if (accumulationWeight < 1.0) {\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\n      renderer.setRenderTarget(writeBuffer);\n      if (accumulationWeight === 0) renderer.clear();\n      this.fsQuad.render(renderer);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n});\nexport { TAARenderPass };","map":{"version":3,"names":["WebGLRenderTarget","SSAARenderPass","TAARenderPass","scene","camera","clearColor","clearAlpha","undefined","console","error","call","sampleLevel","accumulate","JitterVectors","prototype","Object","assign","create","constructor","render","renderer","writeBuffer","readBuffer","deltaTime","accumulateIndex","jitterOffsets","sampleRenderTarget","width","height","params","texture","name","holdRenderTarget","autoClear","sampleWeight","length","copyUniforms","value","numSamplesPerFrame","Math","pow","i","j","jitterOffset","setViewOffset","setRenderTarget","clear","fsQuad","clearViewOffset","accumulationWeight"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/postprocessing/TAARenderPass.js"],"sourcesContent":["import { WebGLRenderTarget } from 'three';\r\nimport { SSAARenderPass } from './SSAARenderPass.js';\r\n\r\n/**\r\n *\r\n * Temporal Anti-Aliasing Render Pass\r\n *\r\n * When there is no motion in the scene, the TAA render pass accumulates jittered camera samples across frames to create a high quality anti-aliased result.\r\n *\r\n * References:\r\n *\r\n * TODO: Add support for motion vector pas so that accumulation of samples across frames can occur on dynamics scenes.\r\n *\r\n */\r\n\r\nvar TAARenderPass = function (scene, camera, clearColor, clearAlpha) {\r\n  if (SSAARenderPass === undefined) {\r\n    console.error('THREE.TAARenderPass relies on SSAARenderPass');\r\n  }\r\n\r\n  SSAARenderPass.call(this, scene, camera, clearColor, clearAlpha);\r\n  this.sampleLevel = 0;\r\n  this.accumulate = false;\r\n};\r\n\r\nTAARenderPass.JitterVectors = SSAARenderPass.JitterVectors;\r\nTAARenderPass.prototype = Object.assign(Object.create(SSAARenderPass.prototype), {\r\n  constructor: TAARenderPass,\r\n  render: function (renderer, writeBuffer, readBuffer, deltaTime) {\r\n    if (!this.accumulate) {\r\n      SSAARenderPass.prototype.render.call(this, renderer, writeBuffer, readBuffer, deltaTime);\r\n      this.accumulateIndex = -1;\r\n      return;\r\n    }\r\n\r\n    var jitterOffsets = TAARenderPass.JitterVectors[5];\r\n\r\n    if (!this.sampleRenderTarget) {\r\n      this.sampleRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\r\n      this.sampleRenderTarget.texture.name = 'TAARenderPass.sample';\r\n    }\r\n\r\n    if (!this.holdRenderTarget) {\r\n      this.holdRenderTarget = new WebGLRenderTarget(readBuffer.width, readBuffer.height, this.params);\r\n      this.holdRenderTarget.texture.name = 'TAARenderPass.hold';\r\n    }\r\n\r\n    if (this.accumulate && this.accumulateIndex === -1) {\r\n      SSAARenderPass.prototype.render.call(this, renderer, this.holdRenderTarget, readBuffer, deltaTime);\r\n      this.accumulateIndex = 0;\r\n    }\r\n\r\n    var autoClear = renderer.autoClear;\r\n    renderer.autoClear = false;\r\n    var sampleWeight = 1.0 / jitterOffsets.length;\r\n\r\n    if (this.accumulateIndex >= 0 && this.accumulateIndex < jitterOffsets.length) {\r\n      this.copyUniforms['opacity'].value = sampleWeight;\r\n      this.copyUniforms['tDiffuse'].value = writeBuffer.texture; // render the scene multiple times, each slightly jitter offset from the last and accumulate the results.\r\n\r\n      var numSamplesPerFrame = Math.pow(2, this.sampleLevel);\r\n\r\n      for (let i = 0; i < numSamplesPerFrame; i++) {\r\n        var j = this.accumulateIndex;\r\n        var jitterOffset = jitterOffsets[j];\r\n\r\n        if (this.camera.setViewOffset) {\r\n          this.camera.setViewOffset(readBuffer.width, readBuffer.height, jitterOffset[0] * 0.0625, jitterOffset[1] * 0.0625, // 0.0625 = 1 / 16\r\n          readBuffer.width, readBuffer.height);\r\n        }\r\n\r\n        renderer.setRenderTarget(writeBuffer);\r\n        renderer.clear();\r\n        renderer.render(this.scene, this.camera);\r\n        renderer.setRenderTarget(this.sampleRenderTarget);\r\n        if (this.accumulateIndex === 0) renderer.clear();\r\n        this.fsQuad.render(renderer);\r\n        this.accumulateIndex++;\r\n        if (this.accumulateIndex >= jitterOffsets.length) break;\r\n      }\r\n\r\n      if (this.camera.clearViewOffset) this.camera.clearViewOffset();\r\n    }\r\n\r\n    var accumulationWeight = this.accumulateIndex * sampleWeight;\r\n\r\n    if (accumulationWeight > 0) {\r\n      this.copyUniforms['opacity'].value = 1.0;\r\n      this.copyUniforms['tDiffuse'].value = this.sampleRenderTarget.texture;\r\n      renderer.setRenderTarget(writeBuffer);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n    }\r\n\r\n    if (accumulationWeight < 1.0) {\r\n      this.copyUniforms['opacity'].value = 1.0 - accumulationWeight;\r\n      this.copyUniforms['tDiffuse'].value = this.holdRenderTarget.texture;\r\n      renderer.setRenderTarget(writeBuffer);\r\n      if (accumulationWeight === 0) renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n    }\r\n\r\n    renderer.autoClear = autoClear;\r\n  }\r\n});\r\n\r\nexport { TAARenderPass };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}