{"ast":null,"code":"'use client';\n\n// src/use-tabs.ts\nimport { useClickable } from \"@chakra-ui/clickable\";\nimport { createDescendantContext } from \"@chakra-ui/descendant\";\nimport { createContext } from \"@chakra-ui/react-context\";\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { lazyDisclosure } from \"@chakra-ui/lazy-utils\";\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\";\nimport { useCallback, useEffect, useRef, useState, useId, createElement } from \"react\";\nvar [TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant] = createDescendantContext();\nfunction useTabs(props) {\n  var _a;\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props;\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex != null ? defaultIndex : 0);\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex != null ? defaultIndex : 0,\n    value: index,\n    onChange\n  });\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index);\n    }\n  }, [index]);\n  const descendants = useTabsDescendants();\n  const uuid = useId();\n  const uid = (_a = props.id) != null ? _a : uuid;\n  const id = \"tabs-\".concat(uid);\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps\n  };\n}\nvar [TabsProvider, useTabsContext] = createContext({\n  name: \"TabsContext\",\n  errorMessage: \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\"\n});\nfunction useTabList(props) {\n  const {\n    focusedIndex,\n    orientation,\n    direction\n  } = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const onKeyDown = useCallback(event => {\n    const nextTab = () => {\n      var _a;\n      const next = descendants.nextEnabled(focusedIndex);\n      if (next) (_a = next.node) == null ? void 0 : _a.focus();\n    };\n    const prevTab = () => {\n      var _a;\n      const prev = descendants.prevEnabled(focusedIndex);\n      if (prev) (_a = prev.node) == null ? void 0 : _a.focus();\n    };\n    const firstTab = () => {\n      var _a;\n      const first = descendants.firstEnabled();\n      if (first) (_a = first.node) == null ? void 0 : _a.focus();\n    };\n    const lastTab = () => {\n      var _a;\n      const last = descendants.lastEnabled();\n      if (last) (_a = last.node) == null ? void 0 : _a.focus();\n    };\n    const isHorizontal = orientation === \"horizontal\";\n    const isVertical = orientation === \"vertical\";\n    const eventKey = event.key;\n    const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\";\n    const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\";\n    const keyMap = {\n      [ArrowStart]: () => isHorizontal && prevTab(),\n      [ArrowEnd]: () => isHorizontal && nextTab(),\n      ArrowDown: () => isVertical && nextTab(),\n      ArrowUp: () => isVertical && prevTab(),\n      Home: firstTab,\n      End: lastTab\n    };\n    const action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      action(event);\n    }\n  }, [descendants, focusedIndex, orientation, direction]);\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)\n  };\n}\nfunction useTab(props) {\n  const {\n    isDisabled = false,\n    isFocusable = false,\n    ...htmlProps\n  } = props;\n  const {\n    setSelectedIndex,\n    isManual,\n    id,\n    setFocusedIndex,\n    selectedIndex\n  } = useTabsContext();\n  const {\n    index,\n    register\n  } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable\n  });\n  const isSelected = index === selectedIndex;\n  const onClick = () => {\n    setSelectedIndex(index);\n  };\n  const onFocus = () => {\n    setFocusedIndex(index);\n    const isDisabledButFocusable = isDisabled && isFocusable;\n    const shouldSelect = !isManual && !isDisabledButFocusable;\n    if (shouldSelect) {\n      setSelectedIndex(index);\n    }\n  };\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick)\n  });\n  const type = \"button\";\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? void 0 : callAllHandlers(props.onFocus, onFocus)\n  };\n}\nvar [TabPanelProvider, useTabPanelContext] = createContext({});\nfunction useTabPanels(props) {\n  const context = useTabsContext();\n  const {\n    id,\n    selectedIndex\n  } = context;\n  const validChildren = getValidChildren(props.children);\n  const children = validChildren.map((child, index) => createElement(TabPanelProvider, {\n    key: index,\n    value: {\n      isSelected: index === selectedIndex,\n      id: makeTabPanelId(id, index),\n      tabId: makeTabId(id, index),\n      selectedIndex\n    }\n  }, child));\n  return {\n    ...props,\n    children\n  };\n}\nfunction useTabPanel(props) {\n  const {\n    children,\n    ...htmlProps\n  } = props;\n  const {\n    isLazy,\n    lazyBehavior\n  } = useTabsContext();\n  const {\n    isSelected,\n    id,\n    tabId\n  } = useTabPanelContext();\n  const hasBeenSelected = useRef(false);\n  if (isSelected) {\n    hasBeenSelected.current = true;\n  }\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior\n  });\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id\n  };\n}\nfunction useTabIndicator() {\n  const context = useTabsContext();\n  const descendants = useTabsDescendantsContext();\n  const {\n    selectedIndex,\n    orientation\n  } = context;\n  const isHorizontal = orientation === \"horizontal\";\n  const isVertical = orientation === \"vertical\";\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return {\n      left: 0,\n      width: 0\n    };\n    if (isVertical) return {\n      top: 0,\n      height: 0\n    };\n    return void 0;\n  });\n  const [hasMeasured, setHasMeasured] = useState(false);\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return;\n    const tab = descendants.item(selectedIndex);\n    if (tab == null) return;\n    if (isHorizontal) {\n      setRect({\n        left: tab.node.offsetLeft,\n        width: tab.node.offsetWidth\n      });\n    }\n    if (isVertical) {\n      setRect({\n        top: tab.node.offsetTop,\n        height: tab.node.offsetHeight\n      });\n    }\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true);\n    });\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id);\n      }\n    };\n  }, [selectedIndex, isHorizontal, isVertical, descendants]);\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect\n  };\n}\nfunction makeTabId(id, index) {\n  return \"\".concat(id, \"--tab-\").concat(index);\n}\nfunction makeTabPanelId(id, index) {\n  return \"\".concat(id, \"--tabpanel-\").concat(index);\n}\nexport { TabsDescendantsProvider, useTabsDescendantsContext, useTabsDescendants, useTabsDescendant, useTabs, TabsProvider, useTabsContext, useTabList, useTab, useTabPanels, useTabPanel, useTabIndicator };","map":{"version":3,"names":["useClickable","createDescendantContext","createContext","useSafeLayoutEffect","useControllableState","getValidChildren","mergeRefs","lazyDisclosure","callAllHandlers","useCallback","useEffect","useRef","useState","useId","createElement","TabsDescendantsProvider","useTabsDescendantsContext","useTabsDescendants","useTabsDescendant","useTabs","props","_a","defaultIndex","onChange","index","isManual","isLazy","lazyBehavior","orientation","direction","htmlProps","focusedIndex","setFocusedIndex","selectedIndex","setSelectedIndex","defaultValue","value","descendants","uuid","uid","id","concat","TabsProvider","useTabsContext","name","errorMessage","useTabList","onKeyDown","event","nextTab","next","nextEnabled","node","focus","prevTab","prev","prevEnabled","firstTab","first","firstEnabled","lastTab","last","lastEnabled","isHorizontal","isVertical","eventKey","key","ArrowStart","ArrowEnd","keyMap","ArrowDown","ArrowUp","Home","End","action","preventDefault","role","useTab","isDisabled","isFocusable","register","disabled","isSelected","onClick","onFocus","isDisabledButFocusable","shouldSelect","clickableProps","ref","type","makeTabId","tabIndex","makeTabPanelId","TabPanelProvider","useTabPanelContext","useTabPanels","context","validChildren","children","map","child","tabId","useTabPanel","hasBeenSelected","current","shouldRenderChildren","wasSelected","enabled","mode","hidden","useTabIndicator","rect","setRect","left","width","top","height","hasMeasured","setHasMeasured","tab","item","offsetLeft","offsetWidth","offsetTop","offsetHeight","requestAnimationFrame","cancelAnimationFrame","position","transitionProperty","transitionDuration","transitionTimingFunction"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\@chakra-ui\\tabs\\src\\use-tabs.ts"],"sourcesContent":["import { useClickable, UseClickableProps } from \"@chakra-ui/clickable\"\nimport { createDescendantContext } from \"@chakra-ui/descendant\"\nimport { createContext } from \"@chakra-ui/react-context\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { getValidChildren } from \"@chakra-ui/react-children-utils\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport { lazyDisclosure, LazyMode } from \"@chakra-ui/lazy-utils\"\nimport { callAllHandlers } from \"@chakra-ui/shared-utils\"\nimport {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n  useId,\n  createElement,\n} from \"react\"\n\n/* -------------------------------------------------------------------------------------------------\n * Create context to track descendants and their indices\n * -----------------------------------------------------------------------------------------------*/\n\nexport const [\n  TabsDescendantsProvider,\n  useTabsDescendantsContext,\n  useTabsDescendants,\n  useTabsDescendant,\n] = createDescendantContext<HTMLButtonElement>()\n\n/* -------------------------------------------------------------------------------------------------\n * useTabs - The root react hook that manages all tab items\n * -----------------------------------------------------------------------------------------------*/\n\nexport interface UseTabsProps {\n  /**\n   * The orientation of the tab list.\n   * @default \"horizontal\"\n   */\n  orientation?: \"vertical\" | \"horizontal\"\n  /**\n   * If `true`, the tabs will be manually activated and\n   * display its panel by pressing Space or Enter.\n   *\n   * If `false`, the tabs will be automatically activated\n   * and their panel is displayed when they receive focus.\n   *\n   * @default false\n   */\n  isManual?: boolean\n  /**\n   * Callback when the index (controlled or un-controlled) changes.\n   */\n  onChange?: (index: number) => void\n  /**\n   * The index of the selected tab (in controlled mode)\n   */\n  index?: number\n  /**\n   * The initial index of the selected tab (in uncontrolled mode)\n   */\n  defaultIndex?: number\n  /**\n   * The id of the tab\n   */\n  id?: string\n  /**\n   * Performance ðŸš€:\n   * If `true`, rendering of the tab panel's will be deferred until it is selected.\n   * @default false\n   */\n  isLazy?: boolean\n  /**\n   * Performance ðŸš€:\n   * The lazy behavior of tab panels' content when not active.\n   * Only works when `isLazy={true}`\n   *\n   * - \"unmount\": The content of inactive tab panels are always unmounted.\n   * - \"keepMounted\": The content of inactive tab panels is initially unmounted,\n   * but stays mounted when selected.\n   *\n   * @default \"unmount\"\n   */\n  lazyBehavior?: LazyMode\n  /**\n   * The writing mode direction.\n   *\n   * - When in RTL, the left and right navigation is flipped\n   * @default \"ltr\"\n   */\n  direction?: \"rtl\" | \"ltr\"\n}\n\n/**\n * Tabs hook that provides all the states, and accessibility\n * helpers to keep all things working properly.\n *\n * Its returned object will be passed unto a Context Provider\n * so all child components can read from it.\n * There is no document link yet\n * @see Docs https://chakra-ui.com/docs/components/useTabs\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/tabpanel/\n */\nexport function useTabs(props: UseTabsProps) {\n  const {\n    defaultIndex,\n    onChange,\n    index,\n    isManual,\n    isLazy,\n    lazyBehavior = \"unmount\",\n    orientation = \"horizontal\",\n    direction = \"ltr\",\n    ...htmlProps\n  } = props\n\n  /**\n   * We use this to keep track of the index of the focused tab.\n   *\n   * Tabs can be automatically activated, this means selection follows focus.\n   * When we navigate with the arrow keys, we move focus and selection to next/prev tab\n   *\n   * Tabs can also be manually activated, this means selection does not follow focus.\n   * When we navigate with the arrow keys, we only move focus NOT selection. The user\n   * will need not manually activate the tab using `Enter` or `Space`.\n   *\n   * This is why we need to keep track of the `focusedIndex` and `selectedIndex`\n   */\n  const [focusedIndex, setFocusedIndex] = useState(defaultIndex ?? 0)\n\n  const [selectedIndex, setSelectedIndex] = useControllableState({\n    defaultValue: defaultIndex ?? 0,\n    value: index,\n    onChange,\n  })\n\n  /**\n   * Sync focused `index` with controlled `selectedIndex` (which is the `props.index`)\n   */\n  useEffect(() => {\n    if (index != null) {\n      setFocusedIndex(index)\n    }\n  }, [index])\n\n  /**\n   * Think of `useDescendants` as a register for the tab nodes.\n   */\n  const descendants = useTabsDescendants()\n\n  /**\n   * Generate a unique id or use user-provided id for the tabs widget\n   */\n  const uuid = useId()\n  const uid = props.id ?? uuid\n  const id = `tabs-${uid}`\n\n  return {\n    id,\n    selectedIndex,\n    focusedIndex,\n    setSelectedIndex,\n    setFocusedIndex,\n    isManual,\n    isLazy,\n    lazyBehavior,\n    orientation,\n    descendants,\n    direction,\n    htmlProps,\n  }\n}\n\nexport type UseTabsReturn = Omit<\n  ReturnType<typeof useTabs>,\n  \"htmlProps\" | \"descendants\"\n>\n\nexport const [TabsProvider, useTabsContext] = createContext<UseTabsReturn>({\n  name: \"TabsContext\",\n  errorMessage:\n    \"useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />\",\n})\n\nexport interface UseTabListProps {\n  children?: React.ReactNode\n  onKeyDown?: React.KeyboardEventHandler\n  ref?: React.Ref<any>\n}\n\n/**\n * Tabs hook to manage multiple tab buttons,\n * and ensures only one tab is selected per time.\n *\n * @param props props object for the tablist\n */\nexport function useTabList<P extends UseTabListProps>(props: P) {\n  const { focusedIndex, orientation, direction } = useTabsContext()\n\n  const descendants = useTabsDescendantsContext()\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const nextTab = () => {\n        const next = descendants.nextEnabled(focusedIndex)\n        if (next) next.node?.focus()\n      }\n      const prevTab = () => {\n        const prev = descendants.prevEnabled(focusedIndex)\n        if (prev) prev.node?.focus()\n      }\n      const firstTab = () => {\n        const first = descendants.firstEnabled()\n        if (first) first.node?.focus()\n      }\n      const lastTab = () => {\n        const last = descendants.lastEnabled()\n        if (last) last.node?.focus()\n      }\n\n      const isHorizontal = orientation === \"horizontal\"\n      const isVertical = orientation === \"vertical\"\n\n      const eventKey = event.key\n\n      const ArrowStart = direction === \"ltr\" ? \"ArrowLeft\" : \"ArrowRight\"\n      const ArrowEnd = direction === \"ltr\" ? \"ArrowRight\" : \"ArrowLeft\"\n\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        [ArrowStart]: () => isHorizontal && prevTab(),\n        [ArrowEnd]: () => isHorizontal && nextTab(),\n        ArrowDown: () => isVertical && nextTab(),\n        ArrowUp: () => isVertical && prevTab(),\n        Home: firstTab,\n        End: lastTab,\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        action(event)\n      }\n    },\n    [descendants, focusedIndex, orientation, direction],\n  )\n\n  return {\n    ...props,\n    role: \"tablist\",\n    \"aria-orientation\": orientation,\n    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n  }\n}\n\nexport type UseTabListReturn = ReturnType<typeof useTabList>\n\nexport interface UseTabOptions {\n  /**\n   * If `true`, the `Tab` won't be toggleable\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true` and `isDisabled`, the `Tab` will be focusable but not interactive.\n   * @default false\n   */\n  isFocusable?: boolean\n}\n\nexport interface UseTabProps\n  extends Omit<UseClickableProps, \"color\">,\n    UseTabOptions {}\n\n/**\n * Tabs hook to manage each tab button.\n *\n * A tab can be disabled and focusable, or both,\n * hence the use of `useClickable` to handle this scenario\n */\nexport function useTab<P extends UseTabProps>(props: P) {\n  const { isDisabled = false, isFocusable = false, ...htmlProps } = props\n\n  const { setSelectedIndex, isManual, id, setFocusedIndex, selectedIndex } =\n    useTabsContext()\n\n  const { index, register } = useTabsDescendant({\n    disabled: isDisabled && !isFocusable,\n  })\n\n  const isSelected = index === selectedIndex\n\n  const onClick = () => {\n    setSelectedIndex(index)\n  }\n\n  const onFocus = () => {\n    setFocusedIndex(index)\n    const isDisabledButFocusable = isDisabled && isFocusable\n    const shouldSelect = !isManual && !isDisabledButFocusable\n    if (shouldSelect) {\n      setSelectedIndex(index)\n    }\n  }\n\n  const clickableProps = useClickable({\n    ...htmlProps,\n    ref: mergeRefs(register, props.ref),\n    isDisabled,\n    isFocusable,\n    onClick: callAllHandlers(props.onClick, onClick),\n  })\n\n  const type: \"button\" | \"submit\" | \"reset\" = \"button\"\n\n  return {\n    ...clickableProps,\n    id: makeTabId(id, index),\n    role: \"tab\",\n    tabIndex: isSelected ? 0 : -1,\n    type,\n    \"aria-selected\": isSelected,\n    \"aria-controls\": makeTabPanelId(id, index),\n    onFocus: isDisabled ? undefined : callAllHandlers(props.onFocus, onFocus),\n  }\n}\n\nexport interface UseTabPanelsProps {\n  children?: React.ReactNode\n}\n\nconst [TabPanelProvider, useTabPanelContext] = createContext<{\n  isSelected: boolean\n  id: string\n  tabId: string\n  selectedIndex: number\n}>({})\n\n/**\n * Tabs hook for managing the visibility of multiple tab panels.\n *\n * Since only one panel can be show at a time, we use `cloneElement`\n * to inject `selected` panel to each TabPanel.\n *\n * It returns a cloned version of its children with\n * all functionality included.\n */\nexport function useTabPanels<P extends UseTabPanelsProps>(props: P) {\n  const context = useTabsContext()\n\n  const { id, selectedIndex } = context\n\n  const validChildren = getValidChildren(props.children)\n\n  const children = validChildren.map((child, index) =>\n    createElement(\n      TabPanelProvider,\n      {\n        key: index,\n        value: {\n          isSelected: index === selectedIndex,\n          id: makeTabPanelId(id, index),\n          tabId: makeTabId(id, index),\n          selectedIndex,\n        },\n      },\n      child,\n    ),\n  )\n\n  return { ...props, children }\n}\n\n/**\n * Tabs hook for managing the visible/hidden states\n * of the tab panel.\n *\n * @param props props object for the tab panel\n */\nexport function useTabPanel(props: Record<string, any>) {\n  const { children, ...htmlProps } = props\n  const { isLazy, lazyBehavior } = useTabsContext()\n  const { isSelected, id, tabId } = useTabPanelContext()\n\n  const hasBeenSelected = useRef(false)\n  if (isSelected) {\n    hasBeenSelected.current = true\n  }\n\n  const shouldRenderChildren = lazyDisclosure({\n    wasSelected: hasBeenSelected.current,\n    isSelected,\n    enabled: isLazy,\n    mode: lazyBehavior,\n  })\n\n  return {\n    // Puts the tabpanel in the page `Tab` sequence.\n    tabIndex: 0,\n    ...htmlProps,\n    children: shouldRenderChildren ? children : null,\n    role: \"tabpanel\",\n    \"aria-labelledby\": tabId,\n    hidden: !isSelected,\n    id,\n  }\n}\n\n/**\n * Tabs hook to show an animated indicators that\n * follows the active tab.\n *\n * The way we do it is by measuring the DOM Rect (or dimensions)\n * of the active tab, and return that as CSS style for\n * the indicator.\n */\nexport function useTabIndicator(): React.CSSProperties {\n  const context = useTabsContext()\n  const descendants = useTabsDescendantsContext()\n\n  const { selectedIndex, orientation } = context\n\n  const isHorizontal = orientation === \"horizontal\"\n  const isVertical = orientation === \"vertical\"\n\n  // Get the clientRect of the selected tab\n  const [rect, setRect] = useState(() => {\n    if (isHorizontal) return { left: 0, width: 0 }\n    if (isVertical) return { top: 0, height: 0 }\n    return undefined\n  })\n\n  const [hasMeasured, setHasMeasured] = useState(false)\n\n  // Update the selected tab rect when the selectedIndex changes\n  useSafeLayoutEffect(() => {\n    if (selectedIndex == null) return\n\n    const tab = descendants.item(selectedIndex)\n    if (tab == null) return\n\n    // Horizontal Tab: Calculate width and left distance\n    if (isHorizontal) {\n      setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth })\n    }\n\n    // Vertical Tab: Calculate height and top distance\n    if (isVertical) {\n      setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight })\n    }\n\n    // Prevent unwanted transition from 0 to measured rect\n    // by setting the measured state in the next tick\n    const id = requestAnimationFrame(() => {\n      setHasMeasured(true)\n    })\n\n    return () => {\n      if (id) {\n        cancelAnimationFrame(id)\n      }\n    }\n  }, [selectedIndex, isHorizontal, isVertical, descendants])\n\n  return {\n    position: \"absolute\",\n    transitionProperty: \"left, right, top, bottom, height, width\",\n    transitionDuration: hasMeasured ? \"200ms\" : \"0ms\",\n    transitionTimingFunction: \"cubic-bezier(0, 0, 0.2, 1)\",\n    ...rect,\n  }\n}\n\nfunction makeTabId(id: string, index: number) {\n  return `${id}--tab-${index}`\n}\n\nfunction makeTabPanelId(id: string, index: number) {\n  return `${id}--tabpanel-${index}`\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}