{"ast":null,"code":"import * as THREE from 'three';\nimport { version } from '../helpers/constants.js';\nclass ConvolutionMaterial extends THREE.ShaderMaterial {\n  constructor() {\n    let texelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new THREE.Vector2();\n    super({\n      uniforms: {\n        inputBuffer: new THREE.Uniform(null),\n        depthBuffer: new THREE.Uniform(null),\n        resolution: new THREE.Uniform(new THREE.Vector2()),\n        texelSize: new THREE.Uniform(new THREE.Vector2()),\n        halfTexelSize: new THREE.Uniform(new THREE.Vector2()),\n        kernel: new THREE.Uniform(0.0),\n        scale: new THREE.Uniform(1.0),\n        cameraNear: new THREE.Uniform(0.0),\n        cameraFar: new THREE.Uniform(1.0),\n        minDepthThreshold: new THREE.Uniform(0.0),\n        maxDepthThreshold: new THREE.Uniform(1.0),\n        depthScale: new THREE.Uniform(0.0),\n        depthToBlurRatioBias: new THREE.Uniform(0.25)\n      },\n      fragmentShader: \"#include <common>\\n        #include <dithering_pars_fragment>      \\n        uniform sampler2D inputBuffer;\\n        uniform sampler2D depthBuffer;\\n        uniform float cameraNear;\\n        uniform float cameraFar;\\n        uniform float minDepthThreshold;\\n        uniform float maxDepthThreshold;\\n        uniform float depthScale;\\n        uniform float depthToBlurRatioBias;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          float depthFactor = 0.0;\\n          \\n          #ifdef USE_DEPTH\\n            vec4 depth = texture2D(depthBuffer, vUv);\\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\\n            depthFactor *= depthScale;\\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\\n          #endif\\n          \\n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\\n          gl_FragColor = sum * 0.25 ;\\n\\n          #include <dithering_fragment>\\n          #include <tonemapping_fragment>\\n          #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n        }\"),\n      vertexShader: \"uniform vec2 texelSize;\\n        uniform vec2 halfTexelSize;\\n        uniform float kernel;\\n        uniform float scale;\\n        varying vec2 vUv;\\n        varying vec2 vUv0;\\n        varying vec2 vUv1;\\n        varying vec2 vUv2;\\n        varying vec2 vUv3;\\n\\n        void main() {\\n          vec2 uv = position.xy * 0.5 + 0.5;\\n          vUv = uv;\\n\\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\\n\\n          gl_Position = vec4(position.xy, 1.0, 1.0);\\n        }\",\n      blending: THREE.NoBlending,\n      depthWrite: false,\n      depthTest: false\n    });\n    this.toneMapped = false;\n    this.setTexelSize(texelSize.x, texelSize.y);\n    this.kernel = new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]);\n  }\n  setTexelSize(x, y) {\n    this.uniforms.texelSize.value.set(x, y);\n    this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);\n  }\n  setResolution(resolution) {\n    this.uniforms.resolution.value.copy(resolution);\n  }\n}\nexport { ConvolutionMaterial };","map":{"version":3,"names":["THREE","version","ConvolutionMaterial","ShaderMaterial","constructor","texelSize","arguments","length","undefined","Vector2","uniforms","inputBuffer","Uniform","depthBuffer","resolution","halfTexelSize","kernel","scale","cameraNear","cameraFar","minDepthThreshold","maxDepthThreshold","depthScale","depthToBlurRatioBias","fragmentShader","concat","vertexShader","blending","NoBlending","depthWrite","depthTest","toneMapped","setTexelSize","x","y","Float32Array","value","set","multiplyScalar","setResolution","copy"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/@react-three/drei/materials/ConvolutionMaterial.js"],"sourcesContent":["import * as THREE from 'three';\r\nimport { version } from '../helpers/constants.js';\r\n\r\nclass ConvolutionMaterial extends THREE.ShaderMaterial {\r\n  constructor(texelSize = new THREE.Vector2()) {\r\n    super({\r\n      uniforms: {\r\n        inputBuffer: new THREE.Uniform(null),\r\n        depthBuffer: new THREE.Uniform(null),\r\n        resolution: new THREE.Uniform(new THREE.Vector2()),\r\n        texelSize: new THREE.Uniform(new THREE.Vector2()),\r\n        halfTexelSize: new THREE.Uniform(new THREE.Vector2()),\r\n        kernel: new THREE.Uniform(0.0),\r\n        scale: new THREE.Uniform(1.0),\r\n        cameraNear: new THREE.Uniform(0.0),\r\n        cameraFar: new THREE.Uniform(1.0),\r\n        minDepthThreshold: new THREE.Uniform(0.0),\r\n        maxDepthThreshold: new THREE.Uniform(1.0),\r\n        depthScale: new THREE.Uniform(0.0),\r\n        depthToBlurRatioBias: new THREE.Uniform(0.25)\r\n      },\r\n      fragmentShader: `#include <common>\r\n        #include <dithering_pars_fragment>      \r\n        uniform sampler2D inputBuffer;\r\n        uniform sampler2D depthBuffer;\r\n        uniform float cameraNear;\r\n        uniform float cameraFar;\r\n        uniform float minDepthThreshold;\r\n        uniform float maxDepthThreshold;\r\n        uniform float depthScale;\r\n        uniform float depthToBlurRatioBias;\r\n        varying vec2 vUv;\r\n        varying vec2 vUv0;\r\n        varying vec2 vUv1;\r\n        varying vec2 vUv2;\r\n        varying vec2 vUv3;\r\n\r\n        void main() {\r\n          float depthFactor = 0.0;\r\n          \r\n          #ifdef USE_DEPTH\r\n            vec4 depth = texture2D(depthBuffer, vUv);\r\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\r\n            depthFactor *= depthScale;\r\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\r\n          #endif\r\n          \r\n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\r\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\r\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\r\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\r\n          gl_FragColor = sum * 0.25 ;\r\n\r\n          #include <dithering_fragment>\r\n          #include <tonemapping_fragment>\r\n          #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\r\n        }`,\r\n      vertexShader: `uniform vec2 texelSize;\r\n        uniform vec2 halfTexelSize;\r\n        uniform float kernel;\r\n        uniform float scale;\r\n        varying vec2 vUv;\r\n        varying vec2 vUv0;\r\n        varying vec2 vUv1;\r\n        varying vec2 vUv2;\r\n        varying vec2 vUv3;\r\n\r\n        void main() {\r\n          vec2 uv = position.xy * 0.5 + 0.5;\r\n          vUv = uv;\r\n\r\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\r\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\r\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\r\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\r\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\r\n\r\n          gl_Position = vec4(position.xy, 1.0, 1.0);\r\n        }`,\r\n      blending: THREE.NoBlending,\r\n      depthWrite: false,\r\n      depthTest: false\r\n    });\r\n    this.toneMapped = false;\r\n    this.setTexelSize(texelSize.x, texelSize.y);\r\n    this.kernel = new Float32Array([0.0, 1.0, 2.0, 2.0, 3.0]);\r\n  }\r\n  setTexelSize(x, y) {\r\n    this.uniforms.texelSize.value.set(x, y);\r\n    this.uniforms.halfTexelSize.value.set(x, y).multiplyScalar(0.5);\r\n  }\r\n  setResolution(resolution) {\r\n    this.uniforms.resolution.value.copy(resolution);\r\n  }\r\n}\r\n\r\nexport { ConvolutionMaterial };\r\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,OAAO,QAAQ,yBAAyB;AAEjD,MAAMC,mBAAmB,SAASF,KAAK,CAACG,cAAc,CAAC;EACrDC,WAAWA,CAAA,EAAkC;IAAA,IAAjCC,SAAS,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAIN,KAAK,CAACS,OAAO,CAAC,CAAC;IACzC,KAAK,CAAC;MACJC,QAAQ,EAAE;QACRC,WAAW,EAAE,IAAIX,KAAK,CAACY,OAAO,CAAC,IAAI,CAAC;QACpCC,WAAW,EAAE,IAAIb,KAAK,CAACY,OAAO,CAAC,IAAI,CAAC;QACpCE,UAAU,EAAE,IAAId,KAAK,CAACY,OAAO,CAAC,IAAIZ,KAAK,CAACS,OAAO,CAAC,CAAC,CAAC;QAClDJ,SAAS,EAAE,IAAIL,KAAK,CAACY,OAAO,CAAC,IAAIZ,KAAK,CAACS,OAAO,CAAC,CAAC,CAAC;QACjDM,aAAa,EAAE,IAAIf,KAAK,CAACY,OAAO,CAAC,IAAIZ,KAAK,CAACS,OAAO,CAAC,CAAC,CAAC;QACrDO,MAAM,EAAE,IAAIhB,KAAK,CAACY,OAAO,CAAC,GAAG,CAAC;QAC9BK,KAAK,EAAE,IAAIjB,KAAK,CAACY,OAAO,CAAC,GAAG,CAAC;QAC7BM,UAAU,EAAE,IAAIlB,KAAK,CAACY,OAAO,CAAC,GAAG,CAAC;QAClCO,SAAS,EAAE,IAAInB,KAAK,CAACY,OAAO,CAAC,GAAG,CAAC;QACjCQ,iBAAiB,EAAE,IAAIpB,KAAK,CAACY,OAAO,CAAC,GAAG,CAAC;QACzCS,iBAAiB,EAAE,IAAIrB,KAAK,CAACY,OAAO,CAAC,GAAG,CAAC;QACzCU,UAAU,EAAE,IAAItB,KAAK,CAACY,OAAO,CAAC,GAAG,CAAC;QAClCW,oBAAoB,EAAE,IAAIvB,KAAK,CAACY,OAAO,CAAC,IAAI;MAC9C,CAAC;MACDY,cAAc,00CAAAC,MAAA,CAkCExB,OAAO,IAAI,GAAG,GAAG,qBAAqB,GAAG,oBAAoB,iBACzE;MACJyB,YAAY,msBAqBR;MACJC,QAAQ,EAAE3B,KAAK,CAAC4B,UAAU;MAC1BC,UAAU,EAAE,KAAK;MACjBC,SAAS,EAAE;IACb,CAAC,CAAC;IACF,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB,IAAI,CAACC,YAAY,CAAC3B,SAAS,CAAC4B,CAAC,EAAE5B,SAAS,CAAC6B,CAAC,CAAC;IAC3C,IAAI,CAAClB,MAAM,GAAG,IAAImB,YAAY,CAAC,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;EAC3D;EACAH,YAAYA,CAACC,CAAC,EAAEC,CAAC,EAAE;IACjB,IAAI,CAACxB,QAAQ,CAACL,SAAS,CAAC+B,KAAK,CAACC,GAAG,CAACJ,CAAC,EAAEC,CAAC,CAAC;IACvC,IAAI,CAACxB,QAAQ,CAACK,aAAa,CAACqB,KAAK,CAACC,GAAG,CAACJ,CAAC,EAAEC,CAAC,CAAC,CAACI,cAAc,CAAC,GAAG,CAAC;EACjE;EACAC,aAAaA,CAACzB,UAAU,EAAE;IACxB,IAAI,CAACJ,QAAQ,CAACI,UAAU,CAACsB,KAAK,CAACI,IAAI,CAAC1B,UAAU,CAAC;EACjD;AACF;AAEA,SAASZ,mBAAmB"},"metadata":{},"sourceType":"module","externalDependencies":[]}