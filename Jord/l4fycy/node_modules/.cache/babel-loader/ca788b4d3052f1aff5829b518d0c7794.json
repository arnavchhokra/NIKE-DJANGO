{"ast":null,"code":"import _objectSpread from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport * as THREE from 'three';\n\nvar pcss = function pcss() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$frustum = _ref.frustum,\n      frustum = _ref$frustum === void 0 ? 3.75 : _ref$frustum,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 0.005 : _ref$size,\n      _ref$near = _ref.near,\n      near = _ref$near === void 0 ? 9.5 : _ref$near,\n      _ref$samples = _ref.samples,\n      samples = _ref$samples === void 0 ? 17 : _ref$samples,\n      _ref$rings = _ref.rings,\n      rings = _ref$rings === void 0 ? 11 : _ref$rings;\n\n  return \"#define LIGHT_WORLD_SIZE \".concat(size, \"\\n#define LIGHT_FRUSTUM_WIDTH \").concat(frustum, \"\\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\\n#define NEAR_PLANE \").concat(near, \"\\n\\n#define NUM_SAMPLES \").concat(samples, \"\\n#define NUM_RINGS \").concat(rings, \"\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n#define PCF_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples(const in vec2 randomSeed) {\\n  float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\\n  float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\\n  float angle = rand(randomSeed) * PI2;\\n  float radius = INV_NUM_SAMPLES;\\n  float radiusStep = radius;\\n  for (int i = 0; i < NUM_SAMPLES; i++) {\\n    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\\n    radius += radiusStep;\\n    angle += ANGLE_STEP;\\n  }\\n}\\n\\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\\n  return (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\\n  float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\\n  float blockerDepthSum = 0.0;\\n  int numBlockers = 0;\\n  for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\\n    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n    if (shadowMapDepth < zReceiver) {\\n      blockerDepthSum += shadowMapDepth;\\n      numBlockers++;\\n    }\\n  }\\n  if (numBlockers == 0) return -1.0;\\n  return blockerDepthSum / float(numBlockers);\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\\n  float sum = 0.0;\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\\n    if (zReceiver <= depth) sum += 1.0;\\n  }\\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\\n    if (zReceiver <= depth) sum += 1.0;\\n  }\\n  return sum / (2.0 * float(PCF_NUM_SAMPLES));\\n}\\n\\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\\n  vec2 uv = coords.xy;\\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\\n  initPoissonSamples(uv);\\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\\n  if (avgBlockerDepth == -1.0) return 1.0;\\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\\n}\");\n};\n\nvar deployed = false;\n\nvar softShadows = function softShadows(props) {\n  // Avoid adding the effect twice, which may happen in HMR scenarios\n  if (!deployed) {\n    deployed = true;\n    var shader = THREE.ShaderChunk.shadowmap_pars_fragment;\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss(_objectSpread({}, props)));\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\n  }\n};\n\nexport { softShadows };","map":{"version":3,"names":["THREE","pcss","frustum","size","near","samples","rings","deployed","softShadows","props","shader","ShaderChunk","shadowmap_pars_fragment","replace"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@react-three/drei/core/softShadows.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\nconst pcss = ({\r\n  frustum = 3.75,\r\n  size = 0.005,\r\n  near = 9.5,\r\n  samples = 17,\r\n  rings = 11\r\n} = {}) => `#define LIGHT_WORLD_SIZE ${size}\r\n#define LIGHT_FRUSTUM_WIDTH ${frustum}\r\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\r\n#define NEAR_PLANE ${near}\r\n\r\n#define NUM_SAMPLES ${samples}\r\n#define NUM_RINGS ${rings}\r\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\r\n#define PCF_NUM_SAMPLES NUM_SAMPLES\r\n\r\nvec2 poissonDisk[NUM_SAMPLES];\r\n\r\nvoid initPoissonSamples(const in vec2 randomSeed) {\r\n  float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\r\n  float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\r\n  float angle = rand(randomSeed) * PI2;\r\n  float radius = INV_NUM_SAMPLES;\r\n  float radiusStep = radius;\r\n  for (int i = 0; i < NUM_SAMPLES; i++) {\r\n    poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\r\n    radius += radiusStep;\r\n    angle += ANGLE_STEP;\r\n  }\r\n}\r\n\r\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\r\n  return (zReceiver - zBlocker) / zBlocker;\r\n}\r\n\r\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\r\n  float searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\r\n  float blockerDepthSum = 0.0;\r\n  int numBlockers = 0;\r\n  for (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\r\n    float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\r\n    if (shadowMapDepth < zReceiver) {\r\n      blockerDepthSum += shadowMapDepth;\r\n      numBlockers++;\r\n    }\r\n  }\r\n  if (numBlockers == 0) return -1.0;\r\n  return blockerDepthSum / float(numBlockers);\r\n}\r\n\r\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\r\n  float sum = 0.0;\r\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\r\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\r\n    if (zReceiver <= depth) sum += 1.0;\r\n  }\r\n  for (int i = 0; i < PCF_NUM_SAMPLES; i++) {\r\n    float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\r\n    if (zReceiver <= depth) sum += 1.0;\r\n  }\r\n  return sum / (2.0 * float(PCF_NUM_SAMPLES));\r\n}\r\n\r\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\r\n  vec2 uv = coords.xy;\r\n  float zReceiver = coords.z; // Assumed to be eye-space z in this code\r\n  initPoissonSamples(uv);\r\n  float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\r\n  if (avgBlockerDepth == -1.0) return 1.0;\r\n  float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\r\n  float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\r\n  return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\r\n}`;\r\n\r\nlet deployed = false;\r\nconst softShadows = props => {\r\n  // Avoid adding the effect twice, which may happen in HMR scenarios\r\n  if (!deployed) {\r\n    deployed = true;\r\n    let shader = THREE.ShaderChunk.shadowmap_pars_fragment;\r\n    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\\n' + pcss({ ...props\r\n    }));\r\n    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\\nreturn PCSS(shadowMap, shadowCoord);\\n#if defined( SHADOWMAP_TYPE_PCF )');\r\n    THREE.ShaderChunk.shadowmap_pars_fragment = shader;\r\n  }\r\n};\r\n\r\nexport { softShadows };\r\n"],"mappings":";AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;;AAEA,IAAMC,IAAI,GAAG,SAAPA,IAAO;EAAA,+EAMT,EANS;EAAA,wBACXC,OADW;EAAA,IACXA,OADW,6BACD,IADC;EAAA,qBAEXC,IAFW;EAAA,IAEXA,IAFW,0BAEJ,KAFI;EAAA,qBAGXC,IAHW;EAAA,IAGXA,IAHW,0BAGJ,GAHI;EAAA,wBAIXC,OAJW;EAAA,IAIXA,OAJW,6BAID,EAJC;EAAA,sBAKXC,KALW;EAAA,IAKXA,KALW,2BAKH,EALG;;EAAA,0CAM0BH,IAN1B,2CAOiBD,OAPjB,kGASQE,IATR,qCAWSC,OAXT,iCAYOC,KAZP;AAAA,CAAb;;AA0EA,IAAIC,QAAQ,GAAG,KAAf;;AACA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAC,KAAK,EAAI;EAC3B;EACA,IAAI,CAACF,QAAL,EAAe;IACbA,QAAQ,GAAG,IAAX;IACA,IAAIG,MAAM,GAAGV,KAAK,CAACW,WAAN,CAAkBC,uBAA/B;IACAF,MAAM,GAAGA,MAAM,CAACG,OAAP,CAAe,sBAAf,EAAuC,2BAA2BZ,IAAI,mBAAMQ,KAAN,EAAtE,CAAT;IAEAC,MAAM,GAAGA,MAAM,CAACG,OAAP,CAAe,mCAAf,EAAoD,2EAApD,CAAT;IACAb,KAAK,CAACW,WAAN,CAAkBC,uBAAlB,GAA4CF,MAA5C;EACD;AACF,CAVD;;AAYA,SAASF,WAAT"},"metadata":{},"sourceType":"module"}