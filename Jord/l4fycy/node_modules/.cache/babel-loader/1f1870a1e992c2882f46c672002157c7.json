{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ShaderChunk, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, Matrix4, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\n\nvar voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\n\nfunction expandShaderIncludes(source) {\n  var pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\n  function replace(match, include) {\n    var chunk = ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match;\n  }\n\n  return source.replace(pattern, replace);\n}\n/*\r\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\r\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\r\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\r\n */\n\n\nvar _lut = [];\n\nfor (var i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n}\n\nfunction generateUUID() {\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n  var d0 = Math.random() * 0xffffffff | 0;\n  var d1 = Math.random() * 0xffffffff | 0;\n  var d2 = Math.random() * 0xffffffff | 0;\n  var d3 = Math.random() * 0xffffffff | 0;\n  var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.\n\n  return uuid.toUpperCase();\n} // Local assign polyfill to avoid importing troika-core\n\n\nvar assign = Object.assign || function\n  /*target, ...sources*/\n() {\n  var target = arguments[0];\n\n  for (var _i = 1, len = arguments.length; _i < len; _i++) {\n    var source = arguments[_i];\n\n    if (source) {\n      for (var prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n\n  return target;\n};\n\nvar epoch = Date.now();\nvar CONSTRUCTOR_CACHE = new WeakMap();\nvar SHADER_UPGRADE_CACHE = new Map(); // Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\n\nvar materialInstanceId = 1e10;\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\n\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  var optionsKey = getKeyForOptions(options); // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n\n  var ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n  }\n\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]();\n  }\n\n  var privateBeforeCompileProp = \"_onBeforeCompile\".concat(optionsKey); // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n\n  var onBeforeCompile = function onBeforeCompile(shaderInfo) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo); // Upgrade the shaders, caching the result by incoming source code\n\n    var cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    var upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n\n    if (!upgradedShaders) {\n      var upgraded = upgradeShaders(shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    } // Inject upgraded shaders and uniforms into the program\n\n\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms); // Inject auto-updating time uniform if requested\n\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {\n          return Date.now() - epoch;\n        }\n\n      };\n    } // Users can still add their own handlers on top of ours\n\n\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  var DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\n  };\n\n  var derive = function derive(base) {\n    // Prototype chain to the base material\n    var derived = Object.create(base, descriptor); // Store the baseMaterial for reference; this is always the original even when cloning\n\n    Object.defineProperty(derived, 'baseMaterial', {\n      value: baseMaterial\n    }); // Needs its own ids\n\n    Object.defineProperty(derived, 'id', {\n      value: materialInstanceId++\n    });\n    derived.uuid = generateUUID(); // Merge uniforms, defines, and extensions\n\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[\"TROIKA_DERIVED_MATERIAL_\".concat(optionsKey)] = ''; //force a program change from the base material\n\n    derived.extensions = assign({}, base.extensions, options.extensions); // Don't inherit EventDispatcher listeners\n\n    derived._listeners = undefined;\n    return derived;\n  };\n\n  var descriptor = {\n    constructor: {\n      value: DerivedMaterial\n    },\n    isDerivedMaterial: {\n      value: true\n    },\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey;\n      }\n    },\n    onBeforeCompile: {\n      get: function get() {\n        return onBeforeCompile;\n      },\n      set: function set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function value(source) {\n        baseMaterial.copy.call(this, source);\n\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\n        }\n\n        return this;\n      }\n    },\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this);\n      }\n    },\n\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var depthMaterial = this._depthMaterial;\n\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({\n            depthPacking: RGBADepthPacking\n          }), options);\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return depthMaterial;\n      }\n    },\n\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var distanceMaterial = this._distanceMaterial;\n\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(), options);\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n\n        return distanceMaterial;\n      }\n    },\n    dispose: {\n      writable: true,\n      configurable: true,\n      value: function value() {\n        var _depthMaterial = this._depthMaterial,\n            _distanceMaterial = this._distanceMaterial;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial();\n}\n\nfunction upgradeShaders(_ref, options, key) {\n  var vertexShader = _ref.vertexShader,\n      fragmentShader = _ref.fragmentShader;\n  var vertexDefs = options.vertexDefs,\n      vertexMainIntro = options.vertexMainIntro,\n      vertexMainOutro = options.vertexMainOutro,\n      vertexTransform = options.vertexTransform,\n      fragmentDefs = options.fragmentDefs,\n      fragmentMainIntro = options.fragmentMainIntro,\n      fragmentMainOutro = options.fragmentMainOutro,\n      fragmentColorTransform = options.fragmentColorTransform,\n      customRewriter = options.customRewriter,\n      timeUniform = options.timeUniform;\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || ''; // Expand includes if needed\n\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  } // Apply custom rewriter function\n\n\n  if (customRewriter) {\n    var res = customRewriter({\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader\n    });\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  } // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n\n\n  if (fragmentColorTransform) {\n    var postChunks = [];\n    fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n    function (match) {\n      postChunks.push(match);\n      return '';\n    });\n    fragmentMainOutro = \"\".concat(fragmentColorTransform, \"\\n\").concat(postChunks.join('\\n'), \"\\n\").concat(fragmentMainOutro);\n  } // Inject auto-updating time uniform if requested\n\n\n  if (timeUniform) {\n    var code = \"\\nuniform float \".concat(timeUniform, \";\\n\");\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  } // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n\n\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = \"vec3 troika_position_\".concat(key, \";\\nvec3 troika_normal_\").concat(key, \";\\nvec2 troika_uv_\").concat(key, \";\\n\").concat(vertexShader, \"\\n\");\n    vertexDefs = \"\".concat(vertexDefs, \"\\nvoid troikaVertexTransform\").concat(key, \"(inout vec3 position, inout vec3 normal, inout vec2 uv) {\\n  \").concat(vertexTransform, \"\\n}\\n\");\n    vertexMainIntro = \"\\ntroika_position_\".concat(key, \" = vec3(position);\\ntroika_normal_\").concat(key, \" = vec3(normal);\\ntroika_uv_\").concat(key, \" = vec2(uv);\\ntroikaVertexTransform\").concat(key, \"(troika_position_\").concat(key, \", troika_normal_\").concat(key, \", troika_uv_\").concat(key, \");\\n\").concat(vertexMainIntro, \"\\n\");\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, function (match, match1, index, fullStr) {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : \"troika_\".concat(match1, \"_\").concat(key);\n    });\n  } // Inject defs and intro/outro snippets\n\n\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n  return {\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader\n  };\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, \"\\n\".concat(defs, \"\\nvoid troikaOrigMain\").concat(id, \"() {\"));\n    shaderCode += \"\\nvoid main() {\\n  \".concat(intro, \"\\n  troikaOrigMain\").concat(id, \"();\\n  \").concat(outro, \"\\n}\");\n  }\n\n  return shaderCode;\n}\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n}\n\nvar _idCtr = 0;\nvar optionsHashesToIds = new Map();\n\nfunction getKeyForOptions(options) {\n  var optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  var id = optionsHashesToIds.get(optionsHash);\n\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n  }\n\n  return id;\n} // Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\n\n\nvar MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\n\nfunction getShadersForMaterial(material) {\n  var builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n}\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\n\n\nfunction getShaderUniformTypes(shader) {\n  var uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  var uniforms = Object.create(null);\n  var match;\n\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n\n  return uniforms;\n}\n/**\r\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\r\n * that happened in ThreeJS r123.\r\n * @param {Matrix4} srcMatrix\r\n * @param {Matrix4} [tgtMatrix]\r\n */\n\n\nfunction invertMatrix4(srcMatrix) {\n  var tgtMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();\n\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n\n  return tgtMatrix;\n}\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\n\n\nvar vertexDefs = \"\\nuniform vec3 pointA;\\nuniform vec3 controlA;\\nuniform vec3 controlB;\\nuniform vec3 pointB;\\nuniform float radius;\\nvarying float bezierT;\\n\\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  float b0 = t2 * t2 * t2;\\n  float b1 = 3.0 * t * t2 * t2;\\n  float b2 = 3.0 * t * t * t2;\\n  float b3 = t * t * t;\\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\\n}\\n\\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\\n  float t2 = 1.0 - t;\\n  return -3.0 * p1 * t2 * t2 +\\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\\n    3.0 * p2 * t * t;\\n}\\n\";\nvar vertexTransform = \"\\nfloat t = position.y;\\nbezierT = t;\\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\\n\\n// Make \\\"sideways\\\" always perpendicular to the camera ray; this ensures that any twists\\n// in the cylinder occur where you won't see them: \\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\\nif (bezierDir == viewDirection) {\\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\\n}\\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\\nvec3 upish = normalize(cross(sideways, bezierDir));\\n\\n// Build a matrix for transforming this disc in the cylinder:\\nmat4 discTx;\\ndiscTx[0].xyz = sideways * radius;\\ndiscTx[1].xyz = bezierDir * radius;\\ndiscTx[2].xyz = upish * radius;\\ndiscTx[3].xyz = bezierCenterPos;\\ndiscTx[3][3] = 1.0;\\n\\n// Apply transform, ignoring original y\\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\\nnormal = normalize(mat3(discTx) * normal);\\n\";\nvar fragmentDefs = \"\\nuniform vec3 dashing;\\nvarying float bezierT;\\n\";\nvar fragmentMainIntro = \"\\nif (dashing.x + dashing.y > 0.0) {\\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\\n  if (dashFrac > dashing.x) {\\n    discard;\\n  }\\n}\\n\"; // Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(baseMaterial, {\n    chained: true,\n    uniforms: {\n      pointA: {\n        value: new Vector3()\n      },\n      controlA: {\n        value: new Vector3()\n      },\n      controlB: {\n        value: new Vector3()\n      },\n      pointB: {\n        value: new Vector3()\n      },\n      radius: {\n        value: 0.01\n      },\n      dashing: {\n        value: new Vector3()\n      } //on, off, offset\n\n    },\n    vertexDefs: vertexDefs,\n    vertexTransform: vertexTransform,\n    fragmentDefs: fragmentDefs,\n    fragmentMainIntro: fragmentMainIntro\n  });\n}\n\nvar geometry = null;\nvar defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({\n  color: 0xffffff,\n  side: DoubleSide\n});\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\n\nvar BezierMesh = /*#__PURE__*/function (_Mesh) {\n  _inherits(BezierMesh, _Mesh);\n\n  var _super = _createSuper(BezierMesh);\n\n  function BezierMesh() {\n    var _this;\n\n    _classCallCheck(this, BezierMesh);\n\n    _this = _super.call(this, BezierMesh.getGeometry(), defaultBaseMaterial);\n    _this.pointA = new Vector3();\n    _this.controlA = new Vector3();\n    _this.controlB = new Vector3();\n    _this.pointB = new Vector3();\n    _this.radius = 0.01;\n    _this.dashArray = new Vector2();\n    _this.dashOffset = 0; // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n\n    _this.frustumCulled = false;\n    return _this;\n  } // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n\n\n  _createClass(BezierMesh, [{\n    key: \"material\",\n    get: function get() {\n      var derivedMaterial = this._derivedMaterial;\n      var baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n\n      if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n        derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial); // dispose the derived material when its base material is disposed:\n\n        baseMaterial.addEventListener('dispose', function onDispose() {\n          baseMaterial.removeEventListener('dispose', onDispose);\n          derivedMaterial.dispose();\n        });\n      }\n\n      return derivedMaterial;\n    },\n    set: function set(baseMaterial) {\n      this._baseMaterial = baseMaterial;\n    } // Create and update material for shadows upon request:\n\n  }, {\n    key: \"customDepthMaterial\",\n    get: function get() {\n      return this.material.getDepthMaterial();\n    }\n  }, {\n    key: \"customDistanceMaterial\",\n    get: function get() {\n      return this.material.getDistanceMaterial();\n    }\n  }, {\n    key: \"onBeforeRender\",\n    value: function onBeforeRender(shaderInfo) {\n      var uniforms = this.material.uniforms;\n      var pointA = this.pointA,\n          controlA = this.controlA,\n          controlB = this.controlB,\n          pointB = this.pointB,\n          radius = this.radius,\n          dashArray = this.dashArray,\n          dashOffset = this.dashOffset;\n      uniforms.pointA.value.copy(pointA);\n      uniforms.controlA.value.copy(controlA);\n      uniforms.controlB.value.copy(controlB);\n      uniforms.pointB.value.copy(pointB);\n      uniforms.radius.value = radius;\n      uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n    }\n  }, {\n    key: \"raycast\",\n    value: function raycast(raycaster, intersects) {// TODO - just fail for now\n    }\n  }], [{\n    key: \"getGeometry\",\n    value: function getGeometry() {\n      return geometry || (geometry = new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n    }\n  }]);\n\n  return BezierMesh;\n}(Mesh);\n\nexport { BezierMesh, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, invertMatrix4, voidMainRegExp };","map":{"version":3,"names":["ShaderChunk","UniformsUtils","MeshDepthMaterial","RGBADepthPacking","MeshDistanceMaterial","ShaderLib","Matrix4","Vector3","Mesh","CylinderBufferGeometry","Vector2","MeshStandardMaterial","DoubleSide","voidMainRegExp","expandShaderIncludes","source","pattern","replace","match","include","chunk","_lut","i","toString","generateUUID","d0","Math","random","d1","d2","d3","uuid","toUpperCase","assign","Object","target","arguments","len","length","prop","hasOwnProperty","epoch","Date","now","CONSTRUCTOR_CACHE","WeakMap","SHADER_UPGRADE_CACHE","Map","materialInstanceId","createDerivedMaterial","baseMaterial","options","optionsKey","getKeyForOptions","ctorsByDerivation","get","set","create","privateBeforeCompileProp","onBeforeCompile","shaderInfo","call","cacheKey","customProgramCacheKey","vertexShader","fragmentShader","upgradedShaders","upgraded","upgradeShaders","uniforms","timeUniform","value","DerivedMaterial","derive","chained","clone","base","derived","descriptor","defineProperty","defines","extensions","_listeners","undefined","constructor","isDerivedMaterial","writable","configurable","fn","copy","isShaderMaterial","newBase","getDepthMaterial","depthMaterial","_depthMaterial","depthPacking","IS_DEPTH_MATERIAL","getDistanceMaterial","distanceMaterial","_distanceMaterial","IS_DISTANCE_MATERIAL","dispose","key","vertexDefs","vertexMainIntro","vertexMainOutro","vertexTransform","fragmentDefs","fragmentMainIntro","fragmentMainOutro","fragmentColorTransform","customRewriter","res","postChunks","push","join","code","match1","index","fullStr","test","substr","injectIntoShaderCode","shaderCode","id","defs","intro","outro","optionsJsonReplacer","_idCtr","optionsHashesToIds","optionsHash","JSON","stringify","MATERIAL_TYPES_TO_SHADERS","MeshNormalMaterial","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","MeshToonMaterial","MeshPhysicalMaterial","MeshMatcapMaterial","LineBasicMaterial","LineDashedMaterial","PointsMaterial","ShadowMaterial","SpriteMaterial","getShadersForMaterial","material","builtinType","type","getShaderUniformTypes","shader","uniformRE","exec","invertMatrix4","srcMatrix","tgtMatrix","invert","getInverse","createBezierMeshMaterial","pointA","controlA","controlB","pointB","radius","dashing","geometry","defaultBaseMaterial","color","side","BezierMesh","getGeometry","dashArray","dashOffset","frustumCulled","derivedMaterial","_derivedMaterial","_baseMaterial","_defaultMaterial","addEventListener","onDispose","removeEventListener","x","y","raycaster","intersects","translate"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/troika-three-utils/dist/troika-three-utils.esm.js"],"sourcesContent":["import { ShaderChunk, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, Matrix4, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\r\n\r\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\r\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\r\n\r\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\r\nfunction expandShaderIncludes( source ) {\r\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\r\n  function replace(match, include) {\r\n    let chunk = ShaderChunk[include];\r\n    return chunk ? expandShaderIncludes(chunk) : match\r\n  }\r\n  return source.replace( pattern, replace )\r\n}\r\n\r\n/*\r\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\r\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\r\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\r\n */\r\n\r\nconst _lut = [];\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\r\n}\r\n\r\nfunction generateUUID() {\r\n\r\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\r\n\r\n  const d0 = Math.random() * 0xffffffff | 0;\r\n  const d1 = Math.random() * 0xffffffff | 0;\r\n  const d2 = Math.random() * 0xffffffff | 0;\r\n  const d3 = Math.random() * 0xffffffff | 0;\r\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\r\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\r\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\r\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\r\n\r\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\r\n  return uuid.toUpperCase()\r\n\r\n}\r\n\r\n// Local assign polyfill to avoid importing troika-core\r\nconst assign = Object.assign || function(/*target, ...sources*/) {\r\n  let target = arguments[0];\r\n  for (let i = 1, len = arguments.length; i < len; i++) {\r\n    let source = arguments[i];\r\n    if (source) {\r\n      for (let prop in source) {\r\n        if (source.hasOwnProperty(prop)) {\r\n          target[prop] = source[prop];\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return target\r\n};\r\n\r\n\r\nconst epoch = Date.now();\r\nconst CONSTRUCTOR_CACHE = new WeakMap();\r\nconst SHADER_UPGRADE_CACHE = new Map();\r\n\r\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\r\n// so let's choose a sufficiently large starting value that should theoretically never collide.\r\nlet materialInstanceId = 1e10;\r\n\r\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\r\nfunction createDerivedMaterial(baseMaterial, options) {\r\n  // Generate a key that is unique to the content of these `options`. We'll use this\r\n  // throughout for caching and for generating the upgraded shader code. This increases\r\n  // the likelihood that the resulting shaders will line up across multiple calls so\r\n  // their GL programs can be shared and cached.\r\n  const optionsKey = getKeyForOptions(options);\r\n\r\n  // First check to see if we've already derived from this baseMaterial using this\r\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\r\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\r\n  if (!ctorsByDerivation) {\r\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\r\n  }\r\n  if (ctorsByDerivation[optionsKey]) {\r\n    return new ctorsByDerivation[optionsKey]()\r\n  }\r\n\r\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\r\n\r\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\r\n  // the renderer switches to this material's program\r\n  const onBeforeCompile = function (shaderInfo) {\r\n    baseMaterial.onBeforeCompile.call(this, shaderInfo);\r\n\r\n    // Upgrade the shaders, caching the result by incoming source code\r\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\r\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\r\n    if (!upgradedShaders) {\r\n      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);\r\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\r\n    }\r\n\r\n    // Inject upgraded shaders and uniforms into the program\r\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\r\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\r\n    assign(shaderInfo.uniforms, this.uniforms);\r\n\r\n    // Inject auto-updating time uniform if requested\r\n    if (options.timeUniform) {\r\n      shaderInfo.uniforms[options.timeUniform] = {\r\n        get value() {return Date.now() - epoch}\r\n      };\r\n    }\r\n\r\n    // Users can still add their own handlers on top of ours\r\n    if (this[privateBeforeCompileProp]) {\r\n      this[privateBeforeCompileProp](shaderInfo);\r\n    }\r\n  };\r\n\r\n  const DerivedMaterial = function DerivedMaterial() {\r\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\r\n  };\r\n\r\n  const derive = function(base) {\r\n    // Prototype chain to the base material\r\n    const derived = Object.create(base, descriptor);\r\n\r\n    // Store the baseMaterial for reference; this is always the original even when cloning\r\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\r\n\r\n    // Needs its own ids\r\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\r\n    derived.uuid = generateUUID();\r\n\r\n    // Merge uniforms, defines, and extensions\r\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\r\n    derived.defines = assign({}, base.defines, options.defines);\r\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\r\n    derived.extensions = assign({}, base.extensions, options.extensions);\r\n\r\n    // Don't inherit EventDispatcher listeners\r\n    derived._listeners = undefined;\r\n\r\n    return derived\r\n  };\r\n\r\n  const descriptor = {\r\n    constructor: {value: DerivedMaterial},\r\n    isDerivedMaterial: {value: true},\r\n\r\n    customProgramCacheKey: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function () {\r\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\r\n      }\r\n    },\r\n\r\n    onBeforeCompile: {\r\n      get() {\r\n        return onBeforeCompile\r\n      },\r\n      set(fn) {\r\n        this[privateBeforeCompileProp] = fn;\r\n      }\r\n    },\r\n\r\n    copy: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function (source) {\r\n        baseMaterial.copy.call(this, source);\r\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\r\n          assign(this.extensions, source.extensions);\r\n          assign(this.defines, source.defines);\r\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\r\n        }\r\n        return this\r\n      }\r\n    },\r\n\r\n    clone: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function () {\r\n        const newBase = new baseMaterial.constructor();\r\n        return derive(newBase).copy(this)\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\r\n    getDepthMaterial: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function() {\r\n        let depthMaterial = this._depthMaterial;\r\n        if (!depthMaterial) {\r\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\r\n            baseMaterial.isDerivedMaterial\r\n              ? baseMaterial.getDepthMaterial()\r\n              : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),\r\n            options\r\n          );\r\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\r\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\r\n        }\r\n        return depthMaterial\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\r\n    getDistanceMaterial: {\r\n      writable: true,\r\n      configurable: true,\r\n      value: function() {\r\n        let distanceMaterial = this._distanceMaterial;\r\n        if (!distanceMaterial) {\r\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\r\n            baseMaterial.isDerivedMaterial\r\n              ? baseMaterial.getDistanceMaterial()\r\n              : new MeshDistanceMaterial(),\r\n            options\r\n          );\r\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\r\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\r\n        }\r\n        return distanceMaterial\r\n      }\r\n    },\r\n\r\n    dispose: {\r\n      writable: true,\r\n      configurable: true,\r\n      value() {\r\n        const {_depthMaterial, _distanceMaterial} = this;\r\n        if (_depthMaterial) _depthMaterial.dispose();\r\n        if (_distanceMaterial) _distanceMaterial.dispose();\r\n        baseMaterial.dispose.call(this);\r\n      }\r\n    }\r\n  };\r\n\r\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\r\n  return new DerivedMaterial()\r\n}\r\n\r\n\r\nfunction upgradeShaders({vertexShader, fragmentShader}, options, key) {\r\n  let {\r\n    vertexDefs,\r\n    vertexMainIntro,\r\n    vertexMainOutro,\r\n    vertexTransform,\r\n    fragmentDefs,\r\n    fragmentMainIntro,\r\n    fragmentMainOutro,\r\n    fragmentColorTransform,\r\n    customRewriter,\r\n    timeUniform\r\n  } = options;\r\n\r\n  vertexDefs = vertexDefs || '';\r\n  vertexMainIntro = vertexMainIntro || '';\r\n  vertexMainOutro = vertexMainOutro || '';\r\n  fragmentDefs = fragmentDefs || '';\r\n  fragmentMainIntro = fragmentMainIntro || '';\r\n  fragmentMainOutro = fragmentMainOutro || '';\r\n\r\n  // Expand includes if needed\r\n  if (vertexTransform || customRewriter) {\r\n    vertexShader = expandShaderIncludes(vertexShader);\r\n  }\r\n  if (fragmentColorTransform || customRewriter) {\r\n    // We need to be able to find postprocessing chunks after include expansion in order to\r\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\r\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\r\n    // so we still mark them.\r\n    fragmentShader = fragmentShader.replace(\r\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\r\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\r\n    );\r\n    fragmentShader = expandShaderIncludes(fragmentShader);\r\n  }\r\n\r\n  // Apply custom rewriter function\r\n  if (customRewriter) {\r\n    let res = customRewriter({vertexShader, fragmentShader});\r\n    vertexShader = res.vertexShader;\r\n    fragmentShader = res.fragmentShader;\r\n  }\r\n\r\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\r\n  // those and re-insert them into the outro in the correct place:\r\n  if (fragmentColorTransform) {\r\n    let postChunks = [];\r\n    fragmentShader = fragmentShader.replace(\r\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\r\n      match => {\r\n        postChunks.push(match);\r\n        return ''\r\n      }\r\n    );\r\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\r\n  }\r\n\r\n  // Inject auto-updating time uniform if requested\r\n  if (timeUniform) {\r\n    const code = `\\nuniform float ${timeUniform};\\n`;\r\n    vertexDefs = code + vertexDefs;\r\n    fragmentDefs = code + fragmentDefs;\r\n  }\r\n\r\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\r\n  if (vertexTransform) {\r\n    // Hoist these defs to the very top so they work in other function defs\r\n    vertexShader = `vec3 troika_position_${key};\r\nvec3 troika_normal_${key};\r\nvec2 troika_uv_${key};\r\n${vertexShader}\r\n`;\r\n    vertexDefs = `${vertexDefs}\r\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\r\n  ${vertexTransform}\r\n}\r\n`;\r\n    vertexMainIntro = `\r\ntroika_position_${key} = vec3(position);\r\ntroika_normal_${key} = vec3(normal);\r\ntroika_uv_${key} = vec2(uv);\r\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\r\n${vertexMainIntro}\r\n`;\r\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\r\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\r\n    });\r\n  }\r\n\r\n  // Inject defs and intro/outro snippets\r\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\r\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\r\n\r\n  return {\r\n    vertexShader,\r\n    fragmentShader\r\n  }\r\n}\r\n\r\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\r\n  if (intro || outro || defs) {\r\n    shaderCode = shaderCode.replace(voidMainRegExp, `\r\n${defs}\r\nvoid troikaOrigMain${id}() {`\r\n    );\r\n    shaderCode += `\r\nvoid main() {\r\n  ${intro}\r\n  troikaOrigMain${id}();\r\n  ${outro}\r\n}`;\r\n  }\r\n  return shaderCode\r\n}\r\n\r\n\r\nfunction optionsJsonReplacer(key, value) {\r\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\r\n}\r\n\r\nlet _idCtr = 0;\r\nconst optionsHashesToIds = new Map();\r\nfunction getKeyForOptions(options) {\r\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\r\n  let id = optionsHashesToIds.get(optionsHash);\r\n  if (id == null) {\r\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\r\n  }\r\n  return id\r\n}\r\n\r\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\r\n// TODO how can we keep this from getting stale?\r\nconst MATERIAL_TYPES_TO_SHADERS = {\r\n  MeshDepthMaterial: 'depth',\r\n  MeshDistanceMaterial: 'distanceRGBA',\r\n  MeshNormalMaterial: 'normal',\r\n  MeshBasicMaterial: 'basic',\r\n  MeshLambertMaterial: 'lambert',\r\n  MeshPhongMaterial: 'phong',\r\n  MeshToonMaterial: 'toon',\r\n  MeshStandardMaterial: 'physical',\r\n  MeshPhysicalMaterial: 'physical',\r\n  MeshMatcapMaterial: 'matcap',\r\n  LineBasicMaterial: 'basic',\r\n  LineDashedMaterial: 'dashed',\r\n  PointsMaterial: 'points',\r\n  ShadowMaterial: 'shadow',\r\n  SpriteMaterial: 'sprite'\r\n};\r\n\r\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\r\nfunction getShadersForMaterial(material) {\r\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\r\n  return builtinType ? ShaderLib[builtinType] : material //TODO fallback for unknown type?\r\n}\r\n\r\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\r\nfunction getShaderUniformTypes(shader) {\r\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\r\n  let uniforms = Object.create(null);\r\n  let match;\r\n  while ((match = uniformRE.exec(shader)) !== null) {\r\n    uniforms[match[2]] = match[1];\r\n  }\r\n  return uniforms\r\n}\r\n\r\n/**\r\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\r\n * that happened in ThreeJS r123.\r\n * @param {Matrix4} srcMatrix\r\n * @param {Matrix4} [tgtMatrix]\r\n */\r\nfunction invertMatrix4(srcMatrix, tgtMatrix = new Matrix4()) {\r\n  if (typeof tgtMatrix.invert === 'function') {\r\n    tgtMatrix.copy(srcMatrix).invert();\r\n  } else {\r\n    tgtMatrix.getInverse(srcMatrix);\r\n  }\r\n  return tgtMatrix\r\n}\r\n\r\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\r\n\r\nconst vertexDefs = `\r\nuniform vec3 pointA;\r\nuniform vec3 controlA;\r\nuniform vec3 controlB;\r\nuniform vec3 pointB;\r\nuniform float radius;\r\nvarying float bezierT;\r\n\r\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\r\n  float t2 = 1.0 - t;\r\n  float b0 = t2 * t2 * t2;\r\n  float b1 = 3.0 * t * t2 * t2;\r\n  float b2 = 3.0 * t * t * t2;\r\n  float b3 = t * t * t;\r\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\r\n}\r\n\r\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\r\n  float t2 = 1.0 - t;\r\n  return -3.0 * p1 * t2 * t2 +\r\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\r\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\r\n    3.0 * p2 * t * t;\r\n}\r\n`;\r\n\r\nconst vertexTransform = `\r\nfloat t = position.y;\r\nbezierT = t;\r\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\r\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\r\n\r\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\r\n// in the cylinder occur where you won't see them: \r\nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\r\nif (bezierDir == viewDirection) {\r\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\r\n}\r\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\r\nvec3 upish = normalize(cross(sideways, bezierDir));\r\n\r\n// Build a matrix for transforming this disc in the cylinder:\r\nmat4 discTx;\r\ndiscTx[0].xyz = sideways * radius;\r\ndiscTx[1].xyz = bezierDir * radius;\r\ndiscTx[2].xyz = upish * radius;\r\ndiscTx[3].xyz = bezierCenterPos;\r\ndiscTx[3][3] = 1.0;\r\n\r\n// Apply transform, ignoring original y\r\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\r\nnormal = normalize(mat3(discTx) * normal);\r\n`;\r\n\r\nconst fragmentDefs = `\r\nuniform vec3 dashing;\r\nvarying float bezierT;\r\n`;\r\n\r\nconst fragmentMainIntro = `\r\nif (dashing.x + dashing.y > 0.0) {\r\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\r\n  if (dashFrac > dashing.x) {\r\n    discard;\r\n  }\r\n}\r\n`;\r\n\r\n// Debugging: separate color for each of the 6 sides:\r\n// const fragmentColorTransform = `\r\n// float sideNum = floor(vUV.x * 6.0);\r\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\r\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\r\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\r\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\r\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\r\n//   vec3(1.0, 0.0, 1.0);\r\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\r\n// `\r\n\r\n\r\n\r\nfunction createBezierMeshMaterial(baseMaterial) {\r\n  return createDerivedMaterial(\r\n    baseMaterial,\r\n    {\r\n      chained: true,\r\n      uniforms: {\r\n        pointA: {value: new Vector3()},\r\n        controlA: {value: new Vector3()},\r\n        controlB: {value: new Vector3()},\r\n        pointB: {value: new Vector3()},\r\n        radius: {value: 0.01},\r\n        dashing: {value: new Vector3()} //on, off, offset\r\n      },\r\n      vertexDefs,\r\n      vertexTransform,\r\n      fragmentDefs,\r\n      fragmentMainIntro\r\n    }\r\n  )\r\n}\r\n\r\nlet geometry = null;\r\n\r\nconst defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({color: 0xffffff, side: DoubleSide});\r\n\r\n\r\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\r\nclass BezierMesh extends Mesh {\r\n  static getGeometry() {\r\n    return geometry || (geometry =\r\n      new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\r\n    )\r\n  }\r\n\r\n  constructor() {\r\n    super(\r\n      BezierMesh.getGeometry(),\r\n      defaultBaseMaterial\r\n    );\r\n\r\n    this.pointA = new Vector3();\r\n    this.controlA = new Vector3();\r\n    this.controlB = new Vector3();\r\n    this.pointB = new Vector3();\r\n    this.radius = 0.01;\r\n    this.dashArray = new Vector2();\r\n    this.dashOffset = 0;\r\n\r\n    // TODO - disabling frustum culling until I figure out how to customize the\r\n    //  geometry's bounding sphere that gets used\r\n    this.frustumCulled = false;\r\n  }\r\n\r\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\r\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\r\n  get material() {\r\n    let derivedMaterial = this._derivedMaterial;\r\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\r\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\r\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\r\n      // dispose the derived material when its base material is disposed:\r\n      baseMaterial.addEventListener('dispose', function onDispose() {\r\n        baseMaterial.removeEventListener('dispose', onDispose);\r\n        derivedMaterial.dispose();\r\n      });\r\n    }\r\n    return derivedMaterial\r\n  }\r\n  set material(baseMaterial) {\r\n    this._baseMaterial = baseMaterial;\r\n  }\r\n\r\n  // Create and update material for shadows upon request:\r\n  get customDepthMaterial() {\r\n    return this.material.getDepthMaterial()\r\n  }\r\n  get customDistanceMaterial() {\r\n    return this.material.getDistanceMaterial()\r\n  }\r\n\r\n  onBeforeRender(shaderInfo) {\r\n    const {uniforms} = this.material;\r\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\r\n    uniforms.pointA.value.copy(pointA);\r\n    uniforms.controlA.value.copy(controlA);\r\n    uniforms.controlB.value.copy(controlB);\r\n    uniforms.pointB.value.copy(pointB);\r\n    uniforms.radius.value = radius;\r\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\r\n  }\r\n\r\n  raycast(raycaster, intersects) {\r\n    // TODO - just fail for now\r\n  }\r\n}\r\n\r\nexport { BezierMesh, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, invertMatrix4, voidMainRegExp };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}