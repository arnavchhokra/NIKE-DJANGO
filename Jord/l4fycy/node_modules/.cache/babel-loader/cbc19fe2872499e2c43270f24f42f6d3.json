{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from 'three';\nimport { CopyShader } from '../shaders/CopyShader.js';\n\nvar OutlinePass = /*#__PURE__*/function (_Pass) {\n  _inherits(OutlinePass, _Pass);\n\n  var _super = _createSuper(OutlinePass);\n\n  function OutlinePass(resolution, scene, camera, selectedObjects) {\n    var _this;\n\n    _classCallCheck(this, OutlinePass);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderScene\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderCamera\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"selectedObjects\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"visibleEdgeColor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"hiddenEdgeColor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"edgeGlow\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"usePatternTexture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"edgeThickness\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"edgeStrength\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"downSampleRatio\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"pulsePeriod\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"resolution\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetMaskBuffer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"depthMaterial\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"prepareMaskMaterial\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetDepthBuffer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetMaskDownSampleBuffer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetBlurBuffer1\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetBlurBuffer2\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"edgeDetectionMaterial\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetEdgeBuffer1\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"renderTargetEdgeBuffer2\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"separableBlurMaterial1\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"separableBlurMaterial2\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"overlayMaterial\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"materialCopy\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"oldClearAlpha\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"fsQuad\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"tempPulseColor1\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"tempPulseColor2\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"textureMatrix\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"patternTexture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_visibilityCache\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_oldClearColor\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"copyUniforms\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"BlurDirectionX\", new Vector2(1.0, 0.0));\n\n    _defineProperty(_assertThisInitialized(_this), \"BlurDirectionY\", new Vector2(0.0, 1.0));\n\n    _this.renderScene = scene;\n    _this.renderCamera = camera;\n    _this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n    _this.visibleEdgeColor = new Color(1, 1, 1);\n    _this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\n    _this.edgeGlow = 0.0;\n    _this.usePatternTexture = false;\n    _this.edgeThickness = 1.0;\n    _this.edgeStrength = 3.0;\n    _this.downSampleRatio = 2;\n    _this.pulsePeriod = 0;\n    _this._visibilityCache = new Map();\n    _this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\n    var resx = Math.round(_this.resolution.x / _this.downSampleRatio);\n    var resy = Math.round(_this.resolution.y / _this.downSampleRatio);\n    _this.renderTargetMaskBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\n    _this.renderTargetMaskBuffer.texture.generateMipmaps = false;\n    _this.depthMaterial = new MeshDepthMaterial();\n    _this.depthMaterial.side = DoubleSide;\n    _this.depthMaterial.depthPacking = RGBADepthPacking;\n    _this.depthMaterial.blending = NoBlending;\n    _this.prepareMaskMaterial = _this.getPrepareMaskMaterial();\n    _this.prepareMaskMaterial.side = DoubleSide;\n    _this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(_this.prepareMaskMaterial.fragmentShader, _this.renderCamera);\n    _this.renderTargetDepthBuffer = new WebGLRenderTarget(_this.resolution.x, _this.resolution.y);\n    _this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\n    _this.renderTargetDepthBuffer.texture.generateMipmaps = false;\n    _this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\n    _this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\n    _this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\n    _this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n    _this.edgeDetectionMaterial = _this.getEdgeDetectionMaterial();\n    _this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\n    _this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\n    _this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n    _this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\n    _this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\n    _this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n    var MAX_EDGE_THICKNESS = 4;\n    var MAX_EDGE_GLOW = 4;\n    _this.separableBlurMaterial1 = _this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\n\n    _this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n\n    _this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\n    _this.separableBlurMaterial2 = _this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\n\n    _this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\n\n    _this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\n\n    _this.overlayMaterial = _this.getOverlayMaterial(); // copy material\n\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\n    var copyShader = CopyShader;\n    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\n    _this.copyUniforms['opacity'].value = 1.0;\n    _this.materialCopy = new ShaderMaterial({\n      uniforms: _this.copyUniforms,\n      vertexShader: copyShader.vertexShader,\n      fragmentShader: copyShader.fragmentShader,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      transparent: true\n    });\n    _this.enabled = true;\n    _this.needsSwap = false;\n    _this._oldClearColor = new Color();\n    _this.oldClearAlpha = 1;\n    _this.fsQuad = new FullScreenQuad(_this.materialCopy);\n    _this.tempPulseColor1 = new Color();\n    _this.tempPulseColor2 = new Color();\n    _this.textureMatrix = new Matrix4();\n\n    function replaceDepthToViewZ(string, camera) {\n      var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\n    }\n\n    return _this;\n  }\n\n  _createClass(OutlinePass, [{\n    key: \"dispose\",\n    value: function dispose() {\n      this.renderTargetMaskBuffer.dispose();\n      this.renderTargetDepthBuffer.dispose();\n      this.renderTargetMaskDownSampleBuffer.dispose();\n      this.renderTargetBlurBuffer1.dispose();\n      this.renderTargetBlurBuffer2.dispose();\n      this.renderTargetEdgeBuffer1.dispose();\n      this.renderTargetEdgeBuffer2.dispose();\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height) {\n      this.renderTargetMaskBuffer.setSize(width, height);\n      this.renderTargetDepthBuffer.setSize(width, height);\n      var resx = Math.round(width / this.downSampleRatio);\n      var resy = Math.round(height / this.downSampleRatio);\n      this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\n      this.renderTargetBlurBuffer1.setSize(resx, resy);\n      this.renderTargetEdgeBuffer1.setSize(resx, resy);\n      this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\n      resx = Math.round(resx / 2);\n      resy = Math.round(resy / 2);\n      this.renderTargetBlurBuffer2.setSize(resx, resy);\n      this.renderTargetEdgeBuffer2.setSize(resx, resy);\n      this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\n    }\n  }, {\n    key: \"changeVisibilityOfSelectedObjects\",\n    value: function changeVisibilityOfSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) {\n          if (bVisible === true) {\n            object.visible = cache.get(object);\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n    }\n  }, {\n    key: \"changeVisibilityOfNonSelectedObjects\",\n    value: function changeVisibilityOfNonSelectedObjects(bVisible) {\n      var cache = this._visibilityCache;\n      var selectedMeshes = [];\n\n      function gatherSelectedMeshesCallBack(object) {\n        if (object.isMesh) selectedMeshes.push(object);\n      }\n\n      for (var i = 0; i < this.selectedObjects.length; i++) {\n        var selectedObject = this.selectedObjects[i];\n        selectedObject.traverse(gatherSelectedMeshesCallBack);\n      }\n\n      function VisibilityChangeCallBack(object) {\n        if (object.isMesh || object.isSprite) {\n          // only meshes and sprites are supported by OutlinePass\n          var bFound = false;\n\n          for (var _i = 0; _i < selectedMeshes.length; _i++) {\n            var selectedObjectId = selectedMeshes[_i].id;\n\n            if (selectedObjectId === object.id) {\n              bFound = true;\n              break;\n            }\n          }\n\n          if (bFound === false) {\n            var visibility = object.visible;\n\n            if (bVisible === false || cache.get(object) === true) {\n              object.visible = bVisible;\n            }\n\n            cache.set(object, visibility);\n          }\n        } else if (object.isPoints || object.isLine) {\n          // the visibilty of points and lines is always set to false in order to\n          // not affect the outline computation\n          if (bVisible === true) {\n            object.visible = cache.get(object); // restore\n          } else {\n            cache.set(object, object.visible);\n            object.visible = bVisible;\n          }\n        }\n      }\n\n      this.renderScene.traverse(VisibilityChangeCallBack);\n    }\n  }, {\n    key: \"updateTextureMatrix\",\n    value: function updateTextureMatrix() {\n      this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\n      this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\n      this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\n    }\n  }, {\n    key: \"render\",\n    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n      if (this.selectedObjects.length > 0) {\n        renderer.getClearColor(this._oldClearColor);\n        this.oldClearAlpha = renderer.getClearAlpha();\n        var oldAutoClear = renderer.autoClear;\n        renderer.autoClear = false;\n        if (maskActive) renderer.state.buffers.stencil.setTest(false);\n        renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\n\n        this.changeVisibilityOfSelectedObjects(false);\n        var currentBackground = this.renderScene.background;\n        this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\n\n        this.renderScene.overrideMaterial = this.depthMaterial;\n        renderer.setRenderTarget(this.renderTargetDepthBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\n\n        this.changeVisibilityOfSelectedObjects(true);\n\n        this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\n\n\n        this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\n        this.changeVisibilityOfNonSelectedObjects(false);\n        this.renderScene.overrideMaterial = this.prepareMaskMaterial;\n        this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\n        this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\n        this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\n        renderer.setRenderTarget(this.renderTargetMaskBuffer);\n        renderer.clear();\n        renderer.render(this.renderScene, this.renderCamera);\n        this.renderScene.overrideMaterial = null;\n        this.changeVisibilityOfNonSelectedObjects(true);\n\n        this._visibilityCache.clear();\n\n        this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\n\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\n        renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.tempPulseColor1.copy(this.visibleEdgeColor);\n        this.tempPulseColor2.copy(this.hiddenEdgeColor);\n\n        if (this.pulsePeriod > 0) {\n          var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\n          this.tempPulseColor1.multiplyScalar(scalar);\n          this.tempPulseColor2.multiplyScalar(scalar);\n        } // 3. Apply Edge Detection Pass\n\n\n        this.fsQuad.material = this.edgeDetectionMaterial;\n        this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\n        this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\n        this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\n        this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer); // 4. Apply Blur on Half res\n\n        this.fsQuad.material = this.separableBlurMaterial1;\n        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX;\n        this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\n        this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\n        renderer.clear();\n        this.fsQuad.render(renderer); // Apply Blur on quarter res\n\n        this.fsQuad.material = this.separableBlurMaterial2;\n        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\n        this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX;\n        renderer.setRenderTarget(this.renderTargetBlurBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer);\n        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\n        this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY;\n        renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\n        renderer.clear();\n        this.fsQuad.render(renderer); // Blend it additively over the input texture\n\n        this.fsQuad.material = this.overlayMaterial;\n        this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\n        this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\n        this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\n        this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\n        this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\n        this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\n        this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\n        if (maskActive) renderer.state.buffers.stencil.setTest(true);\n        renderer.setRenderTarget(readBuffer);\n        this.fsQuad.render(renderer);\n        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\n        renderer.autoClear = oldAutoClear;\n      }\n\n      if (this.renderToScreen) {\n        this.fsQuad.material = this.materialCopy;\n        this.copyUniforms['tDiffuse'].value = readBuffer.texture;\n        renderer.setRenderTarget(null);\n        this.fsQuad.render(renderer);\n      }\n    }\n  }, {\n    key: \"getPrepareMaskMaterial\",\n    value: function getPrepareMaskMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          depthTexture: {\n            value: null\n          },\n          cameraNearFar: {\n            value: new Vector2(0.5, 0.5)\n          },\n          textureMatrix: {\n            value: null\n          }\n        },\n        vertexShader: \"#include <morphtarget_pars_vertex>\\n\\t\\t\\t\\t#include <skinning_pars_vertex>\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tuniform mat4 textureMatrix;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\t#include <skinbase_vertex>\\n\\t\\t\\t\\t\\t#include <begin_vertex>\\n\\t\\t\\t\\t\\t#include <morphtarget_vertex>\\n\\t\\t\\t\\t\\t#include <skinning_vertex>\\n\\t\\t\\t\\t\\t#include <project_vertex>\\n\\t\\t\\t\\t\\tvPosition = mvPosition;\\n\\t\\t\\t\\t\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\t\\tprojTexCoord = textureMatrix * worldPosition;\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <packing>\\n\\t\\t\\t\\tvarying vec4 vPosition;\\n\\t\\t\\t\\tvarying vec4 projTexCoord;\\n\\t\\t\\t\\tuniform sampler2D depthTexture;\\n\\t\\t\\t\\tuniform vec2 cameraNearFar;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\\n\\t\\t\\t\\t\\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\\n\\t\\t\\t\\t\\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getEdgeDetectionMaterial\",\n    value: function getEdgeDetectionMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          visibleEdgeColor: {\n            value: new Vector3(1.0, 1.0, 1.0)\n          },\n          hiddenEdgeColor: {\n            value: new Vector3(1.0, 1.0, 1.0)\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec3 visibleEdgeColor;\\n\\t\\t\\t\\tuniform vec3 hiddenEdgeColor;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\n\\t\\t\\t\\t\\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\n\\t\\t\\t\\t\\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\n\\t\\t\\t\\t\\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\n\\t\\t\\t\\t\\tfloat diff1 = (c1.r - c2.r)*0.5;\\n\\t\\t\\t\\t\\tfloat diff2 = (c3.r - c4.r)*0.5;\\n\\t\\t\\t\\t\\tfloat d = length( vec2(diff1, diff2) );\\n\\t\\t\\t\\t\\tfloat a1 = min(c1.g, c2.g);\\n\\t\\t\\t\\t\\tfloat a2 = min(c3.g, c4.g);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = min(a1, a2);\\n\\t\\t\\t\\t\\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\n\\t\\t\\t\\t\\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getSeperableBlurMaterial\",\n    value: function getSeperableBlurMaterial(maxRadius) {\n      return new ShaderMaterial({\n        defines: {\n          MAX_RADIUS: maxRadius\n        },\n        uniforms: {\n          colorTexture: {\n            value: null\n          },\n          texSize: {\n            value: new Vector2(0.5, 0.5)\n          },\n          direction: {\n            value: new Vector2(0.5, 0.5)\n          },\n          kernelRadius: {\n            value: 1.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"#include <common>\\n\\t\\t\\t\\tvarying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D colorTexture;\\n\\t\\t\\t\\tuniform vec2 texSize;\\n\\t\\t\\t\\tuniform vec2 direction;\\n\\t\\t\\t\\tuniform float kernelRadius;\\n\\t\\t\\t\\tfloat gaussianPdf(in float x, in float sigma) {\\n\\t\\t\\t\\t\\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec2 invSize = 1.0 / texSize;\\n\\t\\t\\t\\t\\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\n\\t\\t\\t\\t\\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\n\\t\\t\\t\\t\\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\n\\t\\t\\t\\t\\tvec2 uvOffset = delta;\\n\\t\\t\\t\\t\\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\n\\t\\t\\t\\t\\t\\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\n\\t\\t\\t\\t\\t\\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\n\\t\\t\\t\\t\\t\\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\n\\t\\t\\t\\t\\t\\tdiffuseSum += ((sample1 + sample2) * w);\\n\\t\\t\\t\\t\\t\\tweightSum += (2.0 * w);\\n\\t\\t\\t\\t\\t\\tuvOffset += delta;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tgl_FragColor = diffuseSum/weightSum;\\n\\t\\t\\t\\t}\"\n      });\n    }\n  }, {\n    key: \"getOverlayMaterial\",\n    value: function getOverlayMaterial() {\n      return new ShaderMaterial({\n        uniforms: {\n          maskTexture: {\n            value: null\n          },\n          edgeTexture1: {\n            value: null\n          },\n          edgeTexture2: {\n            value: null\n          },\n          patternTexture: {\n            value: null\n          },\n          edgeStrength: {\n            value: 1.0\n          },\n          edgeGlow: {\n            value: 1.0\n          },\n          usePatternTexture: {\n            value: 0.0\n          }\n        },\n        vertexShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvUv = uv;\\n\\t\\t\\t\\t\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\t\\t\\t\\t}\",\n        fragmentShader: \"varying vec2 vUv;\\n\\t\\t\\t\\tuniform sampler2D maskTexture;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture1;\\n\\t\\t\\t\\tuniform sampler2D edgeTexture2;\\n\\t\\t\\t\\tuniform sampler2D patternTexture;\\n\\t\\t\\t\\tuniform float edgeStrength;\\n\\t\\t\\t\\tuniform float edgeGlow;\\n\\t\\t\\t\\tuniform bool usePatternTexture;\\n\\t\\t\\t\\tvoid main() {\\n\\t\\t\\t\\t\\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\n\\t\\t\\t\\t\\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\n\\t\\t\\t\\t\\tvec4 maskColor = texture2D(maskTexture, vUv);\\n\\t\\t\\t\\t\\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\n\\t\\t\\t\\t\\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\n\\t\\t\\t\\t\\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\n\\t\\t\\t\\t\\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\n\\t\\t\\t\\t\\tif(usePatternTexture)\\n\\t\\t\\t\\t\\t\\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\n\\t\\t\\t\\t\\tgl_FragColor = finalColor;\\n\\t\\t\\t\\t}\",\n        blending: AdditiveBlending,\n        depthTest: false,\n        depthWrite: false,\n        transparent: true\n      });\n    }\n  }]);\n\n  return OutlinePass;\n}(Pass);\n\nexport { OutlinePass };","map":{"version":3,"names":["_defineProperty","Pass","FullScreenQuad","Vector2","Color","WebGLRenderTarget","MeshDepthMaterial","DoubleSide","RGBADepthPacking","NoBlending","UniformsUtils","ShaderMaterial","Matrix4","Vector3","AdditiveBlending","CopyShader","OutlinePass","resolution","scene","camera","selectedObjects","renderScene","renderCamera","undefined","visibleEdgeColor","hiddenEdgeColor","edgeGlow","usePatternTexture","edgeThickness","edgeStrength","downSampleRatio","pulsePeriod","_visibilityCache","Map","x","y","resx","Math","round","resy","renderTargetMaskBuffer","texture","name","generateMipmaps","depthMaterial","side","depthPacking","blending","prepareMaskMaterial","getPrepareMaskMaterial","fragmentShader","replaceDepthToViewZ","renderTargetDepthBuffer","renderTargetMaskDownSampleBuffer","renderTargetBlurBuffer1","renderTargetBlurBuffer2","edgeDetectionMaterial","getEdgeDetectionMaterial","renderTargetEdgeBuffer1","renderTargetEdgeBuffer2","MAX_EDGE_THICKNESS","MAX_EDGE_GLOW","separableBlurMaterial1","getSeperableBlurMaterial","uniforms","value","set","separableBlurMaterial2","overlayMaterial","getOverlayMaterial","console","error","copyShader","copyUniforms","clone","materialCopy","vertexShader","depthTest","depthWrite","transparent","enabled","needsSwap","_oldClearColor","oldClearAlpha","fsQuad","tempPulseColor1","tempPulseColor2","textureMatrix","string","type","isPerspectiveCamera","replace","dispose","width","height","setSize","bVisible","cache","gatherSelectedMeshesCallBack","object","isMesh","visible","get","i","length","selectedObject","traverse","selectedMeshes","push","VisibilityChangeCallBack","isSprite","bFound","selectedObjectId","id","visibility","isPoints","isLine","multiply","projectionMatrix","matrixWorldInverse","renderer","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","state","buffers","stencil","setTest","setClearColor","changeVisibilityOfSelectedObjects","currentBackground","background","overrideMaterial","setRenderTarget","clear","render","updateTextureMatrix","changeVisibilityOfNonSelectedObjects","near","far","material","copy","scalar","cos","performance","now","multiplyScalar","BlurDirectionX","BlurDirectionY","patternTexture","renderToScreen","depthTexture","cameraNearFar","maskTexture","texSize","maxRadius","defines","MAX_RADIUS","colorTexture","direction","kernelRadius","edgeTexture1","edgeTexture2"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/postprocessing/OutlinePass.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Pass, FullScreenQuad } from './Pass.js';\r\nimport { Vector2, Color, WebGLRenderTarget, MeshDepthMaterial, DoubleSide, RGBADepthPacking, NoBlending, UniformsUtils, ShaderMaterial, Matrix4, Vector3, AdditiveBlending } from 'three';\r\nimport { CopyShader } from '../shaders/CopyShader.js';\r\n\r\nclass OutlinePass extends Pass {\r\n  constructor(resolution, scene, camera, selectedObjects) {\r\n    super();\r\n\r\n    _defineProperty(this, \"renderScene\", void 0);\r\n\r\n    _defineProperty(this, \"renderCamera\", void 0);\r\n\r\n    _defineProperty(this, \"selectedObjects\", void 0);\r\n\r\n    _defineProperty(this, \"visibleEdgeColor\", void 0);\r\n\r\n    _defineProperty(this, \"hiddenEdgeColor\", void 0);\r\n\r\n    _defineProperty(this, \"edgeGlow\", void 0);\r\n\r\n    _defineProperty(this, \"usePatternTexture\", void 0);\r\n\r\n    _defineProperty(this, \"edgeThickness\", void 0);\r\n\r\n    _defineProperty(this, \"edgeStrength\", void 0);\r\n\r\n    _defineProperty(this, \"downSampleRatio\", void 0);\r\n\r\n    _defineProperty(this, \"pulsePeriod\", void 0);\r\n\r\n    _defineProperty(this, \"resolution\", void 0);\r\n\r\n    _defineProperty(this, \"renderTargetMaskBuffer\", void 0);\r\n\r\n    _defineProperty(this, \"depthMaterial\", void 0);\r\n\r\n    _defineProperty(this, \"prepareMaskMaterial\", void 0);\r\n\r\n    _defineProperty(this, \"renderTargetDepthBuffer\", void 0);\r\n\r\n    _defineProperty(this, \"renderTargetMaskDownSampleBuffer\", void 0);\r\n\r\n    _defineProperty(this, \"renderTargetBlurBuffer1\", void 0);\r\n\r\n    _defineProperty(this, \"renderTargetBlurBuffer2\", void 0);\r\n\r\n    _defineProperty(this, \"edgeDetectionMaterial\", void 0);\r\n\r\n    _defineProperty(this, \"renderTargetEdgeBuffer1\", void 0);\r\n\r\n    _defineProperty(this, \"renderTargetEdgeBuffer2\", void 0);\r\n\r\n    _defineProperty(this, \"separableBlurMaterial1\", void 0);\r\n\r\n    _defineProperty(this, \"separableBlurMaterial2\", void 0);\r\n\r\n    _defineProperty(this, \"overlayMaterial\", void 0);\r\n\r\n    _defineProperty(this, \"materialCopy\", void 0);\r\n\r\n    _defineProperty(this, \"oldClearAlpha\", void 0);\r\n\r\n    _defineProperty(this, \"fsQuad\", void 0);\r\n\r\n    _defineProperty(this, \"tempPulseColor1\", void 0);\r\n\r\n    _defineProperty(this, \"tempPulseColor2\", void 0);\r\n\r\n    _defineProperty(this, \"textureMatrix\", void 0);\r\n\r\n    _defineProperty(this, \"patternTexture\", void 0);\r\n\r\n    _defineProperty(this, \"_visibilityCache\", void 0);\r\n\r\n    _defineProperty(this, \"_oldClearColor\", void 0);\r\n\r\n    _defineProperty(this, \"copyUniforms\", void 0);\r\n\r\n    _defineProperty(this, \"BlurDirectionX\", new Vector2(1.0, 0.0));\r\n\r\n    _defineProperty(this, \"BlurDirectionY\", new Vector2(0.0, 1.0));\r\n\r\n    this.renderScene = scene;\r\n    this.renderCamera = camera;\r\n    this.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\r\n    this.visibleEdgeColor = new Color(1, 1, 1);\r\n    this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02);\r\n    this.edgeGlow = 0.0;\r\n    this.usePatternTexture = false;\r\n    this.edgeThickness = 1.0;\r\n    this.edgeStrength = 3.0;\r\n    this.downSampleRatio = 2;\r\n    this.pulsePeriod = 0;\r\n    this._visibilityCache = new Map();\r\n    this.resolution = resolution !== undefined ? new Vector2(resolution.x, resolution.y) : new Vector2(256, 256);\r\n    const resx = Math.round(this.resolution.x / this.downSampleRatio);\r\n    const resy = Math.round(this.resolution.y / this.downSampleRatio);\r\n    this.renderTargetMaskBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\r\n    this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';\r\n    this.renderTargetMaskBuffer.texture.generateMipmaps = false;\r\n    this.depthMaterial = new MeshDepthMaterial();\r\n    this.depthMaterial.side = DoubleSide;\r\n    this.depthMaterial.depthPacking = RGBADepthPacking;\r\n    this.depthMaterial.blending = NoBlending;\r\n    this.prepareMaskMaterial = this.getPrepareMaskMaterial();\r\n    this.prepareMaskMaterial.side = DoubleSide;\r\n    this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(this.prepareMaskMaterial.fragmentShader, this.renderCamera);\r\n    this.renderTargetDepthBuffer = new WebGLRenderTarget(this.resolution.x, this.resolution.y);\r\n    this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';\r\n    this.renderTargetDepthBuffer.texture.generateMipmaps = false;\r\n    this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy);\r\n    this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';\r\n    this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\r\n    this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy);\r\n    this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';\r\n    this.renderTargetBlurBuffer1.texture.generateMipmaps = false;\r\n    this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\r\n    this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';\r\n    this.renderTargetBlurBuffer2.texture.generateMipmaps = false;\r\n    this.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\r\n    this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy);\r\n    this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';\r\n    this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\r\n    this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2));\r\n    this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';\r\n    this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\r\n    const MAX_EDGE_THICKNESS = 4;\r\n    const MAX_EDGE_GLOW = 4;\r\n    this.separableBlurMaterial1 = this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);\r\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\r\n    this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;\r\n    this.separableBlurMaterial2 = this.getSeperableBlurMaterial(MAX_EDGE_GLOW);\r\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));\r\n    this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material\r\n\r\n    this.overlayMaterial = this.getOverlayMaterial(); // copy material\r\n\r\n    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');\r\n    const copyShader = CopyShader;\r\n    this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);\r\n    this.copyUniforms['opacity'].value = 1.0;\r\n    this.materialCopy = new ShaderMaterial({\r\n      uniforms: this.copyUniforms,\r\n      vertexShader: copyShader.vertexShader,\r\n      fragmentShader: copyShader.fragmentShader,\r\n      blending: NoBlending,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n    });\r\n    this.enabled = true;\r\n    this.needsSwap = false;\r\n    this._oldClearColor = new Color();\r\n    this.oldClearAlpha = 1;\r\n    this.fsQuad = new FullScreenQuad(this.materialCopy);\r\n    this.tempPulseColor1 = new Color();\r\n    this.tempPulseColor2 = new Color();\r\n    this.textureMatrix = new Matrix4();\r\n\r\n    function replaceDepthToViewZ(string, camera) {\r\n      const type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\r\n      return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');\r\n    }\r\n  }\r\n\r\n  dispose() {\r\n    this.renderTargetMaskBuffer.dispose();\r\n    this.renderTargetDepthBuffer.dispose();\r\n    this.renderTargetMaskDownSampleBuffer.dispose();\r\n    this.renderTargetBlurBuffer1.dispose();\r\n    this.renderTargetBlurBuffer2.dispose();\r\n    this.renderTargetEdgeBuffer1.dispose();\r\n    this.renderTargetEdgeBuffer2.dispose();\r\n  }\r\n\r\n  setSize(width, height) {\r\n    this.renderTargetMaskBuffer.setSize(width, height);\r\n    this.renderTargetDepthBuffer.setSize(width, height);\r\n    let resx = Math.round(width / this.downSampleRatio);\r\n    let resy = Math.round(height / this.downSampleRatio);\r\n    this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);\r\n    this.renderTargetBlurBuffer1.setSize(resx, resy);\r\n    this.renderTargetEdgeBuffer1.setSize(resx, resy);\r\n    this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);\r\n    resx = Math.round(resx / 2);\r\n    resy = Math.round(resy / 2);\r\n    this.renderTargetBlurBuffer2.setSize(resx, resy);\r\n    this.renderTargetEdgeBuffer2.setSize(resx, resy);\r\n    this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);\r\n  }\r\n\r\n  changeVisibilityOfSelectedObjects(bVisible) {\r\n    const cache = this._visibilityCache;\r\n\r\n    function gatherSelectedMeshesCallBack(object) {\r\n      if (object.isMesh) {\r\n        if (bVisible === true) {\r\n          object.visible = cache.get(object);\r\n        } else {\r\n          cache.set(object, object.visible);\r\n          object.visible = bVisible;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < this.selectedObjects.length; i++) {\r\n      const selectedObject = this.selectedObjects[i];\r\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\r\n    }\r\n  }\r\n\r\n  changeVisibilityOfNonSelectedObjects(bVisible) {\r\n    const cache = this._visibilityCache;\r\n    const selectedMeshes = [];\r\n\r\n    function gatherSelectedMeshesCallBack(object) {\r\n      if (object.isMesh) selectedMeshes.push(object);\r\n    }\r\n\r\n    for (let i = 0; i < this.selectedObjects.length; i++) {\r\n      const selectedObject = this.selectedObjects[i];\r\n      selectedObject.traverse(gatherSelectedMeshesCallBack);\r\n    }\r\n\r\n    function VisibilityChangeCallBack(object) {\r\n      if (object.isMesh || object.isSprite) {\r\n        // only meshes and sprites are supported by OutlinePass\r\n        let bFound = false;\r\n\r\n        for (let i = 0; i < selectedMeshes.length; i++) {\r\n          const selectedObjectId = selectedMeshes[i].id;\r\n\r\n          if (selectedObjectId === object.id) {\r\n            bFound = true;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (bFound === false) {\r\n          const visibility = object.visible;\r\n\r\n          if (bVisible === false || cache.get(object) === true) {\r\n            object.visible = bVisible;\r\n          }\r\n\r\n          cache.set(object, visibility);\r\n        }\r\n      } else if (object.isPoints || object.isLine) {\r\n        // the visibilty of points and lines is always set to false in order to\r\n        // not affect the outline computation\r\n        if (bVisible === true) {\r\n          object.visible = cache.get(object); // restore\r\n        } else {\r\n          cache.set(object, object.visible);\r\n          object.visible = bVisible;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.renderScene.traverse(VisibilityChangeCallBack);\r\n  }\r\n\r\n  updateTextureMatrix() {\r\n    this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);\r\n    this.textureMatrix.multiply(this.renderCamera.projectionMatrix);\r\n    this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);\r\n  }\r\n\r\n  render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\r\n    if (this.selectedObjects.length > 0) {\r\n      renderer.getClearColor(this._oldClearColor);\r\n      this.oldClearAlpha = renderer.getClearAlpha();\r\n      const oldAutoClear = renderer.autoClear;\r\n      renderer.autoClear = false;\r\n      if (maskActive) renderer.state.buffers.stencil.setTest(false);\r\n      renderer.setClearColor(0xffffff, 1); // Make selected objects invisible\r\n\r\n      this.changeVisibilityOfSelectedObjects(false);\r\n      const currentBackground = this.renderScene.background;\r\n      this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer\r\n\r\n      this.renderScene.overrideMaterial = this.depthMaterial;\r\n      renderer.setRenderTarget(this.renderTargetDepthBuffer);\r\n      renderer.clear();\r\n      renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible\r\n\r\n      this.changeVisibilityOfSelectedObjects(true);\r\n\r\n      this._visibilityCache.clear(); // Update Texture Matrix for Depth compare\r\n\r\n\r\n      this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\r\n\r\n      this.changeVisibilityOfNonSelectedObjects(false);\r\n      this.renderScene.overrideMaterial = this.prepareMaskMaterial;\r\n      this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);\r\n      this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;\r\n      this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;\r\n      renderer.setRenderTarget(this.renderTargetMaskBuffer);\r\n      renderer.clear();\r\n      renderer.render(this.renderScene, this.renderCamera);\r\n      this.renderScene.overrideMaterial = null;\r\n      this.changeVisibilityOfNonSelectedObjects(true);\r\n\r\n      this._visibilityCache.clear();\r\n\r\n      this.renderScene.background = currentBackground; // 2. Downsample to Half resolution\r\n\r\n      this.fsQuad.material = this.materialCopy;\r\n      this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;\r\n      renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n      this.tempPulseColor1.copy(this.visibleEdgeColor);\r\n      this.tempPulseColor2.copy(this.hiddenEdgeColor);\r\n\r\n      if (this.pulsePeriod > 0) {\r\n        const scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;\r\n        this.tempPulseColor1.multiplyScalar(scalar);\r\n        this.tempPulseColor2.multiplyScalar(scalar);\r\n      } // 3. Apply Edge Detection Pass\r\n\r\n\r\n      this.fsQuad.material = this.edgeDetectionMaterial;\r\n      this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;\r\n      this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);\r\n      this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value = this.tempPulseColor1;\r\n      this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value = this.tempPulseColor2;\r\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer); // 4. Apply Blur on Half res\r\n\r\n      this.fsQuad.material = this.separableBlurMaterial1;\r\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\r\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionX;\r\n      this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;\r\n      renderer.setRenderTarget(this.renderTargetBlurBuffer1);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n      this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;\r\n      this.separableBlurMaterial1.uniforms['direction'].value = this.BlurDirectionY;\r\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer1);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer); // Apply Blur on quarter res\r\n\r\n      this.fsQuad.material = this.separableBlurMaterial2;\r\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;\r\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionX;\r\n      renderer.setRenderTarget(this.renderTargetBlurBuffer2);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer);\r\n      this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;\r\n      this.separableBlurMaterial2.uniforms['direction'].value = this.BlurDirectionY;\r\n      renderer.setRenderTarget(this.renderTargetEdgeBuffer2);\r\n      renderer.clear();\r\n      this.fsQuad.render(renderer); // Blend it additively over the input texture\r\n\r\n      this.fsQuad.material = this.overlayMaterial;\r\n      this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;\r\n      this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;\r\n      this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;\r\n      this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;\r\n      this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;\r\n      this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;\r\n      this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;\r\n      if (maskActive) renderer.state.buffers.stencil.setTest(true);\r\n      renderer.setRenderTarget(readBuffer);\r\n      this.fsQuad.render(renderer);\r\n      renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);\r\n      renderer.autoClear = oldAutoClear;\r\n    }\r\n\r\n    if (this.renderToScreen) {\r\n      this.fsQuad.material = this.materialCopy;\r\n      this.copyUniforms['tDiffuse'].value = readBuffer.texture;\r\n      renderer.setRenderTarget(null);\r\n      this.fsQuad.render(renderer);\r\n    }\r\n  }\r\n\r\n  getPrepareMaskMaterial() {\r\n    return new ShaderMaterial({\r\n      uniforms: {\r\n        depthTexture: {\r\n          value: null\r\n        },\r\n        cameraNearFar: {\r\n          value: new Vector2(0.5, 0.5)\r\n        },\r\n        textureMatrix: {\r\n          value: null\r\n        }\r\n      },\r\n      vertexShader: `#include <morphtarget_pars_vertex>\r\n\t\t\t\t#include <skinning_pars_vertex>\r\n\t\t\t\tvarying vec4 projTexCoord;\r\n\t\t\t\tvarying vec4 vPosition;\r\n\t\t\t\tuniform mat4 textureMatrix;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\t#include <skinbase_vertex>\r\n\t\t\t\t\t#include <begin_vertex>\r\n\t\t\t\t\t#include <morphtarget_vertex>\r\n\t\t\t\t\t#include <skinning_vertex>\r\n\t\t\t\t\t#include <project_vertex>\r\n\t\t\t\t\tvPosition = mvPosition;\r\n\t\t\t\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\r\n\t\t\t\t}`,\r\n      fragmentShader: `#include <packing>\r\n\t\t\t\tvarying vec4 vPosition;\r\n\t\t\t\tvarying vec4 projTexCoord;\r\n\t\t\t\tuniform sampler2D depthTexture;\r\n\t\t\t\tuniform vec2 cameraNearFar;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\r\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\r\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\r\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\r\n\t\t\t\t}`\r\n    });\r\n  }\r\n\r\n  getEdgeDetectionMaterial() {\r\n    return new ShaderMaterial({\r\n      uniforms: {\r\n        maskTexture: {\r\n          value: null\r\n        },\r\n        texSize: {\r\n          value: new Vector2(0.5, 0.5)\r\n        },\r\n        visibleEdgeColor: {\r\n          value: new Vector3(1.0, 1.0, 1.0)\r\n        },\r\n        hiddenEdgeColor: {\r\n          value: new Vector3(1.0, 1.0, 1.0)\r\n        }\r\n      },\r\n      vertexShader: `varying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n      fragmentShader: `varying vec2 vUv;\r\n\t\t\t\tuniform sampler2D maskTexture;\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec3 visibleEdgeColor;\r\n\t\t\t\tuniform vec3 hiddenEdgeColor;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\r\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\r\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\r\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\r\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\r\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\r\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\r\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\r\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\r\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\r\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\r\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\r\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\r\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\r\n\t\t\t\t}`\r\n    });\r\n  }\r\n\r\n  getSeperableBlurMaterial(maxRadius) {\r\n    return new ShaderMaterial({\r\n      defines: {\r\n        MAX_RADIUS: maxRadius\r\n      },\r\n      uniforms: {\r\n        colorTexture: {\r\n          value: null\r\n        },\r\n        texSize: {\r\n          value: new Vector2(0.5, 0.5)\r\n        },\r\n        direction: {\r\n          value: new Vector2(0.5, 0.5)\r\n        },\r\n        kernelRadius: {\r\n          value: 1.0\r\n        }\r\n      },\r\n      vertexShader: `varying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n      fragmentShader: `#include <common>\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform sampler2D colorTexture;\r\n\t\t\t\tuniform vec2 texSize;\r\n\t\t\t\tuniform vec2 direction;\r\n\t\t\t\tuniform float kernelRadius;\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\r\n\t\t\t\t}\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\r\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\r\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\r\n\t\t\t\t\tvec2 uvOffset = delta;\r\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\r\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\r\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\r\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\r\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\r\n\t\t\t\t\t\tweightSum += (2.0 * w);\r\n\t\t\t\t\t\tuvOffset += delta;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\r\n\t\t\t\t}`\r\n    });\r\n  }\r\n\r\n  getOverlayMaterial() {\r\n    return new ShaderMaterial({\r\n      uniforms: {\r\n        maskTexture: {\r\n          value: null\r\n        },\r\n        edgeTexture1: {\r\n          value: null\r\n        },\r\n        edgeTexture2: {\r\n          value: null\r\n        },\r\n        patternTexture: {\r\n          value: null\r\n        },\r\n        edgeStrength: {\r\n          value: 1.0\r\n        },\r\n        edgeGlow: {\r\n          value: 1.0\r\n        },\r\n        usePatternTexture: {\r\n          value: 0.0\r\n        }\r\n      },\r\n      vertexShader: `varying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}`,\r\n      fragmentShader: `varying vec2 vUv;\r\n\t\t\t\tuniform sampler2D maskTexture;\r\n\t\t\t\tuniform sampler2D edgeTexture1;\r\n\t\t\t\tuniform sampler2D edgeTexture2;\r\n\t\t\t\tuniform sampler2D patternTexture;\r\n\t\t\t\tuniform float edgeStrength;\r\n\t\t\t\tuniform float edgeGlow;\r\n\t\t\t\tuniform bool usePatternTexture;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\r\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\r\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\r\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\r\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\r\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\r\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\r\n\t\t\t\t\tif(usePatternTexture)\r\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\r\n\t\t\t\t\tgl_FragColor = finalColor;\r\n\t\t\t\t}`,\r\n      blending: AdditiveBlending,\r\n      depthTest: false,\r\n      depthWrite: false,\r\n      transparent: true\r\n    });\r\n  }\r\n\r\n}\r\n\r\nexport { OutlinePass };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}