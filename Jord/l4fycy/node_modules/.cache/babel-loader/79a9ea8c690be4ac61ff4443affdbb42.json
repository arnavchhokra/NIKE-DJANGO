{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as THREE from 'three';\nvar PINCH_MAX = 0.05;\nvar PINCH_THRESHOLD = 0.02;\nvar PINCH_MIN = 0.01;\nvar POINTER_ADVANCE_MAX = 0.02;\nvar POINTER_OPACITY_MAX = 1;\nvar POINTER_OPACITY_MIN = 0.4;\nvar POINTER_FRONT_RADIUS = 0.002;\nvar POINTER_REAR_RADIUS = 0.01;\nvar POINTER_REAR_RADIUS_MIN = 0.003;\nvar POINTER_LENGTH = 0.035;\nvar POINTER_SEGMENTS = 16;\nvar POINTER_RINGS = 12;\nvar POINTER_HEMISPHERE_ANGLE = 110;\nvar YAXIS = new THREE.Vector3(0, 1, 0);\nvar ZAXIS = new THREE.Vector3(0, 0, 1);\nvar CURSOR_RADIUS = 0.02;\nvar CURSOR_MAX_DISTANCE = 1.5;\n\nvar OculusHandPointerModel = /*#__PURE__*/function (_THREE$Object3D) {\n  _inherits(OculusHandPointerModel, _THREE$Object3D);\n\n  var _super = _createSuper(OculusHandPointerModel);\n\n  function OculusHandPointerModel(hand, controller) {\n    var _this;\n\n    _classCallCheck(this, OculusHandPointerModel);\n\n    _this = _super.call(this);\n    _this.hand = hand;\n    _this.controller = controller;\n    _this.motionController = null;\n    _this.envMap = null;\n    _this.mesh = null;\n    _this.pointerGeometry = null;\n    _this.pointerMesh = null;\n    _this.pointerObject = null;\n    _this.pinched = false;\n    _this.attached = false;\n    _this.cursorObject = null;\n    _this.raycaster = null;\n    hand.addEventListener('connected', function (event) {\n      var xrInputSource = event.data;\n\n      if (xrInputSource.hand) {\n        _this.visible = true;\n        _this.xrInputSource = xrInputSource;\n\n        _this.createPointer();\n      }\n    });\n    return _this;\n  }\n\n  _createClass(OculusHandPointerModel, [{\n    key: \"_drawVerticesRing\",\n    value: function _drawVerticesRing(vertices, baseVector, ringIndex) {\n      var segmentVector = baseVector.clone();\n\n      for (var i = 0; i < POINTER_SEGMENTS; i++) {\n        segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n        var vid = ringIndex * POINTER_SEGMENTS + i;\n        vertices[3 * vid] = segmentVector.x;\n        vertices[3 * vid + 1] = segmentVector.y;\n        vertices[3 * vid + 2] = segmentVector.z;\n      }\n    }\n  }, {\n    key: \"_updatePointerVertices\",\n    value: function _updatePointerVertices(rearRadius) {\n      var vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n      var frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n\n      this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n\n      var rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n\n      for (var i = 0; i < POINTER_RINGS; i++) {\n        this._drawVerticesRing(vertices, rearBase, i + 1);\n\n        rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n      } // front and rear face center vertices\n\n\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n      var frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n      vertices[frontCenterIndex * 3] = frontCenter.x;\n      vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n      vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n      var rearCenter = new THREE.Vector3(0, 0, rearRadius);\n      vertices[rearCenterIndex * 3] = rearCenter.x;\n      vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n      vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n      this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n    }\n  }, {\n    key: \"createPointer\",\n    value: function createPointer() {\n      var i, j;\n      var vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n      var indices = [];\n      this.pointerGeometry = new THREE.BufferGeometry();\n      this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n      this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n\n      for (i = 0; i < POINTER_RINGS; i++) {\n        for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n          indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n          indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        }\n\n        indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n        indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      } // construct front and rear face\n\n\n      var frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n      var rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n\n      for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n        indices.push(frontCenterIndex, i + 1, i);\n        indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n      }\n\n      indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n      indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n      var material = new THREE.MeshBasicMaterial();\n      material.transparent = true;\n      material.opacity = POINTER_OPACITY_MIN;\n      this.pointerGeometry.setIndex(indices);\n      this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerObject = new THREE.Object3D();\n      this.pointerObject.add(this.pointerMesh);\n      this.raycaster = new THREE.Raycaster(); // create cursor\n\n      var cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n      var cursorMaterial = new THREE.MeshBasicMaterial();\n      cursorMaterial.transparent = true;\n      cursorMaterial.opacity = POINTER_OPACITY_MIN;\n      this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n      this.pointerObject.add(this.cursorObject);\n      this.add(this.pointerObject);\n    }\n  }, {\n    key: \"_updateRaycaster\",\n    value: function _updateRaycaster() {\n      if (this.raycaster) {\n        var pointerMatrix = this.pointerObject.matrixWorld;\n        var tempMatrix = new THREE.Matrix4();\n        tempMatrix.identity().extractRotation(pointerMatrix);\n        this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n        this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n      }\n    }\n  }, {\n    key: \"_updatePointer\",\n    value: function _updatePointer() {\n      this.pointerObject.visible = this.controller.visible;\n      var indexTip = this.hand.joints['index-finger-tip'];\n      var thumbTip = this.hand.joints['thumb-tip'];\n      var distance = indexTip.position.distanceTo(thumbTip.position);\n      var position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n      this.pointerObject.position.copy(position);\n      this.pointerObject.quaternion.copy(this.controller.quaternion);\n      this.pinched = distance <= PINCH_THRESHOLD;\n      var pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n      var focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n\n      if (pinchScale > 1) {\n        this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      } else if (pinchScale > 0) {\n        var rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n\n        this._updatePointerVertices(rearRadius);\n\n        if (focusScale < 1) {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n        } else {\n          this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n          this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n        }\n      } else {\n        this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n\n        this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n      }\n\n      this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n    }\n  }, {\n    key: \"updateMatrixWorld\",\n    value: function updateMatrixWorld(force) {\n      _get(_getPrototypeOf(OculusHandPointerModel.prototype), \"updateMatrixWorld\", this).call(this, force);\n\n      if (this.pointerGeometry) {\n        this._updatePointer();\n\n        this._updateRaycaster();\n      }\n    }\n  }, {\n    key: \"isPinched\",\n    value: function isPinched() {\n      return this.pinched;\n    }\n  }, {\n    key: \"setAttached\",\n    value: function setAttached(attached) {\n      this.attached = attached;\n    }\n  }, {\n    key: \"isAttached\",\n    value: function isAttached() {\n      return this.attached;\n    }\n  }, {\n    key: \"intersectObject\",\n    value: function intersectObject(object) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (this.raycaster) {\n        return this.raycaster.intersectObject(object, recursive);\n      }\n    }\n  }, {\n    key: \"intersectObjects\",\n    value: function intersectObjects(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (this.raycaster) {\n        return this.raycaster.intersectObjects(objects, recursive);\n      }\n    }\n  }, {\n    key: \"checkIntersections\",\n    value: function checkIntersections(objects) {\n      var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this.raycaster && !this.attached) {\n        var intersections = this.raycaster.intersectObjects(objects, recursive);\n        var direction = new THREE.Vector3(0, 0, -1);\n\n        if (intersections.length > 0) {\n          var intersection = intersections[0];\n          var distance = intersection.distance;\n          this.cursorObject.position.copy(direction.multiplyScalar(distance));\n        } else {\n          this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n        }\n      }\n    }\n  }, {\n    key: \"setCursor\",\n    value: function setCursor(distance) {\n      var direction = new THREE.Vector3(0, 0, -1);\n\n      if (this.raycaster && !this.attached) {\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      }\n    }\n  }]);\n\n  return OculusHandPointerModel;\n}(THREE.Object3D);\n\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","hand","controller","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","addEventListener","event","xrInputSource","data","visible","createPointer","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","rearRadius","attributes","position","array","frontFaceBase","_drawVerticesRing","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","_updatePointerVertices","push","material","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","Object3D","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","force","_updatePointer","_updateRaycaster","object","recursive","intersectObject","objects","intersectObjects","intersections","length","intersection"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from 'three';\r\n\r\nconst PINCH_MAX = 0.05;\r\nconst PINCH_THRESHOLD = 0.02;\r\nconst PINCH_MIN = 0.01;\r\nconst POINTER_ADVANCE_MAX = 0.02;\r\nconst POINTER_OPACITY_MAX = 1;\r\nconst POINTER_OPACITY_MIN = 0.4;\r\nconst POINTER_FRONT_RADIUS = 0.002;\r\nconst POINTER_REAR_RADIUS = 0.01;\r\nconst POINTER_REAR_RADIUS_MIN = 0.003;\r\nconst POINTER_LENGTH = 0.035;\r\nconst POINTER_SEGMENTS = 16;\r\nconst POINTER_RINGS = 12;\r\nconst POINTER_HEMISPHERE_ANGLE = 110;\r\nconst YAXIS = new THREE.Vector3(0, 1, 0);\r\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\r\nconst CURSOR_RADIUS = 0.02;\r\nconst CURSOR_MAX_DISTANCE = 1.5;\r\n\r\nclass OculusHandPointerModel extends THREE.Object3D {\r\n  constructor(hand, controller) {\r\n    super();\r\n    this.hand = hand;\r\n    this.controller = controller;\r\n    this.motionController = null;\r\n    this.envMap = null;\r\n    this.mesh = null;\r\n    this.pointerGeometry = null;\r\n    this.pointerMesh = null;\r\n    this.pointerObject = null;\r\n    this.pinched = false;\r\n    this.attached = false;\r\n    this.cursorObject = null;\r\n    this.raycaster = null;\r\n    hand.addEventListener('connected', event => {\r\n      const xrInputSource = event.data;\r\n\r\n      if (xrInputSource.hand) {\r\n        this.visible = true;\r\n        this.xrInputSource = xrInputSource;\r\n        this.createPointer();\r\n      }\r\n    });\r\n  }\r\n\r\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\r\n    const segmentVector = baseVector.clone();\r\n\r\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\r\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\r\n      const vid = ringIndex * POINTER_SEGMENTS + i;\r\n      vertices[3 * vid] = segmentVector.x;\r\n      vertices[3 * vid + 1] = segmentVector.y;\r\n      vertices[3 * vid + 2] = segmentVector.z;\r\n    }\r\n  }\r\n\r\n  _updatePointerVertices(rearRadius) {\r\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\r\n\r\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\r\n\r\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\r\n\r\n\r\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\r\n\r\n    for (var i = 0; i < POINTER_RINGS; i++) {\r\n      this._drawVerticesRing(vertices, rearBase, i + 1);\r\n\r\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\r\n    } // front and rear face center vertices\r\n\r\n\r\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\r\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\r\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\r\n    vertices[frontCenterIndex * 3] = frontCenter.x;\r\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\r\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\r\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\r\n    vertices[rearCenterIndex * 3] = rearCenter.x;\r\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\r\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\r\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\r\n  }\r\n\r\n  createPointer() {\r\n    var i, j;\r\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\r\n\r\n    const indices = [];\r\n    this.pointerGeometry = new THREE.BufferGeometry();\r\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\r\n\r\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\r\n\r\n\r\n    for (i = 0; i < POINTER_RINGS; i++) {\r\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\r\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\r\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\r\n      }\r\n\r\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\r\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\r\n    } // construct front and rear face\r\n\r\n\r\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\r\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\r\n\r\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\r\n      indices.push(frontCenterIndex, i + 1, i);\r\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\r\n    }\r\n\r\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\r\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\r\n    const material = new THREE.MeshBasicMaterial();\r\n    material.transparent = true;\r\n    material.opacity = POINTER_OPACITY_MIN;\r\n    this.pointerGeometry.setIndex(indices);\r\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\r\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\r\n    this.pointerObject = new THREE.Object3D();\r\n    this.pointerObject.add(this.pointerMesh);\r\n    this.raycaster = new THREE.Raycaster(); // create cursor\r\n\r\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\r\n    const cursorMaterial = new THREE.MeshBasicMaterial();\r\n    cursorMaterial.transparent = true;\r\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\r\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\r\n    this.pointerObject.add(this.cursorObject);\r\n    this.add(this.pointerObject);\r\n  }\r\n\r\n  _updateRaycaster() {\r\n    if (this.raycaster) {\r\n      const pointerMatrix = this.pointerObject.matrixWorld;\r\n      const tempMatrix = new THREE.Matrix4();\r\n      tempMatrix.identity().extractRotation(pointerMatrix);\r\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\r\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\r\n    }\r\n  }\r\n\r\n  _updatePointer() {\r\n    this.pointerObject.visible = this.controller.visible;\r\n    const indexTip = this.hand.joints['index-finger-tip'];\r\n    const thumbTip = this.hand.joints['thumb-tip'];\r\n    const distance = indexTip.position.distanceTo(thumbTip.position);\r\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\r\n    this.pointerObject.position.copy(position);\r\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\r\n    this.pinched = distance <= PINCH_THRESHOLD;\r\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\r\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\r\n\r\n    if (pinchScale > 1) {\r\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\r\n\r\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\r\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\r\n    } else if (pinchScale > 0) {\r\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\r\n\r\n      this._updatePointerVertices(rearRadius);\r\n\r\n      if (focusScale < 1) {\r\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\r\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\r\n      } else {\r\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\r\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\r\n      }\r\n    } else {\r\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\r\n\r\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\r\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\r\n    }\r\n\r\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\r\n  }\r\n\r\n  updateMatrixWorld(force) {\r\n    super.updateMatrixWorld(force);\r\n\r\n    if (this.pointerGeometry) {\r\n      this._updatePointer();\r\n\r\n      this._updateRaycaster();\r\n    }\r\n  }\r\n\r\n  isPinched() {\r\n    return this.pinched;\r\n  }\r\n\r\n  setAttached(attached) {\r\n    this.attached = attached;\r\n  }\r\n\r\n  isAttached() {\r\n    return this.attached;\r\n  }\r\n\r\n  intersectObject(object, recursive = true) {\r\n    if (this.raycaster) {\r\n      return this.raycaster.intersectObject(object, recursive);\r\n    }\r\n  }\r\n\r\n  intersectObjects(objects, recursive = true) {\r\n    if (this.raycaster) {\r\n      return this.raycaster.intersectObjects(objects, recursive);\r\n    }\r\n  }\r\n\r\n  checkIntersections(objects, recursive = false) {\r\n    if (this.raycaster && !this.attached) {\r\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\r\n      const direction = new THREE.Vector3(0, 0, -1);\r\n\r\n      if (intersections.length > 0) {\r\n        const intersection = intersections[0];\r\n        const distance = intersection.distance;\r\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\r\n      } else {\r\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\r\n      }\r\n    }\r\n  }\r\n\r\n  setCursor(distance) {\r\n    const direction = new THREE.Vector3(0, 0, -1);\r\n\r\n    if (this.raycaster && !this.attached) {\r\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { OculusHandPointerModel };\r\n"],"mappings":";;;;;;AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AAEA,IAAMC,SAAS,GAAG,IAAlB;AACA,IAAMC,eAAe,GAAG,IAAxB;AACA,IAAMC,SAAS,GAAG,IAAlB;AACA,IAAMC,mBAAmB,GAAG,IAA5B;AACA,IAAMC,mBAAmB,GAAG,CAA5B;AACA,IAAMC,mBAAmB,GAAG,GAA5B;AACA,IAAMC,oBAAoB,GAAG,KAA7B;AACA,IAAMC,mBAAmB,GAAG,IAA5B;AACA,IAAMC,uBAAuB,GAAG,KAAhC;AACA,IAAMC,cAAc,GAAG,KAAvB;AACA,IAAMC,gBAAgB,GAAG,EAAzB;AACA,IAAMC,aAAa,GAAG,EAAtB;AACA,IAAMC,wBAAwB,GAAG,GAAjC;AACA,IAAMC,KAAK,GAAG,IAAId,KAAK,CAACe,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAd;AACA,IAAMC,KAAK,GAAG,IAAIhB,KAAK,CAACe,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAd;AACA,IAAME,aAAa,GAAG,IAAtB;AACA,IAAMC,mBAAmB,GAAG,GAA5B;;IAEMC,sB;;;;;EACJ,gCAAYC,IAAZ,EAAkBC,UAAlB,EAA8B;IAAA;;IAAA;;IAC5B;IACA,MAAKD,IAAL,GAAYA,IAAZ;IACA,MAAKC,UAAL,GAAkBA,UAAlB;IACA,MAAKC,gBAAL,GAAwB,IAAxB;IACA,MAAKC,MAAL,GAAc,IAAd;IACA,MAAKC,IAAL,GAAY,IAAZ;IACA,MAAKC,eAAL,GAAuB,IAAvB;IACA,MAAKC,WAAL,GAAmB,IAAnB;IACA,MAAKC,aAAL,GAAqB,IAArB;IACA,MAAKC,OAAL,GAAe,KAAf;IACA,MAAKC,QAAL,GAAgB,KAAhB;IACA,MAAKC,YAAL,GAAoB,IAApB;IACA,MAAKC,SAAL,GAAiB,IAAjB;IACAX,IAAI,CAACY,gBAAL,CAAsB,WAAtB,EAAmC,UAAAC,KAAK,EAAI;MAC1C,IAAMC,aAAa,GAAGD,KAAK,CAACE,IAA5B;;MAEA,IAAID,aAAa,CAACd,IAAlB,EAAwB;QACtB,MAAKgB,OAAL,GAAe,IAAf;QACA,MAAKF,aAAL,GAAqBA,aAArB;;QACA,MAAKG,aAAL;MACD;IACF,CARD;IAd4B;EAuB7B;;;;WAED,2BAAkBC,QAAlB,EAA4BC,UAA5B,EAAwCC,SAAxC,EAAmD;MACjD,IAAMC,aAAa,GAAGF,UAAU,CAACG,KAAX,EAAtB;;MAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhC,gBAApB,EAAsCgC,CAAC,EAAvC,EAA2C;QACzCF,aAAa,CAACG,cAAd,CAA6B5B,KAA7B,EAAoC6B,IAAI,CAACC,EAAL,GAAU,CAAV,GAAcnC,gBAAlD;QACA,IAAMoC,GAAG,GAAGP,SAAS,GAAG7B,gBAAZ,GAA+BgC,CAA3C;QACAL,QAAQ,CAAC,IAAIS,GAAL,CAAR,GAAoBN,aAAa,CAACO,CAAlC;QACAV,QAAQ,CAAC,IAAIS,GAAJ,GAAU,CAAX,CAAR,GAAwBN,aAAa,CAACQ,CAAtC;QACAX,QAAQ,CAAC,IAAIS,GAAJ,GAAU,CAAX,CAAR,GAAwBN,aAAa,CAACS,CAAtC;MACD;IACF;;;WAED,gCAAuBC,UAAvB,EAAmC;MACjC,IAAMb,QAAQ,GAAG,KAAKb,eAAL,CAAqB2B,UAArB,CAAgCC,QAAhC,CAAyCC,KAA1D,CADiC,CACgC;;MAEjE,IAAMC,aAAa,GAAG,IAAIvD,KAAK,CAACe,OAAV,CAAkBR,oBAAlB,EAAwC,CAAxC,EAA2C,CAAC,CAAD,IAAMG,cAAc,GAAGyC,UAAvB,CAA3C,CAAtB;;MAEA,KAAKK,iBAAL,CAAuBlB,QAAvB,EAAiCiB,aAAjC,EAAgD,CAAhD,EALiC,CAKmB;;;MAGpD,IAAME,QAAQ,GAAG,IAAIzD,KAAK,CAACe,OAAV,CAAkB8B,IAAI,CAACa,GAAL,CAASb,IAAI,CAACC,EAAL,GAAUjC,wBAAV,GAAqC,GAA9C,IAAqDsC,UAAvE,EAAmFN,IAAI,CAACc,GAAL,CAASd,IAAI,CAACC,EAAL,GAAUjC,wBAAV,GAAqC,GAA9C,IAAqDsC,UAAxI,EAAoJ,CAApJ,CAAjB;;MAEA,KAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,aAApB,EAAmC+B,CAAC,EAApC,EAAwC;QACtC,KAAKa,iBAAL,CAAuBlB,QAAvB,EAAiCmB,QAAjC,EAA2Cd,CAAC,GAAG,CAA/C;;QAEAc,QAAQ,CAACb,cAAT,CAAwB9B,KAAxB,EAA+B+B,IAAI,CAACC,EAAL,GAAUjC,wBAAV,GAAqC,GAArC,IAA4CD,aAAa,GAAG,CAAC,CAA7D,CAA/B;MACD,CAdgC,CAc/B;;;MAGF,IAAMgD,gBAAgB,GAAGjD,gBAAgB,IAAI,IAAIC,aAAR,CAAzC;MACA,IAAMiD,eAAe,GAAGlD,gBAAgB,IAAI,IAAIC,aAAR,CAAhB,GAAyC,CAAjE;MACA,IAAMkD,WAAW,GAAG,IAAI9D,KAAK,CAACe,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAC,CAAD,IAAML,cAAc,GAAGyC,UAAvB,CAAxB,CAApB;MACAb,QAAQ,CAACsB,gBAAgB,GAAG,CAApB,CAAR,GAAiCE,WAAW,CAACd,CAA7C;MACAV,QAAQ,CAACsB,gBAAgB,GAAG,CAAnB,GAAuB,CAAxB,CAAR,GAAqCE,WAAW,CAACb,CAAjD;MACAX,QAAQ,CAACsB,gBAAgB,GAAG,CAAnB,GAAuB,CAAxB,CAAR,GAAqCE,WAAW,CAACZ,CAAjD;MACA,IAAMa,UAAU,GAAG,IAAI/D,KAAK,CAACe,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwBoC,UAAxB,CAAnB;MACAb,QAAQ,CAACuB,eAAe,GAAG,CAAnB,CAAR,GAAgCE,UAAU,CAACf,CAA3C;MACAV,QAAQ,CAACuB,eAAe,GAAG,CAAlB,GAAsB,CAAvB,CAAR,GAAoCE,UAAU,CAACd,CAA/C;MACAX,QAAQ,CAACuB,eAAe,GAAG,CAAlB,GAAsB,CAAvB,CAAR,GAAoCE,UAAU,CAACb,CAA/C;MACA,KAAKzB,eAAL,CAAqBuC,YAArB,CAAkC,UAAlC,EAA8C,IAAIhE,KAAK,CAACiE,sBAAV,CAAiC3B,QAAjC,EAA2C,CAA3C,CAA9C,EA3BiC,CA2B6D;IAC/F;;;WAED,yBAAgB;MACd,IAAIK,CAAJ,EAAOuB,CAAP;MACA,IAAM5B,QAAQ,GAAG,IAAI6B,KAAJ,CAAU,CAAC,CAACvD,aAAa,GAAG,CAAjB,IAAsBD,gBAAtB,GAAyC,CAA1C,IAA+C,CAAzD,EAA4DyD,IAA5D,CAAiE,CAAjE,CAAjB,CAFc,CAEwE;;MAEtF,IAAMC,OAAO,GAAG,EAAhB;MACA,KAAK5C,eAAL,GAAuB,IAAIzB,KAAK,CAACsE,cAAV,EAAvB;MACA,KAAK7C,eAAL,CAAqBuC,YAArB,CAAkC,UAAlC,EAA8C,IAAIhE,KAAK,CAACiE,sBAAV,CAAiC3B,QAAjC,EAA2C,CAA3C,CAA9C;;MAEA,KAAKiC,sBAAL,CAA4B/D,mBAA5B,EARc,CAQoC;;;MAGlD,KAAKmC,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG/B,aAAhB,EAA+B+B,CAAC,EAAhC,EAAoC;QAClC,KAAKuB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGvD,gBAAgB,GAAG,CAAnC,EAAsCuD,CAAC,EAAvC,EAA2C;UACzCG,OAAO,CAACG,IAAR,CAAa7B,CAAC,GAAGhC,gBAAJ,GAAuBuD,CAApC,EAAuCvB,CAAC,GAAGhC,gBAAJ,GAAuBuD,CAAvB,GAA2B,CAAlE,EAAqE,CAACvB,CAAC,GAAG,CAAL,IAAUhC,gBAAV,GAA6BuD,CAAlG;UACAG,OAAO,CAACG,IAAR,CAAa7B,CAAC,GAAGhC,gBAAJ,GAAuBuD,CAAvB,GAA2B,CAAxC,EAA2C,CAACvB,CAAC,GAAG,CAAL,IAAUhC,gBAAV,GAA6BuD,CAA7B,GAAiC,CAA5E,EAA+E,CAACvB,CAAC,GAAG,CAAL,IAAUhC,gBAAV,GAA6BuD,CAA5G;QACD;;QAEDG,OAAO,CAACG,IAAR,CAAa,CAAC7B,CAAC,GAAG,CAAL,IAAUhC,gBAAV,GAA6B,CAA1C,EAA6CgC,CAAC,GAAGhC,gBAAjD,EAAmE,CAACgC,CAAC,GAAG,CAAL,IAAUhC,gBAAV,GAA6B,CAAhG;QACA0D,OAAO,CAACG,IAAR,CAAa7B,CAAC,GAAGhC,gBAAjB,EAAmC,CAACgC,CAAC,GAAG,CAAL,IAAUhC,gBAA7C,EAA+D,CAACgC,CAAC,GAAG,CAAL,IAAUhC,gBAAV,GAA6B,CAA5F;MACD,CAnBa,CAmBZ;;;MAGF,IAAMiD,gBAAgB,GAAGjD,gBAAgB,IAAI,IAAIC,aAAR,CAAzC;MACA,IAAMiD,eAAe,GAAGlD,gBAAgB,IAAI,IAAIC,aAAR,CAAhB,GAAyC,CAAjE;;MAEA,KAAK+B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGhC,gBAAgB,GAAG,CAAnC,EAAsCgC,CAAC,EAAvC,EAA2C;QACzC0B,OAAO,CAACG,IAAR,CAAaZ,gBAAb,EAA+BjB,CAAC,GAAG,CAAnC,EAAsCA,CAAtC;QACA0B,OAAO,CAACG,IAAR,CAAaX,eAAb,EAA8BlB,CAAC,GAAGhC,gBAAgB,GAAGC,aAArD,EAAoE+B,CAAC,GAAGhC,gBAAgB,GAAGC,aAAvB,GAAuC,CAA3G;MACD;;MAEDyD,OAAO,CAACG,IAAR,CAAaZ,gBAAb,EAA+B,CAA/B,EAAkCjD,gBAAgB,GAAG,CAArD;MACA0D,OAAO,CAACG,IAAR,CAAaX,eAAb,EAA8BlD,gBAAgB,IAAIC,aAAa,GAAG,CAApB,CAAhB,GAAyC,CAAvE,EAA0ED,gBAAgB,GAAGC,aAA7F;MACA,IAAM6D,QAAQ,GAAG,IAAIzE,KAAK,CAAC0E,iBAAV,EAAjB;MACAD,QAAQ,CAACE,WAAT,GAAuB,IAAvB;MACAF,QAAQ,CAACG,OAAT,GAAmBtE,mBAAnB;MACA,KAAKmB,eAAL,CAAqBoD,QAArB,CAA8BR,OAA9B;MACA,KAAK3C,WAAL,GAAmB,IAAI1B,KAAK,CAAC8E,IAAV,CAAe,KAAKrD,eAApB,EAAqCgD,QAArC,CAAnB;MACA,KAAK/C,WAAL,CAAiB2B,QAAjB,CAA0B0B,GAA1B,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAAC,CAAD,GAAKvE,mBAAzC;MACA,KAAKmB,aAAL,GAAqB,IAAI3B,KAAK,CAACgF,QAAV,EAArB;MACA,KAAKrD,aAAL,CAAmBsD,GAAnB,CAAuB,KAAKvD,WAA5B;MACA,KAAKK,SAAL,GAAiB,IAAI/B,KAAK,CAACkF,SAAV,EAAjB,CAxCc,CAwC0B;;MAExC,IAAMC,cAAc,GAAG,IAAInF,KAAK,CAACoF,cAAV,CAAyBnE,aAAzB,EAAwC,EAAxC,EAA4C,EAA5C,CAAvB;MACA,IAAMoE,cAAc,GAAG,IAAIrF,KAAK,CAAC0E,iBAAV,EAAvB;MACAW,cAAc,CAACV,WAAf,GAA6B,IAA7B;MACAU,cAAc,CAACT,OAAf,GAAyBtE,mBAAzB;MACA,KAAKwB,YAAL,GAAoB,IAAI9B,KAAK,CAAC8E,IAAV,CAAeK,cAAf,EAA+BE,cAA/B,CAApB;MACA,KAAK1D,aAAL,CAAmBsD,GAAnB,CAAuB,KAAKnD,YAA5B;MACA,KAAKmD,GAAL,CAAS,KAAKtD,aAAd;IACD;;;WAED,4BAAmB;MACjB,IAAI,KAAKI,SAAT,EAAoB;QAClB,IAAMuD,aAAa,GAAG,KAAK3D,aAAL,CAAmB4D,WAAzC;QACA,IAAMC,UAAU,GAAG,IAAIxF,KAAK,CAACyF,OAAV,EAAnB;QACAD,UAAU,CAACE,QAAX,GAAsBC,eAAtB,CAAsCL,aAAtC;QACA,KAAKvD,SAAL,CAAe6D,GAAf,CAAmBC,MAAnB,CAA0BC,qBAA1B,CAAgDR,aAAhD;QACA,KAAKvD,SAAL,CAAe6D,GAAf,CAAmBG,SAAnB,CAA6BhB,GAA7B,CAAiC,CAAjC,EAAoC,CAApC,EAAuC,CAAC,CAAxC,EAA2CiB,YAA3C,CAAwDR,UAAxD;MACD;IACF;;;WAED,0BAAiB;MACf,KAAK7D,aAAL,CAAmBS,OAAnB,GAA6B,KAAKf,UAAL,CAAgBe,OAA7C;MACA,IAAM6D,QAAQ,GAAG,KAAK7E,IAAL,CAAU8E,MAAV,CAAiB,kBAAjB,CAAjB;MACA,IAAMC,QAAQ,GAAG,KAAK/E,IAAL,CAAU8E,MAAV,CAAiB,WAAjB,CAAjB;MACA,IAAME,QAAQ,GAAGH,QAAQ,CAAC5C,QAAT,CAAkBgD,UAAlB,CAA6BF,QAAQ,CAAC9C,QAAtC,CAAjB;MACA,IAAMA,QAAQ,GAAG4C,QAAQ,CAAC5C,QAAT,CAAkBX,KAAlB,GAA0BuC,GAA1B,CAA8BkB,QAAQ,CAAC9C,QAAvC,EAAiDiD,cAAjD,CAAgE,GAAhE,CAAjB;MACA,KAAK3E,aAAL,CAAmB0B,QAAnB,CAA4BkD,IAA5B,CAAiClD,QAAjC;MACA,KAAK1B,aAAL,CAAmB6E,UAAnB,CAA8BD,IAA9B,CAAmC,KAAKlF,UAAL,CAAgBmF,UAAnD;MACA,KAAK5E,OAAL,GAAewE,QAAQ,IAAIlG,eAA3B;MACA,IAAMuG,UAAU,GAAG,CAACL,QAAQ,GAAGjG,SAAZ,KAA0BF,SAAS,GAAGE,SAAtC,CAAnB;MACA,IAAMuG,UAAU,GAAG,CAACN,QAAQ,GAAGjG,SAAZ,KAA0BD,eAAe,GAAGC,SAA5C,CAAnB;;MAEA,IAAIsG,UAAU,GAAG,CAAjB,EAAoB;QAClB,KAAKlC,sBAAL,CAA4B/D,mBAA5B;;QAEA,KAAKkB,WAAL,CAAiB2B,QAAjB,CAA0B0B,GAA1B,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAAC,CAAD,GAAKvE,mBAAzC;QACA,KAAKkB,WAAL,CAAiB+C,QAAjB,CAA0BG,OAA1B,GAAoCtE,mBAApC;MACD,CALD,MAKO,IAAImG,UAAU,GAAG,CAAjB,EAAoB;QACzB,IAAMtD,UAAU,GAAG,CAAC3C,mBAAmB,GAAGC,uBAAvB,IAAkDgG,UAAlD,GAA+DhG,uBAAlF;;QAEA,KAAK8D,sBAAL,CAA4BpB,UAA5B;;QAEA,IAAIuD,UAAU,GAAG,CAAjB,EAAoB;UAClB,KAAKhF,WAAL,CAAiB2B,QAAjB,CAA0B0B,GAA1B,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAAC,CAAD,GAAK5B,UAAL,GAAkB,CAAC,IAAIuD,UAAL,IAAmBtG,mBAAzE;UACA,KAAKsB,WAAL,CAAiB+C,QAAjB,CAA0BG,OAA1B,GAAoCtE,mBAAmB,GAAG,CAAC,IAAIoG,UAAL,KAAoBrG,mBAAmB,GAAGC,mBAA1C,CAA1D;QACD,CAHD,MAGO;UACL,KAAKoB,WAAL,CAAiB2B,QAAjB,CAA0B0B,GAA1B,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAAC,CAAD,GAAK5B,UAAzC;UACA,KAAKzB,WAAL,CAAiB+C,QAAjB,CAA0BG,OAA1B,GAAoCtE,mBAApC;QACD;MACF,CAZM,MAYA;QACL,KAAKiE,sBAAL,CAA4B9D,uBAA5B;;QAEA,KAAKiB,WAAL,CAAiB2B,QAAjB,CAA0B0B,GAA1B,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAAC,CAAD,GAAKtE,uBAAL,GAA+BL,mBAAnE;QACA,KAAKsB,WAAL,CAAiB+C,QAAjB,CAA0BG,OAA1B,GAAoCvE,mBAApC;MACD;;MAED,KAAKyB,YAAL,CAAkB2C,QAAlB,CAA2BG,OAA3B,GAAqC,KAAKlD,WAAL,CAAiB+C,QAAjB,CAA0BG,OAA/D;IACD;;;WAED,2BAAkB+B,KAAlB,EAAyB;MACvB,8FAAwBA,KAAxB;;MAEA,IAAI,KAAKlF,eAAT,EAA0B;QACxB,KAAKmF,cAAL;;QAEA,KAAKC,gBAAL;MACD;IACF;;;WAED,qBAAY;MACV,OAAO,KAAKjF,OAAZ;IACD;;;WAED,qBAAYC,QAAZ,EAAsB;MACpB,KAAKA,QAAL,GAAgBA,QAAhB;IACD;;;WAED,sBAAa;MACX,OAAO,KAAKA,QAAZ;IACD;;;WAED,yBAAgBiF,MAAhB,EAA0C;MAAA,IAAlBC,SAAkB,uEAAN,IAAM;;MACxC,IAAI,KAAKhF,SAAT,EAAoB;QAClB,OAAO,KAAKA,SAAL,CAAeiF,eAAf,CAA+BF,MAA/B,EAAuCC,SAAvC,CAAP;MACD;IACF;;;WAED,0BAAiBE,OAAjB,EAA4C;MAAA,IAAlBF,SAAkB,uEAAN,IAAM;;MAC1C,IAAI,KAAKhF,SAAT,EAAoB;QAClB,OAAO,KAAKA,SAAL,CAAemF,gBAAf,CAAgCD,OAAhC,EAAyCF,SAAzC,CAAP;MACD;IACF;;;WAED,4BAAmBE,OAAnB,EAA+C;MAAA,IAAnBF,SAAmB,uEAAP,KAAO;;MAC7C,IAAI,KAAKhF,SAAL,IAAkB,CAAC,KAAKF,QAA5B,EAAsC;QACpC,IAAMsF,aAAa,GAAG,KAAKpF,SAAL,CAAemF,gBAAf,CAAgCD,OAAhC,EAAyCF,SAAzC,CAAtB;QACA,IAAMhB,SAAS,GAAG,IAAI/F,KAAK,CAACe,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAC,CAAzB,CAAlB;;QAEA,IAAIoG,aAAa,CAACC,MAAd,GAAuB,CAA3B,EAA8B;UAC5B,IAAMC,YAAY,GAAGF,aAAa,CAAC,CAAD,CAAlC;UACA,IAAMf,QAAQ,GAAGiB,YAAY,CAACjB,QAA9B;UACA,KAAKtE,YAAL,CAAkBuB,QAAlB,CAA2BkD,IAA3B,CAAgCR,SAAS,CAACO,cAAV,CAAyBF,QAAzB,CAAhC;QACD,CAJD,MAIO;UACL,KAAKtE,YAAL,CAAkBuB,QAAlB,CAA2BkD,IAA3B,CAAgCR,SAAS,CAACO,cAAV,CAAyBpF,mBAAzB,CAAhC;QACD;MACF;IACF;;;WAED,mBAAUkF,QAAV,EAAoB;MAClB,IAAML,SAAS,GAAG,IAAI/F,KAAK,CAACe,OAAV,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAC,CAAzB,CAAlB;;MAEA,IAAI,KAAKgB,SAAL,IAAkB,CAAC,KAAKF,QAA5B,EAAsC;QACpC,KAAKC,YAAL,CAAkBuB,QAAlB,CAA2BkD,IAA3B,CAAgCR,SAAS,CAACO,cAAV,CAAyBF,QAAzB,CAAhC;MACD;IACF;;;;EA/NkCpG,KAAK,CAACgF,Q;;AAmO3C,SAAS7D,sBAAT"},"metadata":{},"sourceType":"module"}