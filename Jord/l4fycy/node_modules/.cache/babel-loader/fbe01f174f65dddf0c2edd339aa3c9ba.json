{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\nvar shaderStages = ['fragment', 'vertex'];\nvar vector = ['x', 'y', 'z', 'w'];\n\nvar toFloat = function toFloat(value) {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nvar NodeBuilder = /*#__PURE__*/function () {\n  function NodeBuilder(object, renderer, parser) {\n    _classCallCheck(this, NodeBuilder);\n\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  _createClass(NodeBuilder, [{\n    key: \"addStack\",\n    value: function addStack(node) {\n      /*\n      if ( this.stack.indexOf( node ) !== - 1 ) {\n      console.warn( 'Recursive node: ', node );\n      }\n      */\n      this.stack.push(node);\n    }\n  }, {\n    key: \"removeStack\",\n    value: function removeStack(node) {\n      var lastStack = this.stack.pop();\n\n      if (lastStack !== node) {\n        throw new Error('NodeBuilder: Invalid node stack!');\n      }\n    }\n  }, {\n    key: \"setHashNode\",\n    value: function setHashNode(node, hash) {\n      this.hashNodes[hash] = node;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(node) {\n      if (this.nodes.indexOf(node) === -1) {\n        var updateType = node.getUpdateType(this);\n\n        if (updateType !== NodeUpdateType.None) {\n          this.updateNodes.push(node);\n        }\n\n        this.nodes.push(node);\n        this.setHashNode(node, node.getHash(this));\n      }\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getNodeFromHash\",\n    value: function getNodeFromHash(hash) {\n      return this.hashNodes[hash];\n    }\n  }, {\n    key: \"addFlow\",\n    value: function addFlow(shaderStage, node) {\n      this.flowNodes[shaderStage].push(node);\n      return node;\n    }\n  }, {\n    key: \"setContext\",\n    value: function setContext(context) {\n      this.context = context;\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.context;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getTextureBias\",\n    value: function getTextureBias() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTexture\",\n    value: function getCubeTexture() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCubeTextureBias\",\n    value: function getCubeTextureBias() {\n      console.warn('Abstract function.');\n    } // @TODO: rename to .generateConst()\n\n  }, {\n    key: \"getConst\",\n    value: function getConst(type, value) {\n      var _this = this;\n\n      if (type === 'float') return toFloat(value);\n      if (type === 'int') return \"\".concat(Math.round(value));\n      if (type === 'uint') return value >= 0 ? \"\".concat(Math.round(value), \"u\") : '0u';\n      if (type === 'bool') return value ? 'true' : 'false';\n      if (type === 'color') return \"\".concat(this.getType('vec3'), \"( \").concat(toFloat(value.r), \", \").concat(toFloat(value.g), \", \").concat(toFloat(value.b), \" )\");\n      var typeLength = this.getTypeLength(type);\n      var componentType = this.getComponentType(type);\n\n      var getConst = function getConst(value) {\n        return _this.getConst(componentType, value);\n      };\n\n      if (typeLength === 2) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \" )\");\n      } else if (typeLength === 3) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \" )\");\n      } else if (typeLength === 4) {\n        return \"\".concat(this.getType(type), \"( \").concat(getConst(value.x), \", \").concat(getConst(value.y), \", \").concat(getConst(value.z), \", \").concat(getConst(value.w), \" )\");\n      }\n\n      throw new Error(\"NodeBuilder: Type '\".concat(type, \"' not found in generate constant attempt.\"));\n    }\n  }, {\n    key: \"getType\",\n    value: function getType(type) {\n      return type;\n    }\n  }, {\n    key: \"generateMethod\",\n    value: function generateMethod(method) {\n      return method;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name, type) {\n      var attributes = this.attributes; // find attribute\n\n      var _iterator = _createForOfIteratorHelper(attributes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _attribute = _step.value;\n\n          if (_attribute.name === name) {\n            return _attribute;\n          }\n        } // create a new if no exist\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var attribute = new NodeAttribute(name, type);\n      attributes.push(attribute);\n      return attribute;\n    }\n  }, {\n    key: \"getPropertyName\",\n    value: function getPropertyName(node\n    /*, shaderStage*/\n    ) {\n      return node.name;\n    }\n  }, {\n    key: \"isVector\",\n    value: function isVector(type) {\n      return /vec\\d/.test(type);\n    }\n  }, {\n    key: \"isMatrix\",\n    value: function isMatrix(type) {\n      return /mat\\d/.test(type);\n    }\n  }, {\n    key: \"isReference\",\n    value: function isReference(type) {\n      return type === 'void' || type === 'property' || type === 'sampler';\n    }\n  }, {\n    key: \"isShaderStage\",\n    value: function isShaderStage(shaderStage) {\n      return this.shaderStage === shaderStage;\n    }\n  }, {\n    key: \"getTextureEncodingFromMap\",\n    value: function getTextureEncodingFromMap(map) {\n      var encoding;\n\n      if (map && map.isTexture) {\n        encoding = map.encoding;\n      } else if (map && map.isWebGLRenderTarget) {\n        encoding = map.texture.encoding;\n      } else {\n        encoding = LinearEncoding;\n      }\n\n      return encoding;\n    }\n  }, {\n    key: \"getComponentType\",\n    value: function getComponentType(type) {\n      type = this.getVectorType(type);\n      var componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n      if (componentType === null) return null;\n      if (componentType[1] === 'b') return 'bool';\n      if (componentType[1] === 'i') return 'int';\n      if (componentType[1] === 'u') return 'uint';\n      return 'float';\n    }\n  }, {\n    key: \"getVectorType\",\n    value: function getVectorType(type) {\n      if (type === 'color') return 'vec3';\n      if (type === 'texture') return 'vec4';\n      return type;\n    }\n  }, {\n    key: \"getTypeFromLength\",\n    value: function getTypeFromLength(type) {\n      if (type === 1) return 'float';\n      if (type === 2) return 'vec2';\n      if (type === 3) return 'vec3';\n      if (type === 4) return 'vec4';\n      return 0;\n    }\n  }, {\n    key: \"getTypeLength\",\n    value: function getTypeLength(type) {\n      var vecType = this.getVectorType(type);\n      var vecNum = /vec([2-4])/.exec(vecType);\n      if (vecNum !== null) return Number(vecNum[1]);\n      if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n      return 0;\n    }\n  }, {\n    key: \"getVectorFromMatrix\",\n    value: function getVectorFromMatrix(type) {\n      return type.replace('mat', 'vec');\n    }\n  }, {\n    key: \"getDataFromNode\",\n    value: function getDataFromNode(node) {\n      var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n      var nodeData = this.nodesData.get(node);\n\n      if (nodeData === undefined) {\n        nodeData = {\n          vertex: {},\n          fragment: {}\n        };\n        this.nodesData.set(node, nodeData);\n      }\n\n      return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n    }\n  }, {\n    key: \"getUniformFromNode\",\n    value: function getUniformFromNode(node, shaderStage, type) {\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeUniform = nodeData.uniform;\n\n      if (nodeUniform === undefined) {\n        var index = this.uniforms.index++;\n        nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n        this.uniforms[shaderStage].push(nodeUniform);\n        nodeData.uniform = nodeUniform;\n      }\n\n      return nodeUniform;\n    }\n  }, {\n    key: \"getVarFromNode\",\n    value: function getVarFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node, shaderStage);\n      var nodeVar = nodeData.variable;\n\n      if (nodeVar === undefined) {\n        var vars = this.vars[shaderStage];\n        var index = vars.length;\n        nodeVar = new NodeVar('nodeVar' + index, type);\n        vars.push(nodeVar);\n        nodeData.variable = nodeVar;\n      }\n\n      return nodeVar;\n    }\n  }, {\n    key: \"getVaryFromNode\",\n    value: function getVaryFromNode(node, type) {\n      var nodeData = this.getDataFromNode(node, null);\n      var nodeVary = nodeData.vary;\n\n      if (nodeVary === undefined) {\n        var varys = this.varys;\n        var index = varys.length;\n        nodeVary = new NodeVary('nodeVary' + index, type);\n        varys.push(nodeVary);\n        nodeData.vary = nodeVary;\n      }\n\n      return nodeVary;\n    }\n  }, {\n    key: \"getCodeFromNode\",\n    value: function getCodeFromNode(node, type) {\n      var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n      var nodeData = this.getDataFromNode(node);\n      var nodeCode = nodeData.code;\n\n      if (nodeCode === undefined) {\n        var codes = this.codes[shaderStage];\n        var index = codes.length;\n        nodeCode = new NodeCode('nodeCode' + index, type);\n        codes.push(nodeCode);\n        nodeData.code = nodeCode;\n      }\n\n      return nodeCode;\n    }\n  }, {\n    key: \"addFlowCode\",\n    value: function addFlowCode(code) {\n      this.flow.code += code;\n    }\n  }, {\n    key: \"getFlowData\",\n    value: function getFlowData(shaderStage, node) {\n      return this.flowsData.get(node);\n    }\n  }, {\n    key: \"flowNode\",\n    value: function flowNode(node) {\n      this.node = node;\n      var output = node.getNodeType(this);\n      var flowData = this.flowChildNode(node, output);\n      this.flowsData.set(node, flowData);\n      this.node = null;\n      return flowData;\n    }\n  }, {\n    key: \"flowChildNode\",\n    value: function flowChildNode(node) {\n      var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var previousFlow = this.flow;\n      var flow = {\n        code: ''\n      };\n      this.flow = flow;\n      flow.result = node.build(this, output);\n      this.flow = previousFlow;\n      return flow;\n    }\n  }, {\n    key: \"flowNodeFromShaderStage\",\n    value: function flowNodeFromShaderStage(shaderStage, node) {\n      var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var previousShaderStage = this.shaderStage;\n      this.setShaderStage(shaderStage);\n      var flowData = this.flowChildNode(node, output);\n\n      if (propertyName !== null) {\n        flowData.code += \"\".concat(propertyName, \" = \").concat(flowData.result, \";\\n\\t\");\n      }\n\n      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n      this.setShaderStage(previousShaderStage);\n      return flowData;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVarys\",\n    value: function getVarys() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getVars\",\n    value: function getVars(shaderStage) {\n      var snippet = '';\n      var vars = this.vars[shaderStage];\n\n      for (var index = 0; index < vars.length; index++) {\n        var variable = vars[index];\n        snippet += \"\".concat(variable.type, \" \").concat(variable.name, \"; \");\n      }\n\n      return snippet;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"getCodes\",\n    value: function getCodes(shaderStage) {\n      var codes = this.codes[shaderStage];\n      var code = '';\n\n      var _iterator2 = _createForOfIteratorHelper(codes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var nodeCode = _step2.value;\n          code += nodeCode.code + '\\n';\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return code;\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash() {\n      return this.vertexShader + this.fragmentShader;\n    }\n  }, {\n    key: \"getShaderStage\",\n    value: function getShaderStage() {\n      return this.shaderStage;\n    }\n  }, {\n    key: \"setShaderStage\",\n    value: function setShaderStage(shaderStage) {\n      this.shaderStage = shaderStage;\n    }\n  }, {\n    key: \"buildCode\",\n    value: function buildCode() {\n      console.warn('Abstract function.');\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      // stage 1: analyze nodes to possible optimization and validation\n      var _iterator3 = _createForOfIteratorHelper(shaderStages),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var shaderStage = _step3.value;\n          this.setShaderStage(shaderStage);\n          var flowNodes = this.flowNodes[shaderStage];\n\n          var _iterator5 = _createForOfIteratorHelper(flowNodes),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var node = _step5.value;\n              node.analyze(this);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        } // stage 2: pre-build vertex code used in fragment shader\n\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      if (this.context.vertex && this.context.vertex.isNode) {\n        this.flowNodeFromShaderStage('vertex', this.context.vertex);\n      } // stage 3: generate shader\n\n\n      var _iterator4 = _createForOfIteratorHelper(shaderStages),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _shaderStage = _step4.value;\n          this.setShaderStage(_shaderStage);\n          var _flowNodes = this.flowNodes[_shaderStage];\n\n          var _iterator6 = _createForOfIteratorHelper(_flowNodes),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _node = _step6.value;\n              this.flowNode(_node, _shaderStage);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.setShaderStage(null); // stage 4: build code for a specific output\n\n      this.buildCode();\n      return this;\n    }\n  }, {\n    key: \"format\",\n    value: function format(snippet, fromType, toType) {\n      fromType = this.getVectorType(fromType);\n      toType = this.getVectorType(toType);\n\n      if (fromType === toType || toType === null || this.isReference(toType)) {\n        return snippet;\n      }\n\n      var fromTypeLength = this.getTypeLength(fromType);\n      var toTypeLength = this.getTypeLength(toType);\n\n      if (fromTypeLength === 0) {\n        // fromType is matrix-like\n        var vectorType = this.getVectorFromMatrix(fromType);\n        return this.format(\"( \".concat(snippet, \" * \").concat(this.getType(vectorType), \"( 1.0 ) )\"), vectorType, toType);\n      }\n\n      if (toTypeLength === 0) {\n        // toType is matrix-like\n        // ignore for now\n        //return `${ this.getType( toType ) }( ${ snippet } )`;\n        return snippet;\n      }\n\n      if (fromTypeLength === toTypeLength) {\n        return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\");\n      }\n\n      if (fromTypeLength > toTypeLength) {\n        return this.format(\"\".concat(snippet, \".\").concat('xyz'.slice(0, toTypeLength)), this.getTypeFromLength(toTypeLength), toType);\n      }\n\n      if (toTypeLength === 4) {\n        // toType is vec4-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec3'), \", 1.0 )\");\n      }\n\n      if (fromTypeLength === 2) {\n        // fromType is vec2-like and toType is vec3-like\n        return \"\".concat(this.getType(toType), \"( \").concat(this.format(snippet, fromType, 'vec2'), \", 0.0 )\");\n      }\n\n      return \"\".concat(this.getType(toType), \"( \").concat(snippet, \" )\"); // fromType is float-like\n    }\n  }, {\n    key: \"getSignature\",\n    value: function getSignature() {\n      return \"// Three.js r\".concat(REVISION, \" - NodeMaterial System\\n\");\n    }\n  }]);\n\n  return NodeBuilder;\n}();\n\nexport default NodeBuilder;\nexport { shaderStages, vector };","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVary","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","shaderStages","vector","toFloat","value","Number","NodeBuilder","object","renderer","parser","material","nodes","updateNodes","hashNodes","vertexShader","fragmentShader","flowNodes","vertex","fragment","flowCode","uniforms","index","codes","attributes","varys","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","node","push","lastStack","pop","Error","hash","indexOf","updateType","getUpdateType","None","setHashNode","getHash","method","console","warn","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","getConst","x","y","z","w","name","attribute","test","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","vecType","vecNum","replace","nodeData","get","undefined","set","getDataFromNode","nodeUniform","uniform","nodeVar","variable","length","nodeVary","vary","nodeCode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","propertyName","previousShaderStage","setShaderStage","snippet","analyze","isNode","flowNodeFromShaderStage","flowNode","buildCode","fromType","toType","isReference","fromTypeLength","toTypeLength","vectorType","getVectorFromMatrix","format","slice","getTypeFromLength"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}