{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTextureLoader, LinearMipmapLinearFilter } from 'three';\n\nvar TGALoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(TGALoader, _DataTextureLoader);\n\n  var _super = _createSuper(TGALoader);\n\n  function TGALoader(manager) {\n    _classCallCheck(this, TGALoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(TGALoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\n      function tgaCheckHeader(header) {\n        switch (header.image_type) {\n          // check indexed type\n          case TGA_TYPE_INDEXED:\n          case TGA_TYPE_RLE_INDEXED:\n            if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\n              console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\n            }\n\n            break;\n          // check colormap type\n\n          case TGA_TYPE_RGB:\n          case TGA_TYPE_GREY:\n          case TGA_TYPE_RLE_RGB:\n          case TGA_TYPE_RLE_GREY:\n            if (header.colormap_type) {\n              console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\n            }\n\n            break;\n          // What the need of a file without data ?\n\n          case TGA_TYPE_NO_DATA:\n            console.error('THREE.TGALoader: No data.');\n          // Invalid type ?\n\n          default:\n            console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\n        } // check image width and height\n\n\n        if (header.width <= 0 || header.height <= 0) {\n          console.error('THREE.TGALoader: Invalid image size.');\n        } // check image pixel size\n\n\n        if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\n          console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\n        }\n      } // parse tga image buffer\n\n\n      function tgaParse(use_rle, use_pal, header, offset, data) {\n        var pixel_data, palettes;\n        var pixel_size = header.pixel_size >> 3;\n        var pixel_total = header.width * header.height * pixel_size; // read palettes\n\n        if (use_pal) {\n          palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\n        } // read RLE\n\n\n        if (use_rle) {\n          pixel_data = new Uint8Array(pixel_total);\n          var c, count, i;\n          var shift = 0;\n          var pixels = new Uint8Array(pixel_size);\n\n          while (shift < pixel_total) {\n            c = data[offset++];\n            count = (c & 0x7f) + 1; // RLE pixels\n\n            if (c & 0x80) {\n              // bind pixel tmp array\n              for (i = 0; i < pixel_size; ++i) {\n                pixels[i] = data[offset++];\n              } // copy pixel array\n\n\n              for (i = 0; i < count; ++i) {\n                pixel_data.set(pixels, shift + i * pixel_size);\n              }\n\n              shift += pixel_size * count;\n            } else {\n              // raw pixels\n              count *= pixel_size;\n\n              for (i = 0; i < count; ++i) {\n                pixel_data[shift + i] = data[offset++];\n              }\n\n              shift += count;\n            }\n          }\n        } else {\n          // raw pixels\n          pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\n        }\n\n        return {\n          pixel_data: pixel_data,\n          palettes: palettes\n        };\n      }\n\n      function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\n        var colormap = palettes;\n        var color,\n            i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData[(x + width * y) * 4 + 3] = 255;\n            imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\n            imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\n            imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var color,\n            i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\n\n            imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\n            imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\n            imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\n            imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 3) {\n            imageData[(x + width * y) * 4 + 3] = 255;\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 4) {\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 1];\n            imageData[(x + width * y) * 4 + 0] = image[i + 2];\n            imageData[(x + width * y) * 4 + 3] = image[i + 3];\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var color,\n            i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i++) {\n            color = image[i];\n            imageData[(x + width * y) * 4 + 0] = color;\n            imageData[(x + width * y) * 4 + 1] = color;\n            imageData[(x + width * y) * 4 + 2] = color;\n            imageData[(x + width * y) * 4 + 3] = 255;\n          }\n        }\n\n        return imageData;\n      }\n\n      function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\n        var i = 0,\n            x,\n            y;\n        var width = header.width;\n\n        for (y = y_start; y !== y_end; y += y_step) {\n          for (x = x_start; x !== x_end; x += x_step, i += 2) {\n            imageData[(x + width * y) * 4 + 0] = image[i + 0];\n            imageData[(x + width * y) * 4 + 1] = image[i + 0];\n            imageData[(x + width * y) * 4 + 2] = image[i + 0];\n            imageData[(x + width * y) * 4 + 3] = image[i + 1];\n          }\n        }\n\n        return imageData;\n      }\n\n      function getTgaRGBA(data, width, height, image, palette) {\n        var x_start, y_start, x_step, y_step, x_end, y_end;\n\n        switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\n          default:\n          case TGA_ORIGIN_UL:\n            x_start = 0;\n            x_step = 1;\n            x_end = width;\n            y_start = 0;\n            y_step = 1;\n            y_end = height;\n            break;\n\n          case TGA_ORIGIN_BL:\n            x_start = 0;\n            x_step = 1;\n            x_end = width;\n            y_start = height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n\n          case TGA_ORIGIN_UR:\n            x_start = width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = 0;\n            y_step = 1;\n            y_end = height;\n            break;\n\n          case TGA_ORIGIN_BR:\n            x_start = width - 1;\n            x_step = -1;\n            x_end = -1;\n            y_start = height - 1;\n            y_step = -1;\n            y_end = -1;\n            break;\n        }\n\n        if (use_grey) {\n          switch (header.pixel_size) {\n            case 8:\n              tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            case 16:\n              tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            default:\n              console.error('THREE.TGALoader: Format not supported.');\n              break;\n          }\n        } else {\n          switch (header.pixel_size) {\n            case 8:\n              tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\n              break;\n\n            case 16:\n              tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            case 24:\n              tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            case 32:\n              tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\n              break;\n\n            default:\n              console.error('THREE.TGALoader: Format not supported.');\n              break;\n          }\n        } // Load image data according to specific method\n        // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\n        // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\n\n\n        return data;\n      } // TGA constants\n\n\n      var TGA_TYPE_NO_DATA = 0,\n          TGA_TYPE_INDEXED = 1,\n          TGA_TYPE_RGB = 2,\n          TGA_TYPE_GREY = 3,\n          TGA_TYPE_RLE_INDEXED = 9,\n          TGA_TYPE_RLE_RGB = 10,\n          TGA_TYPE_RLE_GREY = 11,\n          TGA_ORIGIN_MASK = 0x30,\n          TGA_ORIGIN_SHIFT = 0x04,\n          TGA_ORIGIN_BL = 0x00,\n          TGA_ORIGIN_BR = 0x01,\n          TGA_ORIGIN_UL = 0x02,\n          TGA_ORIGIN_UR = 0x03;\n      if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\n      var offset = 0;\n      var content = new Uint8Array(buffer),\n          header = {\n        id_length: content[offset++],\n        colormap_type: content[offset++],\n        image_type: content[offset++],\n        colormap_index: content[offset++] | content[offset++] << 8,\n        colormap_length: content[offset++] | content[offset++] << 8,\n        colormap_size: content[offset++],\n        origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\n        width: content[offset++] | content[offset++] << 8,\n        height: content[offset++] | content[offset++] << 8,\n        pixel_size: content[offset++],\n        flags: content[offset++]\n      }; // check tga if it is valid format\n\n      tgaCheckHeader(header);\n\n      if (header.id_length + offset > buffer.length) {\n        console.error('THREE.TGALoader: No data.');\n      } // skip the needn't data\n\n\n      offset += header.id_length; // get targa information about RLE compression and palette\n\n      var use_rle = false,\n          use_pal = false,\n          use_grey = false;\n\n      switch (header.image_type) {\n        case TGA_TYPE_RLE_INDEXED:\n          use_rle = true;\n          use_pal = true;\n          break;\n\n        case TGA_TYPE_INDEXED:\n          use_pal = true;\n          break;\n\n        case TGA_TYPE_RLE_RGB:\n          use_rle = true;\n          break;\n\n        case TGA_TYPE_RGB:\n          break;\n\n        case TGA_TYPE_RLE_GREY:\n          use_rle = true;\n          use_grey = true;\n          break;\n\n        case TGA_TYPE_GREY:\n          use_grey = true;\n          break;\n      } //\n\n\n      var imageData = new Uint8Array(header.width * header.height * 4);\n      var result = tgaParse(use_rle, use_pal, header, offset, content);\n      getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\n      return {\n        data: imageData,\n        width: header.width,\n        height: header.height,\n        flipY: true,\n        generateMipmaps: true,\n        minFilter: LinearMipmapLinearFilter\n      };\n    }\n  }]);\n\n  return TGALoader;\n}(DataTextureLoader);\n\nexport { TGALoader };","map":{"version":3,"names":["DataTextureLoader","LinearMipmapLinearFilter","TGALoader","manager","buffer","tgaCheckHeader","header","image_type","TGA_TYPE_INDEXED","TGA_TYPE_RLE_INDEXED","colormap_length","colormap_size","colormap_type","console","error","TGA_TYPE_RGB","TGA_TYPE_GREY","TGA_TYPE_RLE_RGB","TGA_TYPE_RLE_GREY","TGA_TYPE_NO_DATA","width","height","pixel_size","tgaParse","use_rle","use_pal","offset","data","pixel_data","palettes","pixel_total","subarray","Uint8Array","c","count","i","shift","pixels","set","tgaGetImageData8bits","imageData","y_start","y_step","y_end","x_start","x_step","x_end","image","colormap","color","x","y","tgaGetImageData16bits","tgaGetImageData24bits","tgaGetImageData32bits","tgaGetImageDataGrey8bits","tgaGetImageDataGrey16bits","getTgaRGBA","palette","flags","TGA_ORIGIN_MASK","TGA_ORIGIN_SHIFT","TGA_ORIGIN_UL","TGA_ORIGIN_BL","TGA_ORIGIN_UR","TGA_ORIGIN_BR","use_grey","length","content","id_length","colormap_index","origin","result","flipY","generateMipmaps","minFilter"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/loaders/TGALoader.js"],"sourcesContent":["import { DataTextureLoader, LinearMipmapLinearFilter } from 'three';\r\n\r\nclass TGALoader extends DataTextureLoader {\r\n  constructor(manager) {\r\n    super(manager);\r\n  }\r\n\r\n  parse(buffer) {\r\n    // reference from vthibault, https://github.com/vthibault/roBrowser/blob/master/src/Loaders/Targa.js\r\n    function tgaCheckHeader(header) {\r\n      switch (header.image_type) {\r\n        // check indexed type\r\n        case TGA_TYPE_INDEXED:\r\n        case TGA_TYPE_RLE_INDEXED:\r\n          if (header.colormap_length > 256 || header.colormap_size !== 24 || header.colormap_type !== 1) {\r\n            console.error('THREE.TGALoader: Invalid type colormap data for indexed type.');\r\n          }\r\n\r\n          break;\r\n        // check colormap type\r\n\r\n        case TGA_TYPE_RGB:\r\n        case TGA_TYPE_GREY:\r\n        case TGA_TYPE_RLE_RGB:\r\n        case TGA_TYPE_RLE_GREY:\r\n          if (header.colormap_type) {\r\n            console.error('THREE.TGALoader: Invalid type colormap data for colormap type.');\r\n          }\r\n\r\n          break;\r\n        // What the need of a file without data ?\r\n\r\n        case TGA_TYPE_NO_DATA:\r\n          console.error('THREE.TGALoader: No data.');\r\n        // Invalid type ?\r\n\r\n        default:\r\n          console.error('THREE.TGALoader: Invalid type \"%s\".', header.image_type);\r\n      } // check image width and height\r\n\r\n\r\n      if (header.width <= 0 || header.height <= 0) {\r\n        console.error('THREE.TGALoader: Invalid image size.');\r\n      } // check image pixel size\r\n\r\n\r\n      if (header.pixel_size !== 8 && header.pixel_size !== 16 && header.pixel_size !== 24 && header.pixel_size !== 32) {\r\n        console.error('THREE.TGALoader: Invalid pixel size \"%s\".', header.pixel_size);\r\n      }\r\n    } // parse tga image buffer\r\n\r\n\r\n    function tgaParse(use_rle, use_pal, header, offset, data) {\r\n      let pixel_data, palettes;\r\n      const pixel_size = header.pixel_size >> 3;\r\n      const pixel_total = header.width * header.height * pixel_size; // read palettes\r\n\r\n      if (use_pal) {\r\n        palettes = data.subarray(offset, offset += header.colormap_length * (header.colormap_size >> 3));\r\n      } // read RLE\r\n\r\n\r\n      if (use_rle) {\r\n        pixel_data = new Uint8Array(pixel_total);\r\n        let c, count, i;\r\n        let shift = 0;\r\n        const pixels = new Uint8Array(pixel_size);\r\n\r\n        while (shift < pixel_total) {\r\n          c = data[offset++];\r\n          count = (c & 0x7f) + 1; // RLE pixels\r\n\r\n          if (c & 0x80) {\r\n            // bind pixel tmp array\r\n            for (i = 0; i < pixel_size; ++i) {\r\n              pixels[i] = data[offset++];\r\n            } // copy pixel array\r\n\r\n\r\n            for (i = 0; i < count; ++i) {\r\n              pixel_data.set(pixels, shift + i * pixel_size);\r\n            }\r\n\r\n            shift += pixel_size * count;\r\n          } else {\r\n            // raw pixels\r\n            count *= pixel_size;\r\n\r\n            for (i = 0; i < count; ++i) {\r\n              pixel_data[shift + i] = data[offset++];\r\n            }\r\n\r\n            shift += count;\r\n          }\r\n        }\r\n      } else {\r\n        // raw pixels\r\n        pixel_data = data.subarray(offset, offset += use_pal ? header.width * header.height : pixel_total);\r\n      }\r\n\r\n      return {\r\n        pixel_data: pixel_data,\r\n        palettes: palettes\r\n      };\r\n    }\r\n\r\n    function tgaGetImageData8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image, palettes) {\r\n      const colormap = palettes;\r\n      let color,\r\n          i = 0,\r\n          x,\r\n          y;\r\n      const width = header.width;\r\n\r\n      for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n          color = image[i];\r\n          imageData[(x + width * y) * 4 + 3] = 255;\r\n          imageData[(x + width * y) * 4 + 2] = colormap[color * 3 + 0];\r\n          imageData[(x + width * y) * 4 + 1] = colormap[color * 3 + 1];\r\n          imageData[(x + width * y) * 4 + 0] = colormap[color * 3 + 2];\r\n        }\r\n      }\r\n\r\n      return imageData;\r\n    }\r\n\r\n    function tgaGetImageData16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\r\n      let color,\r\n          i = 0,\r\n          x,\r\n          y;\r\n      const width = header.width;\r\n\r\n      for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n          color = image[i + 0] + (image[i + 1] << 8); // Inversed ?\r\n\r\n          imageData[(x + width * y) * 4 + 0] = (color & 0x7c00) >> 7;\r\n          imageData[(x + width * y) * 4 + 1] = (color & 0x03e0) >> 2;\r\n          imageData[(x + width * y) * 4 + 2] = (color & 0x001f) >> 3;\r\n          imageData[(x + width * y) * 4 + 3] = color & 0x8000 ? 0 : 255;\r\n        }\r\n      }\r\n\r\n      return imageData;\r\n    }\r\n\r\n    function tgaGetImageData24bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\r\n      let i = 0,\r\n          x,\r\n          y;\r\n      const width = header.width;\r\n\r\n      for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 3) {\r\n          imageData[(x + width * y) * 4 + 3] = 255;\r\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n        }\r\n      }\r\n\r\n      return imageData;\r\n    }\r\n\r\n    function tgaGetImageData32bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\r\n      let i = 0,\r\n          x,\r\n          y;\r\n      const width = header.width;\r\n\r\n      for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 4) {\r\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n          imageData[(x + width * y) * 4 + 1] = image[i + 1];\r\n          imageData[(x + width * y) * 4 + 0] = image[i + 2];\r\n          imageData[(x + width * y) * 4 + 3] = image[i + 3];\r\n        }\r\n      }\r\n\r\n      return imageData;\r\n    }\r\n\r\n    function tgaGetImageDataGrey8bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\r\n      let color,\r\n          i = 0,\r\n          x,\r\n          y;\r\n      const width = header.width;\r\n\r\n      for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i++) {\r\n          color = image[i];\r\n          imageData[(x + width * y) * 4 + 0] = color;\r\n          imageData[(x + width * y) * 4 + 1] = color;\r\n          imageData[(x + width * y) * 4 + 2] = color;\r\n          imageData[(x + width * y) * 4 + 3] = 255;\r\n        }\r\n      }\r\n\r\n      return imageData;\r\n    }\r\n\r\n    function tgaGetImageDataGrey16bits(imageData, y_start, y_step, y_end, x_start, x_step, x_end, image) {\r\n      let i = 0,\r\n          x,\r\n          y;\r\n      const width = header.width;\r\n\r\n      for (y = y_start; y !== y_end; y += y_step) {\r\n        for (x = x_start; x !== x_end; x += x_step, i += 2) {\r\n          imageData[(x + width * y) * 4 + 0] = image[i + 0];\r\n          imageData[(x + width * y) * 4 + 1] = image[i + 0];\r\n          imageData[(x + width * y) * 4 + 2] = image[i + 0];\r\n          imageData[(x + width * y) * 4 + 3] = image[i + 1];\r\n        }\r\n      }\r\n\r\n      return imageData;\r\n    }\r\n\r\n    function getTgaRGBA(data, width, height, image, palette) {\r\n      let x_start, y_start, x_step, y_step, x_end, y_end;\r\n\r\n      switch ((header.flags & TGA_ORIGIN_MASK) >> TGA_ORIGIN_SHIFT) {\r\n        default:\r\n        case TGA_ORIGIN_UL:\r\n          x_start = 0;\r\n          x_step = 1;\r\n          x_end = width;\r\n          y_start = 0;\r\n          y_step = 1;\r\n          y_end = height;\r\n          break;\r\n\r\n        case TGA_ORIGIN_BL:\r\n          x_start = 0;\r\n          x_step = 1;\r\n          x_end = width;\r\n          y_start = height - 1;\r\n          y_step = -1;\r\n          y_end = -1;\r\n          break;\r\n\r\n        case TGA_ORIGIN_UR:\r\n          x_start = width - 1;\r\n          x_step = -1;\r\n          x_end = -1;\r\n          y_start = 0;\r\n          y_step = 1;\r\n          y_end = height;\r\n          break;\r\n\r\n        case TGA_ORIGIN_BR:\r\n          x_start = width - 1;\r\n          x_step = -1;\r\n          x_end = -1;\r\n          y_start = height - 1;\r\n          y_step = -1;\r\n          y_end = -1;\r\n          break;\r\n      }\r\n\r\n      if (use_grey) {\r\n        switch (header.pixel_size) {\r\n          case 8:\r\n            tgaGetImageDataGrey8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\r\n            break;\r\n\r\n          case 16:\r\n            tgaGetImageDataGrey16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\r\n            break;\r\n\r\n          default:\r\n            console.error('THREE.TGALoader: Format not supported.');\r\n            break;\r\n        }\r\n      } else {\r\n        switch (header.pixel_size) {\r\n          case 8:\r\n            tgaGetImageData8bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image, palette);\r\n            break;\r\n\r\n          case 16:\r\n            tgaGetImageData16bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\r\n            break;\r\n\r\n          case 24:\r\n            tgaGetImageData24bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\r\n            break;\r\n\r\n          case 32:\r\n            tgaGetImageData32bits(data, y_start, y_step, y_end, x_start, x_step, x_end, image);\r\n            break;\r\n\r\n          default:\r\n            console.error('THREE.TGALoader: Format not supported.');\r\n            break;\r\n        }\r\n      } // Load image data according to specific method\r\n      // let func = 'tgaGetImageData' + (use_grey ? 'Grey' : '') + (header.pixel_size) + 'bits';\r\n      // func(data, y_start, y_step, y_end, x_start, x_step, x_end, width, image, palette );\r\n\r\n\r\n      return data;\r\n    } // TGA constants\r\n\r\n\r\n    const TGA_TYPE_NO_DATA = 0,\r\n          TGA_TYPE_INDEXED = 1,\r\n          TGA_TYPE_RGB = 2,\r\n          TGA_TYPE_GREY = 3,\r\n          TGA_TYPE_RLE_INDEXED = 9,\r\n          TGA_TYPE_RLE_RGB = 10,\r\n          TGA_TYPE_RLE_GREY = 11,\r\n          TGA_ORIGIN_MASK = 0x30,\r\n          TGA_ORIGIN_SHIFT = 0x04,\r\n          TGA_ORIGIN_BL = 0x00,\r\n          TGA_ORIGIN_BR = 0x01,\r\n          TGA_ORIGIN_UL = 0x02,\r\n          TGA_ORIGIN_UR = 0x03;\r\n    if (buffer.length < 19) console.error('THREE.TGALoader: Not enough data to contain header.');\r\n    let offset = 0;\r\n    const content = new Uint8Array(buffer),\r\n          header = {\r\n      id_length: content[offset++],\r\n      colormap_type: content[offset++],\r\n      image_type: content[offset++],\r\n      colormap_index: content[offset++] | content[offset++] << 8,\r\n      colormap_length: content[offset++] | content[offset++] << 8,\r\n      colormap_size: content[offset++],\r\n      origin: [content[offset++] | content[offset++] << 8, content[offset++] | content[offset++] << 8],\r\n      width: content[offset++] | content[offset++] << 8,\r\n      height: content[offset++] | content[offset++] << 8,\r\n      pixel_size: content[offset++],\r\n      flags: content[offset++]\r\n    }; // check tga if it is valid format\r\n\r\n    tgaCheckHeader(header);\r\n\r\n    if (header.id_length + offset > buffer.length) {\r\n      console.error('THREE.TGALoader: No data.');\r\n    } // skip the needn't data\r\n\r\n\r\n    offset += header.id_length; // get targa information about RLE compression and palette\r\n\r\n    let use_rle = false,\r\n        use_pal = false,\r\n        use_grey = false;\r\n\r\n    switch (header.image_type) {\r\n      case TGA_TYPE_RLE_INDEXED:\r\n        use_rle = true;\r\n        use_pal = true;\r\n        break;\r\n\r\n      case TGA_TYPE_INDEXED:\r\n        use_pal = true;\r\n        break;\r\n\r\n      case TGA_TYPE_RLE_RGB:\r\n        use_rle = true;\r\n        break;\r\n\r\n      case TGA_TYPE_RGB:\r\n        break;\r\n\r\n      case TGA_TYPE_RLE_GREY:\r\n        use_rle = true;\r\n        use_grey = true;\r\n        break;\r\n\r\n      case TGA_TYPE_GREY:\r\n        use_grey = true;\r\n        break;\r\n    } //\r\n\r\n\r\n    const imageData = new Uint8Array(header.width * header.height * 4);\r\n    const result = tgaParse(use_rle, use_pal, header, offset, content);\r\n    getTgaRGBA(imageData, header.width, header.height, result.pixel_data, result.palettes);\r\n    return {\r\n      data: imageData,\r\n      width: header.width,\r\n      height: header.height,\r\n      flipY: true,\r\n      generateMipmaps: true,\r\n      minFilter: LinearMipmapLinearFilter\r\n    };\r\n  }\r\n\r\n}\r\n\r\nexport { TGALoader };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}