{"ast":null,"code":"import _classCallCheck from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { DataTexture, FloatType, IntType, UnsignedIntType, ByteType, UnsignedByteType, ShortType, UnsignedShortType, RedFormat, RGFormat, RGBAFormat, RedIntegerFormat, RGIntegerFormat, RGBAIntegerFormat, NearestFilter } from 'three';\n\nfunction countToStringFormat(count) {\n  switch (count) {\n    case 1:\n      return 'R';\n\n    case 2:\n      return 'RG';\n\n    case 3:\n      return 'RGBA';\n\n    case 4:\n      return 'RGBA';\n  }\n\n  throw new Error();\n}\n\nfunction countToFormat(count) {\n  switch (count) {\n    case 1:\n      return RedFormat;\n\n    case 2:\n      return RGFormat;\n\n    case 3:\n      return RGBAFormat;\n\n    case 4:\n      return RGBAFormat;\n  }\n}\n\nfunction countToIntFormat(count) {\n  switch (count) {\n    case 1:\n      return RedIntegerFormat;\n\n    case 2:\n      return RGIntegerFormat;\n\n    case 3:\n      return RGBAIntegerFormat;\n\n    case 4:\n      return RGBAIntegerFormat;\n  }\n}\n\nexport var VertexAttributeTexture = /*#__PURE__*/function (_DataTexture) {\n  _inherits(VertexAttributeTexture, _DataTexture);\n\n  var _super = _createSuper(VertexAttributeTexture);\n\n  function VertexAttributeTexture() {\n    var _this;\n\n    _classCallCheck(this, VertexAttributeTexture);\n\n    _this = _super.call(this);\n    _this.minFilter = NearestFilter;\n    _this.magFilter = NearestFilter;\n    _this.generateMipmaps = false;\n    _this.overrideItemSize = null;\n    _this._forcedType = null;\n    return _this;\n  }\n\n  _createClass(VertexAttributeTexture, [{\n    key: \"updateFrom\",\n    value: function updateFrom(attr) {\n      var overrideItemSize = this.overrideItemSize;\n      var originalItemSize = attr.itemSize;\n      var originalCount = attr.count;\n\n      if (overrideItemSize !== null) {\n        if (originalItemSize * originalCount % overrideItemSize !== 0.0) {\n          throw new Error('VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.');\n        }\n\n        attr.itemSize = overrideItemSize;\n        attr.count = originalCount * originalItemSize / overrideItemSize;\n      }\n\n      var itemSize = attr.itemSize;\n      var count = attr.count;\n      var normalized = attr.normalized;\n      var originalBufferCons = attr.array.constructor;\n      var byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n      var targetType = this._forcedType;\n      var finalStride = itemSize; // derive the type of texture this should be in the shader\n\n      if (targetType === null) {\n        switch (originalBufferCons) {\n          case Float32Array:\n            targetType = FloatType;\n            break;\n\n          case Uint8Array:\n          case Uint16Array:\n          case Uint32Array:\n            targetType = UnsignedIntType;\n            break;\n\n          case Int8Array:\n          case Int16Array:\n          case Int32Array:\n            targetType = IntType;\n            break;\n        }\n      } // get the target format to store the texture as\n\n\n      var type, format, normalizeValue, targetBufferCons;\n      var internalFormat = countToStringFormat(itemSize);\n\n      switch (targetType) {\n        case FloatType:\n          normalizeValue = 1.0;\n          format = countToFormat(itemSize);\n\n          if (normalized && byteCount === 1) {\n            targetBufferCons = originalBufferCons;\n            internalFormat += '8';\n\n            if (originalBufferCons === Uint8Array) {\n              type = UnsignedByteType;\n            } else {\n              type = ByteType;\n              internalFormat += '_SNORM';\n            }\n          } else {\n            targetBufferCons = Float32Array;\n            internalFormat += '32F';\n            type = FloatType;\n          }\n\n          break;\n\n        case IntType:\n          internalFormat += byteCount * 8 + 'I';\n          normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n          format = countToIntFormat(itemSize);\n\n          if (byteCount === 1) {\n            targetBufferCons = Int8Array;\n            type = ByteType;\n          } else if (byteCount === 2) {\n            targetBufferCons = Int16Array;\n            type = ShortType;\n          } else {\n            targetBufferCons = Int32Array;\n            type = IntType;\n          }\n\n          break;\n\n        case UnsignedIntType:\n          internalFormat += byteCount * 8 + 'UI';\n          normalizeValue = normalized ? Math.pow(2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1) : 1.0;\n          format = countToIntFormat(itemSize);\n\n          if (byteCount === 1) {\n            targetBufferCons = Uint8Array;\n            type = UnsignedByteType;\n          } else if (byteCount === 2) {\n            targetBufferCons = Uint16Array;\n            type = UnsignedShortType;\n          } else {\n            targetBufferCons = Uint32Array;\n            type = UnsignedIntType;\n          }\n\n          break;\n      } // there will be a mismatch between format length and final length because\n      // RGBFormat and RGBIntegerFormat was removed\n\n\n      if (finalStride === 3 && (format === RGBAFormat || format === RGBAIntegerFormat)) {\n        finalStride = 4;\n      } // copy the data over to the new texture array\n\n\n      var dimension = Math.ceil(Math.sqrt(count));\n      var length = finalStride * dimension * dimension;\n      var dataArray = new targetBufferCons(length);\n\n      for (var i = 0; i < count; i++) {\n        var ii = finalStride * i;\n        dataArray[ii] = attr.getX(i) / normalizeValue;\n\n        if (itemSize >= 2) {\n          dataArray[ii + 1] = attr.getY(i) / normalizeValue;\n        }\n\n        if (itemSize >= 3) {\n          dataArray[ii + 2] = attr.getZ(i) / normalizeValue;\n\n          if (finalStride === 4) {\n            dataArray[ii + 3] = 1.0;\n          }\n        }\n\n        if (itemSize >= 4) {\n          dataArray[ii + 3] = attr.getW(i) / normalizeValue;\n        }\n      }\n\n      this.internalFormat = internalFormat;\n      this.format = format;\n      this.type = type;\n      this.image.width = dimension;\n      this.image.height = dimension;\n      this.image.data = dataArray;\n      this.needsUpdate = true;\n      this.dispose();\n      attr.itemSize = originalItemSize;\n      attr.count = originalCount;\n    }\n  }]);\n\n  return VertexAttributeTexture;\n}(DataTexture);\nexport var UIntVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu) {\n  _inherits(UIntVertexAttributeTexture, _VertexAttributeTextu);\n\n  var _super2 = _createSuper(UIntVertexAttributeTexture);\n\n  function UIntVertexAttributeTexture() {\n    var _this2;\n\n    _classCallCheck(this, UIntVertexAttributeTexture);\n\n    _this2 = _super2.call(this);\n    _this2._forcedType = UnsignedIntType;\n    return _this2;\n  }\n\n  return _createClass(UIntVertexAttributeTexture);\n}(VertexAttributeTexture);\nexport var IntVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu2) {\n  _inherits(IntVertexAttributeTexture, _VertexAttributeTextu2);\n\n  var _super3 = _createSuper(IntVertexAttributeTexture);\n\n  function IntVertexAttributeTexture() {\n    var _this3;\n\n    _classCallCheck(this, IntVertexAttributeTexture);\n\n    _this3 = _super3.call(this);\n    _this3._forcedType = IntType;\n    return _this3;\n  }\n\n  return _createClass(IntVertexAttributeTexture);\n}(VertexAttributeTexture);\nexport var FloatVertexAttributeTexture = /*#__PURE__*/function (_VertexAttributeTextu3) {\n  _inherits(FloatVertexAttributeTexture, _VertexAttributeTextu3);\n\n  var _super4 = _createSuper(FloatVertexAttributeTexture);\n\n  function FloatVertexAttributeTexture() {\n    var _this4;\n\n    _classCallCheck(this, FloatVertexAttributeTexture);\n\n    _this4 = _super4.call(this);\n    _this4._forcedType = FloatType;\n    return _this4;\n  }\n\n  return _createClass(FloatVertexAttributeTexture);\n}(VertexAttributeTexture);","map":{"version":3,"names":["DataTexture","FloatType","IntType","UnsignedIntType","ByteType","UnsignedByteType","ShortType","UnsignedShortType","RedFormat","RGFormat","RGBAFormat","RedIntegerFormat","RGIntegerFormat","RGBAIntegerFormat","NearestFilter","countToStringFormat","count","Error","countToFormat","countToIntFormat","VertexAttributeTexture","minFilter","magFilter","generateMipmaps","overrideItemSize","_forcedType","attr","originalItemSize","itemSize","originalCount","normalized","originalBufferCons","array","constructor","byteCount","BYTES_PER_ELEMENT","targetType","finalStride","Float32Array","Uint8Array","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","type","format","normalizeValue","targetBufferCons","internalFormat","Math","pow","dimension","ceil","sqrt","length","dataArray","i","ii","getX","getY","getZ","getW","image","width","height","data","needsUpdate","dispose","UIntVertexAttributeTexture","IntVertexAttributeTexture","FloatVertexAttributeTexture"],"sources":["D:/Jord/l4fycy/node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js"],"sourcesContent":["import {\r\n\tDataTexture,\r\n\tFloatType,\r\n\tIntType,\r\n\tUnsignedIntType,\r\n\tByteType,\r\n\tUnsignedByteType,\r\n\tShortType,\r\n\tUnsignedShortType,\r\n\r\n\tRedFormat,\r\n\tRGFormat,\r\n\tRGBAFormat,\r\n\r\n\tRedIntegerFormat,\r\n\tRGIntegerFormat,\r\n\tRGBAIntegerFormat,\r\n\r\n\tNearestFilter,\r\n} from 'three';\r\n\r\nfunction countToStringFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return 'R';\r\n\t\tcase 2: return 'RG';\r\n\t\tcase 3: return 'RGBA';\r\n\t\tcase 4: return 'RGBA';\r\n\r\n\t}\r\n\r\n\tthrow new Error();\r\n\r\n}\r\n\r\nfunction countToFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return RedFormat;\r\n\t\tcase 2: return RGFormat;\r\n\t\tcase 3: return RGBAFormat;\r\n\t\tcase 4: return RGBAFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction countToIntFormat( count ) {\r\n\r\n\tswitch ( count ) {\r\n\r\n\t\tcase 1: return RedIntegerFormat;\r\n\t\tcase 2: return RGIntegerFormat;\r\n\t\tcase 3: return RGBAIntegerFormat;\r\n\t\tcase 4: return RGBAIntegerFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class VertexAttributeTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\t\tthis.generateMipmaps = false;\r\n\t\tthis.overrideItemSize = null;\r\n\t\tthis._forcedType = null;\r\n\r\n\t}\r\n\r\n\tupdateFrom( attr ) {\r\n\r\n\t\tconst overrideItemSize = this.overrideItemSize;\r\n\t\tconst originalItemSize = attr.itemSize;\r\n\t\tconst originalCount = attr.count;\r\n\t\tif ( overrideItemSize !== null ) {\r\n\r\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\r\n\r\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattr.itemSize = overrideItemSize;\r\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\r\n\r\n\t\t}\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tconst count = attr.count;\r\n\t\tconst normalized = attr.normalized;\r\n\t\tconst originalBufferCons = attr.array.constructor;\r\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\r\n\t\tlet targetType = this._forcedType;\r\n\t\tlet finalStride = itemSize;\r\n\r\n\t\t// derive the type of texture this should be in the shader\r\n\t\tif ( targetType === null ) {\r\n\r\n\t\t\tswitch ( originalBufferCons ) {\r\n\r\n\t\t\t\tcase Float32Array:\r\n\t\t\t\t\ttargetType = FloatType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Uint8Array:\r\n\t\t\t\tcase Uint16Array:\r\n\t\t\t\tcase Uint32Array:\r\n\t\t\t\t\ttargetType = UnsignedIntType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Int8Array:\r\n\t\t\t\tcase Int16Array:\r\n\t\t\t\tcase Int32Array:\r\n\t\t\t\t\ttargetType = IntType;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// get the target format to store the texture as\r\n\t\tlet type, format, normalizeValue, targetBufferCons;\r\n\t\tlet internalFormat = countToStringFormat( itemSize );\r\n\t\tswitch ( targetType ) {\r\n\r\n\t\t\tcase FloatType:\r\n\t\t\t\tnormalizeValue = 1.0;\r\n\t\t\t\tformat = countToFormat( itemSize );\r\n\r\n\t\t\t\tif ( normalized && byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\r\n\t\t\t\t\tinternalFormat += '8';\r\n\r\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\r\n\r\n\t\t\t\t\t\ttype = UnsignedByteType;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ttype = ByteType;\r\n\t\t\t\t\t\tinternalFormat += '_SNORM';\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Float32Array;\r\n\t\t\t\t\tinternalFormat += '32F';\r\n\t\t\t\t\ttype = FloatType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase IntType:\r\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\r\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\r\n\t\t\t\tformat = countToIntFormat( itemSize );\r\n\r\n\t\t\t\tif ( byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int8Array;\r\n\t\t\t\t\ttype = ByteType;\r\n\r\n\t\t\t\t} else if ( byteCount === 2 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int16Array;\r\n\t\t\t\t\ttype = ShortType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Int32Array;\r\n\t\t\t\t\ttype = IntType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase UnsignedIntType:\r\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\r\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\r\n\t\t\t\tformat = countToIntFormat( itemSize );\r\n\r\n\t\t\t\tif ( byteCount === 1 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint8Array;\r\n\t\t\t\t\ttype = UnsignedByteType;\r\n\r\n\t\t\t\t} else if ( byteCount === 2 ) {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint16Array;\r\n\t\t\t\t\ttype = UnsignedShortType;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttargetBufferCons = Uint32Array;\r\n\t\t\t\t\ttype = UnsignedIntType;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\t// there will be a mismatch between format length and final length because\r\n\t\t// RGBFormat and RGBIntegerFormat was removed\r\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\r\n\r\n\t\t\tfinalStride = 4;\r\n\r\n\t\t}\r\n\r\n\t\t// copy the data over to the new texture array\r\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) );\r\n\t\tconst length = finalStride * dimension * dimension;\r\n\t\tconst dataArray = new targetBufferCons( length );\r\n\t\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\t\tconst ii = finalStride * i;\r\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\r\n\r\n\t\t\tif ( itemSize >= 2 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( itemSize >= 3 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\r\n\r\n\t\t\t\tif ( finalStride === 4 ) {\r\n\r\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( itemSize >= 4 ) {\r\n\r\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.internalFormat = internalFormat;\r\n\t\tthis.format = format;\r\n\t\tthis.type = type;\r\n\t\tthis.image.width = dimension;\r\n\t\tthis.image.height = dimension;\r\n\t\tthis.image.data = dataArray;\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.dispose();\r\n\r\n\t\tattr.itemSize = originalItemSize;\r\n\t\tattr.count = originalCount;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = UnsignedIntType;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = IntType;\r\n\r\n\t}\r\n\r\n\r\n}\r\n\r\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._forcedType = FloatType;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}