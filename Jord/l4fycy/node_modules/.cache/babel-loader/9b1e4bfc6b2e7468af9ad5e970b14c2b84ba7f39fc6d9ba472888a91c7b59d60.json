{"ast":null,"code":"import { Vector3 } from 'three';\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\nconst _boxIntersection = /* @__PURE__ */new Vector3();\nconst _xyzFields = ['x', 'y', 'z'];\nfunction raycastFirst(bvh, root, side, ray) {\n  BufferStack.setBuffer(bvh._roots[root]);\n  const result = _raycastFirst(0, bvh, side, ray);\n  BufferStack.clearBuffer();\n  return result;\n}\nfunction _raycastFirst(nodeIndex32, bvh, side, ray) {\n  const {\n    float32Array,\n    uint16Array,\n    uint32Array\n  } = BufferStack;\n  let nodeIndex16 = nodeIndex32 * 2;\n  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n  if (isLeaf) {\n    const offset = OFFSET(nodeIndex32, uint32Array);\n    const count = COUNT(nodeIndex16, uint16Array);\n    return intersectClosestTri(bvh, side, ray, offset, count);\n  } else {\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\n    // the ray is coming from, look for an intersection among that side of the tree first\n    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n    const xyzAxis = _xyzFields[splitAxis];\n    const rayDir = ray.direction[xyzAxis];\n    const leftToRight = rayDir >= 0;\n\n    // c1 is the child to check first\n    let c1, c2;\n    if (leftToRight) {\n      c1 = LEFT_NODE(nodeIndex32);\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\n    } else {\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\n      c2 = LEFT_NODE(nodeIndex32);\n    }\n    const c1Intersection = intersectRay(c1, float32Array, ray, _boxIntersection);\n    const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray) : null;\n\n    // if we got an intersection in the first node and it's closer than the second node's bounding\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\n    if (c1Result) {\n      // check if the point is within the second bounds\n      // \"point\" is in the local frame of the bvh\n      const point = c1Result.point[xyzAxis];\n      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] :\n      // min bounding data\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n\n      if (isOutside) {\n        return c1Result;\n      }\n    }\n\n    // either there was no intersection in the first node, or there could still be a closer\n    // intersection in the second, so check the second node and then take the better of the two\n    const c2Intersection = intersectRay(c2, float32Array, ray, _boxIntersection);\n    const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray) : null;\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\nexport { raycastFirst };","map":{"version":3,"names":["Vector3","IS_LEAF","OFFSET","COUNT","SPLIT_AXIS","LEFT_NODE","RIGHT_NODE","BufferStack","intersectRay","intersectClosestTri","_boxIntersection","_xyzFields","raycastFirst","bvh","root","side","ray","setBuffer","_roots","result","_raycastFirst","clearBuffer","nodeIndex32","float32Array","uint16Array","uint32Array","nodeIndex16","isLeaf","offset","count","splitAxis","xyzAxis","rayDir","direction","leftToRight","c1","c2","c1Intersection","c1Result","point","isOutside","c2Intersection","c2Result","distance"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js"],"sourcesContent":["import { Vector3 } from 'three';\r\nimport { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\r\nimport { BufferStack } from '../utils/BufferStack.js';\r\nimport { intersectRay } from '../utils/intersectUtils.js';\r\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\r\nimport '../utils/iterationUtils_indirect.generated.js';\r\n\r\n/***********************************************************/\r\n/* This file is generated from \"raycastFirst.template.js\". */\r\n/***********************************************************/\r\nconst _boxIntersection = /* @__PURE__ */ new Vector3();\r\nconst _xyzFields = [ 'x', 'y', 'z' ];\r\nfunction raycastFirst( bvh, root, side, ray ) {\r\n\r\n\tBufferStack.setBuffer( bvh._roots[ root ] );\r\n\tconst result = _raycastFirst( 0, bvh, side, ray );\r\n\tBufferStack.clearBuffer();\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\r\n\r\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\r\n\tlet nodeIndex16 = nodeIndex32 * 2;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\r\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\r\n\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\r\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, _boxIntersection );\r\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\t// \"point\" is in the local frame of the bvh\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, _boxIntersection );\r\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { raycastFirst };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}