{"ast":null,"code":"import _assertThisInitialized from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three'; // Original src: https://github.com/zz85/threejs-path-flow\n\nvar CHANNELS = 4;\nvar TEXTURE_WIDTH = 1024;\nvar TEXTURE_HEIGHT = 4;\n/**\r\n * Make a new DataTexture to store the descriptions of the curves.\r\n *\r\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\r\n */\n\nvar initSplineTexture = function initSplineTexture() {\n  var numberOfCurves = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\n  var dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\n  dataTexture.wrapS = RepeatWrapping;\n  dataTexture.wrapT = RepeatWrapping;\n  dataTexture.magFilter = NearestFilter;\n  dataTexture.needsUpdate = true;\n  return dataTexture;\n};\n/**\r\n * Write the curve description to the data texture\r\n *\r\n * @param { DataTexture } texture The DataTexture to write to\r\n * @param { Curve } splineCurve The curve to describe\r\n * @param { number } offset Which curve slot to write to\r\n */\n\n\nvar updateSplineTexture = function updateSplineTexture(texture, splineCurve) {\n  var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\n  splineCurve.updateArcLengths();\n  var points = splineCurve.getSpacedPoints(numberOfPoints);\n  var frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\n\n  for (var i = 0; i < numberOfPoints; i++) {\n    var rowOffset = Math.floor(i / TEXTURE_WIDTH);\n    var rowIndex = i % TEXTURE_WIDTH;\n    var pt = points[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.tangents[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.normals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\n    pt = frenetFrames.binormals[i];\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\n  }\n\n  texture.needsUpdate = true;\n};\n\nvar setTextureValue = function setTextureValue(texture, index, x, y, z, o) {\n  var image = texture.image;\n  var data = image.data;\n  var i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\n\n  data[index * CHANNELS + i + 0] = x;\n  data[index * CHANNELS + i + 1] = y;\n  data[index * CHANNELS + i + 2] = z;\n  data[index * CHANNELS + i + 3] = 1;\n};\n/**\r\n * Create a new set of uniforms for describing the curve modifier\r\n *\r\n * @param { DataTexture } Texture which holds the curve description\r\n */\n\n\nvar getUniforms = function getUniforms(splineTexture) {\n  return {\n    spineTexture: {\n      value: splineTexture\n    },\n    pathOffset: {\n      type: 'f',\n      value: 0\n    },\n    // time of path curve\n    pathSegment: {\n      type: 'f',\n      value: 1\n    },\n    // fractional length of path\n    spineOffset: {\n      type: 'f',\n      value: 161\n    },\n    spineLength: {\n      type: 'f',\n      value: 400\n    },\n    flow: {\n      type: 'i',\n      value: 1\n    }\n  };\n};\n\nfunction modifyShader(material, uniforms) {\n  var numberOfCurves = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (material.__ok) return;\n  material.__ok = true;\n\n  material.onBeforeCompile = function (shader) {\n    if (shader.__modified) return;\n    shader.__modified = true;\n    Object.assign(shader.uniforms, uniforms);\n    var vertexShader =\n    /* glsl */\n    \"\\n\\t\\tuniform sampler2D spineTexture;\\n\\t\\tuniform float pathOffset;\\n\\t\\tuniform float pathSegment;\\n\\t\\tuniform float spineOffset;\\n\\t\\tuniform float spineLength;\\n\\t\\tuniform int flow;\\n\\n\\t\\tfloat textureLayers = \".concat(TEXTURE_HEIGHT * numberOfCurves, \".;\\n\\t\\tfloat textureStacks = \").concat(TEXTURE_HEIGHT / 4, \".;\\n\\n\\t\\t\").concat(shader.vertexShader, \"\\n\\t\\t\") // chunk import moved in front of modified shader below\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\n    .replace('#include <begin_vertex>', '') // shader override\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\n    /* glsl */\n    \"\\n        void main() {\\n        #include <beginnormal_vertex>\\n\\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\\n\\n        bool bend = flow > 0;\\n        float xWeight = bend ? 0. : 1.;\\n\\n        #ifdef USE_INSTANCING\\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\\n        #else\\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\\n        #endif\\n\\n        mt = mod(mt, textureStacks);\\n        float rowOffset = floor(mt);\\n\\n        #ifdef USE_INSTANCING\\n        rowOffset += instanceMatrix[3][1] * \".concat(TEXTURE_HEIGHT, \".;\\n        #endif\\n\\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\\n        mat3 basis = mat3(a, b, c);\\n\\n        vec3 transformed = basis\\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\\n          + spinePos;\\n\\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\\n\\t\\t\\t\")).replace('#include <project_vertex>',\n    /* glsl */\n    \"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n\\t\\t\\t\\tgl_Position = projectionMatrix * mvPosition;\");\n    shader.vertexShader = vertexShader;\n  };\n}\n/**\r\n * A helper class for making meshes bend aroudn curves\r\n */\n\n\nvar Flow = /*#__PURE__*/function () {\n  /**\r\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\r\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\r\n   */\n  function Flow(mesh) {\n    var numberOfCurves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n    _classCallCheck(this, Flow);\n\n    _defineProperty(this, \"curveArray\", void 0);\n\n    _defineProperty(this, \"curveLengthArray\", void 0);\n\n    _defineProperty(this, \"object3D\", void 0);\n\n    _defineProperty(this, \"splineTexure\", void 0);\n\n    _defineProperty(this, \"uniforms\", void 0);\n\n    var obj3D = mesh.clone();\n    var splineTexure = initSplineTexture(numberOfCurves);\n    var uniforms = getUniforms(splineTexure);\n    obj3D.traverse(function (child) {\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\n        child.material = child.material.clone();\n        modifyShader(child.material, uniforms, numberOfCurves);\n      }\n    });\n    this.curveArray = new Array(numberOfCurves);\n    this.curveLengthArray = new Array(numberOfCurves);\n    this.object3D = obj3D;\n    this.splineTexure = splineTexure;\n    this.uniforms = uniforms;\n  }\n\n  _createClass(Flow, [{\n    key: \"updateCurve\",\n    value: function updateCurve(index, curve) {\n      if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\n      var curveLength = curve.getLength();\n      this.uniforms.spineLength.value = curveLength;\n      this.curveLengthArray[index] = curveLength;\n      this.curveArray[index] = curve;\n      updateSplineTexture(this.splineTexure, curve, index);\n    }\n  }, {\n    key: \"moveAlongCurve\",\n    value: function moveAlongCurve(amount) {\n      this.uniforms.pathOffset.value += amount;\n    }\n  }]);\n\n  return Flow;\n}();\n\nvar matrix = new Matrix4();\n/**\r\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\r\n */\n\nvar InstancedFlow = /*#__PURE__*/function (_Flow) {\n  _inherits(InstancedFlow, _Flow);\n\n  var _super = _createSuper(InstancedFlow);\n\n  /**\r\n   *\r\n   * @param {number} count The number of instanced elements\r\n   * @param {number} curveCount The number of curves to preallocate for\r\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\r\n   * @param {Material} material The material to use for the instanced mesh\r\n   */\n  function InstancedFlow(count, curveCount, geometry, material) {\n    var _this;\n\n    _classCallCheck(this, InstancedFlow);\n\n    var mesh = new InstancedMesh(geometry, material, count);\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\n    _this = _super.call(this, mesh, curveCount);\n\n    _defineProperty(_assertThisInitialized(_this), \"offsets\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"whichCurve\", void 0);\n\n    _this.offsets = new Array(count).fill(0);\n    _this.whichCurve = new Array(count).fill(0);\n    return _this;\n  }\n  /**\r\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\r\n   * This writes that information to the matrix and marks it as needing update.\r\n   *\r\n   * @param {number} index of the instanced element to update\r\n   */\n\n\n  _createClass(InstancedFlow, [{\n    key: \"writeChanges\",\n    value: function writeChanges(index) {\n      matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\n      this.object3D.setMatrixAt(index, matrix);\n      this.object3D.instanceMatrix.needsUpdate = true;\n    }\n    /**\r\n     * Move an individual element along the curve by a specific amount\r\n     *\r\n     * @param {number} index Which element to update\r\n     * @param {number} offset Move by how much\r\n     */\n\n  }, {\n    key: \"moveIndividualAlongCurve\",\n    value: function moveIndividualAlongCurve(index, offset) {\n      this.offsets[index] += offset;\n      this.writeChanges(index);\n    }\n    /**\r\n     * Select which curve to use for an element\r\n     *\r\n     * @param {number} index the index of the instanced element to update\r\n     * @param {number} curveNo the index of the curve it should use\r\n     */\n\n  }, {\n    key: \"setCurve\",\n    value: function setCurve(index, curveNo) {\n      if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\n      this.whichCurve[index] = curveNo;\n      this.writeChanges(index);\n    }\n  }]);\n\n  return InstancedFlow;\n}(Flow);\n\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };","map":{"version":3,"names":["_defineProperty","DataTexture","RGBAFormat","FloatType","RepeatWrapping","NearestFilter","Mesh","InstancedMesh","Matrix4","DynamicDrawUsage","CHANNELS","TEXTURE_WIDTH","TEXTURE_HEIGHT","initSplineTexture","numberOfCurves","dataArray","Float32Array","dataTexture","wrapS","wrapT","magFilter","needsUpdate","updateSplineTexture","texture","splineCurve","offset","numberOfPoints","Math","floor","arcLengthDivisions","updateArcLengths","points","getSpacedPoints","frenetFrames","computeFrenetFrames","i","rowOffset","rowIndex","pt","setTextureValue","x","y","z","tangents","normals","binormals","index","o","image","data","getUniforms","splineTexture","spineTexture","value","pathOffset","type","pathSegment","spineOffset","spineLength","flow","modifyShader","material","uniforms","__ok","onBeforeCompile","shader","__modified","Object","assign","vertexShader","replace","Flow","mesh","obj3D","clone","splineTexure","traverse","child","curveArray","Array","curveLengthArray","object3D","curve","length","Error","curveLength","getLength","amount","matrix","InstancedFlow","count","curveCount","geometry","instanceMatrix","setUsage","offsets","fill","whichCurve","makeTranslation","setMatrixAt","writeChanges","curveNo","isNaN"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/modifiers/CurveModifier.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { DataTexture, RGBAFormat, FloatType, RepeatWrapping, NearestFilter, Mesh, InstancedMesh, Matrix4, DynamicDrawUsage } from 'three';\r\n\r\n// Original src: https://github.com/zz85/threejs-path-flow\r\nconst CHANNELS = 4;\r\nconst TEXTURE_WIDTH = 1024;\r\nconst TEXTURE_HEIGHT = 4;\r\n\r\n/**\r\n * Make a new DataTexture to store the descriptions of the curves.\r\n *\r\n * @param { number } numberOfCurves the number of curves needed to be described by this texture.\r\n */\r\nconst initSplineTexture = (numberOfCurves = 1) => {\r\n  const dataArray = new Float32Array(TEXTURE_WIDTH * TEXTURE_HEIGHT * numberOfCurves * CHANNELS);\r\n  const dataTexture = new DataTexture(dataArray, TEXTURE_WIDTH, TEXTURE_HEIGHT * numberOfCurves, RGBAFormat, FloatType);\r\n  dataTexture.wrapS = RepeatWrapping;\r\n  dataTexture.wrapT = RepeatWrapping;\r\n  dataTexture.magFilter = NearestFilter;\r\n  dataTexture.needsUpdate = true;\r\n  return dataTexture;\r\n};\r\n/**\r\n * Write the curve description to the data texture\r\n *\r\n * @param { DataTexture } texture The DataTexture to write to\r\n * @param { Curve } splineCurve The curve to describe\r\n * @param { number } offset Which curve slot to write to\r\n */\r\n\r\nconst updateSplineTexture = (texture, splineCurve, offset = 0) => {\r\n  const numberOfPoints = Math.floor(TEXTURE_WIDTH * (TEXTURE_HEIGHT / 4));\r\n  splineCurve.arcLengthDivisions = numberOfPoints / 2;\r\n  splineCurve.updateArcLengths();\r\n  const points = splineCurve.getSpacedPoints(numberOfPoints);\r\n  const frenetFrames = splineCurve.computeFrenetFrames(numberOfPoints, true);\r\n\r\n  for (let i = 0; i < numberOfPoints; i++) {\r\n    const rowOffset = Math.floor(i / TEXTURE_WIDTH);\r\n    const rowIndex = i % TEXTURE_WIDTH;\r\n    let pt = points[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 0 + rowOffset + TEXTURE_HEIGHT * offset);\r\n    pt = frenetFrames.tangents[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 1 + rowOffset + TEXTURE_HEIGHT * offset);\r\n    pt = frenetFrames.normals[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 2 + rowOffset + TEXTURE_HEIGHT * offset);\r\n    pt = frenetFrames.binormals[i];\r\n    setTextureValue(texture, rowIndex, pt.x, pt.y, pt.z, 3 + rowOffset + TEXTURE_HEIGHT * offset);\r\n  }\r\n\r\n  texture.needsUpdate = true;\r\n};\r\n\r\nconst setTextureValue = (texture, index, x, y, z, o) => {\r\n  const image = texture.image;\r\n  const {\r\n    data\r\n  } = image;\r\n  const i = CHANNELS * TEXTURE_WIDTH * o; // Row Offset\r\n\r\n  data[index * CHANNELS + i + 0] = x;\r\n  data[index * CHANNELS + i + 1] = y;\r\n  data[index * CHANNELS + i + 2] = z;\r\n  data[index * CHANNELS + i + 3] = 1;\r\n};\r\n\r\n/**\r\n * Create a new set of uniforms for describing the curve modifier\r\n *\r\n * @param { DataTexture } Texture which holds the curve description\r\n */\r\nconst getUniforms = splineTexture => ({\r\n  spineTexture: {\r\n    value: splineTexture\r\n  },\r\n  pathOffset: {\r\n    type: 'f',\r\n    value: 0\r\n  },\r\n  // time of path curve\r\n  pathSegment: {\r\n    type: 'f',\r\n    value: 1\r\n  },\r\n  // fractional length of path\r\n  spineOffset: {\r\n    type: 'f',\r\n    value: 161\r\n  },\r\n  spineLength: {\r\n    type: 'f',\r\n    value: 400\r\n  },\r\n  flow: {\r\n    type: 'i',\r\n    value: 1\r\n  }\r\n});\r\nfunction modifyShader(material, uniforms, numberOfCurves = 1) {\r\n  if (material.__ok) return;\r\n  material.__ok = true;\r\n\r\n  material.onBeforeCompile = shader => {\r\n    if (shader.__modified) return;\r\n    shader.__modified = true;\r\n    Object.assign(shader.uniforms, uniforms);\r\n    const vertexShader =\r\n    /* glsl */\r\n    `\r\n\t\tuniform sampler2D spineTexture;\r\n\t\tuniform float pathOffset;\r\n\t\tuniform float pathSegment;\r\n\t\tuniform float spineOffset;\r\n\t\tuniform float spineLength;\r\n\t\tuniform int flow;\r\n\r\n\t\tfloat textureLayers = ${TEXTURE_HEIGHT * numberOfCurves}.;\r\n\t\tfloat textureStacks = ${TEXTURE_HEIGHT / 4}.;\r\n\r\n\t\t${shader.vertexShader}\r\n\t\t` // chunk import moved in front of modified shader below\r\n    .replace('#include <beginnormal_vertex>', '') // vec3 transformedNormal declaration overriden below\r\n    .replace('#include <defaultnormal_vertex>', '') // vec3 transformed declaration overriden below\r\n    .replace('#include <begin_vertex>', '') // shader override\r\n    .replace(/void\\s*main\\s*\\(\\)\\s*\\{/,\r\n    /* glsl */\r\n    `\r\n        void main() {\r\n        #include <beginnormal_vertex>\r\n\r\n        vec4 worldPos = modelMatrix * vec4(position, 1.);\r\n\r\n        bool bend = flow > 0;\r\n        float xWeight = bend ? 0. : 1.;\r\n\r\n        #ifdef USE_INSTANCING\r\n        float pathOffsetFromInstanceMatrix = instanceMatrix[3][2];\r\n        float spineLengthFromInstanceMatrix = instanceMatrix[3][0];\r\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLengthFromInstanceMatrix : 0.;\r\n        float mt = (spinePortion * pathSegment + pathOffset + pathOffsetFromInstanceMatrix)*textureStacks;\r\n        #else\r\n        float spinePortion = bend ? (worldPos.x + spineOffset) / spineLength : 0.;\r\n        float mt = (spinePortion * pathSegment + pathOffset)*textureStacks;\r\n        #endif\r\n\r\n        mt = mod(mt, textureStacks);\r\n        float rowOffset = floor(mt);\r\n\r\n        #ifdef USE_INSTANCING\r\n        rowOffset += instanceMatrix[3][1] * ${TEXTURE_HEIGHT}.;\r\n        #endif\r\n\r\n        vec3 spinePos = texture2D(spineTexture, vec2(mt, (0. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        vec3 a =        texture2D(spineTexture, vec2(mt, (1. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        vec3 b =        texture2D(spineTexture, vec2(mt, (2. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        vec3 c =        texture2D(spineTexture, vec2(mt, (3. + rowOffset + 0.5) / textureLayers)).xyz;\r\n        mat3 basis = mat3(a, b, c);\r\n\r\n        vec3 transformed = basis\r\n          * vec3(worldPos.x * xWeight, worldPos.y * 1., worldPos.z * 1.)\r\n          + spinePos;\r\n\r\n        vec3 transformedNormal = normalMatrix * (basis * objectNormal);\r\n\t\t\t`).replace('#include <project_vertex>',\r\n    /* glsl */\r\n    `vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\r\n\t\t\t\tgl_Position = projectionMatrix * mvPosition;`);\r\n    shader.vertexShader = vertexShader;\r\n  };\r\n}\r\n/**\r\n * A helper class for making meshes bend aroudn curves\r\n */\r\n\r\nclass Flow {\r\n  /**\r\n   * @param {Mesh} mesh The mesh to clone and modify to bend around the curve\r\n   * @param {number} numberOfCurves The amount of space that should preallocated for additional curves\r\n   */\r\n  constructor(mesh, numberOfCurves = 1) {\r\n    _defineProperty(this, \"curveArray\", void 0);\r\n\r\n    _defineProperty(this, \"curveLengthArray\", void 0);\r\n\r\n    _defineProperty(this, \"object3D\", void 0);\r\n\r\n    _defineProperty(this, \"splineTexure\", void 0);\r\n\r\n    _defineProperty(this, \"uniforms\", void 0);\r\n\r\n    const obj3D = mesh.clone();\r\n    const splineTexure = initSplineTexture(numberOfCurves);\r\n    const uniforms = getUniforms(splineTexure);\r\n    obj3D.traverse(child => {\r\n      if (child instanceof Mesh || child instanceof InstancedMesh) {\r\n        child.material = child.material.clone();\r\n        modifyShader(child.material, uniforms, numberOfCurves);\r\n      }\r\n    });\r\n    this.curveArray = new Array(numberOfCurves);\r\n    this.curveLengthArray = new Array(numberOfCurves);\r\n    this.object3D = obj3D;\r\n    this.splineTexure = splineTexure;\r\n    this.uniforms = uniforms;\r\n  }\r\n\r\n  updateCurve(index, curve) {\r\n    if (index >= this.curveArray.length) throw Error('Index out of range for Flow');\r\n    const curveLength = curve.getLength();\r\n    this.uniforms.spineLength.value = curveLength;\r\n    this.curveLengthArray[index] = curveLength;\r\n    this.curveArray[index] = curve;\r\n    updateSplineTexture(this.splineTexure, curve, index);\r\n  }\r\n\r\n  moveAlongCurve(amount) {\r\n    this.uniforms.pathOffset.value += amount;\r\n  }\r\n\r\n}\r\nconst matrix = new Matrix4();\r\n/**\r\n * A helper class for creating instanced versions of flow, where the instances are placed on the curve.\r\n */\r\n\r\nclass InstancedFlow extends Flow {\r\n  /**\r\n   *\r\n   * @param {number} count The number of instanced elements\r\n   * @param {number} curveCount The number of curves to preallocate for\r\n   * @param {Geometry} geometry The geometry to use for the instanced mesh\r\n   * @param {Material} material The material to use for the instanced mesh\r\n   */\r\n  constructor(count, curveCount, geometry, material) {\r\n    const mesh = new InstancedMesh(geometry, material, count);\r\n    mesh.instanceMatrix.setUsage(DynamicDrawUsage);\r\n    super(mesh, curveCount);\r\n\r\n    _defineProperty(this, \"offsets\", void 0);\r\n\r\n    _defineProperty(this, \"whichCurve\", void 0);\r\n\r\n    this.offsets = new Array(count).fill(0);\r\n    this.whichCurve = new Array(count).fill(0);\r\n  }\r\n  /**\r\n   * The extra information about which curve and curve position is stored in the translation components of the matrix for the instanced objects\r\n   * This writes that information to the matrix and marks it as needing update.\r\n   *\r\n   * @param {number} index of the instanced element to update\r\n   */\r\n\r\n\r\n  writeChanges(index) {\r\n    matrix.makeTranslation(this.curveLengthArray[this.whichCurve[index]], this.whichCurve[index], this.offsets[index]);\r\n    this.object3D.setMatrixAt(index, matrix);\r\n    this.object3D.instanceMatrix.needsUpdate = true;\r\n  }\r\n  /**\r\n   * Move an individual element along the curve by a specific amount\r\n   *\r\n   * @param {number} index Which element to update\r\n   * @param {number} offset Move by how much\r\n   */\r\n\r\n\r\n  moveIndividualAlongCurve(index, offset) {\r\n    this.offsets[index] += offset;\r\n    this.writeChanges(index);\r\n  }\r\n  /**\r\n   * Select which curve to use for an element\r\n   *\r\n   * @param {number} index the index of the instanced element to update\r\n   * @param {number} curveNo the index of the curve it should use\r\n   */\r\n\r\n\r\n  setCurve(index, curveNo) {\r\n    if (isNaN(curveNo)) throw Error('curve index being set is Not a Number (NaN)');\r\n    this.whichCurve[index] = curveNo;\r\n    this.writeChanges(index);\r\n  }\r\n\r\n}\r\n\r\nexport { Flow, InstancedFlow, getUniforms, initSplineTexture, modifyShader, updateSplineTexture };\r\n"],"mappings":";;;;;AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,SAASC,WAAT,EAAsBC,UAAtB,EAAkCC,SAAlC,EAA6CC,cAA7C,EAA6DC,aAA7D,EAA4EC,IAA5E,EAAkFC,aAAlF,EAAiGC,OAAjG,EAA0GC,gBAA1G,QAAkI,OAAlI,C,CAEA;;AACA,IAAMC,QAAQ,GAAG,CAAjB;AACA,IAAMC,aAAa,GAAG,IAAtB;AACA,IAAMC,cAAc,GAAG,CAAvB;AAEA;AACA;AACA;AACA;AACA;;AACA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,GAAwB;EAAA,IAAvBC,cAAuB,uEAAN,CAAM;EAChD,IAAMC,SAAS,GAAG,IAAIC,YAAJ,CAAiBL,aAAa,GAAGC,cAAhB,GAAiCE,cAAjC,GAAkDJ,QAAnE,CAAlB;EACA,IAAMO,WAAW,GAAG,IAAIhB,WAAJ,CAAgBc,SAAhB,EAA2BJ,aAA3B,EAA0CC,cAAc,GAAGE,cAA3D,EAA2EZ,UAA3E,EAAuFC,SAAvF,CAApB;EACAc,WAAW,CAACC,KAAZ,GAAoBd,cAApB;EACAa,WAAW,CAACE,KAAZ,GAAoBf,cAApB;EACAa,WAAW,CAACG,SAAZ,GAAwBf,aAAxB;EACAY,WAAW,CAACI,WAAZ,GAA0B,IAA1B;EACA,OAAOJ,WAAP;AACD,CARD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAMK,mBAAmB,GAAG,SAAtBA,mBAAsB,CAACC,OAAD,EAAUC,WAAV,EAAsC;EAAA,IAAfC,MAAe,uEAAN,CAAM;EAChE,IAAMC,cAAc,GAAGC,IAAI,CAACC,KAAL,CAAWjB,aAAa,IAAIC,cAAc,GAAG,CAArB,CAAxB,CAAvB;EACAY,WAAW,CAACK,kBAAZ,GAAiCH,cAAc,GAAG,CAAlD;EACAF,WAAW,CAACM,gBAAZ;EACA,IAAMC,MAAM,GAAGP,WAAW,CAACQ,eAAZ,CAA4BN,cAA5B,CAAf;EACA,IAAMO,YAAY,GAAGT,WAAW,CAACU,mBAAZ,CAAgCR,cAAhC,EAAgD,IAAhD,CAArB;;EAEA,KAAK,IAAIS,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,cAApB,EAAoCS,CAAC,EAArC,EAAyC;IACvC,IAAMC,SAAS,GAAGT,IAAI,CAACC,KAAL,CAAWO,CAAC,GAAGxB,aAAf,CAAlB;IACA,IAAM0B,QAAQ,GAAGF,CAAC,GAAGxB,aAArB;IACA,IAAI2B,EAAE,GAAGP,MAAM,CAACI,CAAD,CAAf;IACAI,eAAe,CAAChB,OAAD,EAAUc,QAAV,EAAoBC,EAAE,CAACE,CAAvB,EAA0BF,EAAE,CAACG,CAA7B,EAAgCH,EAAE,CAACI,CAAnC,EAAsC,IAAIN,SAAJ,GAAgBxB,cAAc,GAAGa,MAAvE,CAAf;IACAa,EAAE,GAAGL,YAAY,CAACU,QAAb,CAAsBR,CAAtB,CAAL;IACAI,eAAe,CAAChB,OAAD,EAAUc,QAAV,EAAoBC,EAAE,CAACE,CAAvB,EAA0BF,EAAE,CAACG,CAA7B,EAAgCH,EAAE,CAACI,CAAnC,EAAsC,IAAIN,SAAJ,GAAgBxB,cAAc,GAAGa,MAAvE,CAAf;IACAa,EAAE,GAAGL,YAAY,CAACW,OAAb,CAAqBT,CAArB,CAAL;IACAI,eAAe,CAAChB,OAAD,EAAUc,QAAV,EAAoBC,EAAE,CAACE,CAAvB,EAA0BF,EAAE,CAACG,CAA7B,EAAgCH,EAAE,CAACI,CAAnC,EAAsC,IAAIN,SAAJ,GAAgBxB,cAAc,GAAGa,MAAvE,CAAf;IACAa,EAAE,GAAGL,YAAY,CAACY,SAAb,CAAuBV,CAAvB,CAAL;IACAI,eAAe,CAAChB,OAAD,EAAUc,QAAV,EAAoBC,EAAE,CAACE,CAAvB,EAA0BF,EAAE,CAACG,CAA7B,EAAgCH,EAAE,CAACI,CAAnC,EAAsC,IAAIN,SAAJ,GAAgBxB,cAAc,GAAGa,MAAvE,CAAf;EACD;;EAEDF,OAAO,CAACF,WAAR,GAAsB,IAAtB;AACD,CArBD;;AAuBA,IAAMkB,eAAe,GAAG,SAAlBA,eAAkB,CAAChB,OAAD,EAAUuB,KAAV,EAAiBN,CAAjB,EAAoBC,CAApB,EAAuBC,CAAvB,EAA0BK,CAA1B,EAAgC;EACtD,IAAMC,KAAK,GAAGzB,OAAO,CAACyB,KAAtB;EACA,IACEC,IADF,GAEID,KAFJ,CACEC,IADF;EAGA,IAAMd,CAAC,GAAGzB,QAAQ,GAAGC,aAAX,GAA2BoC,CAArC,CALsD,CAKd;;EAExCE,IAAI,CAACH,KAAK,GAAGpC,QAAR,GAAmByB,CAAnB,GAAuB,CAAxB,CAAJ,GAAiCK,CAAjC;EACAS,IAAI,CAACH,KAAK,GAAGpC,QAAR,GAAmByB,CAAnB,GAAuB,CAAxB,CAAJ,GAAiCM,CAAjC;EACAQ,IAAI,CAACH,KAAK,GAAGpC,QAAR,GAAmByB,CAAnB,GAAuB,CAAxB,CAAJ,GAAiCO,CAAjC;EACAO,IAAI,CAACH,KAAK,GAAGpC,QAAR,GAAmByB,CAAnB,GAAuB,CAAxB,CAAJ,GAAiC,CAAjC;AACD,CAXD;AAaA;AACA;AACA;AACA;AACA;;;AACA,IAAMe,WAAW,GAAG,SAAdA,WAAc,CAAAC,aAAa;EAAA,OAAK;IACpCC,YAAY,EAAE;MACZC,KAAK,EAAEF;IADK,CADsB;IAIpCG,UAAU,EAAE;MACVC,IAAI,EAAE,GADI;MAEVF,KAAK,EAAE;IAFG,CAJwB;IAQpC;IACAG,WAAW,EAAE;MACXD,IAAI,EAAE,GADK;MAEXF,KAAK,EAAE;IAFI,CATuB;IAapC;IACAI,WAAW,EAAE;MACXF,IAAI,EAAE,GADK;MAEXF,KAAK,EAAE;IAFI,CAduB;IAkBpCK,WAAW,EAAE;MACXH,IAAI,EAAE,GADK;MAEXF,KAAK,EAAE;IAFI,CAlBuB;IAsBpCM,IAAI,EAAE;MACJJ,IAAI,EAAE,GADF;MAEJF,KAAK,EAAE;IAFH;EAtB8B,CAAL;AAAA,CAAjC;;AA2BA,SAASO,YAAT,CAAsBC,QAAtB,EAAgCC,QAAhC,EAA8D;EAAA,IAApBhD,cAAoB,uEAAH,CAAG;EAC5D,IAAI+C,QAAQ,CAACE,IAAb,EAAmB;EACnBF,QAAQ,CAACE,IAAT,GAAgB,IAAhB;;EAEAF,QAAQ,CAACG,eAAT,GAA2B,UAAAC,MAAM,EAAI;IACnC,IAAIA,MAAM,CAACC,UAAX,EAAuB;IACvBD,MAAM,CAACC,UAAP,GAAoB,IAApB;IACAC,MAAM,CAACC,MAAP,CAAcH,MAAM,CAACH,QAArB,EAA+BA,QAA/B;IACA,IAAMO,YAAY;IAClB;IACA,mOAQsBzD,cAAc,GAAGE,cARvC,2CASsBF,cAAc,GAAG,CATvC,uBAWAqD,MAAM,CAACI,YAXP,YAYA;IAZA,CAaCC,OAbD,CAaS,+BAbT,EAa0C,EAb1C,EAa8C;IAb9C,CAcCA,OAdD,CAcS,iCAdT,EAc4C,EAd5C,EAcgD;IAdhD,CAeCA,OAfD,CAeS,yBAfT,EAeoC,EAfpC,EAewC;IAfxC,CAgBCA,OAhBD,CAgBS,yBAhBT;IAiBA;IAjBA,w6BAyC0C1D,cAzC1C,wrBAuDE0D,OAvDF,CAuDU,2BAvDV;IAwDA;IAxDA,sHAFA;IA6DAL,MAAM,CAACI,YAAP,GAAsBA,YAAtB;EACD,CAlED;AAmED;AACD;AACA;AACA;;;IAEME,I;EACJ;AACF;AACA;AACA;EACE,cAAYC,IAAZ,EAAsC;IAAA,IAApB1D,cAAoB,uEAAH,CAAG;;IAAA;;IACpCd,eAAe,CAAC,IAAD,EAAO,YAAP,EAAqB,KAAK,CAA1B,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,kBAAP,EAA2B,KAAK,CAAhC,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,UAAP,EAAmB,KAAK,CAAxB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,cAAP,EAAuB,KAAK,CAA5B,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,UAAP,EAAmB,KAAK,CAAxB,CAAf;;IAEA,IAAMyE,KAAK,GAAGD,IAAI,CAACE,KAAL,EAAd;IACA,IAAMC,YAAY,GAAG9D,iBAAiB,CAACC,cAAD,CAAtC;IACA,IAAMgD,QAAQ,GAAGZ,WAAW,CAACyB,YAAD,CAA5B;IACAF,KAAK,CAACG,QAAN,CAAe,UAAAC,KAAK,EAAI;MACtB,IAAIA,KAAK,YAAYvE,IAAjB,IAAyBuE,KAAK,YAAYtE,aAA9C,EAA6D;QAC3DsE,KAAK,CAAChB,QAAN,GAAiBgB,KAAK,CAAChB,QAAN,CAAea,KAAf,EAAjB;QACAd,YAAY,CAACiB,KAAK,CAAChB,QAAP,EAAiBC,QAAjB,EAA2BhD,cAA3B,CAAZ;MACD;IACF,CALD;IAMA,KAAKgE,UAAL,GAAkB,IAAIC,KAAJ,CAAUjE,cAAV,CAAlB;IACA,KAAKkE,gBAAL,GAAwB,IAAID,KAAJ,CAAUjE,cAAV,CAAxB;IACA,KAAKmE,QAAL,GAAgBR,KAAhB;IACA,KAAKE,YAAL,GAAoBA,YAApB;IACA,KAAKb,QAAL,GAAgBA,QAAhB;EACD;;;;WAED,qBAAYhB,KAAZ,EAAmBoC,KAAnB,EAA0B;MACxB,IAAIpC,KAAK,IAAI,KAAKgC,UAAL,CAAgBK,MAA7B,EAAqC,MAAMC,KAAK,CAAC,6BAAD,CAAX;MACrC,IAAMC,WAAW,GAAGH,KAAK,CAACI,SAAN,EAApB;MACA,KAAKxB,QAAL,CAAcJ,WAAd,CAA0BL,KAA1B,GAAkCgC,WAAlC;MACA,KAAKL,gBAAL,CAAsBlC,KAAtB,IAA+BuC,WAA/B;MACA,KAAKP,UAAL,CAAgBhC,KAAhB,IAAyBoC,KAAzB;MACA5D,mBAAmB,CAAC,KAAKqD,YAAN,EAAoBO,KAApB,EAA2BpC,KAA3B,CAAnB;IACD;;;WAED,wBAAeyC,MAAf,EAAuB;MACrB,KAAKzB,QAAL,CAAcR,UAAd,CAAyBD,KAAzB,IAAkCkC,MAAlC;IACD;;;;;;AAGH,IAAMC,MAAM,GAAG,IAAIhF,OAAJ,EAAf;AACA;AACA;AACA;;IAEMiF,a;;;;;EACJ;AACF;AACA;AACA;AACA;AACA;AACA;EACE,uBAAYC,KAAZ,EAAmBC,UAAnB,EAA+BC,QAA/B,EAAyC/B,QAAzC,EAAmD;IAAA;;IAAA;;IACjD,IAAMW,IAAI,GAAG,IAAIjE,aAAJ,CAAkBqF,QAAlB,EAA4B/B,QAA5B,EAAsC6B,KAAtC,CAAb;IACAlB,IAAI,CAACqB,cAAL,CAAoBC,QAApB,CAA6BrF,gBAA7B;IACA,0BAAM+D,IAAN,EAAYmB,UAAZ;;IAEA3F,eAAe,gCAAO,SAAP,EAAkB,KAAK,CAAvB,CAAf;;IAEAA,eAAe,gCAAO,YAAP,EAAqB,KAAK,CAA1B,CAAf;;IAEA,MAAK+F,OAAL,GAAe,IAAIhB,KAAJ,CAAUW,KAAV,EAAiBM,IAAjB,CAAsB,CAAtB,CAAf;IACA,MAAKC,UAAL,GAAkB,IAAIlB,KAAJ,CAAUW,KAAV,EAAiBM,IAAjB,CAAsB,CAAtB,CAAlB;IAViD;EAWlD;EACD;AACF;AACA;AACA;AACA;AACA;;;;;WAGE,sBAAalD,KAAb,EAAoB;MAClB0C,MAAM,CAACU,eAAP,CAAuB,KAAKlB,gBAAL,CAAsB,KAAKiB,UAAL,CAAgBnD,KAAhB,CAAtB,CAAvB,EAAsE,KAAKmD,UAAL,CAAgBnD,KAAhB,CAAtE,EAA8F,KAAKiD,OAAL,CAAajD,KAAb,CAA9F;MACA,KAAKmC,QAAL,CAAckB,WAAd,CAA0BrD,KAA1B,EAAiC0C,MAAjC;MACA,KAAKP,QAAL,CAAcY,cAAd,CAA6BxE,WAA7B,GAA2C,IAA3C;IACD;IACD;AACF;AACA;AACA;AACA;AACA;;;;WAGE,kCAAyByB,KAAzB,EAAgCrB,MAAhC,EAAwC;MACtC,KAAKsE,OAAL,CAAajD,KAAb,KAAuBrB,MAAvB;MACA,KAAK2E,YAAL,CAAkBtD,KAAlB;IACD;IACD;AACF;AACA;AACA;AACA;AACA;;;;WAGE,kBAASA,KAAT,EAAgBuD,OAAhB,EAAyB;MACvB,IAAIC,KAAK,CAACD,OAAD,CAAT,EAAoB,MAAMjB,KAAK,CAAC,6CAAD,CAAX;MACpB,KAAKa,UAAL,CAAgBnD,KAAhB,IAAyBuD,OAAzB;MACA,KAAKD,YAAL,CAAkBtD,KAAlB;IACD;;;;EAzDyByB,I;;AA6D5B,SAASA,IAAT,EAAekB,aAAf,EAA8BvC,WAA9B,EAA2CrC,iBAA3C,EAA8D+C,YAA9D,EAA4EtC,mBAA5E"},"metadata":{},"sourceType":"module"}