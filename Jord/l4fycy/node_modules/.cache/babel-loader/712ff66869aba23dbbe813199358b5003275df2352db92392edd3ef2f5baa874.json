{"ast":null,"code":"import { Vector3 } from \"three\";\nconst hilbert2D = function () {\n  let center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 0);\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  let iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let v0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let v1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  let v2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;\n  let v3 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 3;\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y, center.z - half), new Vector3(center.x - half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z + half), new Vector3(center.x + half, center.y, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]];\n  if (0 <= --iterations) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3));\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3));\n    return tmp;\n  }\n  return vec;\n};\nconst hilbert3D = function () {\n  let center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 0);\n  let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  let iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let v0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let v1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  let v2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;\n  let v3 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 3;\n  let v4 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 4;\n  let v5 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 5;\n  let v6 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 6;\n  let v7 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 7;\n  const half = size / 2;\n  const vec_s = [new Vector3(center.x - half, center.y + half, center.z - half), new Vector3(center.x - half, center.y + half, center.z + half), new Vector3(center.x - half, center.y - half, center.z + half), new Vector3(center.x - half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z - half), new Vector3(center.x + half, center.y - half, center.z + half), new Vector3(center.x + half, center.y + half, center.z + half), new Vector3(center.x + half, center.y + half, center.z - half)];\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]];\n  if (--iterations >= 0) {\n    const tmp = [];\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7));\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7));\n    return tmp;\n  }\n  return vec;\n};\nconst gosper = function () {\n  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  function fractalize(config) {\n    let output = \"\";\n    let input = config.axiom;\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = \"\";\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        const char = input[j];\n        if (char in config.rules) {\n          output += config.rules[char];\n        } else {\n          output += char;\n        }\n      }\n      input = output;\n    }\n    return output;\n  }\n  function toPoints(config) {\n    let currX = 0;\n    let currY = 0;\n    let angle = 0;\n    const path = [0, 0, 0];\n    const fractal = config.fractal;\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      const char = fractal[i];\n      if (char === \"+\") {\n        angle += config.angle;\n      } else if (char === \"-\") {\n        angle -= config.angle;\n      } else if (char === \"F\") {\n        currX += config.size * Math.cos(angle);\n        currY += -config.size * Math.sin(angle);\n        path.push(currX, currY, 0);\n      }\n    }\n    return path;\n  }\n  const gosper2 = fractalize({\n    axiom: \"A\",\n    steps: 4,\n    rules: {\n      A: \"A+BF++BF-FA--FAFA-BF+\",\n      B: \"-FA+BFBF++BF+FA--FA-B\"\n    }\n  });\n  const points = toPoints({\n    fractal: gosper2,\n    size,\n    angle: Math.PI / 3\n    // 60 degrees\n  });\n  return points;\n};\nconst GeometryUtils = {\n  hilbert3D,\n  gosper,\n  hilbert2D\n};\nexport { GeometryUtils };","map":{"version":3,"names":["hilbert2D","center","arguments","length","undefined","Vector3","size","iterations","v0","v1","v2","v3","half","vec_s","x","y","z","vec","tmp","Array","prototype","push","apply","hilbert3D","v4","v5","v6","v7","gosper","fractalize","config","output","input","axiom","i","il","steps","j","jl","char","rules","toPoints","currX","currY","angle","path","fractal","l","Math","cos","sin","gosper2","A","B","points","PI","GeometryUtils"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\src\\utils\\GeometryUtils.ts"],"sourcesContent":["import { Vector3 } from 'three'\n\n/**\n * Generates 2D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/sketch/15493\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, -Z.\n * @param v1         Corner index -X, +Z.\n * @param v2         Corner index +X, +Z.\n * @param v3         Corner index +X, -Z.\n */\nconst hilbert2D = (\n  center = new Vector3(0, 0, 0),\n  size = 10,\n  iterations = 1,\n  v0 = 0,\n  v1 = 1,\n  v2 = 2,\n  v3 = 3,\n): Vector3[] => {\n  // Default Vars\n  const half = size / 2\n  const vec_s = [\n    new Vector3(center.x - half, center.y, center.z - half),\n    new Vector3(center.x - half, center.y, center.z + half),\n    new Vector3(center.x + half, center.y, center.z + half),\n    new Vector3(center.x + half, center.y, center.z - half),\n  ]\n\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]]\n\n  // Recurse iterations\n  if (0 <= --iterations) {\n    const tmp: Vector3[] = []\n\n    Array.prototype.push.apply(tmp, hilbert2D(vec[0], half, iterations, v0, v3, v2, v1))\n    Array.prototype.push.apply(tmp, hilbert2D(vec[1], half, iterations, v0, v1, v2, v3))\n    Array.prototype.push.apply(tmp, hilbert2D(vec[2], half, iterations, v0, v1, v2, v3))\n    Array.prototype.push.apply(tmp, hilbert2D(vec[3], half, iterations, v2, v1, v0, v3))\n\n    // Return recursive call\n    return tmp\n  }\n\n  // Return complete Hilbert Curve.\n  return vec\n}\n\n/**\n * Generates 3D-Coordinates in a very fast way.\n *\n * Based on work by:\n * @link http://www.openprocessing.org/visuals/?visualID=15599\n *\n * @param center     Center of Hilbert curve.\n * @param size       Total width of Hilbert curve.\n * @param iterations Number of subdivisions.\n * @param v0         Corner index -X, +Y, -Z.\n * @param v1         Corner index -X, +Y, +Z.\n * @param v2         Corner index -X, -Y, +Z.\n * @param v3         Corner index -X, -Y, -Z.\n * @param v4         Corner index +X, -Y, -Z.\n * @param v5         Corner index +X, -Y, +Z.\n * @param v6         Corner index +X, +Y, +Z.\n * @param v7         Corner index +X, +Y, -Z.\n */\nconst hilbert3D = (\n  center = new Vector3(0, 0, 0),\n  size = 10,\n  iterations = 1,\n  v0 = 0,\n  v1 = 1,\n  v2 = 2,\n  v3 = 3,\n  v4 = 4,\n  v5 = 5,\n  v6 = 6,\n  v7 = 7,\n): Vector3[] => {\n  // Default Vars\n  const half = size / 2\n  const vec_s = [\n    new Vector3(center.x - half, center.y + half, center.z - half),\n    new Vector3(center.x - half, center.y + half, center.z + half),\n    new Vector3(center.x - half, center.y - half, center.z + half),\n    new Vector3(center.x - half, center.y - half, center.z - half),\n    new Vector3(center.x + half, center.y - half, center.z - half),\n    new Vector3(center.x + half, center.y - half, center.z + half),\n    new Vector3(center.x + half, center.y + half, center.z + half),\n    new Vector3(center.x + half, center.y + half, center.z - half),\n  ]\n\n  const vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]]\n\n  // Recurse iterations\n  if (--iterations >= 0) {\n    const tmp: Vector3[] = []\n\n    Array.prototype.push.apply(tmp, hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7))\n    Array.prototype.push.apply(tmp, hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7))\n\n    // Return recursive call\n    return tmp\n  }\n\n  // Return complete Hilbert Curve.\n  return vec\n}\n\n/**\n * Generates a Gosper curve (lying in the XY plane)\n *\n * https://gist.github.com/nitaku/6521802\n *\n * @param size The size of a single gosper island.\n */\nconst gosper = (size = 1): number[] => {\n  function fractalize(config: { axiom: string; steps: number; rules: Record<string, string> }): string {\n    let output = ''\n    let input = config.axiom\n\n    for (let i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {\n      output = ''\n\n      for (let j = 0, jl = input.length; j < jl; j++) {\n        const char = input[j]\n\n        if (char in config.rules) {\n          output += config.rules[char]\n        } else {\n          output += char\n        }\n      }\n\n      input = output\n    }\n\n    return output\n  }\n\n  function toPoints(config: { fractal: string; size: number; angle: number }): number[] {\n    let currX = 0\n    let currY = 0\n    let angle = 0\n    const path = [0, 0, 0]\n    const fractal = config.fractal\n\n    for (let i = 0, l = fractal.length; i < l; i++) {\n      const char = fractal[i]\n\n      if (char === '+') {\n        angle += config.angle\n      } else if (char === '-') {\n        angle -= config.angle\n      } else if (char === 'F') {\n        currX += config.size * Math.cos(angle)\n        currY += -config.size * Math.sin(angle)\n        path.push(currX, currY, 0)\n      }\n    }\n\n    return path\n  }\n\n  //\n\n  const gosper = fractalize({\n    axiom: 'A',\n    steps: 4,\n    rules: {\n      A: 'A+BF++BF-FA--FAFA-BF+',\n      B: '-FA+BFBF++BF+FA--FA-B',\n    },\n  })\n\n  const points = toPoints({\n    fractal: gosper,\n    size: size,\n    angle: Math.PI / 3, // 60 degrees\n  })\n\n  return points\n}\n\nexport const GeometryUtils = {\n  hilbert3D,\n  gosper,\n  hilbert2D,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}