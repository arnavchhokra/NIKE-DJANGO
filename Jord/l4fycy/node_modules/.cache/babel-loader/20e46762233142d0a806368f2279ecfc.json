{"ast":null,"code":"import { Vector3, Color } from 'three';\n/**\r\n * God-rays (crepuscular rays)\r\n *\r\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\r\n * Blurs a mask generated from the depth map along radial lines emanating from the light\r\n * source. The blur repeatedly applies a blur filter of increasing support but constant\r\n * sample count to produce a blur filter with large support.\r\n *\r\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\r\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\r\n * with decreasing filter support. The result is equivalent to a single pass with\r\n * 6*6*6 = 216 samples.\r\n *\r\n * References:\r\n *\r\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\r\n */\n\nvar GodRaysDepthMaskShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tInput;', 'void main() {', '\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );', '}'].join('\\n')\n};\n/**\r\n * The god-ray generation shader.\r\n *\r\n * First pass:\r\n *\r\n * The depth map is blurred along radial lines towards the \"sun\". The\r\n * output is written to a temporary render target (I used a 1/4 sized\r\n * target).\r\n *\r\n * Pass two & three:\r\n *\r\n * The results of the previous pass are re-blurred, each time with a\r\n * decreased distance between samples.\r\n */\n\nvar GodRaysGenerateShader = {\n  uniforms: {\n    tInput: {\n      value: null\n    },\n    fStepSize: {\n      value: 1.0\n    },\n    vSunPositionScreenSpace: {\n      value: new Vector3()\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['#define TAPS_PER_PASS 6.0', 'varying vec2 vUv;', 'uniform sampler2D tInput;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fStepSize;', // filter step size\n  'void main() {', // delta from current pixel to \"sun\" position\n  '\tvec2 delta = vSunPositionScreenSpace.xy - vUv;', '\tfloat dist = length( delta );', // Step vector (uv space)\n  '\tvec2 stepv = fStepSize * delta / dist;', // Number of iterations between pixel and sun\n  '\tfloat iters = dist/fStepSize;', '\tvec2 uv = vUv.xy;', '\tfloat col = 0.0;', // This breaks ANGLE in Chrome 22\n  //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\n\n  /*\r\n  // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\r\n  // so i've just left the loop\r\n  \"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\r\n  // Accumulate samples, making sure we dont walk past the light source.\r\n  // The check for uv.y < 1 would not be necessary with \"border\" UV wrap\r\n  // mode, with a black border color. I don't think this is currently\r\n  // exposed by three.js. As a result there might be artifacts when the\r\n  // sun is to the left, right or bottom of screen as these cases are\r\n  // not specifically handled.\r\n  \"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\r\n  \"\tuv += stepv;\",\r\n  \"}\",\r\n  */\n  // Unrolling loop manually makes it work in ANGLE\n  '\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );', // used to fade out godrays\n  '\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\n  // objectionable artifacts, in particular near the sun position. The side\n  // effect is that the result is darker than it should be around the sun, as\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\n  // When the result is inverted (in the shader 'godrays_combine', this produces\n  // a slight bright spot at the position of the sun, even when it is occluded.\n  '\tgl_FragColor = vec4( col/TAPS_PER_PASS );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n/**\r\n * Additively applies god rays from texture tGodRays to a background (tColors).\r\n * fGodRayIntensity attenuates the god rays.\r\n */\n\nvar GodRaysCombineShader = {\n  uniforms: {\n    tColors: {\n      value: null\n    },\n    tGodRays: {\n      value: null\n    },\n    fGodRayIntensity: {\n      value: 0.69\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tColors;', 'uniform sampler2D tGodRays;', 'uniform float fGodRayIntensity;', 'void main() {', // Since THREE.MeshDepthMaterial renders foreground objects white and background\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\n  // before being combined with tColors\n  '\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\n};\n/**\r\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\r\n * cheaper/faster/simpler to implement this as a simple sun sprite.\r\n */\n\nvar GodRaysFakeSunShader = {\n  uniforms: {\n    vSunPositionScreenSpace: {\n      value: new Vector3()\n    },\n    fAspect: {\n      value: 1.0\n    },\n    sunColor: {\n      value: new Color(0xffee00)\n    },\n    bgColor: {\n      value: new Color(0x000000)\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\n  fragmentShader: ['varying vec2 vUv;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fAspect;', 'uniform vec3 sunColor;', 'uniform vec3 bgColor;', 'void main() {', '\tvec2 diff = vUv - vSunPositionScreenSpace.xy;', // Correct for aspect ratio\n  '\tdiff.x *= fAspect;', '\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );', '\tprop = 0.35 * pow( 1.0 - prop, 3.0 );', '\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;', '\tgl_FragColor.w = 1.0;', '}'].join('\\n')\n};\nexport { GodRaysCombineShader, GodRaysDepthMaskShader, GodRaysFakeSunShader, GodRaysGenerateShader };","map":{"version":3,"names":["Vector3","Color","GodRaysDepthMaskShader","uniforms","tInput","value","vertexShader","join","fragmentShader","GodRaysGenerateShader","fStepSize","vSunPositionScreenSpace","GodRaysCombineShader","tColors","tGodRays","fGodRayIntensity","GodRaysFakeSunShader","fAspect","sunColor","bgColor"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/shaders/GodRaysShader.js"],"sourcesContent":["import { Vector3, Color } from 'three';\r\n\r\n/**\r\n * God-rays (crepuscular rays)\r\n *\r\n * Similar implementation to the one used by Crytek for CryEngine 2 [Sousa2008].\r\n * Blurs a mask generated from the depth map along radial lines emanating from the light\r\n * source. The blur repeatedly applies a blur filter of increasing support but constant\r\n * sample count to produce a blur filter with large support.\r\n *\r\n * My implementation performs 3 passes, similar to the implementation from Sousa. I found\r\n * just 6 samples per pass produced acceptible results. The blur is applied three times,\r\n * with decreasing filter support. The result is equivalent to a single pass with\r\n * 6*6*6 = 216 samples.\r\n *\r\n * References:\r\n *\r\n * Sousa2008 - Crysis Next Gen Effects, GDC2008, http://www.crytek.com/sites/default/files/GDC08_SousaT_CrysisEffects.ppt\r\n */\r\n\r\nconst GodRaysDepthMaskShader = {\r\n  uniforms: {\r\n    tInput: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tInput;', 'void main() {', '\tgl_FragColor = vec4( 1.0 ) - texture2D( tInput, vUv );', '}'].join('\\n')\r\n};\r\n/**\r\n * The god-ray generation shader.\r\n *\r\n * First pass:\r\n *\r\n * The depth map is blurred along radial lines towards the \"sun\". The\r\n * output is written to a temporary render target (I used a 1/4 sized\r\n * target).\r\n *\r\n * Pass two & three:\r\n *\r\n * The results of the previous pass are re-blurred, each time with a\r\n * decreased distance between samples.\r\n */\r\n\r\nconst GodRaysGenerateShader = {\r\n  uniforms: {\r\n    tInput: {\r\n      value: null\r\n    },\r\n    fStepSize: {\r\n      value: 1.0\r\n    },\r\n    vSunPositionScreenSpace: {\r\n      value: new Vector3()\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', ' vUv = uv;', ' gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['#define TAPS_PER_PASS 6.0', 'varying vec2 vUv;', 'uniform sampler2D tInput;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fStepSize;', // filter step size\r\n  'void main() {', // delta from current pixel to \"sun\" position\r\n  '\tvec2 delta = vSunPositionScreenSpace.xy - vUv;', '\tfloat dist = length( delta );', // Step vector (uv space)\r\n  '\tvec2 stepv = fStepSize * delta / dist;', // Number of iterations between pixel and sun\r\n  '\tfloat iters = dist/fStepSize;', '\tvec2 uv = vUv.xy;', '\tfloat col = 0.0;', // This breaks ANGLE in Chrome 22\r\n  //\t- see http://code.google.com/p/chromium/issues/detail?id=153105\r\n\r\n  /*\r\n  // Unrolling didnt do much on my hardware (ATI Mobility Radeon 3450),\r\n  // so i've just left the loop\r\n  \"for ( float i = 0.0; i < TAPS_PER_PASS; i += 1.0 ) {\",\r\n  // Accumulate samples, making sure we dont walk past the light source.\r\n  // The check for uv.y < 1 would not be necessary with \"border\" UV wrap\r\n  // mode, with a black border color. I don't think this is currently\r\n  // exposed by three.js. As a result there might be artifacts when the\r\n  // sun is to the left, right or bottom of screen as these cases are\r\n  // not specifically handled.\r\n  \"\tcol += ( i <= iters && uv.y < 1.0 ? texture2D( tInput, uv ).r : 0.0 );\",\r\n  \"\tuv += stepv;\",\r\n  \"}\",\r\n  */\r\n  // Unrolling loop manually makes it work in ANGLE\r\n  '\tfloat f = min( 1.0, max( vSunPositionScreenSpace.z / 1000.0, 0.0 ) );', // used to fade out godrays\r\n  '\tif ( 0.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 1.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 2.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 3.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 4.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', '\tif ( 5.0 <= iters && uv.y < 1.0 ) col += texture2D( tInput, uv ).r * f;', '\tuv += stepv;', // Should technically be dividing by 'iters', but 'TAPS_PER_PASS' smooths out\r\n  // objectionable artifacts, in particular near the sun position. The side\r\n  // effect is that the result is darker than it should be around the sun, as\r\n  // TAPS_PER_PASS is greater than the number of samples actually accumulated.\r\n  // When the result is inverted (in the shader 'godrays_combine', this produces\r\n  // a slight bright spot at the position of the sun, even when it is occluded.\r\n  '\tgl_FragColor = vec4( col/TAPS_PER_PASS );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\r\n};\r\n/**\r\n * Additively applies god rays from texture tGodRays to a background (tColors).\r\n * fGodRayIntensity attenuates the god rays.\r\n */\r\n\r\nconst GodRaysCombineShader = {\r\n  uniforms: {\r\n    tColors: {\r\n      value: null\r\n    },\r\n    tGodRays: {\r\n      value: null\r\n    },\r\n    fGodRayIntensity: {\r\n      value: 0.69\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['varying vec2 vUv;', 'uniform sampler2D tColors;', 'uniform sampler2D tGodRays;', 'uniform float fGodRayIntensity;', 'void main() {', // Since THREE.MeshDepthMaterial renders foreground objects white and background\r\n  // objects black, the god-rays will be white streaks. Therefore value is inverted\r\n  // before being combined with tColors\r\n  '\tgl_FragColor = texture2D( tColors, vUv ) + fGodRayIntensity * vec4( 1.0 - texture2D( tGodRays, vUv ).r );', '\tgl_FragColor.a = 1.0;', '}'].join('\\n')\r\n};\r\n/**\r\n * A dodgy sun/sky shader. Makes a bright spot at the sun location. Would be\r\n * cheaper/faster/simpler to implement this as a simple sun sprite.\r\n */\r\n\r\nconst GodRaysFakeSunShader = {\r\n  uniforms: {\r\n    vSunPositionScreenSpace: {\r\n      value: new Vector3()\r\n    },\r\n    fAspect: {\r\n      value: 1.0\r\n    },\r\n    sunColor: {\r\n      value: new Color(0xffee00)\r\n    },\r\n    bgColor: {\r\n      value: new Color(0x000000)\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'void main() {', '\tvUv = uv;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n'),\r\n  fragmentShader: ['varying vec2 vUv;', 'uniform vec3 vSunPositionScreenSpace;', 'uniform float fAspect;', 'uniform vec3 sunColor;', 'uniform vec3 bgColor;', 'void main() {', '\tvec2 diff = vUv - vSunPositionScreenSpace.xy;', // Correct for aspect ratio\r\n  '\tdiff.x *= fAspect;', '\tfloat prop = clamp( length( diff ) / 0.5, 0.0, 1.0 );', '\tprop = 0.35 * pow( 1.0 - prop, 3.0 );', '\tgl_FragColor.xyz = ( vSunPositionScreenSpace.z > 0.0 ) ? mix( sunColor, bgColor, 1.0 - prop ) : bgColor;', '\tgl_FragColor.w = 1.0;', '}'].join('\\n')\r\n};\r\n\r\nexport { GodRaysCombineShader, GodRaysDepthMaskShader, GodRaysFakeSunShader, GodRaysGenerateShader };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}