{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { BufferGeometry, Mesh, Points } from 'three';\n/**\r\n * Export draco compressed files from threejs geometry objects.\r\n *\r\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\r\n *\r\n * The exporter receives a options object containing\r\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\r\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\r\n *  - encoderMethod\r\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\r\n *  - exportUvs\r\n *  - exportNormals\r\n */\n\nvar DRACOExporter = /*#__PURE__*/function () {\n  function DRACOExporter() {\n    _classCallCheck(this, DRACOExporter);\n  }\n\n  _createClass(DRACOExporter, [{\n    key: \"parse\",\n    value: // Encoder methods\n    // Geometry type\n    // Attribute type\n    function parse(object) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        decodeSpeed: 5,\n        encodeSpeed: 5,\n        encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\n        quantization: [16, 8, 8, 8, 8],\n        exportUvs: true,\n        exportNormals: true,\n        exportColor: false\n      };\n\n      if (object instanceof BufferGeometry && object.isBufferGeometry) {\n        throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\n      }\n\n      if (DracoEncoderModule === undefined) {\n        throw new Error('THREE.DRACOExporter: required the draco_encoder to work.');\n      }\n\n      var geometry = object.geometry;\n      var dracoEncoder = DracoEncoderModule();\n      var encoder = new dracoEncoder.Encoder();\n      var builder;\n      var dracoObject;\n\n      if (!geometry.isBufferGeometry) {\n        throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\n      }\n\n      if (object instanceof Mesh && object.isMesh) {\n        builder = new dracoEncoder.MeshBuilder();\n        dracoObject = new dracoEncoder.Mesh();\n        var vertices = geometry.getAttribute('position'); // @ts-expect-error\n\n        builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\n        var faces = geometry.getIndex();\n\n        if (faces !== null) {\n          // @ts-expect-error\n          builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\n        } else {\n          var _faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\n\n          for (var i = 0; i < _faces.length; i++) {\n            _faces[i] = i;\n          }\n\n          builder.AddFacesToMesh(dracoObject, vertices.count, _faces);\n        }\n\n        if (options.exportNormals) {\n          var normals = geometry.getAttribute('normal');\n\n          if (normals !== undefined) {\n            // @ts-expect-error\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\n          }\n        }\n\n        if (options.exportUvs) {\n          var uvs = geometry.getAttribute('uv');\n\n          if (uvs !== undefined) {\n            // @ts-expect-error\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\n          }\n        }\n\n        if (options.exportColor) {\n          var colors = geometry.getAttribute('color');\n\n          if (colors !== undefined) {\n            // @ts-expect-error\n            builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\n          }\n        }\n      } else if (object instanceof Points && object.isPoints) {\n        // @ts-expect-error\n        builder = new dracoEncoder.PointCloudBuilder(); // @ts-expect-error\n\n        dracoObject = new dracoEncoder.PointCloud();\n\n        var _vertices = geometry.getAttribute('position');\n\n        builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, _vertices.count, _vertices.itemSize, _vertices.array);\n\n        if (options.exportColor) {\n          var _colors = geometry.getAttribute('color');\n\n          if (_colors !== undefined) {\n            builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, _colors.count, _colors.itemSize, _colors.array);\n          }\n        }\n      } else {\n        throw new Error('DRACOExporter: Unsupported object type.');\n      } //Compress using draco encoder\n\n\n      var encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\n\n      var encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\n      var decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\n      encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\n\n      if (options.encoderMethod !== undefined) {\n        encoder.SetEncodingMethod(options.encoderMethod);\n      } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\n      // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\n\n\n      if (options.quantization !== undefined) {\n        for (var _i = 0; _i < 5; _i++) {\n          if (options.quantization[_i] !== undefined) {\n            encoder.SetAttributeQuantization(_i, options.quantization[_i]);\n          }\n        }\n      }\n\n      var length;\n\n      if (object instanceof Mesh && object.isMesh) {\n        length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\n      } else {\n        // @ts-expect-error\n        length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\n      }\n\n      dracoEncoder.destroy(dracoObject);\n\n      if (length === 0) {\n        throw new Error('THREE.DRACOExporter: Draco encoding failed.');\n      } //Copy encoded data to buffer.\n\n\n      var outputData = new Int8Array(new ArrayBuffer(length));\n\n      for (var _i2 = 0; _i2 < length; _i2++) {\n        outputData[_i2] = encodedData.GetValue(_i2);\n      }\n\n      dracoEncoder.destroy(encodedData);\n      dracoEncoder.destroy(encoder);\n      dracoEncoder.destroy(builder);\n      return outputData;\n    }\n  }]);\n\n  return DRACOExporter;\n}();\n\n_defineProperty(DRACOExporter, \"MESH_EDGEBREAKER_ENCODING\", 1);\n\n_defineProperty(DRACOExporter, \"MESH_SEQUENTIAL_ENCODING\", 0);\n\n_defineProperty(DRACOExporter, \"POINT_CLOUD\", 0);\n\n_defineProperty(DRACOExporter, \"TRIANGULAR_MESH\", 1);\n\n_defineProperty(DRACOExporter, \"INVALID\", -1);\n\n_defineProperty(DRACOExporter, \"POSITION\", 0);\n\n_defineProperty(DRACOExporter, \"NORMAL\", 1);\n\n_defineProperty(DRACOExporter, \"COLOR\", 2);\n\n_defineProperty(DRACOExporter, \"TEX_COORD\", 3);\n\n_defineProperty(DRACOExporter, \"GENERIC\", 4);\n\nexport { DRACOExporter };","map":{"version":3,"names":["_defineProperty","BufferGeometry","Mesh","Points","DRACOExporter","object","options","decodeSpeed","encodeSpeed","encoderMethod","MESH_EDGEBREAKER_ENCODING","quantization","exportUvs","exportNormals","exportColor","isBufferGeometry","Error","DracoEncoderModule","undefined","geometry","dracoEncoder","encoder","Encoder","builder","dracoObject","isMesh","MeshBuilder","vertices","getAttribute","AddFloatAttributeToMesh","POSITION","count","itemSize","array","faces","getIndex","AddFacesToMesh","Uint32Array","Uint16Array","i","length","normals","NORMAL","uvs","TEX_COORD","colors","COLOR","isPoints","PointCloudBuilder","PointCloud","AddFloatAttribute","encodedData","DracoInt8Array","SetSpeedOptions","SetEncodingMethod","SetAttributeQuantization","EncodeMeshToDracoBuffer","EncodePointCloudToDracoBuffer","destroy","outputData","Int8Array","ArrayBuffer","GetValue"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/exporters/DRACOExporter.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { BufferGeometry, Mesh, Points } from 'three';\r\n\r\n/**\r\n * Export draco compressed files from threejs geometry objects.\r\n *\r\n * Draco files are compressed and usually are smaller than conventional 3D file formats.\r\n *\r\n * The exporter receives a options object containing\r\n *  - decodeSpeed, indicates how to tune the encoder regarding decode speed (0 gives better speed but worst quality)\r\n *  - encodeSpeed, indicates how to tune the encoder parameters (0 gives better speed but worst quality)\r\n *  - encoderMethod\r\n *  - quantization, indicates the presision of each type of data stored in the draco file in the order (POSITION, NORMAL, COLOR, TEX_COORD, GENERIC)\r\n *  - exportUvs\r\n *  - exportNormals\r\n */\r\n\r\nclass DRACOExporter {\r\n  // Encoder methods\r\n  // Geometry type\r\n  // Attribute type\r\n  parse(object, options = {\r\n    decodeSpeed: 5,\r\n    encodeSpeed: 5,\r\n    encoderMethod: DRACOExporter.MESH_EDGEBREAKER_ENCODING,\r\n    quantization: [16, 8, 8, 8, 8],\r\n    exportUvs: true,\r\n    exportNormals: true,\r\n    exportColor: false\r\n  }) {\r\n    if (object instanceof BufferGeometry && object.isBufferGeometry) {\r\n      throw new Error('DRACOExporter: The first parameter of parse() is now an instance of Mesh or Points.');\r\n    }\r\n\r\n    if (DracoEncoderModule === undefined) {\r\n      throw new Error('THREE.DRACOExporter: required the draco_encoder to work.');\r\n    }\r\n\r\n    const geometry = object.geometry;\r\n    const dracoEncoder = DracoEncoderModule();\r\n    const encoder = new dracoEncoder.Encoder();\r\n    let builder;\r\n    let dracoObject;\r\n\r\n    if (!geometry.isBufferGeometry) {\r\n      throw new Error('THREE.DRACOExporter.parse(geometry, options): geometry is not a THREE.BufferGeometry instance.');\r\n    }\r\n\r\n    if (object instanceof Mesh && object.isMesh) {\r\n      builder = new dracoEncoder.MeshBuilder();\r\n      dracoObject = new dracoEncoder.Mesh();\r\n      const vertices = geometry.getAttribute('position'); // @ts-expect-error\r\n\r\n      builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\r\n      const faces = geometry.getIndex();\r\n\r\n      if (faces !== null) {\r\n        // @ts-expect-error\r\n        builder.AddFacesToMesh(dracoObject, faces.count / 3, faces.array);\r\n      } else {\r\n        const faces = new (vertices.count > 65535 ? Uint32Array : Uint16Array)(vertices.count);\r\n\r\n        for (let i = 0; i < faces.length; i++) {\r\n          faces[i] = i;\r\n        }\r\n\r\n        builder.AddFacesToMesh(dracoObject, vertices.count, faces);\r\n      }\r\n\r\n      if (options.exportNormals) {\r\n        const normals = geometry.getAttribute('normal');\r\n\r\n        if (normals !== undefined) {\r\n          // @ts-expect-error\r\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.NORMAL, normals.count, normals.itemSize, normals.array);\r\n        }\r\n      }\r\n\r\n      if (options.exportUvs) {\r\n        const uvs = geometry.getAttribute('uv');\r\n\r\n        if (uvs !== undefined) {\r\n          // @ts-expect-error\r\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.TEX_COORD, uvs.count, uvs.itemSize, uvs.array);\r\n        }\r\n      }\r\n\r\n      if (options.exportColor) {\r\n        const colors = geometry.getAttribute('color');\r\n\r\n        if (colors !== undefined) {\r\n          // @ts-expect-error\r\n          builder.AddFloatAttributeToMesh(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\r\n        }\r\n      }\r\n    } else if (object instanceof Points && object.isPoints) {\r\n      // @ts-expect-error\r\n      builder = new dracoEncoder.PointCloudBuilder(); // @ts-expect-error\r\n\r\n      dracoObject = new dracoEncoder.PointCloud();\r\n      const vertices = geometry.getAttribute('position');\r\n      builder.AddFloatAttribute(dracoObject, dracoEncoder.POSITION, vertices.count, vertices.itemSize, vertices.array);\r\n\r\n      if (options.exportColor) {\r\n        const colors = geometry.getAttribute('color');\r\n\r\n        if (colors !== undefined) {\r\n          builder.AddFloatAttribute(dracoObject, dracoEncoder.COLOR, colors.count, colors.itemSize, colors.array);\r\n        }\r\n      }\r\n    } else {\r\n      throw new Error('DRACOExporter: Unsupported object type.');\r\n    } //Compress using draco encoder\r\n\r\n\r\n    const encodedData = new dracoEncoder.DracoInt8Array(); //Sets the desired encoding and decoding speed for the given options from 0 (slowest speed, but the best compression) to 10 (fastest, but the worst compression).\r\n\r\n    const encodeSpeed = options.encodeSpeed !== undefined ? options.encodeSpeed : 5;\r\n    const decodeSpeed = options.decodeSpeed !== undefined ? options.decodeSpeed : 5;\r\n    encoder.SetSpeedOptions(encodeSpeed, decodeSpeed); // Sets the desired encoding method for a given geometry.\r\n\r\n    if (options.encoderMethod !== undefined) {\r\n      encoder.SetEncodingMethod(options.encoderMethod);\r\n    } // Sets the quantization (number of bits used to represent) compression options for a named attribute.\r\n    // The attribute values will be quantized in a box defined by the maximum extent of the attribute values.\r\n\r\n\r\n    if (options.quantization !== undefined) {\r\n      for (let i = 0; i < 5; i++) {\r\n        if (options.quantization[i] !== undefined) {\r\n          encoder.SetAttributeQuantization(i, options.quantization[i]);\r\n        }\r\n      }\r\n    }\r\n\r\n    let length;\r\n\r\n    if (object instanceof Mesh && object.isMesh) {\r\n      length = encoder.EncodeMeshToDracoBuffer(dracoObject, encodedData);\r\n    } else {\r\n      // @ts-expect-error\r\n      length = encoder.EncodePointCloudToDracoBuffer(dracoObject, true, encodedData);\r\n    }\r\n\r\n    dracoEncoder.destroy(dracoObject);\r\n\r\n    if (length === 0) {\r\n      throw new Error('THREE.DRACOExporter: Draco encoding failed.');\r\n    } //Copy encoded data to buffer.\r\n\r\n\r\n    const outputData = new Int8Array(new ArrayBuffer(length));\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      outputData[i] = encodedData.GetValue(i);\r\n    }\r\n\r\n    dracoEncoder.destroy(encodedData);\r\n    dracoEncoder.destroy(encoder);\r\n    dracoEncoder.destroy(builder);\r\n    return outputData;\r\n  }\r\n\r\n}\r\n\r\n_defineProperty(DRACOExporter, \"MESH_EDGEBREAKER_ENCODING\", 1);\r\n\r\n_defineProperty(DRACOExporter, \"MESH_SEQUENTIAL_ENCODING\", 0);\r\n\r\n_defineProperty(DRACOExporter, \"POINT_CLOUD\", 0);\r\n\r\n_defineProperty(DRACOExporter, \"TRIANGULAR_MESH\", 1);\r\n\r\n_defineProperty(DRACOExporter, \"INVALID\", -1);\r\n\r\n_defineProperty(DRACOExporter, \"POSITION\", 0);\r\n\r\n_defineProperty(DRACOExporter, \"NORMAL\", 1);\r\n\r\n_defineProperty(DRACOExporter, \"COLOR\", 2);\r\n\r\n_defineProperty(DRACOExporter, \"TEX_COORD\", 3);\r\n\r\n_defineProperty(DRACOExporter, \"GENERIC\", 4);\r\n\r\nexport { DRACOExporter };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}