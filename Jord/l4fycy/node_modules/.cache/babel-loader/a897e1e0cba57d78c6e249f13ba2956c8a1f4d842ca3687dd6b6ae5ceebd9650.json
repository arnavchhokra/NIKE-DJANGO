{"ast":null,"code":"import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps } from './geometryUtils.js';\nimport { getBounds, getCentroidBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nfunction generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n  const useUint32 = triCount > 2 ** 16;\n  const byteCount = useUint32 ? 4 : 2;\n  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n  for (let i = 0, l = indirectBuffer.length; i < l; i++) {\n    indirectBuffer[i] = i;\n  }\n  return indirectBuffer;\n}\nfunction buildTree(bvh, options) {\n  // Compute the full bounds of the geometry at the same time as triangle bounds because\n  // we'll need it for the root bounds in the case with no groups and it should be fast here.\n  // We can't use the geometry bounding box if it's available because it may be out of date.\n  const geometry = bvh.geometry;\n  const indexArray = geometry.index ? geometry.index.array : null;\n  const maxDepth = options.maxDepth;\n  const verbose = options.verbose;\n  const maxLeafTris = options.maxLeafTris;\n  const strategy = options.strategy;\n  const onProgress = options.onProgress;\n  const totalTriangles = getTriCount(geometry);\n  const indirectBuffer = bvh._indirectBuffer;\n  let reachedMaxDepth = false;\n  const fullBounds = new Float32Array(6);\n  const cacheCentroidBoundingData = new Float32Array(6);\n  const triangleBounds = computeTriangleBounds(geometry, fullBounds);\n  const partionFunc = options.indirect ? partition_indirect : partition;\n  const roots = [];\n  const ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);\n  if (ranges.length === 1) {\n    const range = ranges[0];\n    const root = new MeshBVHNode();\n    root.boundingData = fullBounds;\n    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n    roots.push(root);\n  } else {\n    for (let range of ranges) {\n      const root = new MeshBVHNode();\n      root.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n      roots.push(root);\n    }\n  }\n  return roots;\n  function triggerProgress(trianglesProcessed) {\n    if (onProgress) {\n      onProgress(trianglesProcessed / totalTriangles);\n    }\n  }\n\n  // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n  // recording the offset and count of its triangles and writing them into the reordered geometry index.\n  function splitNode(node, offset, count) {\n    let centroidBoundingData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    let depth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    if (!reachedMaxDepth && depth >= maxDepth) {\n      reachedMaxDepth = true;\n      if (verbose) {\n        console.warn(\"MeshBVH: Max depth of \".concat(maxDepth, \" reached when generating BVH. Consider increasing maxDepth.\"));\n        console.warn(geometry);\n      }\n    }\n\n    // early out if we've met our capacity\n    if (count <= maxLeafTris || depth >= maxDepth) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n\n    // Find where to split the volume\n    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n    if (split.axis === -1) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n      return node;\n    }\n    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n\n    // create the two new child nodes\n    if (splitOffset === offset || splitOffset === offset + count) {\n      triggerProgress(offset + count);\n      node.offset = offset;\n      node.count = count;\n    } else {\n      node.splitAxis = split.axis;\n\n      // create the left child and compute its bounding box\n      const left = new MeshBVHNode();\n      const lstart = offset;\n      const lcount = splitOffset - offset;\n      node.left = left;\n      left.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n\n      // repeat for right\n      const right = new MeshBVHNode();\n      const rstart = splitOffset;\n      const rcount = count - lcount;\n      node.right = right;\n      right.boundingData = new Float32Array(6);\n      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n    }\n    return node;\n  }\n}\nexport function buildPackedTree(bvh, options) {\n  const geometry = bvh.geometry;\n  if (options.indirect) {\n    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n    if (hasGroupGaps(geometry) && !options.verbose) {\n      console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' + 'BVH may incorrectly report intersections on unrendered portions of the geometry.');\n    }\n  }\n  if (!bvh._indirectBuffer) {\n    ensureIndex(geometry, options);\n  }\n\n  // boundingData  \t\t\t\t: 6 float32\n  // right / offset \t\t\t\t: 1 uint32\n  // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n  const roots = buildTree(bvh, options);\n  let float32Array;\n  let uint32Array;\n  let uint16Array;\n  const packedRoots = [];\n  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n  for (let i = 0; i < roots.length; i++) {\n    const root = roots[i];\n    let nodeCount = countNodes(root);\n    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);\n    float32Array = new Float32Array(buffer);\n    uint32Array = new Uint32Array(buffer);\n    uint16Array = new Uint16Array(buffer);\n    populateBuffer(0, root);\n    packedRoots.push(buffer);\n  }\n  bvh._roots = packedRoots;\n  return;\n  function countNodes(node) {\n    if (node.count) {\n      return 1;\n    } else {\n      return 1 + countNodes(node.left) + countNodes(node.right);\n    }\n  }\n  function populateBuffer(byteOffset, node) {\n    const stride4Offset = byteOffset / 4;\n    const stride2Offset = byteOffset / 2;\n    const isLeaf = !!node.count;\n    const boundingData = node.boundingData;\n    for (let i = 0; i < 6; i++) {\n      float32Array[stride4Offset + i] = boundingData[i];\n    }\n    if (isLeaf) {\n      const offset = node.offset;\n      const count = node.count;\n      uint32Array[stride4Offset + 6] = offset;\n      uint16Array[stride2Offset + 14] = count;\n      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;\n      return byteOffset + BYTES_PER_NODE;\n    } else {\n      const left = node.left;\n      const right = node.right;\n      const splitAxis = node.splitAxis;\n      let nextUnusedPointer;\n      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);\n      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n        throw new Error('MeshBVH: Cannot store child pointer greater than 32 bits.');\n      }\n      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n      uint32Array[stride4Offset + 7] = splitAxis;\n      return nextUnusedPointer;\n    }\n  }\n}","map":{"version":3,"names":["ensureIndex","getFullGeometryRange","getRootIndexRanges","getTriCount","hasGroupGaps","getBounds","getCentroidBounds","computeTriangleBounds","getOptimalSplit","MeshBVHNode","BYTES_PER_NODE","IS_LEAFNODE_FLAG","partition","partition_indirect","generateIndirectBuffer","geometry","useSharedArrayBuffer","triCount","index","count","attributes","position","useUint32","byteCount","buffer","SharedArrayBuffer","ArrayBuffer","indirectBuffer","Uint32Array","Uint16Array","i","l","length","buildTree","bvh","options","indexArray","array","maxDepth","verbose","maxLeafTris","strategy","onProgress","totalTriangles","_indirectBuffer","reachedMaxDepth","fullBounds","Float32Array","cacheCentroidBoundingData","triangleBounds","partionFunc","indirect","roots","ranges","range","root","boundingData","offset","splitNode","push","triggerProgress","trianglesProcessed","node","centroidBoundingData","arguments","undefined","depth","console","warn","concat","split","axis","splitOffset","splitAxis","left","lstart","lcount","right","rstart","rcount","buildPackedTree","float32Array","uint32Array","uint16Array","packedRoots","BufferConstructor","nodeCount","countNodes","populateBuffer","_roots","byteOffset","stride4Offset","stride2Offset","isLeaf","nextUnusedPointer","Math","pow","Error"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/build/buildTree.js"],"sourcesContent":["import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\r\nimport { getBounds, getCentroidBounds, computeTriangleBounds } from './computeBoundsUtils.js';\r\nimport { getOptimalSplit } from './splitUtils.js';\r\nimport { MeshBVHNode } from '../MeshBVHNode.js';\r\nimport { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\r\n\r\nimport { partition } from './sortUtils.generated.js';\r\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\r\n\r\nfunction generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\r\n\r\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\tconst useUint32 = triCount > 2 ** 16;\r\n\tconst byteCount = useUint32 ? 4 : 2;\r\n\r\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\r\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\r\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\r\n\r\n\t\tindirectBuffer[ i ] = i;\r\n\r\n\t}\r\n\r\n\treturn indirectBuffer;\r\n\r\n}\r\n\r\nfunction buildTree( bvh, options ) {\r\n\r\n\t// Compute the full bounds of the geometry at the same time as triangle bounds because\r\n\t// we'll need it for the root bounds in the case with no groups and it should be fast here.\r\n\t// We can't use the geometry bounding box if it's available because it may be out of date.\r\n\tconst geometry = bvh.geometry;\r\n\tconst indexArray = geometry.index ? geometry.index.array : null;\r\n\tconst maxDepth = options.maxDepth;\r\n\tconst verbose = options.verbose;\r\n\tconst maxLeafTris = options.maxLeafTris;\r\n\tconst strategy = options.strategy;\r\n\tconst onProgress = options.onProgress;\r\n\tconst totalTriangles = getTriCount( geometry );\r\n\tconst indirectBuffer = bvh._indirectBuffer;\r\n\tlet reachedMaxDepth = false;\r\n\r\n\tconst fullBounds = new Float32Array( 6 );\r\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\r\n\tconst triangleBounds = computeTriangleBounds( geometry, fullBounds );\r\n\tconst partionFunc = options.indirect ? partition_indirect : partition;\r\n\r\n\tconst roots = [];\r\n\tconst ranges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\r\n\r\n\tif ( ranges.length === 1 ) {\r\n\r\n\t\tconst range = ranges[ 0 ];\r\n\t\tconst root = new MeshBVHNode();\r\n\t\troot.boundingData = fullBounds;\r\n\t\tgetCentroidBounds( triangleBounds, range.offset, range.count, cacheCentroidBoundingData );\r\n\r\n\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\troots.push( root );\r\n\r\n\t} else {\r\n\r\n\t\tfor ( let range of ranges ) {\r\n\r\n\t\t\tconst root = new MeshBVHNode();\r\n\t\t\troot.boundingData = new Float32Array( 6 );\r\n\t\t\tgetBounds( triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData );\r\n\r\n\t\t\tsplitNode( root, range.offset, range.count, cacheCentroidBoundingData );\r\n\t\t\troots.push( root );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn roots;\r\n\r\n\tfunction triggerProgress( trianglesProcessed ) {\r\n\r\n\t\tif ( onProgress ) {\r\n\r\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\r\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\r\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\r\n\r\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\r\n\r\n\t\t\treachedMaxDepth = true;\r\n\t\t\tif ( verbose ) {\r\n\r\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\r\n\t\t\t\tconsole.warn( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// early out if we've met our capacity\r\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\t// Find where to split the volume\r\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\r\n\t\tif ( split.axis === - 1 ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\t\t\treturn node;\r\n\r\n\t\t}\r\n\r\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\r\n\r\n\t\t// create the two new child nodes\r\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\r\n\r\n\t\t\ttriggerProgress( offset + count );\r\n\t\t\tnode.offset = offset;\r\n\t\t\tnode.count = count;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnode.splitAxis = split.axis;\r\n\r\n\t\t\t// create the left child and compute its bounding box\r\n\t\t\tconst left = new MeshBVHNode();\r\n\t\t\tconst lstart = offset;\r\n\t\t\tconst lcount = splitOffset - offset;\r\n\t\t\tnode.left = left;\r\n\t\t\tleft.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t\t// repeat for right\r\n\t\t\tconst right = new MeshBVHNode();\r\n\t\t\tconst rstart = splitOffset;\r\n\t\t\tconst rcount = count - lcount;\r\n\t\t\tnode.right = right;\r\n\t\t\tright.boundingData = new Float32Array( 6 );\r\n\r\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\r\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\r\n\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function buildPackedTree( bvh, options ) {\r\n\r\n\tconst geometry = bvh.geometry;\r\n\tif ( options.indirect ) {\r\n\r\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\r\n\r\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\r\n\r\n\t\t\tconsole.warn(\r\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\r\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( ! bvh._indirectBuffer ) {\r\n\r\n\t\tensureIndex( geometry, options );\r\n\r\n\t}\r\n\r\n\t// boundingData  \t\t\t\t: 6 float32\r\n\t// right / offset \t\t\t\t: 1 uint32\r\n\t// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\r\n\tconst roots = buildTree( bvh, options );\r\n\r\n\tlet float32Array;\r\n\tlet uint32Array;\r\n\tlet uint16Array;\r\n\tconst packedRoots = [];\r\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\tfor ( let i = 0; i < roots.length; i ++ ) {\r\n\r\n\t\tconst root = roots[ i ];\r\n\t\tlet nodeCount = countNodes( root );\r\n\r\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\r\n\t\tfloat32Array = new Float32Array( buffer );\r\n\t\tuint32Array = new Uint32Array( buffer );\r\n\t\tuint16Array = new Uint16Array( buffer );\r\n\t\tpopulateBuffer( 0, root );\r\n\t\tpackedRoots.push( buffer );\r\n\r\n\t}\r\n\r\n\tbvh._roots = packedRoots;\r\n\treturn;\r\n\r\n\tfunction countNodes( node ) {\r\n\r\n\t\tif ( node.count ) {\r\n\r\n\t\t\treturn 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction populateBuffer( byteOffset, node ) {\r\n\r\n\t\tconst stride4Offset = byteOffset / 4;\r\n\t\tconst stride2Offset = byteOffset / 2;\r\n\t\tconst isLeaf = ! ! node.count;\r\n\t\tconst boundingData = node.boundingData;\r\n\t\tfor ( let i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = node.offset;\r\n\t\t\tconst count = node.count;\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\r\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\r\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\r\n\t\t\treturn byteOffset + BYTES_PER_NODE;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = node.left;\r\n\t\t\tconst right = node.right;\r\n\t\t\tconst splitAxis = node.splitAxis;\r\n\r\n\t\t\tlet nextUnusedPointer;\r\n\t\t\tnextUnusedPointer = populateBuffer( byteOffset + BYTES_PER_NODE, left );\r\n\r\n\t\t\tif ( ( nextUnusedPointer / 4 ) > Math.pow( 2, 32 ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\r\n\t\t\tnextUnusedPointer = populateBuffer( nextUnusedPointer, right );\r\n\r\n\t\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\r\n\t\t\treturn nextUnusedPointer;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}