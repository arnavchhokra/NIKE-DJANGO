{"ast":null,"code":"import { mix } from './mix.mjs';\nimport { invariant } from './errors.mjs';\nimport { hslaToRgba } from './hsla-to-rgba.mjs';\nimport { hex } from '../value/types/color/hex.mjs';\nimport { rgba } from '../value/types/color/rgba.mjs';\nimport { hsla } from '../value/types/color/hsla.mjs';\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = v => colorTypes.find(type => type.test(v));\nfunction asRGBA(color) {\n  const type = getColorType(color);\n  invariant(Boolean(type), \"'\".concat(color, \"' is not an animatable color. Use the equivalent color code instead.\"));\n  let model = type.parse(color);\n  if (type === hsla) {\n    // TODO Remove this cast - needed since Framer Motion's stricter typing\n    model = hslaToRgba(model);\n  }\n  return model;\n}\nconst mixColor = (from, to) => {\n  const fromRGBA = asRGBA(from);\n  const toRGBA = asRGBA(to);\n  const blended = {\n    ...fromRGBA\n  };\n  return v => {\n    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);\n    return rgba.transform(blended);\n  };\n};\nexport { mixColor, mixLinearColor };","map":{"version":3,"names":["mix","invariant","hslaToRgba","hex","rgba","hsla","mixLinearColor","from","to","v","fromExpo","Math","sqrt","max","colorTypes","getColorType","find","type","test","asRGBA","color","Boolean","concat","model","parse","mixColor","fromRGBA","toRGBA","blended","red","green","blue","alpha","transform"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/framer-motion/dist/es/utils/mix-color.mjs"],"sourcesContent":["import { mix } from './mix.mjs';\r\nimport { invariant } from './errors.mjs';\r\nimport { hslaToRgba } from './hsla-to-rgba.mjs';\r\nimport { hex } from '../value/types/color/hex.mjs';\r\nimport { rgba } from '../value/types/color/rgba.mjs';\r\nimport { hsla } from '../value/types/color/hsla.mjs';\r\n\r\n// Linear color space blending\r\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\r\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\r\nconst mixLinearColor = (from, to, v) => {\r\n    const fromExpo = from * from;\r\n    return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));\r\n};\r\nconst colorTypes = [hex, rgba, hsla];\r\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\r\nfunction asRGBA(color) {\r\n    const type = getColorType(color);\r\n    invariant(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\r\n    let model = type.parse(color);\r\n    if (type === hsla) {\r\n        // TODO Remove this cast - needed since Framer Motion's stricter typing\r\n        model = hslaToRgba(model);\r\n    }\r\n    return model;\r\n}\r\nconst mixColor = (from, to) => {\r\n    const fromRGBA = asRGBA(from);\r\n    const toRGBA = asRGBA(to);\r\n    const blended = { ...fromRGBA };\r\n    return (v) => {\r\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\r\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\r\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\r\n        blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);\r\n        return rgba.transform(blended);\r\n    };\r\n};\r\n\r\nexport { mixColor, mixLinearColor };\r\n"],"mappings":"AAAA,SAASA,GAAG,QAAQ,WAAW;AAC/B,SAASC,SAAS,QAAQ,cAAc;AACxC,SAASC,UAAU,QAAQ,oBAAoB;AAC/C,SAASC,GAAG,QAAQ,8BAA8B;AAClD,SAASC,IAAI,QAAQ,+BAA+B;AACpD,SAASC,IAAI,QAAQ,+BAA+B;;AAEpD;AACA;AACA;AACA,MAAMC,cAAc,GAAGA,CAACC,IAAI,EAAEC,EAAE,EAAEC,CAAC,KAAK;EACpC,MAAMC,QAAQ,GAAGH,IAAI,GAAGA,IAAI;EAC5B,OAAOI,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEJ,CAAC,IAAID,EAAE,GAAGA,EAAE,GAAGE,QAAQ,CAAC,GAAGA,QAAQ,CAAC,CAAC;AACtE,CAAC;AACD,MAAMI,UAAU,GAAG,CAACX,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;AACpC,MAAMU,YAAY,GAAIN,CAAC,IAAKK,UAAU,CAACE,IAAI,CAAEC,IAAI,IAAKA,IAAI,CAACC,IAAI,CAACT,CAAC,CAAC,CAAC;AACnE,SAASU,MAAMA,CAACC,KAAK,EAAE;EACnB,MAAMH,IAAI,GAAGF,YAAY,CAACK,KAAK,CAAC;EAChCnB,SAAS,CAACoB,OAAO,CAACJ,IAAI,CAAC,MAAAK,MAAA,CAAMF,KAAK,yEAAsE,CAAC;EACzG,IAAIG,KAAK,GAAGN,IAAI,CAACO,KAAK,CAACJ,KAAK,CAAC;EAC7B,IAAIH,IAAI,KAAKZ,IAAI,EAAE;IACf;IACAkB,KAAK,GAAGrB,UAAU,CAACqB,KAAK,CAAC;EAC7B;EACA,OAAOA,KAAK;AAChB;AACA,MAAME,QAAQ,GAAGA,CAAClB,IAAI,EAAEC,EAAE,KAAK;EAC3B,MAAMkB,QAAQ,GAAGP,MAAM,CAACZ,IAAI,CAAC;EAC7B,MAAMoB,MAAM,GAAGR,MAAM,CAACX,EAAE,CAAC;EACzB,MAAMoB,OAAO,GAAG;IAAE,GAAGF;EAAS,CAAC;EAC/B,OAAQjB,CAAC,IAAK;IACVmB,OAAO,CAACC,GAAG,GAAGvB,cAAc,CAACoB,QAAQ,CAACG,GAAG,EAAEF,MAAM,CAACE,GAAG,EAAEpB,CAAC,CAAC;IACzDmB,OAAO,CAACE,KAAK,GAAGxB,cAAc,CAACoB,QAAQ,CAACI,KAAK,EAAEH,MAAM,CAACG,KAAK,EAAErB,CAAC,CAAC;IAC/DmB,OAAO,CAACG,IAAI,GAAGzB,cAAc,CAACoB,QAAQ,CAACK,IAAI,EAAEJ,MAAM,CAACI,IAAI,EAAEtB,CAAC,CAAC;IAC5DmB,OAAO,CAACI,KAAK,GAAGhC,GAAG,CAAC0B,QAAQ,CAACM,KAAK,EAAEL,MAAM,CAACK,KAAK,EAAEvB,CAAC,CAAC;IACpD,OAAOL,IAAI,CAAC6B,SAAS,CAACL,OAAO,CAAC;EAClC,CAAC;AACL,CAAC;AAED,SAASH,QAAQ,EAAEnB,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}