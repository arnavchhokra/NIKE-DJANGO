{"ast":null,"code":"import { ShaderChunk } from 'three';\nvar Shader = {\n  lights_fragment_begin:\n  /* glsl */\n  \"\\nGeometricContext geometry;\\n\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n\\n#ifdef CLEARCOAT\\n\\n\\tgeometry.clearcoatNormal = clearcoatNormal;\\n\\n#endif\\n\\nIncidentLight directLight;\\n\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\n\\tPointLight pointLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\\tPointLightShadow pointLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\tpointLight = pointLights[ i ];\\n\\n\\t\\tgetPointLightInfo( pointLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\\t\\tpointLightShadow = pointLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\\n\\tSpotLight spotLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\\tSpotLightShadow spotLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\\n\\t\\tspotLight = spotLights[ i ];\\n\\n\\t\\tgetSpotLightInfo( spotLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\\t\\tspotLightShadow = spotLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\\n\\tvec2 cascade;\\n\\tfloat cascadeCenter;\\n\\tfloat closestEdge;\\n\\tfloat margin;\\n\\tfloat csmx;\\n\\tfloat csmy;\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\\n\\n\\t\\t// NOTE: Depth gets larger away from the camera.\\n\\t\\t// cascade.x is closer, cascade.y is further\\n\\t\\tcascade = CSM_cascades[ i ];\\n\\t\\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\\n\\t\\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\\n\\t\\tmargin = 0.25 * pow( closestEdge, 2.0 );\\n\\t\\tcsmx = cascade.x - margin / 2.0;\\n\\t\\tcsmy = cascade.y + margin / 2.0;\\n\\t\\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\\n\\n\\t\\t\\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\\n\\t\\t\\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\\n\\t\\t\\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\\n\\n\\t\\t\\t\\tvec3 prevColor = directLight.color;\\n\\t\\t\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\t\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t\\t\\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\\n\\t\\t\\t\\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tReflectedLight prevLight = reflectedLight;\\n\\t\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t\\t\\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\\n\\t\\t\\tfloat blendRatio = shouldBlend ? ratio : 1.0;\\n\\n\\t\\t\\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\\n\\t\\t\\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\\n\\t\\t\\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\\n\\t\\t\\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\\n\\n\\t\\t}\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\t#else\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\t\\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\n\\t\\t#endif\\n\\n\\t\\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\\n\\n\\tDirectionalLight directionalLight;\\n\\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\\tDirectionalLightShadow directionalLightShadow;\\n\\t#endif\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\tdirectionalLight = directionalLights[ i ];\\n\\n\\t\\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\\n\\n\\t\\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\\t\\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\\t\\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\\t\\t#endif\\n\\n\\t\\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\\n\\tRectAreaLight rectAreaLight;\\n\\n\\t#pragma unroll_loop_start\\n\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\\n\\t\\trectAreaLight = rectAreaLights[ i ];\\n\\t\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\\n\\t}\\n\\t#pragma unroll_loop_end\\n\\n#endif\\n\\n#if defined( RE_IndirectDiffuse )\\n\\n\\tvec3 iblIrradiance = vec3( 0.0 );\\n\\n\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\\n\\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\\n\\n\\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\\n\\t\\t#pragma unroll_loop_start\\n\\t\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\\n\\t\\t\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\\n\\n\\t\\t}\\n\\t\\t#pragma unroll_loop_end\\n\\n\\t#endif\\n\\n#endif\\n\\n#if defined( RE_IndirectSpecular )\\n\\n\\tvec3 radiance = vec3( 0.0 );\\n\\tvec3 clearcoatRadiance = vec3( 0.0 );\\n\\n#endif\\n\",\n  lights_pars_begin:\n  /* glsl */\n  \"\\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\\nuniform vec2 CSM_cascades[CSM_CASCADES];\\nuniform float cameraNear;\\nuniform float shadowFar;\\n#endif\\n\\t\" + ShaderChunk.lights_pars_begin\n};\nexport default Shader;","map":{"version":3,"names":["ShaderChunk","Shader","lights_fragment_begin","lights_pars_begin"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/csm/Shader.js"],"sourcesContent":["import { ShaderChunk } from 'three';\r\n\r\nvar Shader = {\r\n  lights_fragment_begin:\r\n  /* glsl */\r\n  `\r\nGeometricContext geometry;\r\n\r\ngeometry.position = - vViewPosition;\r\ngeometry.normal = normal;\r\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\r\n\r\n#ifdef CLEARCOAT\r\n\r\n\tgeometry.clearcoatNormal = clearcoatNormal;\r\n\r\n#endif\r\n\r\nIncidentLight directLight;\r\n\r\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tPointLight pointLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\r\n\tPointLightShadow pointLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\r\n\t\tpointLight = pointLights[ i ];\r\n\r\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\r\n\t\tpointLightShadow = pointLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\r\n\r\n\tSpotLight spotLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\r\n\tSpotLightShadow spotLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\r\n\t\tspotLight = spotLights[ i ];\r\n\r\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\r\n\t\tspotLightShadow = spotLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\r\n\tvec2 cascade;\r\n\tfloat cascadeCenter;\r\n\tfloat closestEdge;\r\n\tfloat margin;\r\n\tfloat csmx;\r\n\tfloat csmy;\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n\t\t// NOTE: Depth gets larger away from the camera.\r\n\t\t// cascade.x is closer, cascade.y is further\r\n\t\tcascade = CSM_cascades[ i ];\r\n\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\r\n\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\r\n\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\r\n\t\tcsmx = cascade.x - margin / 2.0;\r\n\t\tcsmy = cascade.y + margin / 2.0;\r\n\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\r\n\r\n\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\r\n\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\r\n\t\t\tif( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\r\n\r\n\t\t\t\tvec3 prevColor = directLight.color;\r\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\t\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\r\n\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tReflectedLight prevLight = reflectedLight;\r\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\r\n\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\r\n\r\n\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\r\n\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\r\n\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\r\n\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\t#else\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\r\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\r\n\t\t#endif\r\n\r\n\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n\r\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\r\n\r\n\tDirectionalLight directionalLight;\r\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\r\n\tDirectionalLightShadow directionalLightShadow;\r\n\t#endif\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\r\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\r\n\r\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\r\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\r\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\t\t#endif\r\n\r\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\r\n\r\n\tRectAreaLight rectAreaLight;\r\n\r\n\t#pragma unroll_loop_start\r\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\r\n\r\n\t\trectAreaLight = rectAreaLights[ i ];\r\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\r\n\r\n\t}\r\n\t#pragma unroll_loop_end\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectDiffuse )\r\n\r\n\tvec3 iblIrradiance = vec3( 0.0 );\r\n\r\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\r\n\r\n\t#if ( NUM_HEMI_LIGHTS > 0 )\r\n\r\n\t\t#pragma unroll_loop_start\r\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\r\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\r\n\r\n\t\t}\r\n\t\t#pragma unroll_loop_end\r\n\r\n\t#endif\r\n\r\n#endif\r\n\r\n#if defined( RE_IndirectSpecular )\r\n\r\n\tvec3 radiance = vec3( 0.0 );\r\n\tvec3 clearcoatRadiance = vec3( 0.0 );\r\n\r\n#endif\r\n`,\r\n  lights_pars_begin:\r\n  /* glsl */\r\n  `\r\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\r\nuniform vec2 CSM_cascades[CSM_CASCADES];\r\nuniform float cameraNear;\r\nuniform float shadowFar;\r\n#endif\r\n\t` + ShaderChunk.lights_pars_begin\r\n};\r\n\r\nexport default Shader;\r\n"],"mappings":"AAAA,SAASA,WAAT,QAA4B,OAA5B;AAEA,IAAIC,MAAM,GAAG;EACXC,qBAAqB;EACrB;EADqB,6xPADV;EAiOXC,iBAAiB;EACjB;EACA,mKAMGH,WAAW,CAACG;AAzOJ,CAAb;AA4OA,eAAeF,MAAf"},"metadata":{},"sourceType":"module"}