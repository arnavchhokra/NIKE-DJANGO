{"ast":null,"code":"import _classCallCheck from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\nvar _taskCache = new WeakMap();\n\nvar DRACOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(DRACOLoader, _Loader);\n\n  var _super = _createSuper(DRACOLoader);\n\n  function DRACOLoader(manager) {\n    var _this;\n\n    _classCallCheck(this, DRACOLoader);\n\n    _this = _super.call(this, manager);\n    _this.decoderPath = '';\n    _this.decoderConfig = {};\n    _this.decoderBinary = null;\n    _this.decoderPending = null;\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = '';\n    _this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    _this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n    return _this;\n  }\n\n  _createClass(DRACOLoader, [{\n    key: \"setDecoderPath\",\n    value: function setDecoderPath(path) {\n      this.decoderPath = path;\n      return this;\n    }\n  }, {\n    key: \"setDecoderConfig\",\n    value: function setDecoderConfig(config) {\n      this.decoderConfig = config;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        var taskConfig = {\n          attributeIDs: _this2.defaultAttributeIDs,\n          attributeTypes: _this2.defaultAttributeTypes,\n          useUniqueIDs: false\n        };\n\n        _this2.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n      }, onProgress, onError);\n    }\n    /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n  }, {\n    key: \"decodeDracoFile\",\n    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n      var taskConfig = {\n        attributeIDs: attributeIDs || this.defaultAttributeIDs,\n        attributeTypes: attributeTypes || this.defaultAttributeTypes,\n        useUniqueIDs: !!attributeIDs\n      };\n      this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n  }, {\n    key: \"decodeGeometry\",\n    value: function decodeGeometry(buffer, taskConfig) {\n      var _this3 = this;\n\n      // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n      // references (rather than names) to typed array constructors. These must be\n      // serialized before sending them to the worker.\n      for (var attribute in taskConfig.attributeTypes) {\n        var type = taskConfig.attributeTypes[attribute];\n\n        if (type.BYTES_PER_ELEMENT !== undefined) {\n          taskConfig.attributeTypes[attribute] = type.name;\n        }\n      } //\n\n\n      var taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n\n      if (_taskCache.has(buffer)) {\n        var cachedTask = _taskCache.get(buffer);\n\n        if (cachedTask.key === taskKey) {\n          return cachedTask.promise;\n        } else if (buffer.byteLength === 0) {\n          // Technically, it would be possible to wait for the previous task to complete,\n          // transfer the buffer back, and decode again with the second configuration. That\n          // is complex, and I don't know of any reason to decode a Draco buffer twice in\n          // different ways, so this is left unimplemented.\n          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n        }\n      } //\n\n\n      var worker;\n      var taskID = this.workerNextTaskID++;\n      var taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n      // when the task completes.\n\n      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\n        worker = _worker;\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: 'decode',\n            id: taskID,\n            taskConfig: taskConfig,\n            buffer: buffer\n          }, [buffer]); // this.debug();\n        });\n      }).then(function (message) {\n        return _this3._createGeometry(message.geometry);\n      }); // Remove task from the task list.\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n      geometryPending.catch(function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          _this3._releaseTask(worker, taskID); // this.debug();\n\n        }\n      }); // Cache the task result.\n\n      _taskCache.set(buffer, {\n        key: taskKey,\n        promise: geometryPending\n      });\n\n      return geometryPending;\n    }\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry(geometryData) {\n      var geometry = new BufferGeometry();\n\n      if (geometryData.index) {\n        geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n      }\n\n      for (var i = 0; i < geometryData.attributes.length; i++) {\n        var attribute = geometryData.attributes[i];\n        var name = attribute.name;\n        var array = attribute.array;\n        var itemSize = attribute.itemSize;\n        geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n      }\n\n      return geometry;\n    }\n  }, {\n    key: \"_loadLibrary\",\n    value: function _loadLibrary(url, responseType) {\n      var loader = new FileLoader(this.manager);\n      loader.setPath(this.decoderPath);\n      loader.setResponseType(responseType);\n      loader.setWithCredentials(this.withCredentials);\n      return new Promise(function (resolve, reject) {\n        loader.load(url, resolve, undefined, reject);\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      this._initDecoder();\n\n      return this;\n    }\n  }, {\n    key: \"_initDecoder\",\n    value: function _initDecoder() {\n      var _this4 = this;\n\n      if (this.decoderPending) return this.decoderPending;\n      var useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n      var librariesPending = [];\n\n      if (useJS) {\n        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n      } else {\n        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n      }\n\n      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\n        var jsContent = libraries[0];\n\n        if (!useJS) {\n          _this4.decoderConfig.wasmBinary = libraries[1];\n        }\n\n        var fn = DRACOWorker.toString();\n        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n      return this.decoderPending;\n    }\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(taskID, taskCost) {\n      var _this5 = this;\n\n      return this._initDecoder().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var _worker2 = new Worker(_this5.workerSourceURL);\n\n          _worker2._callbacks = {};\n          _worker2._taskCosts = {};\n          _worker2._taskLoad = 0;\n\n          _worker2.postMessage({\n            type: 'init',\n            decoderConfig: _this5.decoderConfig\n          });\n\n          _worker2.onmessage = function (e) {\n            var message = e.data;\n\n            switch (message.type) {\n              case 'decode':\n                _worker2._callbacks[message.id].resolve(message);\n\n                break;\n\n              case 'error':\n                _worker2._callbacks[message.id].reject(message);\n\n                break;\n\n              default:\n                console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n\n          _this5.workerPool.push(_worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskCosts[taskID] = taskCost;\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"_releaseTask\",\n    value: function _releaseTask(worker, taskID) {\n      worker._taskLoad -= worker._taskCosts[taskID];\n      delete worker._callbacks[taskID];\n      delete worker._taskCosts[taskID];\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      console.log('Task load: ', this.workerPool.map(function (worker) {\n        return worker._taskLoad;\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; ++i) {\n        this.workerPool[i].terminate();\n      }\n\n      this.workerPool.length = 0;\n      return this;\n    }\n  }]);\n\n  return DRACOLoader;\n}(Loader);\n/* WEB WORKER */\n\n\nfunction DRACOWorker() {\n  var decoderConfig;\n  var decoderPending;\n\n  onmessage = function onmessage(e) {\n    var message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(function (module) {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          var decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            var geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            var buffers = geometry.attributes.map(function (attr) {\n              return attr.array.buffer;\n            });\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry: geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    var geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (var attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute = void 0;\n      var attributeID = void 0; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n\n    var ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nexport { DRACOLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","_taskCache","WeakMap","DRACOLoader","manager","decoderPath","decoderConfig","decoderBinary","decoderPending","workerLimit","workerPool","workerNextTaskID","workerSourceURL","defaultAttributeIDs","position","normal","color","uv","defaultAttributeTypes","path","config","url","onLoad","onProgress","onError","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","buffer","taskConfig","attributeIDs","attributeTypes","useUniqueIDs","decodeGeometry","then","catch","callback","attribute","type","BYTES_PER_ELEMENT","undefined","name","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","worker","taskID","taskCost","geometryPending","_getWorker","_worker","Promise","resolve","reject","_callbacks","postMessage","id","message","_createGeometry","geometry","_releaseTask","set","geometryData","index","setIndex","array","i","attributes","length","itemSize","setAttribute","responseType","_initDecoder","useJS","WebAssembly","librariesPending","push","_loadLibrary","all","libraries","jsContent","wasmBinary","fn","DRACOWorker","toString","body","substring","indexOf","lastIndexOf","join","URL","createObjectURL","Blob","Worker","_taskCosts","_taskLoad","onmessage","e","data","console","error","sort","a","b","log","map","terminate","onModuleLoaded","draco","DracoDecoderModule","module","decoder","Decoder","decoderBuffer","DecoderBuffer","Init","Int8Array","buffers","attr","self","destroy","dracoGeometry","decodingStatus","geometryType","GetEncodedGeometryType","TRIANGULAR_MESH","Mesh","DecodeBufferToMesh","POINT_CLOUD","PointCloud","DecodeBufferToPointCloud","ok","ptr","error_msg","attributeName","attributeType","attributeID","GetAttributeByUniqueId","GetAttributeId","GetAttribute","decodeAttribute","decodeIndex","numFaces","num_faces","numIndices","_malloc","GetTrianglesUInt32Array","Uint32Array","HEAPF32","slice","_free","numComponents","num_components","numPoints","num_points","numValues","dataType","getDracoDataType","GetAttributeDataArrayForAllPoints","Float32Array","DT_FLOAT32","DT_INT8","Int16Array","DT_INT16","Int32Array","DT_INT32","Uint8Array","DT_UINT8","Uint16Array","DT_UINT16","DT_UINT32"],"sources":["C:/Users/Arnav/Downloads/l4fycy/node_modules/three-stdlib/loaders/DRACOLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n\nconst _taskCache = new WeakMap();\n\nclass DRACOLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.decoderPath = '';\n    this.decoderConfig = {};\n    this.decoderBinary = null;\n    this.decoderPending = null;\n    this.workerLimit = 4;\n    this.workerPool = [];\n    this.workerNextTaskID = 1;\n    this.workerSourceURL = '';\n    this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n  }\n\n  setDecoderPath(path) {\n    this.decoderPath = path;\n    return this;\n  }\n\n  setDecoderConfig(config) {\n    this.decoderConfig = config;\n    return this;\n  }\n\n  setWorkerLimit(workerLimit) {\n    this.workerLimit = workerLimit;\n    return this;\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, buffer => {\n      const taskConfig = {\n        attributeIDs: this.defaultAttributeIDs,\n        attributeTypes: this.defaultAttributeTypes,\n        useUniqueIDs: false\n      };\n      this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError);\n    }, onProgress, onError);\n  }\n  /** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */\n\n\n  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {\n    const taskConfig = {\n      attributeIDs: attributeIDs || this.defaultAttributeIDs,\n      attributeTypes: attributeTypes || this.defaultAttributeTypes,\n      useUniqueIDs: !!attributeIDs\n    };\n    this.decodeGeometry(buffer, taskConfig).then(callback);\n  }\n\n  decodeGeometry(buffer, taskConfig) {\n    // TODO: For backward-compatibility, support 'attributeTypes' objects containing\n    // references (rather than names) to typed array constructors. These must be\n    // serialized before sending them to the worker.\n    for (const attribute in taskConfig.attributeTypes) {\n      const type = taskConfig.attributeTypes[attribute];\n\n      if (type.BYTES_PER_ELEMENT !== undefined) {\n        taskConfig.attributeTypes[attribute] = type.name;\n      }\n    } //\n\n\n    const taskKey = JSON.stringify(taskConfig); // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n    // again from this thread.\n\n    if (_taskCache.has(buffer)) {\n      const cachedTask = _taskCache.get(buffer);\n\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n      }\n    } //\n\n\n    let worker;\n    const taskID = this.workerNextTaskID++;\n    const taskCost = buffer.byteLength; // Obtain a worker and assign a task, and construct a geometry instance\n    // when the task completes.\n\n    const geometryPending = this._getWorker(taskID, taskCost).then(_worker => {\n      worker = _worker;\n      return new Promise((resolve, reject) => {\n        worker._callbacks[taskID] = {\n          resolve,\n          reject\n        };\n        worker.postMessage({\n          type: 'decode',\n          id: taskID,\n          taskConfig,\n          buffer\n        }, [buffer]); // this.debug();\n      });\n    }).then(message => this._createGeometry(message.geometry)); // Remove task from the task list.\n    // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n\n\n    geometryPending.catch(() => true).then(() => {\n      if (worker && taskID) {\n        this._releaseTask(worker, taskID); // this.debug();\n\n      }\n    }); // Cache the task result.\n\n    _taskCache.set(buffer, {\n      key: taskKey,\n      promise: geometryPending\n    });\n\n    return geometryPending;\n  }\n\n  _createGeometry(geometryData) {\n    const geometry = new BufferGeometry();\n\n    if (geometryData.index) {\n      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1));\n    }\n\n    for (let i = 0; i < geometryData.attributes.length; i++) {\n      const attribute = geometryData.attributes[i];\n      const name = attribute.name;\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      geometry.setAttribute(name, new BufferAttribute(array, itemSize));\n    }\n\n    return geometry;\n  }\n\n  _loadLibrary(url, responseType) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.decoderPath);\n    loader.setResponseType(responseType);\n    loader.setWithCredentials(this.withCredentials);\n    return new Promise((resolve, reject) => {\n      loader.load(url, resolve, undefined, reject);\n    });\n  }\n\n  preload() {\n    this._initDecoder();\n\n    return this;\n  }\n\n  _initDecoder() {\n    if (this.decoderPending) return this.decoderPending;\n    const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';\n    const librariesPending = [];\n\n    if (useJS) {\n      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n    } else {\n      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n      librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n    }\n\n    this.decoderPending = Promise.all(librariesPending).then(libraries => {\n      const jsContent = libraries[0];\n\n      if (!useJS) {\n        this.decoderConfig.wasmBinary = libraries[1];\n      }\n\n      const fn = DRACOWorker.toString();\n      const body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n      this.workerSourceURL = URL.createObjectURL(new Blob([body]));\n    });\n    return this.decoderPending;\n  }\n\n  _getWorker(taskID, taskCost) {\n    return this._initDecoder().then(() => {\n      if (this.workerPool.length < this.workerLimit) {\n        const worker = new Worker(this.workerSourceURL);\n        worker._callbacks = {};\n        worker._taskCosts = {};\n        worker._taskLoad = 0;\n        worker.postMessage({\n          type: 'init',\n          decoderConfig: this.decoderConfig\n        });\n\n        worker.onmessage = function (e) {\n          const message = e.data;\n\n          switch (message.type) {\n            case 'decode':\n              worker._callbacks[message.id].resolve(message);\n\n              break;\n\n            case 'error':\n              worker._callbacks[message.id].reject(message);\n\n              break;\n\n            default:\n              console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n          }\n        };\n\n        this.workerPool.push(worker);\n      } else {\n        this.workerPool.sort(function (a, b) {\n          return a._taskLoad > b._taskLoad ? -1 : 1;\n        });\n      }\n\n      const worker = this.workerPool[this.workerPool.length - 1];\n      worker._taskCosts[taskID] = taskCost;\n      worker._taskLoad += taskCost;\n      return worker;\n    });\n  }\n\n  _releaseTask(worker, taskID) {\n    worker._taskLoad -= worker._taskCosts[taskID];\n    delete worker._callbacks[taskID];\n    delete worker._taskCosts[taskID];\n  }\n\n  debug() {\n    console.log('Task load: ', this.workerPool.map(worker => worker._taskLoad));\n  }\n\n  dispose() {\n    for (let i = 0; i < this.workerPool.length; ++i) {\n      this.workerPool[i].terminate();\n    }\n\n    this.workerPool.length = 0;\n    return this;\n  }\n\n}\n/* WEB WORKER */\n\n\nfunction DRACOWorker() {\n  let decoderConfig;\n  let decoderPending;\n\n  onmessage = function (e) {\n    const message = e.data;\n\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve\n        /*, reject*/\n        ) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n        break;\n\n      case 'decode':\n        const buffer = message.buffer;\n        const taskConfig = message.taskConfig;\n        decoderPending.then(module => {\n          const draco = module.draco;\n          const decoder = new draco.Decoder();\n          const decoderBuffer = new draco.DecoderBuffer();\n          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n\n          try {\n            const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n            const buffers = geometry.attributes.map(attr => attr.array.buffer);\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoderBuffer);\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n\n  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n    const attributeIDs = taskConfig.attributeIDs;\n    const attributeTypes = taskConfig.attributeTypes;\n    let dracoGeometry;\n    let decodingStatus;\n    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeBufferToPointCloud(decoderBuffer, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n\n    const geometry = {\n      index: null,\n      attributes: []\n    }; // Gather all vertex attributes.\n\n    for (const attributeName in attributeIDs) {\n      const attributeType = self[attributeTypes[attributeName]];\n      let attribute;\n      let attributeID; // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n\n      geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n    } // Add index.\n\n\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * 4;\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n\n    draco._free(ptr);\n\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    const numComponents = attribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(draco, attributeType);\n\n    const ptr = draco._malloc(byteLength);\n\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n\n    draco._free(ptr);\n\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n\n      case Int8Array:\n        return draco.DT_INT8;\n\n      case Int16Array:\n        return draco.DT_INT16;\n\n      case Int32Array:\n        return draco.DT_INT32;\n\n      case Uint8Array:\n        return draco.DT_UINT8;\n\n      case Uint16Array:\n        return draco.DT_UINT16;\n\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}\n\nexport { DRACOLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}