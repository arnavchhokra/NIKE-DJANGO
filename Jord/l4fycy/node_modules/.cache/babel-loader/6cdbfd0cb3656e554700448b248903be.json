{"ast":null,"code":"\"use strict\"; // Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getKeyForAutomaticLookahead = exports.AT_LEAST_ONE_SEP_IDX = exports.MANY_SEP_IDX = exports.AT_LEAST_ONE_IDX = exports.MANY_IDX = exports.OPTION_IDX = exports.OR_IDX = exports.BITS_FOR_ALT_IDX = exports.BITS_FOR_RULE_IDX = exports.BITS_FOR_OCCURRENCE_IDX = exports.BITS_FOR_METHOD_TYPE = void 0;\nexports.BITS_FOR_METHOD_TYPE = 4;\nexports.BITS_FOR_OCCURRENCE_IDX = 8;\nexports.BITS_FOR_RULE_IDX = 12; // TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\n\nexports.BITS_FOR_ALT_IDX = 8; // short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\n\nexports.OR_IDX = 1 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.OPTION_IDX = 2 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.MANY_IDX = 3 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.AT_LEAST_ONE_IDX = 4 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.MANY_SEP_IDX = 5 << exports.BITS_FOR_OCCURRENCE_IDX;\nexports.AT_LEAST_ONE_SEP_IDX = 6 << exports.BITS_FOR_OCCURRENCE_IDX; // this actually returns a number, but it is always used as a string (object prop key)\n\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n  return occurrence | dslMethodIdx | ruleIdx;\n}\n\nexports.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;\nvar BITS_START_FOR_ALT_IDX = 32 - exports.BITS_FOR_ALT_IDX;","map":{"version":3,"mappings":"cAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEaA,+BAAuB,CAAvB;AACAA,kCAA0B,CAA1B;AACAA,4BAAoB,EAApB,C,CACb;;AACaA,2BAAmB,CAAnB,C,CAEb;AACA;AACA;;AACaA,iBAAS,KAAKA,+BAAd;AACAA,qBAAa,KAAKA,+BAAlB;AACAA,mBAAW,KAAKA,+BAAhB;AACAA,2BAAmB,KAAKA,+BAAxB;AACAA,uBAAe,KAAKA,+BAApB;AACAA,+BAAuB,KAAKA,+BAA5B,C,CAEb;;AACA,SAAgBC,2BAAhB,CACEC,OADF,EAEEC,YAFF,EAGEC,UAHF,EAGoB;EAElB,OAAOA,UAAU,GAAGD,YAAb,GAA4BD,OAAnC;AACD;;AANDF;AAQA,IAAMK,sBAAsB,GAAG,KAAKL,wBAApC","names":["exports","getKeyForAutomaticLookahead","ruleIdx","dslMethodIdx","occurrence","BITS_START_FOR_ALT_IDX"],"sources":["C:\\Users\\Arnav\\Downloads\\l4fycy\\node_modules\\chevrotain\\src\\parse\\grammar\\keys.ts"],"sourcesContent":["// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\n\nexport const BITS_FOR_METHOD_TYPE = 4\nexport const BITS_FOR_OCCURRENCE_IDX = 8\nexport const BITS_FOR_RULE_IDX = 12\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\nexport const BITS_FOR_ALT_IDX = 8\n\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX\n\n// this actually returns a number, but it is always used as a string (object prop key)\nexport function getKeyForAutomaticLookahead(\n  ruleIdx: number,\n  dslMethodIdx: number,\n  occurrence: number\n): number {\n  return occurrence | dslMethodIdx | ruleIdx\n}\n\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX\n"]},"metadata":{},"sourceType":"script"}