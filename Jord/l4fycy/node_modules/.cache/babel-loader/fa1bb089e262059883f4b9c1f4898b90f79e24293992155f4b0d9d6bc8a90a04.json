{"ast":null,"code":"'use client';\n\nimport { ariaAttr, callAllHandlers, dataAttr } from \"./chunk-DX64QB22.mjs\";\nimport { getIds, getIsReversed, getStyles, orient } from \"./chunk-E23N4XEN.mjs\";\n\n// src/use-range-slider.ts\nimport { usePanEvent } from \"@chakra-ui/react-use-pan-event\";\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\";\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\";\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\";\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\";\nimport { percentToValue, roundValueToStep, valueToPercent, clampValue } from \"@chakra-ui/number-utils\";\nimport { useCallback, useMemo, useRef, useState, useId } from \"react\";\nimport { useSizes } from \"@chakra-ui/react-use-size\";\nfunction useRangeSlider(props) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0,\n    ...htmlProps\n  } = props;\n  const onChangeStart = useCallbackRef(onChangeStartProp);\n  const onChangeEnd = useCallbackRef(onChangeEndProp);\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  const [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : [25, 75],\n    onChange\n  });\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\"[range-slider] You passed an invalid value for `value` or `defaultValue`, expected `Array` but got `\".concat(typeof valueState, \"`\"));\n  }\n  const [isDragging, setDragging] = useState(false);\n  const [isFocused, setFocused] = useState(false);\n  const [activeIndex, setActiveIndex] = useState(-1);\n  const isInteractive = !(isDisabled || isReadOnly);\n  const initialValue = useRef(valueState);\n  const value = valueState.map(val => clampValue(val, min, max));\n  const spacing = minStepsBetweenThumbs * step;\n  const valueBounds = getValueBounds(value, min, max, spacing);\n  const stateRef = useRef({\n    eventSource: null,\n    value: [],\n    valueBounds: []\n  });\n  stateRef.current.value = value;\n  stateRef.current.valueBounds = valueBounds;\n  const reversedValue = value.map(val => max - val + min);\n  const thumbValues = isReversed ? reversedValue : value;\n  const thumbPercents = thumbValues.map(val => valueToPercent(val, min, max));\n  const isVertical = orientation === \"vertical\";\n  const trackRef = useRef(null);\n  const rootRef = useRef(null);\n  const thumbRects = useSizes({\n    getNodes() {\n      const rootNode = rootRef.current;\n      const thumbNodes = rootNode == null ? void 0 : rootNode.querySelectorAll(\"[role=slider]\");\n      return thumbNodes ? Array.from(thumbNodes) : [];\n    }\n  });\n  const reactId = useId();\n  const uuid = idProp != null ? idProp : reactId;\n  const ids = getIds(uuid);\n  const getValueFromPointer = useCallback(event => {\n    var _a, _b;\n    if (!trackRef.current) return;\n    stateRef.current.eventSource = \"pointer\";\n    const rect = trackRef.current.getBoundingClientRect();\n    const {\n      clientX,\n      clientY\n    } = (_b = (_a = event.touches) == null ? void 0 : _a[0]) != null ? _b : event;\n    const diff = isVertical ? rect.bottom - clientY : clientX - rect.left;\n    const length = isVertical ? rect.height : rect.width;\n    let percent = diff / length;\n    if (isReversed) percent = 1 - percent;\n    return percentToValue(percent, min, max);\n  }, [isVertical, isReversed, max, min]);\n  const tenSteps = (max - min) / 10;\n  const oneStep = step || (max - min) / 100;\n  const actions = useMemo(() => ({\n    setValueAtIndex(index, val) {\n      if (!isInteractive) return;\n      const bounds = stateRef.current.valueBounds[index];\n      val = parseFloat(roundValueToStep(val, bounds.min, oneStep));\n      val = clampValue(val, bounds.min, bounds.max);\n      const next = [...stateRef.current.value];\n      next[index] = val;\n      setValue(next);\n    },\n    setActiveIndex,\n    stepUp(index) {\n      let step2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : oneStep;\n      const valueAtIndex = stateRef.current.value[index];\n      const next = isReversed ? valueAtIndex - step2 : valueAtIndex + step2;\n      actions.setValueAtIndex(index, next);\n    },\n    stepDown(index) {\n      let step2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : oneStep;\n      const valueAtIndex = stateRef.current.value[index];\n      const next = isReversed ? valueAtIndex + step2 : valueAtIndex - step2;\n      actions.setValueAtIndex(index, next);\n    },\n    reset() {\n      setValue(initialValue.current);\n    }\n  }), [oneStep, isReversed, setValue, isInteractive]);\n  const onKeyDown = useCallback(event => {\n    const eventKey = event.key;\n    const keyMap = {\n      ArrowRight: () => actions.stepUp(activeIndex),\n      ArrowUp: () => actions.stepUp(activeIndex),\n      ArrowLeft: () => actions.stepDown(activeIndex),\n      ArrowDown: () => actions.stepDown(activeIndex),\n      PageUp: () => actions.stepUp(activeIndex, tenSteps),\n      PageDown: () => actions.stepDown(activeIndex, tenSteps),\n      Home: () => {\n        const {\n          min: value2\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value2);\n      },\n      End: () => {\n        const {\n          max: value2\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value2);\n      }\n    };\n    const action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      stateRef.current.eventSource = \"keyboard\";\n    }\n  }, [actions, activeIndex, tenSteps, valueBounds]);\n  const {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => getStyles({\n    isReversed,\n    orientation,\n    thumbRects,\n    thumbPercents\n  }), [isReversed, orientation, thumbPercents, thumbRects]);\n  const focusThumb = useCallback(index => {\n    var _a;\n    const idx = index != null ? index : activeIndex;\n    if (idx !== -1 && focusThumbOnChange) {\n      const id = ids.getThumb(idx);\n      const thumb = (_a = rootRef.current) == null ? void 0 : _a.ownerDocument.getElementById(id);\n      if (thumb) {\n        setTimeout(() => thumb.focus());\n      }\n    }\n  }, [focusThumbOnChange, activeIndex, ids]);\n  useUpdateEffect(() => {\n    if (stateRef.current.eventSource === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);\n    }\n  }, [value, onChangeEnd]);\n  const onPanSessionStart = event => {\n    const pointValue = getValueFromPointer(event) || 0;\n    const distances = stateRef.current.value.map(val => Math.abs(val - pointValue));\n    const closest = Math.min(...distances);\n    let index = distances.indexOf(closest);\n    const thumbsAtPosition = distances.filter(distance => distance === closest);\n    const isThumbStacked = thumbsAtPosition.length > 1;\n    if (isThumbStacked && pointValue > stateRef.current.value[index]) {\n      index = index + thumbsAtPosition.length - 1;\n    }\n    setActiveIndex(index);\n    actions.setValueAtIndex(index, pointValue);\n    focusThumb(index);\n  };\n  const onPan = event => {\n    if (activeIndex == -1) return;\n    const pointValue = getValueFromPointer(event) || 0;\n    setActiveIndex(activeIndex);\n    actions.setValueAtIndex(activeIndex, pointValue);\n    focusThumb(activeIndex);\n  };\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging(true);\n      onPanSessionStart(event);\n      onChangeStart == null ? void 0 : onChangeStart(stateRef.current.value);\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging(false);\n      onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);\n    },\n    onPan(event) {\n      if (!isInteractive) return;\n      onPan(event);\n    }\n  });\n  const getRootProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      ...htmlProps,\n      id: ids.root,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: {\n        ...props2.style,\n        ...rootStyle\n      }\n    };\n  }, [htmlProps, isDisabled, isFocused, rootStyle, ids]);\n  const getTrackProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      ref: mergeRefs(ref, trackRef),\n      id: ids.track,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: {\n        ...props2.style,\n        ...trackStyle\n      }\n    };\n  }, [isDisabled, trackStyle, ids]);\n  const getInnerTrackProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      ref,\n      id: ids.innerTrack,\n      style: {\n        ...props2.style,\n        ...innerTrackStyle\n      }\n    };\n  }, [innerTrackStyle, ids]);\n  const getThumbProps = useCallback(function (props2) {\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var _a;\n    const {\n      index,\n      ...rest\n    } = props2;\n    const valueAtIndex = value[index];\n    if (valueAtIndex == null) {\n      throw new TypeError(\"[range-slider > thumb] Cannot find value at index `\".concat(index, \"`. The `value` or `defaultValue` length is : \").concat(value.length));\n    }\n    const bounds = valueBounds[index];\n    return {\n      ...rest,\n      ref,\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : void 0,\n      id: ids.getThumb(index),\n      \"data-active\": dataAttr(isDragging && activeIndex === index),\n      \"aria-valuetext\": (_a = getAriaValueText == null ? void 0 : getAriaValueText(valueAtIndex)) != null ? _a : ariaValueText == null ? void 0 : ariaValueText[index],\n      \"aria-valuemin\": bounds.min,\n      \"aria-valuemax\": bounds.max,\n      \"aria-valuenow\": valueAtIndex,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel == null ? void 0 : ariaLabel[index],\n      \"aria-labelledby\": (ariaLabel == null ? void 0 : ariaLabel[index]) ? void 0 : ariaLabelledBy == null ? void 0 : ariaLabelledBy[index],\n      style: {\n        ...props2.style,\n        ...getThumbStyle(index)\n      },\n      onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props2.onFocus, () => {\n        setFocused(true);\n        setActiveIndex(index);\n      }),\n      onBlur: callAllHandlers(props2.onBlur, () => {\n        setFocused(false);\n        setActiveIndex(-1);\n      })\n    };\n  }, [ids, value, valueBounds, isInteractive, isDragging, activeIndex, getAriaValueText, ariaValueText, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused]);\n  const getOutputProps = useCallback(function () {\n    let props2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return {\n      ...props2,\n      ref,\n      id: ids.output,\n      htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n      \"aria-live\": \"off\"\n    };\n  }, [ids, value]);\n  const getMarkerProps = useCallback(function (props2) {\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      value: v,\n      ...rest\n    } = props2;\n    const isInRange = !(v < min || v > max);\n    const isHighlighted = v >= value[0] && v <= value[value.length - 1];\n    let percent = valueToPercent(v, min, max);\n    percent = isReversed ? 100 - percent : percent;\n    const markerStyle = {\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      ...orient({\n        orientation,\n        vertical: {\n          bottom: \"\".concat(percent, \"%\")\n        },\n        horizontal: {\n          left: \"\".concat(percent, \"%\")\n        }\n      })\n    };\n    return {\n      ...rest,\n      ref,\n      id: ids.getMarker(props2.value),\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: {\n        ...props2.style,\n        ...markerStyle\n      }\n    };\n  }, [isDisabled, isReversed, max, min, orientation, value, ids]);\n  const getInputProps = useCallback(function (props2) {\n    let ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const {\n      index,\n      ...rest\n    } = props2;\n    return {\n      ...rest,\n      ref,\n      id: ids.getInput(index),\n      type: \"hidden\",\n      value: value[index],\n      name: Array.isArray(name) ? name[index] : \"\".concat(name, \"-\").concat(index)\n    };\n  }, [name, value, ids]);\n  const state = {\n    value,\n    isFocused,\n    isDragging,\n    getThumbPercent: index => thumbPercents[index],\n    getThumbMinValue: index => valueBounds[index].min,\n    getThumbMaxValue: index => valueBounds[index].max\n  };\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps\n  };\n}\nfunction getValueBounds(arr, min, max, spacing) {\n  return arr.map((v, i) => {\n    const _min = i === 0 ? min : arr[i - 1] + spacing;\n    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;\n    return {\n      min: _min,\n      max: _max\n    };\n  });\n}\nexport { useRangeSlider };","map":{"version":3,"names":["usePanEvent","useControllableState","useCallbackRef","useUpdateEffect","mergeRefs","percentToValue","roundValueToStep","valueToPercent","clampValue","useCallback","useMemo","useRef","useState","useId","useSizes","useRangeSlider","props","min","max","onChange","value","valueProp","defaultValue","isReversed","isReversedProp","direction","orientation","id","idProp","isDisabled","isReadOnly","onChangeStart","onChangeStartProp","onChangeEnd","onChangeEndProp","step","getAriaValueText","getAriaValueTextProp","ariaValueText","ariaLabel","ariaLabelledBy","name","focusThumbOnChange","minStepsBetweenThumbs","htmlProps","getIsReversed","valueState","setValue","Array","isArray","TypeError","concat","isDragging","setDragging","isFocused","setFocused","activeIndex","setActiveIndex","isInteractive","initialValue","map","val","spacing","valueBounds","getValueBounds","stateRef","eventSource","current","reversedValue","thumbValues","thumbPercents","isVertical","trackRef","rootRef","thumbRects","getNodes","rootNode","thumbNodes","querySelectorAll","from","reactId","uuid","ids","getIds","getValueFromPointer","event","_a","_b","rect","getBoundingClientRect","clientX","clientY","touches","diff","bottom","left","length","height","width","percent","tenSteps","oneStep","actions","setValueAtIndex","index","bounds","parseFloat","next","stepUp","step2","arguments","undefined","valueAtIndex","stepDown","reset","onKeyDown","eventKey","key","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","value2","End","action","preventDefault","stopPropagation","getThumbStyle","rootStyle","trackStyle","innerTrackStyle","getStyles","focusThumb","idx","getThumb","thumb","ownerDocument","getElementById","setTimeout","focus","onPanSessionStart","pointValue","distances","Math","abs","closest","indexOf","thumbsAtPosition","filter","distance","isThumbStacked","onPan","onPanSessionEnd","getRootProps","props2","ref","root","tabIndex","ariaAttr","dataAttr","style","getTrackProps","track","getInnerTrackProps","innerTrack","getThumbProps","rest","role","callAllHandlers","onFocus","onBlur","getOutputProps","output","htmlFor","v","i","join","getMarkerProps","isInRange","isHighlighted","markerStyle","position","pointerEvents","orient","vertical","horizontal","getMarker","getInputProps","getInput","type","state","getThumbPercent","getThumbMinValue","getThumbMaxValue","arr","_min","_max"],"sources":["D:\\Repos\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\@chakra-ui\\slider\\src\\use-range-slider.ts"],"sourcesContent":["import { usePanEvent } from \"@chakra-ui/react-use-pan-event\"\nimport { useControllableState } from \"@chakra-ui/react-use-controllable-state\"\nimport { useCallbackRef } from \"@chakra-ui/react-use-callback-ref\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport { mergeRefs } from \"@chakra-ui/react-use-merge-refs\"\nimport type { PropGetter, RequiredPropGetter } from \"@chakra-ui/react-types\"\nimport { ariaAttr, callAllHandlers, dataAttr } from \"@chakra-ui/utils\"\nimport {\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n  clampValue,\n} from \"@chakra-ui/number-utils\"\nimport { useCallback, useMemo, useRef, useState, useId } from \"react\"\nimport { getIds, getIsReversed, getStyles, orient } from \"./slider-utils\"\nimport { useSizes } from \"@chakra-ui/react-use-size\"\n\nexport interface UseRangeSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number[]\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number[]\n  /**\n   * Orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   * @default false\n   */\n  isReversed?: boolean\n\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number[]): void\n\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number[]): void\n\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number[]): void\n\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string | string[]\n  /**\n   * If `true`, the slider will be disabled\n   * @default false\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   * @default false\n   */\n  isReadOnly?: boolean\n\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string[]\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string[]\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string[]\n  /**\n   * The writing mode\n   * @default \"ltr\"\n   */\n  direction?: \"ltr\" | \"rtl\"\n  /**\n   * The minimum distance between slider thumbs. Useful for preventing\n   * the thumbs from being too close together.\n   * @default 0\n   */\n  minStepsBetweenThumbs?: number\n}\n\nexport interface RangeSliderState {\n  value: number[]\n  isFocused: boolean\n  isDragging: boolean\n  getThumbPercent: (index: number) => number\n  getThumbMinValue: (index: number) => number\n  getThumbMaxValue: (index: number) => number\n}\n\nexport interface RangeSliderActions {\n  setValueAtIndex(index: number, val: number): void\n  setActiveIndex: React.Dispatch<React.SetStateAction<number>>\n  stepUp(index: number, step?: number): void\n  stepDown(index: number, step?: number): void\n  reset(): void\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/WAI/ARIA/apg/patterns/slidertwothumb/\n */\nexport function useRangeSlider(props: UseRangeSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  const [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? [25, 75],\n    onChange,\n  })\n\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\n      `[range-slider] You passed an invalid value for \\`value\\` or \\`defaultValue\\`, expected \\`Array\\` but got \\`${typeof valueState}\\``,\n    )\n  }\n\n  const [isDragging, setDragging] = useState(false)\n  const [isFocused, setFocused] = useState(false)\n  const [activeIndex, setActiveIndex] = useState(-1)\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  const initialValue = useRef(valueState)\n  const value = valueState.map((val) => clampValue(val, min, max))\n\n  const spacing = minStepsBetweenThumbs * step\n  const valueBounds = getValueBounds(value, min, max, spacing)\n\n  const stateRef = useRef<{\n    eventSource: \"pointer\" | \"keyboard\" | null\n    value: number[]\n    valueBounds: Array<{ min: number; max: number }>\n  }>({\n    eventSource: null,\n    value: [],\n    valueBounds: [],\n  })\n\n  stateRef.current.value = value\n  stateRef.current.valueBounds = valueBounds\n\n  const reversedValue = value.map((val) => max - val + min)\n  const thumbValues = isReversed ? reversedValue : value\n  const thumbPercents = thumbValues.map((val) => valueToPercent(val, min, max))\n\n  const isVertical = orientation === \"vertical\"\n\n  const trackRef = useRef<HTMLElement>(null)\n  const rootRef = useRef<HTMLElement>(null)\n\n  const thumbRects = useSizes({\n    getNodes() {\n      const rootNode = rootRef.current\n      const thumbNodes =\n        rootNode?.querySelectorAll<HTMLElement>(\"[role=slider]\")\n      return thumbNodes ? Array.from(thumbNodes) : []\n    },\n  })\n\n  const reactId = useId()\n  const uuid = idProp ?? reactId\n  const ids = getIds(uuid)\n\n  const getValueFromPointer = useCallback(\n    (event: any) => {\n      if (!trackRef.current) return\n      stateRef.current.eventSource = \"pointer\"\n      const rect = trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical ? rect.bottom - clientY : clientX - rect.left\n      const length = isVertical ? rect.height : rect.width\n\n      let percent = diff / length\n      if (isReversed) percent = 1 - percent\n\n      return percentToValue(percent, min, max)\n    },\n    [isVertical, isReversed, max, min],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const actions: RangeSliderActions = useMemo(\n    () => ({\n      setValueAtIndex(index: number, val: number) {\n        if (!isInteractive) return\n        const bounds = stateRef.current.valueBounds[index]\n        val = parseFloat(roundValueToStep(val, bounds.min, oneStep))\n        val = clampValue(val, bounds.min, bounds.max)\n        const next = [...stateRef.current.value]\n        next[index] = val\n        setValue(next)\n      },\n      setActiveIndex,\n      stepUp(index: number, step = oneStep) {\n        const valueAtIndex = stateRef.current.value[index]\n        const next = isReversed ? valueAtIndex - step : valueAtIndex + step\n        actions.setValueAtIndex(index, next)\n      },\n      stepDown(index: number, step = oneStep) {\n        const valueAtIndex = stateRef.current.value[index]\n        const next = isReversed ? valueAtIndex + step : valueAtIndex - step\n        actions.setValueAtIndex(index, next)\n      },\n      reset() {\n        setValue(initialValue.current)\n      },\n    }),\n    [oneStep, isReversed, setValue, isInteractive],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = event.key\n      const keyMap: Record<string, React.KeyboardEventHandler> = {\n        ArrowRight: () => actions.stepUp(activeIndex),\n        ArrowUp: () => actions.stepUp(activeIndex),\n        ArrowLeft: () => actions.stepDown(activeIndex),\n        ArrowDown: () => actions.stepDown(activeIndex),\n        PageUp: () => actions.stepUp(activeIndex, tenSteps),\n        PageDown: () => actions.stepDown(activeIndex, tenSteps),\n        Home: () => {\n          const { min: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n        End: () => {\n          const { max: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        stateRef.current.eventSource = \"keyboard\"\n      }\n    },\n    [actions, activeIndex, tenSteps, valueBounds],\n  )\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = useMemo(\n    () =>\n      getStyles({\n        isReversed,\n        orientation,\n        thumbRects,\n        thumbPercents,\n      }),\n    [isReversed, orientation, thumbPercents, thumbRects],\n  )\n\n  const focusThumb = useCallback(\n    (index?: number) => {\n      const idx = index ?? activeIndex\n      if (idx !== -1 && focusThumbOnChange) {\n        const id = ids.getThumb(idx)\n        const thumb = rootRef.current?.ownerDocument.getElementById(id)\n        if (thumb) {\n          setTimeout(() => thumb.focus())\n        }\n      }\n    },\n    [focusThumbOnChange, activeIndex, ids],\n  )\n\n  useUpdateEffect(() => {\n    if (stateRef.current.eventSource === \"keyboard\") {\n      onChangeEnd?.(stateRef.current.value)\n    }\n  }, [value, onChangeEnd])\n\n  const onPanSessionStart = (event: MouseEvent | TouchEvent | PointerEvent) => {\n    const pointValue = getValueFromPointer(event) || 0\n    const distances = stateRef.current.value.map((val) =>\n      Math.abs(val - pointValue),\n    )\n    const closest = Math.min(...distances)\n    let index = distances.indexOf(closest)\n\n    // check if the clicked thumb is stacked by checking if there are multiple\n    // thumbs at the same distance\n    const thumbsAtPosition = distances.filter(\n      (distance) => distance === closest,\n    )\n    const isThumbStacked = thumbsAtPosition.length > 1\n\n    // when two thumbs are stacked and the user clicks at a point larger than\n    // their values, pick the last thumb with the greatest index\n    if (isThumbStacked && pointValue > stateRef.current.value[index]) {\n      index = index + thumbsAtPosition.length - 1\n    }\n\n    setActiveIndex(index)\n    actions.setValueAtIndex(index, pointValue)\n    focusThumb(index)\n  }\n\n  const onPan = (event: MouseEvent | TouchEvent | PointerEvent) => {\n    if (activeIndex == -1) return\n    const pointValue = getValueFromPointer(event) || 0\n    setActiveIndex(activeIndex)\n    actions.setValueAtIndex(activeIndex, pointValue)\n    focusThumb(activeIndex)\n  }\n\n  usePanEvent(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging(true)\n      onPanSessionStart(event)\n      onChangeStart?.(stateRef.current.value)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging(false)\n      onChangeEnd?.(stateRef.current.value)\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      onPan(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ...htmlProps,\n        id: ids.root,\n        ref: mergeRefs(ref, rootRef),\n        tabIndex: -1,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"data-focused\": dataAttr(isFocused),\n        style: { ...props.style, ...rootStyle },\n      }\n    },\n    [htmlProps, isDisabled, isFocused, rootStyle, ids],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref: mergeRefs(ref, trackRef),\n        id: ids.track,\n        \"data-disabled\": dataAttr(isDisabled),\n        style: { ...props.style, ...trackStyle },\n      }\n    },\n    [isDisabled, trackStyle, ids],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        id: ids.innerTrack,\n        style: {\n          ...props.style,\n          ...innerTrackStyle,\n        },\n      }\n    },\n    [innerTrackStyle, ids],\n  )\n\n  const getThumbProps: RequiredPropGetter<{ index: number }> = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n\n      const valueAtIndex = value[index]\n      if (valueAtIndex == null) {\n        throw new TypeError(\n          `[range-slider > thumb] Cannot find value at index \\`${index}\\`. The \\`value\\` or \\`defaultValue\\` length is : ${value.length}`,\n        )\n      }\n\n      const bounds = valueBounds[index]\n\n      return {\n        ...rest,\n        ref,\n        role: \"slider\",\n        tabIndex: isInteractive ? 0 : undefined,\n        id: ids.getThumb(index),\n        \"data-active\": dataAttr(isDragging && activeIndex === index),\n        \"aria-valuetext\":\n          getAriaValueText?.(valueAtIndex) ?? ariaValueText?.[index],\n        \"aria-valuemin\": bounds.min,\n        \"aria-valuemax\": bounds.max,\n        \"aria-valuenow\": valueAtIndex,\n        \"aria-orientation\": orientation,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        \"aria-label\": ariaLabel?.[index],\n        \"aria-labelledby\": ariaLabel?.[index]\n          ? undefined\n          : ariaLabelledBy?.[index],\n        style: { ...props.style, ...getThumbStyle(index) },\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, () => {\n          setFocused(true)\n          setActiveIndex(index)\n        }),\n        onBlur: callAllHandlers(props.onBlur, () => {\n          setFocused(false)\n          setActiveIndex(-1)\n        }),\n      }\n    },\n    [\n      ids,\n      value,\n      valueBounds,\n      isInteractive,\n      isDragging,\n      activeIndex,\n      getAriaValueText,\n      ariaValueText,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n      setFocused,\n    ],\n  )\n\n  const getOutputProps: PropGetter = useCallback(\n    (props = {}, ref = null) => {\n      return {\n        ...props,\n        ref,\n        id: ids.output,\n        htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n        \"aria-live\": \"off\",\n      }\n    },\n    [ids, value],\n  )\n\n  const getMarkerProps: RequiredPropGetter<{ value: number }> = useCallback(\n    (props, ref = null) => {\n      const { value: v, ...rest } = props\n\n      const isInRange = !(v < min || v > max)\n      const isHighlighted = v >= value[0] && v <= value[value.length - 1]\n\n      let percent = valueToPercent(v, min, max)\n      percent = isReversed ? 100 - percent : percent\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: { bottom: `${percent}%` },\n          horizontal: { left: `${percent}%` },\n        }),\n      }\n\n      return {\n        ...rest,\n        ref,\n        id: ids.getMarker(props.value),\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value, ids],\n  )\n\n  const getInputProps: RequiredPropGetter<{ index: number }> = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n      return {\n        ...rest,\n        ref,\n        id: ids.getInput(index),\n        type: \"hidden\",\n        value: value[index],\n        name: Array.isArray(name) ? name[index] : `${name}-${index}`,\n      }\n    },\n    [name, value, ids],\n  )\n\n  const state: RangeSliderState = {\n    value,\n    isFocused,\n    isDragging,\n    getThumbPercent: (index: number) => thumbPercents[index],\n    getThumbMinValue: (index: number) => valueBounds[index].min,\n    getThumbMaxValue: (index: number) => valueBounds[index].max,\n  }\n\n  return {\n    state,\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps,\n  }\n}\n\nexport type UseRangeSliderReturn = ReturnType<typeof useRangeSlider>\n\nfunction getValueBounds(\n  arr: number[],\n  min: number,\n  max: number,\n  spacing: number,\n) {\n  return arr.map((v, i) => {\n    const _min = i === 0 ? min : arr[i - 1] + spacing\n    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing\n    return { min: _min, max: _max }\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}