{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from 'three';\n\nvar AssimpLoader = function AssimpLoader(manager) {\n  Loader.call(this, manager);\n};\n\nAssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: AssimpLoader,\n  load: function load(url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function parse(buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n\n    Virtulous.KeyFrame = function (time, matrix) {\n      this.time = time;\n      this.matrix = matrix.clone();\n      this.position = new Vector3();\n      this.quaternion = new Quaternion();\n      this.scale = new Vector3(1, 1, 1);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n\n      this.clone = function () {\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\n        return n;\n      };\n\n      this.lerp = function (nextKey, time) {\n        time -= this.time;\n        var dist = nextKey.time - this.time;\n        var l = time / dist;\n        var l2 = 1 - l;\n        var keypos = this.position;\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\n\n        var key2pos = nextKey.position;\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\n\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n      };\n    };\n\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n\n        for (var j = 0; j < this.length * this.fps; j++) {\n          for (var i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n\n        for (var i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n\n        this.init();\n      };\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n\n        for (var i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n\n        this.init();\n      };\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n\n        for (var i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n\n        t.init();\n        return t;\n      };\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n\n        for (var i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n\n        for (var i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n\n        return null;\n      }\n\n      return find(root, target.name);\n    };\n\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n\n      this.setTime = function (time) {\n        this.time = time;\n\n        for (var i = 0; i < this.tracks.length; i++) {\n          this.tracks[i].setTime(time);\n        }\n      };\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n\n        for (var i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n\n        return n;\n      };\n    };\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\n    var ASSBIN_CHUNK_AINODE = 0x123c;\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n\n    var aiTextureType_DIFFUSE = 0x1;\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n\n    var aiTextureType_NORMALS = 0x6;\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n\n    var aiTextureType_OPACITY = 0x8;\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n\n    var aiTextureType_LIGHTMAP = 0xa;\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n\n    var BONESPERVERT = 4;\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n\n    function markBones(scene) {\n      for (var i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n\n        for (var k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n\n      for (var i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n\n      return rootBone;\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n\n      for (var i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n\n      for (var _i = 0; _i < 4; _i++) {\n        sum += pairs[_i].w * pairs[_i].w;\n      }\n\n      sum = Math.sqrt(sum);\n\n      for (var _i2 = 0; _i2 < 4; _i2++) {\n        pairs[_i2].w = pairs[_i2].w / sum;\n        indexes[_i2] = pairs[_i2].i;\n        weights[_i2] = pairs[_i2].w;\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root;\n\n      for (var i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n\n      return undefined;\n    }\n\n    function aiMesh() {\n      this.mPrimitiveTypes = 0;\n      this.mNumVertices = 0;\n      this.mNumFaces = 0;\n      this.mNumBones = 0;\n      this.mMaterialIndex = 0;\n      this.mVertices = [];\n      this.mNormals = [];\n      this.mTangents = [];\n      this.mBitangents = [];\n      this.mColors = [[]];\n      this.mTextureCoords = [[]];\n      this.mFaces = [];\n      this.mBones = [];\n\n      this.hookupSkeletons = function (scene) {\n        if (this.mBones.length == 0) return;\n        var allBones = [];\n        var offsetMatrix = [];\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\n\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n          skeletonRoot = skeletonRoot.mParent;\n        }\n\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n        this.threeNode.add(threeSkeletonRootBone);\n\n        for (var i = 0; i < this.mBones.length; i++) {\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\n          if (bone) {\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          } else {\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\n            if (!skeletonRoot) return;\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n            this.threeNode.add(threeSkeletonRootBone);\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          }\n        }\n\n        var skeleton = new Skeleton(allBones, offsetMatrix);\n        this.threeNode.bind(skeleton, new Matrix4());\n        this.threeNode.material.skinning = true;\n      };\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var geometry = new BufferGeometry();\n        var mat;\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n        geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3));\n\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n          geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3));\n        }\n\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n          geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4));\n        }\n\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n          geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n        }\n\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n          geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n        }\n\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n          geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3));\n        }\n\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n          geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3));\n        }\n\n        if (this.mBones.length > 0) {\n          var weights = [];\n          var bones = [];\n\n          for (var i = 0; i < this.mBones.length; i++) {\n            for (var j = 0; j < this.mBones[i].mWeights.length; j++) {\n              var weight = this.mBones[i].mWeights[j];\n\n              if (weight) {\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                weights[weight.mVertexId].push(weight.mWeight);\n                bones[weight.mVertexId].push(parseInt(i));\n              }\n            }\n          }\n\n          for (var _i3 in bones) {\n            sortWeights(bones[_i3], weights[_i3]);\n          }\n\n          var _weights = [];\n          var _bones = [];\n\n          for (var _i4 = 0; _i4 < weights.length; _i4++) {\n            for (var _j = 0; _j < 4; _j++) {\n              if (weights[_i4] && bones[_i4]) {\n                _weights.push(weights[_i4][_j]);\n\n                _bones.push(bones[_i4][_j]);\n              } else {\n                _weights.push(0);\n\n                _bones.push(0);\n              }\n            }\n          }\n\n          geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n          geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n        }\n\n        var mesh;\n        if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n\n        if (this.mBones.length > 0) {\n          mesh = new SkinnedMesh(geometry, mat);\n          mesh.normalizeSkinWeights();\n        }\n\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\n\n        return mesh;\n      };\n    }\n\n    function aiFace() {\n      this.mNumIndices = 0;\n      this.mIndices = [];\n    }\n\n    function aiVector3D() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n\n      this.toTHREE = function () {\n        return new Vector3(this.x, this.y, this.z);\n      };\n    }\n\n    function aiColor3D() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n\n      this.toTHREE = function () {\n        return new Color(this.r, this.g, this.b);\n      };\n    }\n\n    function aiQuaternion() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n\n      this.toTHREE = function () {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n      };\n    }\n\n    function aiVertexWeight() {\n      this.mVertexId = 0;\n      this.mWeight = 0;\n    }\n\n    function aiString() {\n      this.data = [];\n\n      this.toString = function () {\n        var str = '';\n        this.data.forEach(function (i) {\n          str += String.fromCharCode(i);\n        });\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\n      };\n    }\n\n    function aiVectorKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiQuatKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiNode() {\n      this.mName = '';\n      this.mTransformation = [];\n      this.mNumChildren = 0;\n      this.mNumMeshes = 0;\n      this.mMeshes = [];\n      this.mChildren = [];\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var o = new Object3D();\n        o.name = this.mName;\n        o.matrix = this.mTransformation.toTHREE();\n\n        for (var i = 0; i < this.mChildren.length; i++) {\n          o.add(this.mChildren[i].toTHREE(scene));\n        }\n\n        for (var _i5 = 0; _i5 < this.mMeshes.length; _i5++) {\n          o.add(scene.mMeshes[this.mMeshes[_i5]].toTHREE(scene));\n        }\n\n        this.threeNode = o; //o.matrixAutoUpdate = false;\n\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\n        return o;\n      };\n    }\n\n    function aiBone() {\n      this.mName = '';\n      this.mNumWeights = 0;\n      this.mOffsetMatrix = 0;\n    }\n\n    function aiMaterialProperty() {\n      this.mKey = '';\n      this.mSemantic = 0;\n      this.mIndex = 0;\n      this.mData = [];\n      this.mDataLength = 0;\n      this.mType = 0;\n\n      this.dataAsColor = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        var g = reader.getFloat32(4, true);\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\n\n        return new Color(r, g, b);\n      };\n\n      this.dataAsFloat = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return r;\n      };\n\n      this.dataAsBool = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return !!r;\n      };\n\n      this.dataAsString = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        return s.toString();\n      };\n\n      this.dataAsMap = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        var path = s.toString();\n        path = path.replace(/\\\\/g, '/');\n\n        if (path.indexOf('/') != -1) {\n          path = path.substr(path.lastIndexOf('/') + 1);\n        }\n\n        return textureLoader.load(path);\n      };\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map'\n    };\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map'\n    };\n\n    function aiMaterial() {\n      this.mNumAllocated = 0;\n      this.mNumProperties = 0;\n      this.mProperties = [];\n\n      this.toTHREE = function () {\n        var mat = new MeshPhongMaterial();\n\n        for (var i = 0; i < this.mProperties.length; i++) {\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n            var prop = this.mProperties[i];\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n          }\n        }\n\n        mat.ambient.r = 0.53;\n        mat.ambient.g = 0.53;\n        mat.ambient.b = 0.53;\n        mat.color.r = 1;\n        mat.color.g = 1;\n        mat.color.b = 1;\n        return mat;\n      };\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n\n      for (var i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n\n    function aiNodeAnim() {\n      this.mNodeName = '';\n      this.mNumPositionKeys = 0;\n      this.mNumRotationKeys = 0;\n      this.mNumScalingKeys = 0;\n      this.mPositionKeys = [];\n      this.mRotationKeys = [];\n      this.mScalingKeys = [];\n      this.mPreState = '';\n      this.mPostState = '';\n\n      this.init = function (tps) {\n        if (!tps) tps = 1;\n\n        function t(t) {\n          t.mTime /= tps;\n        }\n\n        this.mPositionKeys.forEach(t);\n        this.mRotationKeys.forEach(t);\n        this.mScalingKeys.forEach(t);\n      };\n\n      this.sortKeys = function () {\n        function comp(a, b) {\n          return a.mTime - b.mTime;\n        }\n\n        this.mPositionKeys.sort(comp);\n        this.mRotationKeys.sort(comp);\n        this.mScalingKeys.sort(comp);\n      };\n\n      this.getLength = function () {\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n          return a.mTime;\n        })));\n      };\n\n      this.toTHREE = function (o) {\n        this.sortKeys();\n        var length = this.getLength();\n        var track = new Virtulous.KeyFrameTrack();\n\n        for (var i = 0; i < length; i += 0.05) {\n          var matrix = new Matrix4();\n          var time = i;\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n          matrix.compose(pos, rotation, scale);\n          var key = new Virtulous.KeyFrame(time, matrix);\n          track.addKey(key);\n        }\n\n        track.target = o.findNode(this.mNodeName).toTHREE();\n        var tracks = [track];\n\n        if (o.nodeToBoneMap[this.mNodeName]) {\n          for (var _i6 = 0; _i6 < o.nodeToBoneMap[this.mNodeName].length; _i6++) {\n            var t2 = track.clone();\n            t2.target = o.nodeToBoneMap[this.mNodeName][_i6];\n            tracks.push(t2);\n          }\n        }\n\n        return tracks;\n      };\n    }\n\n    function aiAnimation() {\n      this.mName = '';\n      this.mDuration = 0;\n      this.mTicksPerSecond = 0;\n      this.mNumChannels = 0;\n      this.mChannels = [];\n\n      this.toTHREE = function (root) {\n        var animationHandle = new Virtulous.Animation();\n\n        for (var i in this.mChannels) {\n          this.mChannels[i].init(this.mTicksPerSecond);\n          var tracks = this.mChannels[i].toTHREE(root);\n\n          for (var j in tracks) {\n            tracks[j].init();\n            animationHandle.addTrack(tracks[j]);\n          }\n        }\n\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n          return e.length;\n        }));\n        return animationHandle;\n      };\n    }\n\n    function aiTexture() {\n      this.mWidth = 0;\n      this.mHeight = 0;\n      this.texAchFormatHint = [];\n      this.pcData = [];\n    }\n\n    function aiLight() {\n      this.mName = '';\n      this.mType = 0;\n      this.mAttenuationConstant = 0;\n      this.mAttenuationLinear = 0;\n      this.mAttenuationQuadratic = 0;\n      this.mAngleInnerCone = 0;\n      this.mAngleOuterCone = 0;\n      this.mColorDiffuse = null;\n      this.mColorSpecular = null;\n      this.mColorAmbient = null;\n    }\n\n    function aiCamera() {\n      this.mName = '';\n      this.mPosition = null;\n      this.mLookAt = null;\n      this.mUp = null;\n      this.mHorizontalFOV = 0;\n      this.mClipPlaneNear = 0;\n      this.mClipPlaneFar = 0;\n      this.mAspect = 0;\n    }\n\n    function aiScene() {\n      this.versionMajor = 0;\n      this.versionMinor = 0;\n      this.versionRevision = 0;\n      this.compileFlags = 0;\n      this.mFlags = 0;\n      this.mNumMeshes = 0;\n      this.mNumMaterials = 0;\n      this.mNumAnimations = 0;\n      this.mNumTextures = 0;\n      this.mNumLights = 0;\n      this.mNumCameras = 0;\n      this.mRootNode = null;\n      this.mMeshes = [];\n      this.mMaterials = [];\n      this.mAnimations = [];\n      this.mLights = [];\n      this.mCameras = [];\n      this.nodeToBoneMap = {};\n\n      this.findNode = function (name, root) {\n        if (!root) {\n          root = this.mRootNode;\n        }\n\n        if (root.mName == name) {\n          return root;\n        }\n\n        for (var i = 0; i < root.mChildren.length; i++) {\n          var ret = this.findNode(name, root.mChildren[i]);\n          if (ret) return ret;\n        }\n\n        return null;\n      };\n\n      this.toTHREE = function () {\n        this.nodeCount = 0;\n        markBones(this);\n        var o = this.mRootNode.toTHREE(this);\n\n        for (var i in this.mMeshes) {\n          this.mMeshes[i].hookupSkeletons(this);\n        }\n\n        if (this.mAnimations.length > 0) {\n          var a = this.mAnimations[0].toTHREE(this);\n        }\n\n        return {\n          object: o,\n          animation: a\n        };\n      };\n    }\n\n    function aiMatrix4() {\n      this.elements = [[], [], [], []];\n\n      this.toTHREE = function () {\n        var m = new Matrix4();\n\n        for (var i = 0; i < 4; ++i) {\n          for (var i2 = 0; i2 < 4; ++i2) {\n            m.elements[i * 4 + i2] = this.elements[i2][i];\n          }\n        }\n\n        return m;\n      };\n    }\n\n    var littleEndian = true;\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n\n      for (var i = 0; i < 4; ++i) {\n        for (var i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n\n      return m;\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiVertexWeight(stream);\n      }\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiVectorKey(stream);\n      }\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (var i = 0; i < size; i++) {\n        data[i] = Read_aiQuatKey(stream);\n      }\n    }\n\n    function ReadBounds(stream, T\n    /*p*/\n    , n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed';\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n\n        for (var i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = [];\n\n        for (var _i7 = 0; _i7 < node.mNumChildren; ++_i7) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[_i7] = node2;\n        }\n      }\n\n      return node;\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        // else write as usual\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n\n      return b;\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\n\n      var c = Read_unsigned_int(stream);\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      for (var n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n\n      mesh.mTexCoordsBuffers = [];\n\n      for (var _n = 0; _n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++_n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(_n))) break; // write number of UV components\n\n        mesh.mNumUVComponents[_n] = Read_unsigned_int(stream);\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[_n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTextureCoords[_n] = []; //note that assbin always writes 3d texcoords\n\n          mesh.mTexCoordsBuffers[_n] = [];\n\n          for (var uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n\n            mesh.mTexCoordsBuffers[_n].push(readFloat(stream));\n\n            readFloat(stream);\n          }\n        }\n      } // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n\n\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        // else write as usual\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n\n        for (var i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n\n          for (var a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      } // write bones\n\n\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n\n        for (var _a = 0; _a < mesh.mNumBones; ++_a) {\n          mesh.mBones[_a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[_a]);\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n\n        mat.mProperties = [];\n\n        for (var i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          // else write as usual\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          // else write as usual\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          // else write as usual\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n\n        for (var a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\n\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\n\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n\n        for (var i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      } // Read materials\n\n\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n\n        for (var _i8 = 0; _i8 < scene.mNumMaterials; ++_i8) {\n          scene.mMaterials[_i8] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[_i8]);\n        }\n      } // Read all animations\n\n\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n\n        for (var _i9 = 0; _i9 < scene.mNumAnimations; ++_i9) {\n          scene.mAnimations[_i9] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[_i9]);\n        }\n      } // Read all textures\n\n\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n\n        for (var _i10 = 0; _i10 < scene.mNumTextures; ++_i10) {\n          scene.mTextures[_i10] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[_i10]);\n        }\n      } // Read lights\n\n\n      if (scene.mNumLights) {\n        scene.mLights = [];\n\n        for (var _i11 = 0; _i11 < scene.mNumLights; ++_i11) {\n          scene.mLights[_i11] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[_i11]);\n        }\n      } // Read cameras\n\n\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n\n        for (var _i12 = 0; _i12 < scene.mNumCameras; ++_i12) {\n          scene.mCameras[_i12] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[_i12]);\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n\n    function extendStream(stream) {\n      stream.readOffset = 0;\n\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n\n        for (var i = 0; i < bytes; i++) {\n          buff[i] = Read_uint8_t(this);\n        }\n      };\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n\n    var shortened, compressed;\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR); // signature\n\n      /*unsigned int versionMajor =*/\n\n      pScene.versionMajor = Read_unsigned_int(stream);\n      /*unsigned int versionMinor =*/\n\n      pScene.versionMinor = Read_unsigned_int(stream);\n      /*unsigned int versionRevision =*/\n\n      pScene.versionRevision = Read_unsigned_int(stream);\n      /*unsigned int compileFlags =*/\n\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw 'Shortened binaries are not supported!';\n      stream.Seek(256, aiOrigin_CUR); // original filename\n\n      stream.Seek(128, aiOrigin_CUR); // options\n\n      stream.Seek(64, aiOrigin_CUR); // padding\n\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\n\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n\n      return pScene.toTHREE();\n    }\n\n    return InternReadFile(buffer);\n  }\n});\nexport { AssimpLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","TextureLoader","Vector3","Quaternion","Matrix4","Skeleton","BufferGeometry","MeshLambertMaterial","BufferAttribute","Mesh","SkinnedMesh","Object3D","MeshPhongMaterial","Bone","Color","AssimpLoader","manager","call","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","buffer","parse","e","console","error","itemError","textureLoader","resourcePath","setCrossOrigin","crossOrigin","Virtulous","KeyFrame","time","matrix","clone","position","quaternion","scale","decompose","n","lerp","nextKey","dist","l","l2","keypos","keyrot","key2pos","key2rot","tempAniPos","x","y","z","tempAniQuat","set","w","slerp","tempAniMatrix","compose","tempAniScale","KeyFrameTrack","keys","target","length","_accelTable","fps","addKey","key","push","init","sortKeys","j","i","parseFromThree","data","node","track","hierarchy","targets","parseFromCollada","sort","keySortFunc","a","b","t","reTarget","root","compareitor","TrackTargetNodeNameCompare","keySearchAccel","Math","floor","setTime","abs","key0","key1","matrixAutoUpdate","copy","matrixWorldNeedsUpdate","find","name","children","r","Animation","tracks","addTrack","max","ASSBIN_CHUNK_AICAMERA","ASSBIN_CHUNK_AILIGHT","ASSBIN_CHUNK_AITEXTURE","ASSBIN_CHUNK_AIMESH","ASSBIN_CHUNK_AINODEANIM","ASSBIN_CHUNK_AISCENE","ASSBIN_CHUNK_AIBONE","ASSBIN_CHUNK_AIANIMATION","ASSBIN_CHUNK_AINODE","ASSBIN_CHUNK_AIMATERIAL","ASSBIN_CHUNK_AIMATERIALPROPERTY","ASSBIN_MESH_HAS_POSITIONS","ASSBIN_MESH_HAS_NORMALS","ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS","ASSBIN_MESH_HAS_TEXCOORD_BASE","ASSBIN_MESH_HAS_COLOR_BASE","AI_MAX_NUMBER_OF_COLOR_SETS","AI_MAX_NUMBER_OF_TEXTURECOORDS","aiLightSource_DIRECTIONAL","aiLightSource_SPOT","aiTextureType_DIFFUSE","aiTextureType_NORMALS","aiTextureType_OPACITY","aiTextureType_LIGHTMAP","BONESPERVERT","ASSBIN_MESH_HAS_TEXCOORD","ASSBIN_MESH_HAS_COLOR","markBones","scene","mMeshes","mesh","k","mBones","boneNode","findNode","mName","isBone","cloneTreeToBones","rootBone","matrixWorld","nodeCount","toString","nodeToBoneMap","child","add","sortWeights","indexes","weights","pairs","sum","sqrt","findMatchingBone","indexOf","ret","undefined","aiMesh","mPrimitiveTypes","mNumVertices","mNumFaces","mNumBones","mMaterialIndex","mVertices","mNormals","mTangents","mBitangents","mColors","mTextureCoords","mFaces","hookupSkeletons","allBones","offsetMatrix","skeletonRoot","mParent","threeSkeletonRoot","toTHREE","threeSkeletonRootBone","threeNode","bone","tbone","mOffsetMatrix","skeleton","bind","material","skinning","geometry","mat","mMaterials","setIndex","Uint32Array","mIndexArray","setAttribute","mVertexBuffer","mNormalBuffer","mColorBuffer","mTexCoordsBuffers","Float32Array","mTangentBuffer","mBitangentBuffer","bones","mWeights","weight","mVertexId","mWeight","parseInt","_weights","_bones","normalizeSkinWeights","aiFace","mNumIndices","mIndices","aiVector3D","aiColor3D","g","aiQuaternion","aiVertexWeight","aiString","str","forEach","String","fromCharCode","replace","aiVectorKey","mTime","mValue","aiQuatKey","aiNode","mTransformation","mNumChildren","mNumMeshes","mChildren","o","aiBone","mNumWeights","aiMaterialProperty","mKey","mSemantic","mIndex","mData","mDataLength","mType","dataAsColor","array","Uint8Array","reader","DataView","getFloat32","dataAsFloat","dataAsBool","dataAsString","s","dataAsMap","substr","lastIndexOf","namePropMapping","nameTypeMapping","aiMaterial","mNumAllocated","mNumProperties","mProperties","prop","map","normalMap","lightMap","alphaMap","ambient","color","veclerp","v1","v2","v","lm1","quatlerp","q1","q2","sampleTrack","lne","Infinity","timeDist","dT","T","aiNodeAnim","mNodeName","mNumPositionKeys","mNumRotationKeys","mNumScalingKeys","mPositionKeys","mRotationKeys","mScalingKeys","mPreState","mPostState","tps","comp","getLength","apply","pos","rotation","t2","aiAnimation","mDuration","mTicksPerSecond","mNumChannels","mChannels","animationHandle","aiTexture","mWidth","mHeight","texAchFormatHint","pcData","aiLight","mAttenuationConstant","mAttenuationLinear","mAttenuationQuadratic","mAngleInnerCone","mAngleOuterCone","mColorDiffuse","mColorSpecular","mColorAmbient","aiCamera","mPosition","mLookAt","mUp","mHorizontalFOV","mClipPlaneNear","mClipPlaneFar","mAspect","aiScene","versionMajor","versionMinor","versionRevision","compileFlags","mFlags","mNumMaterials","mNumAnimations","mNumTextures","mNumLights","mNumCameras","mRootNode","mAnimations","mLights","mCameras","object","animation","aiMatrix4","elements","m","i2","littleEndian","readFloat","dataview","val","readOffset","Read_double","getFloat64","Read_uint8_t","getUint8","Read_uint16_t","getUint16","Read_unsigned_int","getUint32","Read_uint32_t","Read_aiVector3D","stream","Read_aiColor3D","c","Read_aiQuaternion","Read_aiString","stringlengthbytes","ReadBytes","Read_aiVertexWeight","Read_aiMatrix4x4","Read_aiVectorKey","Read_aiQuatKey","ReadArray_aiVertexWeight","size","ReadArray_aiVectorKey","ReadArray_aiQuatKey","ReadBounds","Seek","sizeof","aiOrigin_CUR","ai_assert","bool","ReadBinaryNode","parent","depth","chunkID","mDepth","node2","ReadBinaryBone","shortened","ReadBinaryMesh","mNumUVComponents","subArray32","uv","f","Error","ReadBinaryMaterialProperty","ReadBinaryMaterial","ReadBinaryNodeAnim","nd","ReadBinaryAnim","anim","ReadBinaryTexture","tex","achFormatHint","ReadBinaryLight","ReadBinaryCamera","cam","ReadBinaryScene","mTextures","aiOrigin_BEG","extendStream","off","ori","buff","bytes","start","end","newbuff","slice","subArrayUint16","Uint16Array","subArrayUint8","subArrayUint32","compressed","InternReadFile","pFiledata","pScene","uncompressedSize","compressedSize","FileSize","Tell","compressedData","Read","uncompressedData","uncompress","ArrayBuffer"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/loaders/AssimpLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, TextureLoader, Vector3, Quaternion, Matrix4, Skeleton, BufferGeometry, MeshLambertMaterial, BufferAttribute, Mesh, SkinnedMesh, Object3D, MeshPhongMaterial, Bone, Color } from 'three';\n\nvar AssimpLoader = function (manager) {\n  Loader.call(this, manager);\n};\n\nAssimpLoader.prototype = Object.assign(Object.create(Loader.prototype), {\n  constructor: AssimpLoader,\n  load: function (url, onLoad, onProgress, onError) {\n    var scope = this;\n    var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    var loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (buffer) {\n      try {\n        onLoad(scope.parse(buffer, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  },\n  parse: function (buffer, path) {\n    var textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    var Virtulous = {};\n\n    Virtulous.KeyFrame = function (time, matrix) {\n      this.time = time;\n      this.matrix = matrix.clone();\n      this.position = new Vector3();\n      this.quaternion = new Quaternion();\n      this.scale = new Vector3(1, 1, 1);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n\n      this.clone = function () {\n        var n = new Virtulous.KeyFrame(this.time, this.matrix);\n        return n;\n      };\n\n      this.lerp = function (nextKey, time) {\n        time -= this.time;\n        var dist = nextKey.time - this.time;\n        var l = time / dist;\n        var l2 = 1 - l;\n        var keypos = this.position;\n        var keyrot = this.quaternion; //      var keyscl =  key.parentspaceScl || key.scl;\n\n        var key2pos = nextKey.position;\n        var key2rot = nextKey.quaternion; //  var key2scl =  key2.parentspaceScl || key2.scl;\n\n        Virtulous.KeyFrame.tempAniPos.x = keypos.x * l2 + key2pos.x * l;\n        Virtulous.KeyFrame.tempAniPos.y = keypos.y * l2 + key2pos.y * l;\n        Virtulous.KeyFrame.tempAniPos.z = keypos.z * l2 + key2pos.z * l; //     tempAniScale.x = keyscl[0] * l2 + key2scl[0] * l;\n        //     tempAniScale.y = keyscl[1] * l2 + key2scl[1] * l;\n        //     tempAniScale.z = keyscl[2] * l2 + key2scl[2] * l;\n\n        Virtulous.KeyFrame.tempAniQuat.set(keyrot.x, keyrot.y, keyrot.z, keyrot.w);\n        Virtulous.KeyFrame.tempAniQuat.slerp(key2rot, l);\n        return Virtulous.KeyFrame.tempAniMatrix.compose(Virtulous.KeyFrame.tempAniPos, Virtulous.KeyFrame.tempAniQuat, Virtulous.KeyFrame.tempAniScale);\n      };\n    };\n\n    Virtulous.KeyFrame.tempAniPos = new Vector3();\n    Virtulous.KeyFrame.tempAniQuat = new Quaternion();\n    Virtulous.KeyFrame.tempAniScale = new Vector3(1, 1, 1);\n    Virtulous.KeyFrame.tempAniMatrix = new Matrix4();\n\n    Virtulous.KeyFrameTrack = function () {\n      this.keys = [];\n      this.target = null;\n      this.time = 0;\n      this.length = 0;\n      this._accelTable = {};\n      this.fps = 20;\n\n      this.addKey = function (key) {\n        this.keys.push(key);\n      };\n\n      this.init = function () {\n        this.sortKeys();\n        if (this.keys.length > 0) this.length = this.keys[this.keys.length - 1].time;else this.length = 0;\n        if (!this.fps) return;\n\n        for (let j = 0; j < this.length * this.fps; j++) {\n          for (let i = 0; i < this.keys.length; i++) {\n            if (this.keys[i].time == j) {\n              this._accelTable[j] = i;\n              break;\n            } else if (this.keys[i].time < j / this.fps && this.keys[i + 1] && this.keys[i + 1].time >= j / this.fps) {\n              this._accelTable[j] = i;\n              break;\n            }\n          }\n        }\n      };\n\n      this.parseFromThree = function (data) {\n        var fps = data.fps;\n        this.target = data.node;\n        var track = data.hierarchy[0].keys;\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].targets[0].data));\n        }\n\n        this.init();\n      };\n\n      this.parseFromCollada = function (data) {\n        var track = data.keys;\n        var fps = this.fps;\n\n        for (let i = 0; i < track.length; i++) {\n          this.addKey(new Virtulous.KeyFrame(i / fps || track[i].time, track[i].matrix));\n        }\n\n        this.init();\n      };\n\n      this.sortKeys = function () {\n        this.keys.sort(this.keySortFunc);\n      };\n\n      this.keySortFunc = function (a, b) {\n        return a.time - b.time;\n      };\n\n      this.clone = function () {\n        var t = new Virtulous.KeyFrameTrack();\n        t.target = this.target;\n        t.time = this.time;\n        t.length = this.length;\n\n        for (let i = 0; i < this.keys.length; i++) {\n          t.addKey(this.keys[i].clone());\n        }\n\n        t.init();\n        return t;\n      };\n\n      this.reTarget = function (root, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        this.target = compareitor(root, this.target);\n      };\n\n      this.keySearchAccel = function (time) {\n        time *= this.fps;\n        time = Math.floor(time);\n        return this._accelTable[time] || 0;\n      };\n\n      this.setTime = function (time) {\n        time = Math.abs(time);\n        if (this.length) time = time % this.length + 0.05;\n        var key0 = null;\n        var key1 = null;\n\n        for (let i = this.keySearchAccel(time); i < this.keys.length; i++) {\n          if (this.keys[i].time == time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i];\n            break;\n          } else if (this.keys[i].time < time && this.keys[i + 1] && this.keys[i + 1].time > time) {\n            key0 = this.keys[i];\n            key1 = this.keys[i + 1];\n            break;\n          } else if (this.keys[i].time < time && i == this.keys.length - 1) {\n            key0 = this.keys[i];\n            key1 = this.keys[0].clone();\n            key1.time += this.length + 0.05;\n            break;\n          }\n        }\n\n        if (key0 && key1 && key0 !== key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.lerp(key1, time));\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n\n        if (key0 && key1 && key0 == key1) {\n          this.target.matrixAutoUpdate = false;\n          this.target.matrix.copy(key0.matrix);\n          this.target.matrixWorldNeedsUpdate = true;\n          return;\n        }\n      };\n    };\n\n    Virtulous.TrackTargetNodeNameCompare = function (root, target) {\n      function find(node, name) {\n        if (node.name == name) return node;\n\n        for (let i = 0; i < node.children.length; i++) {\n          var r = find(node.children[i], name);\n          if (r) return r;\n        }\n\n        return null;\n      }\n\n      return find(root, target.name);\n    };\n\n    Virtulous.Animation = function () {\n      this.tracks = [];\n      this.length = 0;\n\n      this.addTrack = function (track) {\n        this.tracks.push(track);\n        this.length = Math.max(track.length, this.length);\n      };\n\n      this.setTime = function (time) {\n        this.time = time;\n\n        for (let i = 0; i < this.tracks.length; i++) this.tracks[i].setTime(time);\n      };\n\n      this.clone = function (target, compareitor) {\n        if (!compareitor) compareitor = Virtulous.TrackTargetNodeNameCompare;\n        var n = new Virtulous.Animation();\n        n.target = target;\n\n        for (let i = 0; i < this.tracks.length; i++) {\n          var track = this.tracks[i].clone();\n          track.reTarget(target, compareitor);\n          n.addTrack(track);\n        }\n\n        return n;\n      };\n    };\n\n    var ASSBIN_CHUNK_AICAMERA = 0x1234;\n    var ASSBIN_CHUNK_AILIGHT = 0x1235;\n    var ASSBIN_CHUNK_AITEXTURE = 0x1236;\n    var ASSBIN_CHUNK_AIMESH = 0x1237;\n    var ASSBIN_CHUNK_AINODEANIM = 0x1238;\n    var ASSBIN_CHUNK_AISCENE = 0x1239;\n    var ASSBIN_CHUNK_AIBONE = 0x123a;\n    var ASSBIN_CHUNK_AIANIMATION = 0x123b;\n    var ASSBIN_CHUNK_AINODE = 0x123c;\n    var ASSBIN_CHUNK_AIMATERIAL = 0x123d;\n    var ASSBIN_CHUNK_AIMATERIALPROPERTY = 0x123e;\n    var ASSBIN_MESH_HAS_POSITIONS = 0x1;\n    var ASSBIN_MESH_HAS_NORMALS = 0x2;\n    var ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS = 0x4;\n    var ASSBIN_MESH_HAS_TEXCOORD_BASE = 0x100;\n    var ASSBIN_MESH_HAS_COLOR_BASE = 0x10000;\n    var AI_MAX_NUMBER_OF_COLOR_SETS = 1;\n    var AI_MAX_NUMBER_OF_TEXTURECOORDS = 4; //var aiLightSource_UNDEFINED = 0x0;\n    //! A directional light source has a well-defined direction\n    //! but is infinitely far away. That's quite a good\n    //! approximation for sun light.\n\n    var aiLightSource_DIRECTIONAL = 0x1; //! A point light source has a well-defined position\n    //! in space but no direction - it emits light in all\n    //! directions. A normal bulb is a point light.\n    //var aiLightSource_POINT = 0x2;\n    //! A spot light source emits light in a specific\n    //! angle. It has a position and a direction it is pointing to.\n    //! A good example for a spot light is a light spot in\n    //! sport arenas.\n\n    var aiLightSource_SPOT = 0x3; //! The generic light level of the world, including the bounces\n    //! of all other lightsources.\n    //! Typically, there's at most one ambient light in a scene.\n    //! This light type doesn't have a valid position, direction, or\n    //! other properties, just a color.\n    //var aiLightSource_AMBIENT = 0x4;\n\n    /** Flat shading. Shading is done on per-face base,\n     *  diffuse only. Also known as 'faceted shading'.\n     */\n    //var aiShadingMode_Flat = 0x1;\n\n    /** Simple Gouraud shading.\n     */\n    //var aiShadingMode_Gouraud = 0x2;\n\n    /** Phong-Shading -\n     */\n    //var aiShadingMode_Phong = 0x3;\n\n    /** Phong-Blinn-Shading\n     */\n    //var aiShadingMode_Blinn = 0x4;\n\n    /** Toon-Shading per pixel\n     *\n     *  Also known as 'comic' shader.\n     */\n    //var aiShadingMode_Toon = 0x5;\n\n    /** OrenNayar-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  roughness of the material into account\n     */\n    //var aiShadingMode_OrenNayar = 0x6;\n\n    /** Minnaert-Shading per pixel\n     *\n     *  Extension to standard Lambertian shading, taking the\n     *  \"darkness\" of the material into account\n     */\n    //var aiShadingMode_Minnaert = 0x7;\n\n    /** CookTorrance-Shading per pixel\n     *\n     *  Special shader for metallic surfaces.\n     */\n    //var aiShadingMode_CookTorrance = 0x8;\n\n    /** No shading at all. Constant light influence of 1.0.\n     */\n    //var aiShadingMode_NoShading = 0x9;\n\n    /** Fresnel shading\n     */\n    //var aiShadingMode_Fresnel = 0xa;\n    //var aiTextureType_NONE = 0x0;\n\n    /** The texture is combined with the result of the diffuse\n     *  lighting equation.\n     */\n\n    var aiTextureType_DIFFUSE = 0x1;\n    /** The texture is combined with the result of the specular\n     *  lighting equation.\n     */\n    //var aiTextureType_SPECULAR = 0x2;\n\n    /** The texture is combined with the result of the ambient\n     *  lighting equation.\n     */\n    //var aiTextureType_AMBIENT = 0x3;\n\n    /** The texture is added to the result of the lighting\n     *  calculation. It isn't influenced by incoming light.\n     */\n    //var aiTextureType_EMISSIVE = 0x4;\n\n    /** The texture is a height map.\n     *\n     *  By convention, higher gray-scale values stand for\n     *  higher elevations from the base height.\n     */\n    //var aiTextureType_HEIGHT = 0x5;\n\n    /** The texture is a (tangent space) normal-map.\n     *\n     *  Again, there are several conventions for tangent-space\n     *  normal maps. Assimp does (intentionally) not\n     *  distinguish here.\n     */\n\n    var aiTextureType_NORMALS = 0x6;\n    /** The texture defines the glossiness of the material.\n     *\n     *  The glossiness is in fact the exponent of the specular\n     *  (phong) lighting equation. Usually there is a conversion\n     *  function defined to map the linear color values in the\n     *  texture to a suitable exponent. Have fun.\n     */\n    //var aiTextureType_SHININESS = 0x7;\n\n    /** The texture defines per-pixel opacity.\n     *\n     *  Usually 'white' means opaque and 'black' means\n     *  'transparency'. Or quite the opposite. Have fun.\n     */\n\n    var aiTextureType_OPACITY = 0x8;\n    /** Displacement texture\n     *\n     *  The exact purpose and format is application-dependent.\n     *  Higher color values stand for higher vertex displacements.\n     */\n    //var aiTextureType_DISPLACEMENT = 0x9;\n\n    /** Lightmap texture (aka Ambient Occlusion)\n     *\n     *  Both 'Lightmaps' and dedicated 'ambient occlusion maps' are\n     *  covered by this material property. The texture contains a\n     *  scaling value for the final color value of a pixel. Its\n     *  intensity is not affected by incoming light.\n     */\n\n    var aiTextureType_LIGHTMAP = 0xa;\n    /** Reflection texture\n     *\n     * Contains the color of a perfect mirror reflection.\n     * Rarely used, almost never for real-time applications.\n     */\n    //var aiTextureType_REFLECTION = 0xB;\n\n    /** Unknown texture\n     *\n     *  A texture reference that does not match any of the definitions\n     *  above is considered to be 'unknown'. It is still imported,\n     *  but is excluded from any further postprocessing.\n     */\n    //var aiTextureType_UNKNOWN = 0xC;\n\n    var BONESPERVERT = 4;\n\n    function ASSBIN_MESH_HAS_TEXCOORD(n) {\n      return ASSBIN_MESH_HAS_TEXCOORD_BASE << n;\n    }\n\n    function ASSBIN_MESH_HAS_COLOR(n) {\n      return ASSBIN_MESH_HAS_COLOR_BASE << n;\n    }\n\n    function markBones(scene) {\n      for (let i in scene.mMeshes) {\n        var mesh = scene.mMeshes[i];\n\n        for (let k in mesh.mBones) {\n          var boneNode = scene.findNode(mesh.mBones[k].mName);\n          if (boneNode) boneNode.isBone = true;\n        }\n      }\n    }\n\n    function cloneTreeToBones(root, scene) {\n      var rootBone = new Bone();\n      rootBone.matrix.copy(root.matrix);\n      rootBone.matrixWorld.copy(root.matrixWorld);\n      rootBone.position.copy(root.position);\n      rootBone.quaternion.copy(root.quaternion);\n      rootBone.scale.copy(root.scale);\n      scene.nodeCount++;\n      rootBone.name = 'bone_' + root.name + scene.nodeCount.toString();\n      if (!scene.nodeToBoneMap[root.name]) scene.nodeToBoneMap[root.name] = [];\n      scene.nodeToBoneMap[root.name].push(rootBone);\n\n      for (let i in root.children) {\n        var child = cloneTreeToBones(root.children[i], scene);\n        rootBone.add(child);\n      }\n\n      return rootBone;\n    }\n\n    function sortWeights(indexes, weights) {\n      var pairs = [];\n\n      for (let i = 0; i < indexes.length; i++) {\n        pairs.push({\n          i: indexes[i],\n          w: weights[i]\n        });\n      }\n\n      pairs.sort(function (a, b) {\n        return b.w - a.w;\n      });\n\n      while (pairs.length < 4) {\n        pairs.push({\n          i: 0,\n          w: 0\n        });\n      }\n\n      if (pairs.length > 4) pairs.length = 4;\n      var sum = 0;\n\n      for (let i = 0; i < 4; i++) {\n        sum += pairs[i].w * pairs[i].w;\n      }\n\n      sum = Math.sqrt(sum);\n\n      for (let i = 0; i < 4; i++) {\n        pairs[i].w = pairs[i].w / sum;\n        indexes[i] = pairs[i].i;\n        weights[i] = pairs[i].w;\n      }\n    }\n\n    function findMatchingBone(root, name) {\n      if (root.name.indexOf('bone_' + name) == 0) return root;\n\n      for (let i in root.children) {\n        var ret = findMatchingBone(root.children[i], name);\n        if (ret) return ret;\n      }\n\n      return undefined;\n    }\n\n    function aiMesh() {\n      this.mPrimitiveTypes = 0;\n      this.mNumVertices = 0;\n      this.mNumFaces = 0;\n      this.mNumBones = 0;\n      this.mMaterialIndex = 0;\n      this.mVertices = [];\n      this.mNormals = [];\n      this.mTangents = [];\n      this.mBitangents = [];\n      this.mColors = [[]];\n      this.mTextureCoords = [[]];\n      this.mFaces = [];\n      this.mBones = [];\n\n      this.hookupSkeletons = function (scene) {\n        if (this.mBones.length == 0) return;\n        var allBones = [];\n        var offsetMatrix = [];\n        var skeletonRoot = scene.findNode(this.mBones[0].mName);\n\n        while (skeletonRoot.mParent && skeletonRoot.mParent.isBone) {\n          skeletonRoot = skeletonRoot.mParent;\n        }\n\n        var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n        var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n        this.threeNode.add(threeSkeletonRootBone);\n\n        for (let i = 0; i < this.mBones.length; i++) {\n          var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n\n          if (bone) {\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          } else {\n            var skeletonRoot = scene.findNode(this.mBones[i].mName);\n            if (!skeletonRoot) return;\n            var threeSkeletonRoot = skeletonRoot.toTHREE(scene);\n            var threeSkeletonRootBone = cloneTreeToBones(threeSkeletonRoot, scene);\n            this.threeNode.add(threeSkeletonRootBone);\n            var bone = findMatchingBone(threeSkeletonRootBone, this.mBones[i].mName);\n            var tbone = bone;\n            allBones.push(tbone); //tbone.matrixAutoUpdate = false;\n\n            offsetMatrix.push(this.mBones[i].mOffsetMatrix.toTHREE());\n          }\n        }\n\n        var skeleton = new Skeleton(allBones, offsetMatrix);\n        this.threeNode.bind(skeleton, new Matrix4());\n        this.threeNode.material.skinning = true;\n      };\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var geometry = new BufferGeometry();\n        var mat;\n        if (scene.mMaterials[this.mMaterialIndex]) mat = scene.mMaterials[this.mMaterialIndex].toTHREE(scene);else mat = new MeshLambertMaterial();\n        geometry.setIndex(new BufferAttribute(new Uint32Array(this.mIndexArray), 1));\n        geometry.setAttribute('position', new BufferAttribute(this.mVertexBuffer, 3));\n\n        if (this.mNormalBuffer && this.mNormalBuffer.length > 0) {\n          geometry.setAttribute('normal', new BufferAttribute(this.mNormalBuffer, 3));\n        }\n\n        if (this.mColorBuffer && this.mColorBuffer.length > 0) {\n          geometry.setAttribute('color', new BufferAttribute(this.mColorBuffer, 4));\n        }\n\n        if (this.mTexCoordsBuffers[0] && this.mTexCoordsBuffers[0].length > 0) {\n          geometry.setAttribute('uv', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[0]), 2));\n        }\n\n        if (this.mTexCoordsBuffers[1] && this.mTexCoordsBuffers[1].length > 0) {\n          geometry.setAttribute('uv1', new BufferAttribute(new Float32Array(this.mTexCoordsBuffers[1]), 2));\n        }\n\n        if (this.mTangentBuffer && this.mTangentBuffer.length > 0) {\n          geometry.setAttribute('tangents', new BufferAttribute(this.mTangentBuffer, 3));\n        }\n\n        if (this.mBitangentBuffer && this.mBitangentBuffer.length > 0) {\n          geometry.setAttribute('bitangents', new BufferAttribute(this.mBitangentBuffer, 3));\n        }\n\n        if (this.mBones.length > 0) {\n          var weights = [];\n          var bones = [];\n\n          for (let i = 0; i < this.mBones.length; i++) {\n            for (let j = 0; j < this.mBones[i].mWeights.length; j++) {\n              var weight = this.mBones[i].mWeights[j];\n\n              if (weight) {\n                if (!weights[weight.mVertexId]) weights[weight.mVertexId] = [];\n                if (!bones[weight.mVertexId]) bones[weight.mVertexId] = [];\n                weights[weight.mVertexId].push(weight.mWeight);\n                bones[weight.mVertexId].push(parseInt(i));\n              }\n            }\n          }\n\n          for (let i in bones) {\n            sortWeights(bones[i], weights[i]);\n          }\n\n          var _weights = [];\n          var _bones = [];\n\n          for (let i = 0; i < weights.length; i++) {\n            for (let j = 0; j < 4; j++) {\n              if (weights[i] && bones[i]) {\n                _weights.push(weights[i][j]);\n\n                _bones.push(bones[i][j]);\n              } else {\n                _weights.push(0);\n\n                _bones.push(0);\n              }\n            }\n          }\n\n          geometry.setAttribute('skinWeight', new BufferAttribute(new Float32Array(_weights), BONESPERVERT));\n          geometry.setAttribute('skinIndex', new BufferAttribute(new Float32Array(_bones), BONESPERVERT));\n        }\n\n        var mesh;\n        if (this.mBones.length == 0) mesh = new Mesh(geometry, mat);\n\n        if (this.mBones.length > 0) {\n          mesh = new SkinnedMesh(geometry, mat);\n          mesh.normalizeSkinWeights();\n        }\n\n        this.threeNode = mesh; //mesh.matrixAutoUpdate = false;\n\n        return mesh;\n      };\n    }\n\n    function aiFace() {\n      this.mNumIndices = 0;\n      this.mIndices = [];\n    }\n\n    function aiVector3D() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n\n      this.toTHREE = function () {\n        return new Vector3(this.x, this.y, this.z);\n      };\n    }\n\n    function aiColor3D() {\n      this.r = 0;\n      this.g = 0;\n      this.b = 0;\n      this.a = 0;\n\n      this.toTHREE = function () {\n        return new Color(this.r, this.g, this.b);\n      };\n    }\n\n    function aiQuaternion() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      this.w = 0;\n\n      this.toTHREE = function () {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n      };\n    }\n\n    function aiVertexWeight() {\n      this.mVertexId = 0;\n      this.mWeight = 0;\n    }\n\n    function aiString() {\n      this.data = [];\n\n      this.toString = function () {\n        var str = '';\n        this.data.forEach(function (i) {\n          str += String.fromCharCode(i);\n        });\n        return str.replace(/[^\\x20-\\x7E]+/g, '');\n      };\n    }\n\n    function aiVectorKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiQuatKey() {\n      this.mTime = 0;\n      this.mValue = null;\n    }\n\n    function aiNode() {\n      this.mName = '';\n      this.mTransformation = [];\n      this.mNumChildren = 0;\n      this.mNumMeshes = 0;\n      this.mMeshes = [];\n      this.mChildren = [];\n\n      this.toTHREE = function (scene) {\n        if (this.threeNode) return this.threeNode;\n        var o = new Object3D();\n        o.name = this.mName;\n        o.matrix = this.mTransformation.toTHREE();\n\n        for (let i = 0; i < this.mChildren.length; i++) {\n          o.add(this.mChildren[i].toTHREE(scene));\n        }\n\n        for (let i = 0; i < this.mMeshes.length; i++) {\n          o.add(scene.mMeshes[this.mMeshes[i]].toTHREE(scene));\n        }\n\n        this.threeNode = o; //o.matrixAutoUpdate = false;\n\n        o.matrix.decompose(o.position, o.quaternion, o.scale);\n        return o;\n      };\n    }\n\n    function aiBone() {\n      this.mName = '';\n      this.mNumWeights = 0;\n      this.mOffsetMatrix = 0;\n    }\n\n    function aiMaterialProperty() {\n      this.mKey = '';\n      this.mSemantic = 0;\n      this.mIndex = 0;\n      this.mData = [];\n      this.mDataLength = 0;\n      this.mType = 0;\n\n      this.dataAsColor = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        var g = reader.getFloat32(4, true);\n        var b = reader.getFloat32(8, true); //var a = reader.getFloat32(12, true);\n\n        return new Color(r, g, b);\n      };\n\n      this.dataAsFloat = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return r;\n      };\n\n      this.dataAsBool = function () {\n        var array = new Uint8Array(this.mData).buffer;\n        var reader = new DataView(array);\n        var r = reader.getFloat32(0, true);\n        return !!r;\n      };\n\n      this.dataAsString = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        return s.toString();\n      };\n\n      this.dataAsMap = function () {\n        var s = new aiString();\n        s.data = this.mData;\n        var path = s.toString();\n        path = path.replace(/\\\\/g, '/');\n\n        if (path.indexOf('/') != -1) {\n          path = path.substr(path.lastIndexOf('/') + 1);\n        }\n\n        return textureLoader.load(path);\n      };\n    }\n\n    var namePropMapping = {\n      '?mat.name': 'name',\n      '$mat.shadingm': 'shading',\n      '$mat.twosided': 'twoSided',\n      '$mat.wireframe': 'wireframe',\n      '$clr.ambient': 'ambient',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'specular',\n      '$clr.emissive': 'emissive',\n      '$clr.transparent': 'transparent',\n      '$clr.reflective': 'reflect',\n      '$mat.shininess': 'shininess',\n      '$mat.reflectivity': 'reflectivity',\n      '$mat.refracti': 'refraction',\n      '$tex.file': 'map'\n    };\n    var nameTypeMapping = {\n      '?mat.name': 'string',\n      '$mat.shadingm': 'bool',\n      '$mat.twosided': 'bool',\n      '$mat.wireframe': 'bool',\n      '$clr.ambient': 'color',\n      '$clr.diffuse': 'color',\n      '$clr.specular': 'color',\n      '$clr.emissive': 'color',\n      '$clr.transparent': 'color',\n      '$clr.reflective': 'color',\n      '$mat.shininess': 'float',\n      '$mat.reflectivity': 'float',\n      '$mat.refracti': 'float',\n      '$tex.file': 'map'\n    };\n\n    function aiMaterial() {\n      this.mNumAllocated = 0;\n      this.mNumProperties = 0;\n      this.mProperties = [];\n\n      this.toTHREE = function () {\n        var mat = new MeshPhongMaterial();\n\n        for (let i = 0; i < this.mProperties.length; i++) {\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'float') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsFloat();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'color') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsColor();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'bool') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsBool();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'string') {\n            mat[namePropMapping[this.mProperties[i].mKey]] = this.mProperties[i].dataAsString();\n          }\n\n          if (nameTypeMapping[this.mProperties[i].mKey] == 'map') {\n            var prop = this.mProperties[i];\n            if (prop.mSemantic == aiTextureType_DIFFUSE) mat.map = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_NORMALS) mat.normalMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_LIGHTMAP) mat.lightMap = this.mProperties[i].dataAsMap();\n            if (prop.mSemantic == aiTextureType_OPACITY) mat.alphaMap = this.mProperties[i].dataAsMap();\n          }\n        }\n\n        mat.ambient.r = 0.53;\n        mat.ambient.g = 0.53;\n        mat.ambient.b = 0.53;\n        mat.color.r = 1;\n        mat.color.g = 1;\n        mat.color.b = 1;\n        return mat;\n      };\n    }\n\n    function veclerp(v1, v2, l) {\n      var v = new Vector3();\n      var lm1 = 1 - l;\n      v.x = v1.x * l + v2.x * lm1;\n      v.y = v1.y * l + v2.y * lm1;\n      v.z = v1.z * l + v2.z * lm1;\n      return v;\n    }\n\n    function quatlerp(q1, q2, l) {\n      return q1.clone().slerp(q2, 1 - l);\n    }\n\n    function sampleTrack(keys, time, lne, lerp) {\n      if (keys.length == 1) return keys[0].mValue.toTHREE();\n      var dist = Infinity;\n      var key = null;\n      var nextKey = null;\n\n      for (let i = 0; i < keys.length; i++) {\n        var timeDist = Math.abs(keys[i].mTime - time);\n\n        if (timeDist < dist && keys[i].mTime <= time) {\n          dist = timeDist;\n          key = keys[i];\n          nextKey = keys[i + 1];\n        }\n      }\n\n      if (!key) {\n        return null;\n      } else if (nextKey) {\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      } else {\n        nextKey = keys[0].clone();\n        nextKey.mTime += lne;\n        var dT = nextKey.mTime - key.mTime;\n        var T = key.mTime - time;\n        var l = T / dT;\n        return lerp(key.mValue.toTHREE(), nextKey.mValue.toTHREE(), l);\n      }\n    }\n\n    function aiNodeAnim() {\n      this.mNodeName = '';\n      this.mNumPositionKeys = 0;\n      this.mNumRotationKeys = 0;\n      this.mNumScalingKeys = 0;\n      this.mPositionKeys = [];\n      this.mRotationKeys = [];\n      this.mScalingKeys = [];\n      this.mPreState = '';\n      this.mPostState = '';\n\n      this.init = function (tps) {\n        if (!tps) tps = 1;\n\n        function t(t) {\n          t.mTime /= tps;\n        }\n\n        this.mPositionKeys.forEach(t);\n        this.mRotationKeys.forEach(t);\n        this.mScalingKeys.forEach(t);\n      };\n\n      this.sortKeys = function () {\n        function comp(a, b) {\n          return a.mTime - b.mTime;\n        }\n\n        this.mPositionKeys.sort(comp);\n        this.mRotationKeys.sort(comp);\n        this.mScalingKeys.sort(comp);\n      };\n\n      this.getLength = function () {\n        return Math.max(Math.max.apply(null, this.mPositionKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mRotationKeys.map(function (a) {\n          return a.mTime;\n        })), Math.max.apply(null, this.mScalingKeys.map(function (a) {\n          return a.mTime;\n        })));\n      };\n\n      this.toTHREE = function (o) {\n        this.sortKeys();\n        var length = this.getLength();\n        var track = new Virtulous.KeyFrameTrack();\n\n        for (let i = 0; i < length; i += 0.05) {\n          var matrix = new Matrix4();\n          var time = i;\n          var pos = sampleTrack(this.mPositionKeys, time, length, veclerp);\n          var scale = sampleTrack(this.mScalingKeys, time, length, veclerp);\n          var rotation = sampleTrack(this.mRotationKeys, time, length, quatlerp);\n          matrix.compose(pos, rotation, scale);\n          var key = new Virtulous.KeyFrame(time, matrix);\n          track.addKey(key);\n        }\n\n        track.target = o.findNode(this.mNodeName).toTHREE();\n        var tracks = [track];\n\n        if (o.nodeToBoneMap[this.mNodeName]) {\n          for (let i = 0; i < o.nodeToBoneMap[this.mNodeName].length; i++) {\n            var t2 = track.clone();\n            t2.target = o.nodeToBoneMap[this.mNodeName][i];\n            tracks.push(t2);\n          }\n        }\n\n        return tracks;\n      };\n    }\n\n    function aiAnimation() {\n      this.mName = '';\n      this.mDuration = 0;\n      this.mTicksPerSecond = 0;\n      this.mNumChannels = 0;\n      this.mChannels = [];\n\n      this.toTHREE = function (root) {\n        var animationHandle = new Virtulous.Animation();\n\n        for (let i in this.mChannels) {\n          this.mChannels[i].init(this.mTicksPerSecond);\n          var tracks = this.mChannels[i].toTHREE(root);\n\n          for (let j in tracks) {\n            tracks[j].init();\n            animationHandle.addTrack(tracks[j]);\n          }\n        }\n\n        animationHandle.length = Math.max.apply(null, animationHandle.tracks.map(function (e) {\n          return e.length;\n        }));\n        return animationHandle;\n      };\n    }\n\n    function aiTexture() {\n      this.mWidth = 0;\n      this.mHeight = 0;\n      this.texAchFormatHint = [];\n      this.pcData = [];\n    }\n\n    function aiLight() {\n      this.mName = '';\n      this.mType = 0;\n      this.mAttenuationConstant = 0;\n      this.mAttenuationLinear = 0;\n      this.mAttenuationQuadratic = 0;\n      this.mAngleInnerCone = 0;\n      this.mAngleOuterCone = 0;\n      this.mColorDiffuse = null;\n      this.mColorSpecular = null;\n      this.mColorAmbient = null;\n    }\n\n    function aiCamera() {\n      this.mName = '';\n      this.mPosition = null;\n      this.mLookAt = null;\n      this.mUp = null;\n      this.mHorizontalFOV = 0;\n      this.mClipPlaneNear = 0;\n      this.mClipPlaneFar = 0;\n      this.mAspect = 0;\n    }\n\n    function aiScene() {\n      this.versionMajor = 0;\n      this.versionMinor = 0;\n      this.versionRevision = 0;\n      this.compileFlags = 0;\n      this.mFlags = 0;\n      this.mNumMeshes = 0;\n      this.mNumMaterials = 0;\n      this.mNumAnimations = 0;\n      this.mNumTextures = 0;\n      this.mNumLights = 0;\n      this.mNumCameras = 0;\n      this.mRootNode = null;\n      this.mMeshes = [];\n      this.mMaterials = [];\n      this.mAnimations = [];\n      this.mLights = [];\n      this.mCameras = [];\n      this.nodeToBoneMap = {};\n\n      this.findNode = function (name, root) {\n        if (!root) {\n          root = this.mRootNode;\n        }\n\n        if (root.mName == name) {\n          return root;\n        }\n\n        for (let i = 0; i < root.mChildren.length; i++) {\n          var ret = this.findNode(name, root.mChildren[i]);\n          if (ret) return ret;\n        }\n\n        return null;\n      };\n\n      this.toTHREE = function () {\n        this.nodeCount = 0;\n        markBones(this);\n        var o = this.mRootNode.toTHREE(this);\n\n        for (let i in this.mMeshes) this.mMeshes[i].hookupSkeletons(this);\n\n        if (this.mAnimations.length > 0) {\n          var a = this.mAnimations[0].toTHREE(this);\n        }\n\n        return {\n          object: o,\n          animation: a\n        };\n      };\n    }\n\n    function aiMatrix4() {\n      this.elements = [[], [], [], []];\n\n      this.toTHREE = function () {\n        var m = new Matrix4();\n\n        for (let i = 0; i < 4; ++i) {\n          for (let i2 = 0; i2 < 4; ++i2) {\n            m.elements[i * 4 + i2] = this.elements[i2][i];\n          }\n        }\n\n        return m;\n      };\n    }\n\n    var littleEndian = true;\n\n    function readFloat(dataview) {\n      var val = dataview.getFloat32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_double(dataview) {\n      var val = dataview.getFloat64(dataview.readOffset, littleEndian);\n      dataview.readOffset += 8;\n      return val;\n    }\n\n    function Read_uint8_t(dataview) {\n      var val = dataview.getUint8(dataview.readOffset);\n      dataview.readOffset += 1;\n      return val;\n    }\n\n    function Read_uint16_t(dataview) {\n      var val = dataview.getUint16(dataview.readOffset, littleEndian);\n      dataview.readOffset += 2;\n      return val;\n    }\n\n    function Read_unsigned_int(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_uint32_t(dataview) {\n      var val = dataview.getUint32(dataview.readOffset, littleEndian);\n      dataview.readOffset += 4;\n      return val;\n    }\n\n    function Read_aiVector3D(stream) {\n      var v = new aiVector3D();\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiColor3D(stream) {\n      var c = new aiColor3D();\n      c.r = readFloat(stream);\n      c.g = readFloat(stream);\n      c.b = readFloat(stream);\n      return c;\n    }\n\n    function Read_aiQuaternion(stream) {\n      var v = new aiQuaternion();\n      v.w = readFloat(stream);\n      v.x = readFloat(stream);\n      v.y = readFloat(stream);\n      v.z = readFloat(stream);\n      return v;\n    }\n\n    function Read_aiString(stream) {\n      var s = new aiString();\n      var stringlengthbytes = Read_unsigned_int(stream);\n      stream.ReadBytes(s.data, 1, stringlengthbytes);\n      return s.toString();\n    }\n\n    function Read_aiVertexWeight(stream) {\n      var w = new aiVertexWeight();\n      w.mVertexId = Read_unsigned_int(stream);\n      w.mWeight = readFloat(stream);\n      return w;\n    }\n\n    function Read_aiMatrix4x4(stream) {\n      var m = new aiMatrix4();\n\n      for (let i = 0; i < 4; ++i) {\n        for (let i2 = 0; i2 < 4; ++i2) {\n          m.elements[i][i2] = readFloat(stream);\n        }\n      }\n\n      return m;\n    }\n\n    function Read_aiVectorKey(stream) {\n      var v = new aiVectorKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiVector3D(stream);\n      return v;\n    }\n\n    function Read_aiQuatKey(stream) {\n      var v = new aiQuatKey();\n      v.mTime = Read_double(stream);\n      v.mValue = Read_aiQuaternion(stream);\n      return v;\n    }\n\n    function ReadArray_aiVertexWeight(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVertexWeight(stream);\n    }\n\n    function ReadArray_aiVectorKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiVectorKey(stream);\n    }\n\n    function ReadArray_aiQuatKey(stream, data, size) {\n      for (let i = 0; i < size; i++) data[i] = Read_aiQuatKey(stream);\n    }\n\n    function ReadBounds(stream, T\n    /*p*/\n    , n) {\n      // not sure what to do here, the data isn't really useful.\n      return stream.Seek(sizeof(T) * n, aiOrigin_CUR); // eslint-disable-line no-undef\n    }\n\n    function ai_assert(bool) {\n      if (!bool) throw 'asset failed';\n    }\n\n    function ReadBinaryNode(stream, parent, depth) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      var node = new aiNode();\n      node.mParent = parent;\n      node.mDepth = depth;\n      node.mName = Read_aiString(stream);\n      node.mTransformation = Read_aiMatrix4x4(stream);\n      node.mNumChildren = Read_unsigned_int(stream);\n      node.mNumMeshes = Read_unsigned_int(stream);\n\n      if (node.mNumMeshes) {\n        node.mMeshes = [];\n\n        for (let i = 0; i < node.mNumMeshes; ++i) {\n          node.mMeshes[i] = Read_unsigned_int(stream);\n        }\n      }\n\n      if (node.mNumChildren) {\n        node.mChildren = [];\n\n        for (let i = 0; i < node.mNumChildren; ++i) {\n          var node2 = ReadBinaryNode(stream, node, depth++);\n          node.mChildren[i] = node2;\n        }\n      }\n\n      return node;\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryBone(stream, b) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIBONE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      b.mName = Read_aiString(stream);\n      b.mNumWeights = Read_unsigned_int(stream);\n      b.mOffsetMatrix = Read_aiMatrix4x4(stream); // for the moment we write dumb min/max values for the bones, too.\n      // maybe I'll add a better, hash-like solution later\n\n      if (shortened) {\n        ReadBounds(stream, b.mWeights, b.mNumWeights);\n      } else {\n        // else write as usual\n        b.mWeights = [];\n        ReadArray_aiVertexWeight(stream, b.mWeights, b.mNumWeights);\n      }\n\n      return b;\n    }\n\n    function ReadBinaryMesh(stream, mesh) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMESH);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mesh.mPrimitiveTypes = Read_unsigned_int(stream);\n      mesh.mNumVertices = Read_unsigned_int(stream);\n      mesh.mNumFaces = Read_unsigned_int(stream);\n      mesh.mNumBones = Read_unsigned_int(stream);\n      mesh.mMaterialIndex = Read_unsigned_int(stream);\n      mesh.mNumUVComponents = []; // first of all, write bits for all existent vertex components\n\n      var c = Read_unsigned_int(stream);\n\n      if (c & ASSBIN_MESH_HAS_POSITIONS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mVertices, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mVertices = [];\n          mesh.mVertexBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_NORMALS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mNormals, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mNormals = [];\n          mesh.mNormalBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      if (c & ASSBIN_MESH_HAS_TANGENTS_AND_BITANGENTS) {\n        if (shortened) {\n          ReadBounds(stream, mesh.mTangents, mesh.mNumVertices);\n          ReadBounds(stream, mesh.mBitangents, mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTangents = [];\n          mesh.mTangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n          mesh.mBitangents = [];\n          mesh.mBitangentBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 3 * 4);\n          stream.Seek(mesh.mNumVertices * 3 * 4, aiOrigin_CUR);\n        }\n      }\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_COLOR_SETS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_COLOR(n))) break;\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mColors[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mColors[n] = [];\n          mesh.mColorBuffer = stream.subArray32(stream.readOffset, stream.readOffset + mesh.mNumVertices * 4 * 4);\n          stream.Seek(mesh.mNumVertices * 4 * 4, aiOrigin_CUR);\n        }\n      }\n\n      mesh.mTexCoordsBuffers = [];\n\n      for (let n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++n) {\n        if (!(c & ASSBIN_MESH_HAS_TEXCOORD(n))) break; // write number of UV components\n\n        mesh.mNumUVComponents[n] = Read_unsigned_int(stream);\n\n        if (shortened) {\n          ReadBounds(stream, mesh.mTextureCoords[n], mesh.mNumVertices);\n        } else {\n          // else write as usual\n          mesh.mTextureCoords[n] = []; //note that assbin always writes 3d texcoords\n\n          mesh.mTexCoordsBuffers[n] = [];\n\n          for (let uv = 0; uv < mesh.mNumVertices; uv++) {\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            mesh.mTexCoordsBuffers[n].push(readFloat(stream));\n            readFloat(stream);\n          }\n        }\n      } // write faces. There are no floating-point calculations involved\n      // in these, so we can write a simple hash over the face data\n      // to the dump file. We generate a single 32 Bit hash for 512 faces\n      // using Assimp's standard hashing function.\n\n\n      if (shortened) {\n        Read_unsigned_int(stream);\n      } else {\n        // else write as usual\n        // if there are less than 2^16 vertices, we can simply use 16 bit integers ...\n        mesh.mFaces = [];\n        mesh.mIndexArray = [];\n\n        for (let i = 0; i < mesh.mNumFaces; ++i) {\n          var f = mesh.mFaces[i] = new aiFace(); // BOOST_STATIC_ASSERT(AI_MAX_FACE_INDICES <= 0xffff);\n\n          f.mNumIndices = Read_uint16_t(stream);\n          f.mIndices = [];\n\n          for (let a = 0; a < f.mNumIndices; ++a) {\n            if (mesh.mNumVertices < 1 << 16) {\n              f.mIndices[a] = Read_uint16_t(stream);\n            } else {\n              f.mIndices[a] = Read_unsigned_int(stream);\n            }\n          }\n\n          if (f.mNumIndices === 3) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n          } else if (f.mNumIndices === 4) {\n            mesh.mIndexArray.push(f.mIndices[0]);\n            mesh.mIndexArray.push(f.mIndices[1]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[2]);\n            mesh.mIndexArray.push(f.mIndices[3]);\n            mesh.mIndexArray.push(f.mIndices[0]);\n          } else {\n            throw new Error(\"Sorry, can't currently triangulate polys. Use the triangulate preprocessor in Assimp.\");\n          }\n        }\n      } // write bones\n\n\n      if (mesh.mNumBones) {\n        mesh.mBones = [];\n\n        for (let a = 0; a < mesh.mNumBones; ++a) {\n          mesh.mBones[a] = new aiBone();\n          ReadBinaryBone(stream, mesh.mBones[a]);\n        }\n      }\n    }\n\n    function ReadBinaryMaterialProperty(stream, prop) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIALPROPERTY);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      prop.mKey = Read_aiString(stream);\n      prop.mSemantic = Read_unsigned_int(stream);\n      prop.mIndex = Read_unsigned_int(stream);\n      prop.mDataLength = Read_unsigned_int(stream);\n      prop.mType = Read_unsigned_int(stream);\n      prop.mData = [];\n      stream.ReadBytes(prop.mData, 1, prop.mDataLength);\n    } // -----------------------------------------------------------------------------------\n\n\n    function ReadBinaryMaterial(stream, mat) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIMATERIAL);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      mat.mNumAllocated = mat.mNumProperties = Read_unsigned_int(stream);\n\n      if (mat.mNumProperties) {\n        if (mat.mProperties) {\n          delete mat.mProperties;\n        }\n\n        mat.mProperties = [];\n\n        for (let i = 0; i < mat.mNumProperties; ++i) {\n          mat.mProperties[i] = new aiMaterialProperty();\n          ReadBinaryMaterialProperty(stream, mat.mProperties[i]);\n        }\n      }\n    }\n\n    function ReadBinaryNodeAnim(stream, nd) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AINODEANIM);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      nd.mNodeName = Read_aiString(stream);\n      nd.mNumPositionKeys = Read_unsigned_int(stream);\n      nd.mNumRotationKeys = Read_unsigned_int(stream);\n      nd.mNumScalingKeys = Read_unsigned_int(stream);\n      nd.mPreState = Read_unsigned_int(stream);\n      nd.mPostState = Read_unsigned_int(stream);\n\n      if (nd.mNumPositionKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        } else {\n          // else write as usual\n          nd.mPositionKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mPositionKeys, nd.mNumPositionKeys);\n        }\n      }\n\n      if (nd.mNumRotationKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        } else {\n          // else write as usual\n          nd.mRotationKeys = [];\n          ReadArray_aiQuatKey(stream, nd.mRotationKeys, nd.mNumRotationKeys);\n        }\n      }\n\n      if (nd.mNumScalingKeys) {\n        if (shortened) {\n          ReadBounds(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        } else {\n          // else write as usual\n          nd.mScalingKeys = [];\n          ReadArray_aiVectorKey(stream, nd.mScalingKeys, nd.mNumScalingKeys);\n        }\n      }\n    }\n\n    function ReadBinaryAnim(stream, anim) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AIANIMATION);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      anim.mName = Read_aiString(stream);\n      anim.mDuration = Read_double(stream);\n      anim.mTicksPerSecond = Read_double(stream);\n      anim.mNumChannels = Read_unsigned_int(stream);\n\n      if (anim.mNumChannels) {\n        anim.mChannels = [];\n\n        for (let a = 0; a < anim.mNumChannels; ++a) {\n          anim.mChannels[a] = new aiNodeAnim();\n          ReadBinaryNodeAnim(stream, anim.mChannels[a]);\n        }\n      }\n    }\n\n    function ReadBinaryTexture(stream, tex) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AITEXTURE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      tex.mWidth = Read_unsigned_int(stream);\n      tex.mHeight = Read_unsigned_int(stream);\n      stream.ReadBytes(tex.achFormatHint, 1, 4);\n\n      if (!shortened) {\n        if (!tex.mHeight) {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth);\n        } else {\n          tex.pcData = [];\n          stream.ReadBytes(tex.pcData, 1, tex.mWidth * tex.mHeight * 4);\n        }\n      }\n    }\n\n    function ReadBinaryLight(stream, l) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AILIGHT);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      l.mName = Read_aiString(stream);\n      l.mType = Read_unsigned_int(stream);\n\n      if (l.mType != aiLightSource_DIRECTIONAL) {\n        l.mAttenuationConstant = readFloat(stream);\n        l.mAttenuationLinear = readFloat(stream);\n        l.mAttenuationQuadratic = readFloat(stream);\n      }\n\n      l.mColorDiffuse = Read_aiColor3D(stream);\n      l.mColorSpecular = Read_aiColor3D(stream);\n      l.mColorAmbient = Read_aiColor3D(stream);\n\n      if (l.mType == aiLightSource_SPOT) {\n        l.mAngleInnerCone = readFloat(stream);\n        l.mAngleOuterCone = readFloat(stream);\n      }\n    }\n\n    function ReadBinaryCamera(stream, cam) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AICAMERA);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      cam.mName = Read_aiString(stream);\n      cam.mPosition = Read_aiVector3D(stream);\n      cam.mLookAt = Read_aiVector3D(stream);\n      cam.mUp = Read_aiVector3D(stream);\n      cam.mHorizontalFOV = readFloat(stream);\n      cam.mClipPlaneNear = readFloat(stream);\n      cam.mClipPlaneFar = readFloat(stream);\n      cam.mAspect = readFloat(stream);\n    }\n\n    function ReadBinaryScene(stream, scene) {\n      var chunkID = Read_uint32_t(stream);\n      ai_assert(chunkID == ASSBIN_CHUNK_AISCENE);\n      /*uint32_t size =*/\n\n      Read_uint32_t(stream);\n      scene.mFlags = Read_unsigned_int(stream);\n      scene.mNumMeshes = Read_unsigned_int(stream);\n      scene.mNumMaterials = Read_unsigned_int(stream);\n      scene.mNumAnimations = Read_unsigned_int(stream);\n      scene.mNumTextures = Read_unsigned_int(stream);\n      scene.mNumLights = Read_unsigned_int(stream);\n      scene.mNumCameras = Read_unsigned_int(stream); // Read node graph\n\n      scene.mRootNode = new aiNode();\n      scene.mRootNode = ReadBinaryNode(stream, null, 0); // Read all meshes\n\n      if (scene.mNumMeshes) {\n        scene.mMeshes = [];\n\n        for (let i = 0; i < scene.mNumMeshes; ++i) {\n          scene.mMeshes[i] = new aiMesh();\n          ReadBinaryMesh(stream, scene.mMeshes[i]);\n        }\n      } // Read materials\n\n\n      if (scene.mNumMaterials) {\n        scene.mMaterials = [];\n\n        for (let i = 0; i < scene.mNumMaterials; ++i) {\n          scene.mMaterials[i] = new aiMaterial();\n          ReadBinaryMaterial(stream, scene.mMaterials[i]);\n        }\n      } // Read all animations\n\n\n      if (scene.mNumAnimations) {\n        scene.mAnimations = [];\n\n        for (let i = 0; i < scene.mNumAnimations; ++i) {\n          scene.mAnimations[i] = new aiAnimation();\n          ReadBinaryAnim(stream, scene.mAnimations[i]);\n        }\n      } // Read all textures\n\n\n      if (scene.mNumTextures) {\n        scene.mTextures = [];\n\n        for (let i = 0; i < scene.mNumTextures; ++i) {\n          scene.mTextures[i] = new aiTexture();\n          ReadBinaryTexture(stream, scene.mTextures[i]);\n        }\n      } // Read lights\n\n\n      if (scene.mNumLights) {\n        scene.mLights = [];\n\n        for (let i = 0; i < scene.mNumLights; ++i) {\n          scene.mLights[i] = new aiLight();\n          ReadBinaryLight(stream, scene.mLights[i]);\n        }\n      } // Read cameras\n\n\n      if (scene.mNumCameras) {\n        scene.mCameras = [];\n\n        for (let i = 0; i < scene.mNumCameras; ++i) {\n          scene.mCameras[i] = new aiCamera();\n          ReadBinaryCamera(stream, scene.mCameras[i]);\n        }\n      }\n    }\n\n    var aiOrigin_CUR = 0;\n    var aiOrigin_BEG = 1;\n\n    function extendStream(stream) {\n      stream.readOffset = 0;\n\n      stream.Seek = function (off, ori) {\n        if (ori == aiOrigin_CUR) {\n          stream.readOffset += off;\n        }\n\n        if (ori == aiOrigin_BEG) {\n          stream.readOffset = off;\n        }\n      };\n\n      stream.ReadBytes = function (buff, size, n) {\n        var bytes = size * n;\n\n        for (let i = 0; i < bytes; i++) buff[i] = Read_uint8_t(this);\n      };\n\n      stream.subArray32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Float32Array(newbuff);\n      };\n\n      stream.subArrayUint16 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint16Array(newbuff);\n      };\n\n      stream.subArrayUint8 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint8Array(newbuff);\n      };\n\n      stream.subArrayUint32 = function (start, end) {\n        var buff = this.buffer;\n        var newbuff = buff.slice(start, end);\n        return new Uint32Array(newbuff);\n      };\n    }\n\n    var shortened, compressed;\n\n    function InternReadFile(pFiledata) {\n      var pScene = new aiScene();\n      var stream = new DataView(pFiledata);\n      extendStream(stream);\n      stream.Seek(44, aiOrigin_CUR); // signature\n\n      /*unsigned int versionMajor =*/\n\n      pScene.versionMajor = Read_unsigned_int(stream);\n      /*unsigned int versionMinor =*/\n\n      pScene.versionMinor = Read_unsigned_int(stream);\n      /*unsigned int versionRevision =*/\n\n      pScene.versionRevision = Read_unsigned_int(stream);\n      /*unsigned int compileFlags =*/\n\n      pScene.compileFlags = Read_unsigned_int(stream);\n      shortened = Read_uint16_t(stream) > 0;\n      compressed = Read_uint16_t(stream) > 0;\n      if (shortened) throw 'Shortened binaries are not supported!';\n      stream.Seek(256, aiOrigin_CUR); // original filename\n\n      stream.Seek(128, aiOrigin_CUR); // options\n\n      stream.Seek(64, aiOrigin_CUR); // padding\n\n      if (compressed) {\n        var uncompressedSize = Read_uint32_t(stream);\n        var compressedSize = stream.FileSize() - stream.Tell();\n        var compressedData = [];\n        stream.Read(compressedData, 1, compressedSize);\n        var uncompressedData = [];\n        uncompress(uncompressedData, uncompressedSize, compressedData, compressedSize); // eslint-disable-line no-undef\n\n        var buff = new ArrayBuffer(uncompressedData);\n        ReadBinaryScene(buff, pScene);\n      } else {\n        ReadBinaryScene(stream, pScene);\n      }\n\n      return pScene.toTHREE();\n    }\n\n    return InternReadFile(buffer);\n  }\n});\n\nexport { AssimpLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}