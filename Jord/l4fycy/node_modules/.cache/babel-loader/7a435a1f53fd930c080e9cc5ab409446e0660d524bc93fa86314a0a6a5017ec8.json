{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { Vector3, Color, Vector2, Mesh, Line, Points, Matrix3, BufferAttribute } from \"three\";\nclass OBJExporter {\n  constructor() {\n    __publicField(this, \"output\");\n    __publicField(this, \"indexVertex\");\n    __publicField(this, \"indexVertexUvs\");\n    __publicField(this, \"indexNormals\");\n    __publicField(this, \"vertex\");\n    __publicField(this, \"color\");\n    __publicField(this, \"normal\");\n    __publicField(this, \"uv\");\n    __publicField(this, \"face\");\n    this.output = \"\";\n    this.indexVertex = 0;\n    this.indexVertexUvs = 0;\n    this.indexNormals = 0;\n    this.vertex = new Vector3();\n    this.color = new Color();\n    this.normal = new Vector3();\n    this.uv = new Vector2();\n    this.face = [];\n  }\n  parse(object) {\n    object.traverse(child => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child);\n      }\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child);\n      }\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child);\n      }\n    });\n    return this.output;\n  }\n  parseMesh(mesh) {\n    let nbVertex = 0;\n    let nbNormals = 0;\n    let nbVertexUvs = 0;\n    const geometry = mesh.geometry;\n    const normalMatrixWorld = new Matrix3();\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const normals = geometry.getAttribute(\"normal\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const indices = geometry.getIndex();\n    this.output += \"o \".concat(mesh.name, \"\\n\");\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += \"usemtl \".concat(mesh.material.name, \"\\n\");\n    }\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(mesh.matrixWorld);\n        this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n      }\n    }\n    if (uvs !== void 0) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i);\n        this.uv.y = uvs.getY(i);\n        this.output += \"vt \".concat(this.uv.x, \" \").concat(this.uv.y, \"\\n\");\n      }\n    }\n    if (normals !== void 0) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld);\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i);\n        this.normal.y = normals.getY(i);\n        this.normal.z = normals.getZ(i);\n        this.normal.applyMatrix3(normalMatrixWorld).normalize();\n        this.output += \"vn \".concat(this.normal.x, \" \").concat(this.normal.y, \" \").concat(this.normal.z, \"\\n\");\n      }\n    }\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + j : \"\").concat(normals ? \"/\".concat(this.indexNormals + j) : \"\") : \"\");\n        }\n        this.output += \"f \".concat(this.face.join(\" \"), \"\\n\");\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1;\n          this.face[m] = this.indexVertex + j + (normals || uvs ? \"/\".concat(uvs ? this.indexVertexUvs + j : \"\").concat(normals ? \"/\".concat(this.indexNormals + j) : \"\") : \"\");\n        }\n        this.output += \"f \".concat(this.face.join(\" \"), \"\\n\");\n      }\n    }\n    this.indexVertex += nbVertex;\n    this.indexVertexUvs += nbVertexUvs;\n    this.indexNormals += nbNormals;\n  }\n  parseLine(line) {\n    let nbVertex = 0;\n    const geometry = line.geometry;\n    const type = line.type;\n    if (geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    this.output += \"o \".concat(line.name, \"\\n\");\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i);\n        this.vertex.y = vertices.getY(i);\n        this.vertex.z = vertices.getZ(i);\n        this.vertex.applyMatrix4(line.matrixWorld);\n        this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z, \"\\n\");\n      }\n    }\n    if (type === \"Line\") {\n      this.output += \"l \";\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += \"\".concat(this.indexVertex + j, \" \");\n      }\n      this.output += \"\\n\";\n    }\n    if (type === \"LineSegments\") {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += \"l \".concat(this.indexVertex + j, \" \").concat(this.indexVertex + k, \"\\n\");\n      }\n    }\n    this.indexVertex += nbVertex;\n  }\n  parsePoints(points) {\n    let nbVertex = 0;\n    const geometry = points.geometry;\n    if (!geometry.isBufferGeometry) {\n      throw new Error(\"THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.\");\n    }\n    const vertices = geometry.getAttribute(\"position\");\n    const colors = geometry.getAttribute(\"color\");\n    this.output += \"o \".concat(points.name, \"\\n\");\n    if (vertices !== void 0) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i);\n        this.vertex.applyMatrix4(points.matrixWorld);\n        this.output += \"v \".concat(this.vertex.x, \" \").concat(this.vertex.y, \" \").concat(this.vertex.z);\n        if (colors !== void 0 && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i);\n          this.output += \" \".concat(this.color.r, \" \").concat(this.color.g, \" \").concat(this.color.b);\n        }\n        this.output += \"\\n\";\n      }\n    }\n    this.output += \"p \";\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += \"\".concat(this.indexVertex + j, \" \");\n    }\n    this.output += \"\\n\";\n    this.indexVertex += nbVertex;\n  }\n}\nexport { OBJExporter };","map":{"version":3,"names":["OBJExporter","constructor","__publicField","output","indexVertex","indexVertexUvs","indexNormals","vertex","Vector3","color","Color","normal","uv","Vector2","face","parse","object","traverse","child","Mesh","isMesh","parseMesh","Line","isLine","parseLine","Points","isPoints","parsePoints","mesh","nbVertex","nbNormals","nbVertexUvs","geometry","normalMatrixWorld","Matrix3","isBufferGeometry","Error","vertices","getAttribute","normals","uvs","indices","getIndex","concat","name","material","Array","isArray","i","l","count","x","getX","y","getY","z","getZ","applyMatrix4","matrixWorld","getNormalMatrix","applyMatrix3","normalize","m","j","join","line","type","k","points","colors","fromBufferAttribute","BufferAttribute","r","g","b"],"sources":["D:\\Repos\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\src\\exporters\\OBJExporter.ts"],"sourcesContent":["import { BufferAttribute, Color, Line, Matrix3, Mesh, Object3D, Points, Vector2, Vector3 } from 'three'\n\nclass OBJExporter {\n  private output\n\n  private indexVertex\n  private indexVertexUvs\n  private indexNormals\n\n  private vertex\n  private color\n  private normal\n  private uv\n\n  private face: string[]\n\n  constructor() {\n    this.output = ''\n\n    this.indexVertex = 0\n    this.indexVertexUvs = 0\n    this.indexNormals = 0\n\n    this.vertex = new Vector3()\n    this.color = new Color()\n    this.normal = new Vector3()\n    this.uv = new Vector2()\n\n    this.face = []\n  }\n\n  public parse(object: Object3D): string {\n    object.traverse((child) => {\n      if (child instanceof Mesh && child.isMesh) {\n        this.parseMesh(child)\n      }\n\n      if (child instanceof Line && child.isLine) {\n        this.parseLine(child)\n      }\n\n      if (child instanceof Points && child.isPoints) {\n        this.parsePoints(child)\n      }\n    })\n\n    return this.output\n  }\n\n  private parseMesh(mesh: Mesh): void {\n    let nbVertex = 0\n    let nbNormals = 0\n    let nbVertexUvs = 0\n\n    const geometry = mesh.geometry\n\n    const normalMatrixWorld = new Matrix3()\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n    const normals = geometry.getAttribute('normal')\n    const uvs = geometry.getAttribute('uv')\n    const indices = geometry.getIndex()\n\n    // name of the mesh object\n    this.output += `o ${mesh.name}\\n`\n\n    // name of the mesh material\n    if (mesh.material && !Array.isArray(mesh.material) && mesh.material.name) {\n      this.output += `usemtl ${mesh.material.name}\\n`\n    }\n\n    // vertices\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(mesh.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    // uvs\n\n    if (uvs !== undefined) {\n      for (let i = 0, l = uvs.count; i < l; i++, nbVertexUvs++) {\n        this.uv.x = uvs.getX(i)\n        this.uv.y = uvs.getY(i)\n\n        // transform the uv to export format\n        this.output += `vt ${this.uv.x} ${this.uv.y}\\n`\n      }\n    }\n\n    // normals\n\n    if (normals !== undefined) {\n      normalMatrixWorld.getNormalMatrix(mesh.matrixWorld)\n\n      for (let i = 0, l = normals.count; i < l; i++, nbNormals++) {\n        this.normal.x = normals.getX(i)\n        this.normal.y = normals.getY(i)\n        this.normal.z = normals.getZ(i)\n\n        // transform the normal to world space\n        this.normal.applyMatrix3(normalMatrixWorld).normalize()\n\n        // transform the normal to export format\n        this.output += `vn ${this.normal.x} ${this.normal.y} ${this.normal.z}\\n`\n      }\n    }\n\n    // faces\n\n    if (indices !== null) {\n      for (let i = 0, l = indices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = indices.getX(i + m) + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    } else {\n      for (let i = 0, l = vertices.count; i < l; i += 3) {\n        for (let m = 0; m < 3; m++) {\n          const j = i + m + 1\n\n          this.face[m] =\n            this.indexVertex +\n            j +\n            (normals || uvs\n              ? `/${uvs ? this.indexVertexUvs + j : ''}${normals ? `/${this.indexNormals + j}` : ''}`\n              : '')\n        }\n\n        // transform the face to export format\n        this.output += `f ${this.face.join(' ')}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n    this.indexVertexUvs += nbVertexUvs\n    this.indexNormals += nbNormals\n  }\n\n  private parseLine(line: Line): void {\n    let nbVertex = 0\n\n    const geometry = line.geometry\n    const type = line.type\n\n    if (geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    // shortcuts\n    const vertices = geometry.getAttribute('position')\n\n    // name of the line object\n    this.output += `o ${line.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.x = vertices.getX(i)\n        this.vertex.y = vertices.getY(i)\n        this.vertex.z = vertices.getZ(i)\n\n        // transform the vertex to world space\n        this.vertex.applyMatrix4(line.matrixWorld)\n\n        // transform the vertex to export format\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}\\n`\n      }\n    }\n\n    if (type === 'Line') {\n      this.output += 'l '\n\n      for (let j = 1, l = vertices.count; j <= l; j++) {\n        this.output += `${this.indexVertex + j} `\n      }\n\n      this.output += '\\n'\n    }\n\n    if (type === 'LineSegments') {\n      for (let j = 1, k = j + 1, l = vertices.count; j < l; j += 2, k = j + 1) {\n        this.output += `l ${this.indexVertex + j} ${this.indexVertex + k}\\n`\n      }\n    }\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n\n  private parsePoints(points: Points): void {\n    let nbVertex = 0\n\n    const geometry = points.geometry\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.')\n    }\n\n    const vertices = geometry.getAttribute('position')\n    const colors = geometry.getAttribute('color')\n\n    this.output += `o ${points.name}\\n`\n\n    if (vertices !== undefined) {\n      for (let i = 0, l = vertices.count; i < l; i++, nbVertex++) {\n        this.vertex.fromBufferAttribute(vertices, i)\n        this.vertex.applyMatrix4(points.matrixWorld)\n\n        this.output += `v ${this.vertex.x} ${this.vertex.y} ${this.vertex.z}`\n\n        if (colors !== undefined && colors instanceof BufferAttribute) {\n          this.color.fromBufferAttribute(colors, i)\n\n          this.output += ` ${this.color.r} ${this.color.g} ${this.color.b}`\n        }\n\n        this.output += '\\n'\n      }\n    }\n\n    this.output += 'p '\n\n    for (let j = 1, l = vertices.count; j <= l; j++) {\n      this.output += `${this.indexVertex + j} `\n    }\n\n    this.output += '\\n'\n\n    // update index\n    this.indexVertex += nbVertex\n  }\n}\n\nexport { OBJExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}