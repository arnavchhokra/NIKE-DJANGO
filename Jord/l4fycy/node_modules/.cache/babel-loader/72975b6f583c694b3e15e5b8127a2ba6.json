{"ast":null,"code":"import { Mesh, MathUtils } from 'three';\n\nvar MorphBlendMesh = function MorphBlendMesh(geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function createAnimation(name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function autoCreateAnimations(fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n        frameRanges = {};\n    var i = 0;\n\n    for (var key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (var _name in frameRanges) {\n      var range = frameRanges[_name];\n      this.createAnimation(_name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function setAnimationDirectionForward(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function setAnimationDirectionBackward(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function setAnimationFPS(name, fps) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function setAnimationDuration(name, duration) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function setAnimationWeight(name, weight) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function setAnimationTime(name, time) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function getAnimationTime(name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  },\n  getAnimationDuration: function getAnimationDuration(name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  },\n  playAnimation: function playAnimation(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function stopAnimation(name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function update(delta) {\n    for (var i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\nexport { MorphBlendMesh };","map":{"version":3,"names":["Mesh","MathUtils","MorphBlendMesh","geometry","material","call","animationsMap","animationsList","numFrames","Object","keys","morphTargetDictionary","length","name","startFrame","endFrame","fps","createAnimation","setAnimationWeight","prototype","assign","create","constructor","start","end","animation","duration","lastFrame","currentFrame","active","time","direction","weight","directionBackwards","mirroredLoop","push","autoCreateAnimations","pattern","firstAnimation","frameRanges","i","key","chunks","match","Infinity","range","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","console","warn","stopAnimation","update","delta","il","frameTime","keyframe","clamp","Math","floor","morphTargetInfluences","mix"],"sources":["C:/Users/Arnav/Downloads/l4fycy/node_modules/three-stdlib/misc/MorphBlendMesh.js"],"sourcesContent":["import { Mesh, MathUtils } from 'three';\n\nvar MorphBlendMesh = function (geometry, material) {\n  Mesh.call(this, geometry, material);\n  this.animationsMap = {};\n  this.animationsList = []; // prepare default animation\n  // (all frames played together in 1 second)\n\n  var numFrames = Object.keys(this.morphTargetDictionary).length;\n  var name = '__default';\n  var startFrame = 0;\n  var endFrame = numFrames - 1;\n  var fps = numFrames / 1;\n  this.createAnimation(name, startFrame, endFrame, fps);\n  this.setAnimationWeight(name, 1);\n};\n\nMorphBlendMesh.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: MorphBlendMesh,\n  createAnimation: function (name, start, end, fps) {\n    var animation = {\n      start: start,\n      end: end,\n      length: end - start + 1,\n      fps: fps,\n      duration: (end - start) / fps,\n      lastFrame: 0,\n      currentFrame: 0,\n      active: false,\n      time: 0,\n      direction: 1,\n      weight: 1,\n      directionBackwards: false,\n      mirroredLoop: false\n    };\n    this.animationsMap[name] = animation;\n    this.animationsList.push(animation);\n  },\n  autoCreateAnimations: function (fps) {\n    var pattern = /([a-z]+)_?(\\d+)/i;\n    var firstAnimation,\n        frameRanges = {};\n    var i = 0;\n\n    for (let key in this.morphTargetDictionary) {\n      var chunks = key.match(pattern);\n\n      if (chunks && chunks.length > 1) {\n        var name = chunks[1];\n        if (!frameRanges[name]) frameRanges[name] = {\n          start: Infinity,\n          end: -Infinity\n        };\n        var range = frameRanges[name];\n        if (i < range.start) range.start = i;\n        if (i > range.end) range.end = i;\n        if (!firstAnimation) firstAnimation = name;\n      }\n\n      i++;\n    }\n\n    for (let name in frameRanges) {\n      var range = frameRanges[name];\n      this.createAnimation(name, range.start, range.end, fps);\n    }\n\n    this.firstAnimation = firstAnimation;\n  },\n  setAnimationDirectionForward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = 1;\n      animation.directionBackwards = false;\n    }\n  },\n  setAnimationDirectionBackward: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.direction = -1;\n      animation.directionBackwards = true;\n    }\n  },\n  setAnimationFPS: function (name, fps) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.fps = fps;\n      animation.duration = (animation.end - animation.start) / animation.fps;\n    }\n  },\n  setAnimationDuration: function (name, duration) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.duration = duration;\n      animation.fps = (animation.end - animation.start) / animation.duration;\n    }\n  },\n  setAnimationWeight: function (name, weight) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.weight = weight;\n    }\n  },\n  setAnimationTime: function (name, time) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = time;\n    }\n  },\n  getAnimationTime: function (name) {\n    var time = 0;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      time = animation.time;\n    }\n\n    return time;\n  },\n  getAnimationDuration: function (name) {\n    var duration = -1;\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      duration = animation.duration;\n    }\n\n    return duration;\n  },\n  playAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.time = 0;\n      animation.active = true;\n    } else {\n      console.warn('THREE.MorphBlendMesh: animation[' + name + '] undefined in .playAnimation()');\n    }\n  },\n  stopAnimation: function (name) {\n    var animation = this.animationsMap[name];\n\n    if (animation) {\n      animation.active = false;\n    }\n  },\n  update: function (delta) {\n    for (let i = 0, il = this.animationsList.length; i < il; i++) {\n      var animation = this.animationsList[i];\n      if (!animation.active) continue;\n      var frameTime = animation.duration / animation.length;\n      animation.time += animation.direction * delta;\n\n      if (animation.mirroredLoop) {\n        if (animation.time > animation.duration || animation.time < 0) {\n          animation.direction *= -1;\n\n          if (animation.time > animation.duration) {\n            animation.time = animation.duration;\n            animation.directionBackwards = true;\n          }\n\n          if (animation.time < 0) {\n            animation.time = 0;\n            animation.directionBackwards = false;\n          }\n        }\n      } else {\n        animation.time = animation.time % animation.duration;\n        if (animation.time < 0) animation.time += animation.duration;\n      }\n\n      var keyframe = animation.start + MathUtils.clamp(Math.floor(animation.time / frameTime), 0, animation.length - 1);\n      var weight = animation.weight;\n\n      if (keyframe !== animation.currentFrame) {\n        this.morphTargetInfluences[animation.lastFrame] = 0;\n        this.morphTargetInfluences[animation.currentFrame] = 1 * weight;\n        this.morphTargetInfluences[keyframe] = 0;\n        animation.lastFrame = animation.currentFrame;\n        animation.currentFrame = keyframe;\n      }\n\n      var mix = animation.time % frameTime / frameTime;\n      if (animation.directionBackwards) mix = 1 - mix;\n\n      if (animation.currentFrame !== animation.lastFrame) {\n        this.morphTargetInfluences[animation.currentFrame] = mix * weight;\n        this.morphTargetInfluences[animation.lastFrame] = (1 - mix) * weight;\n      } else {\n        this.morphTargetInfluences[animation.currentFrame] = weight;\n      }\n    }\n  }\n});\n\nexport { MorphBlendMesh };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}