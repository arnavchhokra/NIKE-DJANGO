{"ast":null,"code":"import { Vector3 } from 'three';\nconst temp = /* @__PURE__ */new Vector3();\nconst temp1 = /* @__PURE__ */new Vector3();\nexport function closestPointToPoint(bvh, point) {\n  let target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let minThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let maxThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n  // early out if under minThreshold\n  // skip checking if over maxThreshold\n  // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n  // returns Infinity if no value found\n  const minThresholdSq = minThreshold * minThreshold;\n  const maxThresholdSq = maxThreshold * maxThreshold;\n  let closestDistanceSq = Infinity;\n  let closestDistanceTriIndex = null;\n  bvh.shapecast({\n    boundsTraverseOrder: box => {\n      temp.copy(point).clamp(box.min, box.max);\n      return temp.distanceToSquared(point);\n    },\n    intersectsBounds: (box, isLeaf, score) => {\n      return score < closestDistanceSq && score < maxThresholdSq;\n    },\n    intersectsTriangle: (tri, triIndex) => {\n      tri.closestPointToPoint(point, temp);\n      const distSq = point.distanceToSquared(temp);\n      if (distSq < closestDistanceSq) {\n        temp1.copy(temp);\n        closestDistanceSq = distSq;\n        closestDistanceTriIndex = triIndex;\n      }\n      if (distSq < minThresholdSq) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  });\n  if (closestDistanceSq === Infinity) return null;\n  const closestDistance = Math.sqrt(closestDistanceSq);\n  if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n  return target;\n}","map":{"version":3,"names":["Vector3","temp","temp1","closestPointToPoint","bvh","point","target","arguments","length","undefined","minThreshold","maxThreshold","Infinity","minThresholdSq","maxThresholdSq","closestDistanceSq","closestDistanceTriIndex","shapecast","boundsTraverseOrder","box","copy","clamp","min","max","distanceToSquared","intersectsBounds","isLeaf","score","intersectsTriangle","tri","triIndex","distSq","closestDistance","Math","sqrt","clone","distance","faceIndex"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js"],"sourcesContent":["import { Vector3 } from 'three';\r\n\r\nconst temp = /* @__PURE__ */ new Vector3();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\n\r\nexport function closestPointToPoint(\r\n\tbvh,\r\n\tpoint,\r\n\ttarget = { },\r\n\tminThreshold = 0,\r\n\tmaxThreshold = Infinity,\r\n) {\r\n\r\n\t// early out if under minThreshold\r\n\t// skip checking if over maxThreshold\r\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t// returns Infinity if no value found\r\n\tconst minThresholdSq = minThreshold * minThreshold;\r\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\tlet closestDistanceSq = Infinity;\r\n\tlet closestDistanceTriIndex = null;\r\n\tbvh.shapecast(\r\n\r\n\t\t{\r\n\r\n\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\r\n\r\n\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\ttemp1.copy( temp );\r\n\t\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t}\r\n\r\n\t);\r\n\r\n\tif ( closestDistanceSq === Infinity ) return null;\r\n\r\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\r\n\r\n\tif ( ! target.point ) target.point = temp1.clone();\r\n\telse target.point.copy( temp1 );\r\n\ttarget.distance = closestDistance,\r\n\ttarget.faceIndex = closestDistanceTriIndex;\r\n\r\n\treturn target;\r\n\r\n}\r\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;AAE/B,MAAMC,IAAI,GAAG,eAAgB,IAAID,OAAO,CAAC,CAAC;AAC1C,MAAME,KAAK,GAAG,eAAgB,IAAIF,OAAO,CAAC,CAAC;AAE3C,OAAO,SAASG,mBAAmBA,CAClCC,GAAG,EACHC,KAAK,EAIJ;EAAA,IAHDC,MAAM,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAE,CAAC;EAAA,IACZG,YAAY,GAAAH,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;EAAA,IAChBI,YAAY,GAAAJ,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGK,QAAQ;EAGvB;EACA;EACA;EACA;EACA,MAAMC,cAAc,GAAGH,YAAY,GAAGA,YAAY;EAClD,MAAMI,cAAc,GAAGH,YAAY,GAAGA,YAAY;EAClD,IAAII,iBAAiB,GAAGH,QAAQ;EAChC,IAAII,uBAAuB,GAAG,IAAI;EAClCZ,GAAG,CAACa,SAAS,CAEZ;IAECC,mBAAmB,EAAEC,GAAG,IAAI;MAE3BlB,IAAI,CAACmB,IAAI,CAAEf,KAAM,CAAC,CAACgB,KAAK,CAAEF,GAAG,CAACG,GAAG,EAAEH,GAAG,CAACI,GAAI,CAAC;MAC5C,OAAOtB,IAAI,CAACuB,iBAAiB,CAAEnB,KAAM,CAAC;IAEvC,CAAC;IAEDoB,gBAAgB,EAAEA,CAAEN,GAAG,EAAEO,MAAM,EAAEC,KAAK,KAAM;MAE3C,OAAOA,KAAK,GAAGZ,iBAAiB,IAAIY,KAAK,GAAGb,cAAc;IAE3D,CAAC;IAEDc,kBAAkB,EAAEA,CAAEC,GAAG,EAAEC,QAAQ,KAAM;MAExCD,GAAG,CAAC1B,mBAAmB,CAAEE,KAAK,EAAEJ,IAAK,CAAC;MACtC,MAAM8B,MAAM,GAAG1B,KAAK,CAACmB,iBAAiB,CAAEvB,IAAK,CAAC;MAC9C,IAAK8B,MAAM,GAAGhB,iBAAiB,EAAG;QAEjCb,KAAK,CAACkB,IAAI,CAAEnB,IAAK,CAAC;QAClBc,iBAAiB,GAAGgB,MAAM;QAC1Bf,uBAAuB,GAAGc,QAAQ;MAEnC;MAEA,IAAKC,MAAM,GAAGlB,cAAc,EAAG;QAE9B,OAAO,IAAI;MAEZ,CAAC,MAAM;QAEN,OAAO,KAAK;MAEb;IAED;EAED,CAED,CAAC;EAED,IAAKE,iBAAiB,KAAKH,QAAQ,EAAG,OAAO,IAAI;EAEjD,MAAMoB,eAAe,GAAGC,IAAI,CAACC,IAAI,CAAEnB,iBAAkB,CAAC;EAEtD,IAAK,CAAET,MAAM,CAACD,KAAK,EAAGC,MAAM,CAACD,KAAK,GAAGH,KAAK,CAACiC,KAAK,CAAC,CAAC,CAAC,KAC9C7B,MAAM,CAACD,KAAK,CAACe,IAAI,CAAElB,KAAM,CAAC;EAC/BI,MAAM,CAAC8B,QAAQ,GAAGJ,eAAe,EACjC1B,MAAM,CAAC+B,SAAS,GAAGrB,uBAAuB;EAE1C,OAAOV,MAAM;AAEd"},"metadata":{},"sourceType":"module","externalDependencies":[]}