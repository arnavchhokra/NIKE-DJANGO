{"ast":null,"code":"import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper } from \"three\";\nfunction retarget(target, source) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4();\n  options.preserveMatrix = options.preserveMatrix !== void 0 ? options.preserveMatrix : true;\n  options.preservePosition = options.preservePosition !== void 0 ? options.preservePosition : true;\n  options.preserveHipPosition = options.preserveHipPosition !== void 0 ? options.preserveHipPosition : false;\n  options.useTargetMatrix = options.useTargetMatrix !== void 0 ? options.useTargetMatrix : false;\n  options.hip = options.hip !== void 0 ? options.hip : \"hip\";\n  options.names = options.names || {};\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target);\n  let bindBones, bone, name, boneTo, bonesPosition;\n  if (target.isObject3D) {\n    target.skeleton.pose();\n  } else {\n    options.useTargetMatrix = true;\n    options.preserveMatrix = false;\n  }\n  if (options.preservePosition) {\n    bonesPosition = [];\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone());\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld();\n    target.matrixWorld.identity();\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true);\n    }\n  }\n  if (options.offsets) {\n    bindBones = [];\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name]);\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n      bindBones.push(bone.matrixWorld.clone());\n    }\n  }\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i];\n    name = options.names[bone.name] || bone.name;\n    boneTo = getBoneByName(name, sourceBones);\n    globalMatrix.copy(bone.matrixWorld);\n    if (boneTo) {\n      boneTo.updateMatrixWorld();\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld);\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert();\n        relativeMatrix.multiply(boneTo.matrixWorld);\n      }\n      scale.setFromMatrixScale(relativeMatrix);\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n        globalMatrix.multiply(wBindMatrix);\n      }\n      globalMatrix.copyPosition(relativeMatrix);\n    }\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert();\n      bone.matrix.multiply(globalMatrix);\n    } else {\n      bone.matrix.copy(globalMatrix);\n    }\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n    }\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n    bone.updateMatrixWorld();\n  }\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i];\n      name = options.names[bone.name] || bone.name;\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i]);\n      }\n    }\n  }\n  if (options.preserveMatrix) {\n    target.updateMatrixWorld(true);\n  }\n}\nfunction retargetClip(target, source, clip) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  options.useFirstFramePosition = options.useFirstFramePosition !== void 0 ? options.useFirstFramePosition : false;\n  options.fps = options.fps !== void 0 ? options.fps : 30;\n  options.names = options.names || [];\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source);\n  }\n  const numFrames = Math.round(clip.duration * (options.fps / 1e3) * 1e3),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = [];\n  let positionOffset, bone, boneTo, boneData, name;\n  mixer.clipAction(clip).play();\n  mixer.update(0);\n  source.updateMatrixWorld();\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta;\n    retarget(target, source, options);\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name;\n      boneTo = getBoneByName(name, source.skeleton);\n      if (boneTo) {\n        bone = bones[j];\n        boneData = boneDatas[j] = boneDatas[j] || {\n          bone\n        };\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3)\n            };\n          }\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone();\n            }\n            bone.position.sub(positionOffset);\n          }\n          boneData.pos.times[i] = time;\n          bone.position.toArray(boneData.pos.values, i * 3);\n        }\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4)\n          };\n        }\n        boneData.quat.times[i] = time;\n        bone.quaternion.toArray(boneData.quat.values, i * 4);\n      }\n    }\n    mixer.update(delta);\n    source.updateMatrixWorld();\n  }\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i];\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(new VectorKeyframeTrack(\".bones[\" + boneData.bone.name + \"].position\", boneData.pos.times, boneData.pos.values));\n      }\n      convertedTracks.push(new QuaternionKeyframeTrack(\".bones[\" + boneData.bone.name + \"].quaternion\", boneData.quat.times, boneData.quat.values));\n    }\n  }\n  mixer.uncacheAction(clip);\n  return new AnimationClip(clip.name, -1, convertedTracks);\n}\nfunction clone(source) {\n  const sourceLookup = /* @__PURE__ */new Map();\n  const cloneLookup = /* @__PURE__ */new Map();\n  const clone2 = source.clone();\n  parallelTraverse(source, clone2, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode);\n    cloneLookup.set(sourceNode, clonedNode);\n  });\n  clone2.traverse(function (node) {\n    if (!node.isSkinnedMesh) return;\n    const clonedMesh = node;\n    const sourceMesh = sourceLookup.get(node);\n    const sourceBones = sourceMesh.skeleton.bones;\n    clonedMesh.skeleton = sourceMesh.skeleton.clone();\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone);\n    });\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n  });\n  return clone2;\n}\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i];\n  }\n}\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n}\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0]);\n  source.skeleton = skeleton;\n  return source;\n}\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\nconst SkeletonUtils = {\n  retarget,\n  retargetClip,\n  clone\n};\nexport { SkeletonUtils };","map":{"version":3,"names":["retarget","target","source","options","arguments","length","undefined","pos","Vector3","quat","Quaternion","scale","bindBoneMatrix","Matrix4","relativeMatrix","globalMatrix","preserveMatrix","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","pose","i","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","AnimationMixer","boneDatas","positionOffset","boneData","clipAction","play","update","time","j","times","Float32Array","values","sub","toArray","VectorKeyframeTrack","QuaternionKeyframeTrack","uncacheAction","AnimationClip","sourceLookup","Map","cloneLookup","clone2","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","Array","isArray","SkeletonHelper","a","b","callback","SkeletonUtils"],"sources":["D:\\Repos\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\src\\utils\\SkeletonUtils.js"],"sourcesContent":["import {\n  AnimationClip,\n  AnimationMixer,\n  Matrix4,\n  Quaternion,\n  QuaternionKeyframeTrack,\n  SkeletonHelper,\n  Vector3,\n  VectorKeyframeTrack,\n} from 'three'\n\nfunction retarget(target, source, options = {}) {\n  const pos = new Vector3(),\n    quat = new Quaternion(),\n    scale = new Vector3(),\n    bindBoneMatrix = new Matrix4(),\n    relativeMatrix = new Matrix4(),\n    globalMatrix = new Matrix4()\n\n  options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true\n  options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true\n  options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false\n  options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false\n  options.hip = options.hip !== undefined ? options.hip : 'hip'\n  options.names = options.names || {}\n\n  const sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),\n    bones = target.isObject3D ? target.skeleton.bones : getBones(target)\n\n  let bindBones, bone, name, boneTo, bonesPosition\n\n  // reset bones\n\n  if (target.isObject3D) {\n    target.skeleton.pose()\n  } else {\n    options.useTargetMatrix = true\n    options.preserveMatrix = false\n  }\n\n  if (options.preservePosition) {\n    bonesPosition = []\n\n    for (let i = 0; i < bones.length; i++) {\n      bonesPosition.push(bones[i].position.clone())\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // reset matrix\n\n    target.updateMatrixWorld()\n\n    target.matrixWorld.identity()\n\n    // reset children matrix\n\n    for (let i = 0; i < target.children.length; ++i) {\n      target.children[i].updateMatrixWorld(true)\n    }\n  }\n\n  if (options.offsets) {\n    bindBones = []\n\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (options.offsets[name]) {\n        bone.matrix.multiply(options.offsets[name])\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n        bone.updateMatrixWorld()\n      }\n\n      bindBones.push(bone.matrixWorld.clone())\n    }\n  }\n\n  for (let i = 0; i < bones.length; ++i) {\n    bone = bones[i]\n    name = options.names[bone.name] || bone.name\n\n    boneTo = getBoneByName(name, sourceBones)\n\n    globalMatrix.copy(bone.matrixWorld)\n\n    if (boneTo) {\n      boneTo.updateMatrixWorld()\n\n      if (options.useTargetMatrix) {\n        relativeMatrix.copy(boneTo.matrixWorld)\n      } else {\n        relativeMatrix.copy(target.matrixWorld).invert()\n        relativeMatrix.multiply(boneTo.matrixWorld)\n      }\n\n      // ignore scale to extract rotation\n\n      scale.setFromMatrixScale(relativeMatrix)\n      relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z))\n\n      // apply to global matrix\n\n      globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix))\n\n      if (target.isObject3D) {\n        const boneIndex = bones.indexOf(bone),\n          wBindMatrix = bindBones\n            ? bindBones[boneIndex]\n            : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert()\n\n        globalMatrix.multiply(wBindMatrix)\n      }\n\n      globalMatrix.copyPosition(relativeMatrix)\n    }\n\n    if (bone.parent && bone.parent.isBone) {\n      bone.matrix.copy(bone.parent.matrixWorld).invert()\n      bone.matrix.multiply(globalMatrix)\n    } else {\n      bone.matrix.copy(globalMatrix)\n    }\n\n    if (options.preserveHipPosition && name === options.hip) {\n      bone.matrix.setPosition(pos.set(0, bone.position.y, 0))\n    }\n\n    bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)\n\n    bone.updateMatrixWorld()\n  }\n\n  if (options.preservePosition) {\n    for (let i = 0; i < bones.length; ++i) {\n      bone = bones[i]\n      name = options.names[bone.name] || bone.name\n\n      if (name !== options.hip) {\n        bone.position.copy(bonesPosition[i])\n      }\n    }\n  }\n\n  if (options.preserveMatrix) {\n    // restore matrix\n\n    target.updateMatrixWorld(true)\n  }\n}\n\nfunction retargetClip(target, source, clip, options = {}) {\n  options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false\n  options.fps = options.fps !== undefined ? options.fps : 30\n  options.names = options.names || []\n\n  if (!source.isObject3D) {\n    source = getHelperFromSkeleton(source)\n  }\n\n  const numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n    delta = 1 / options.fps,\n    convertedTracks = [],\n    mixer = new AnimationMixer(source),\n    bones = getBones(target.skeleton),\n    boneDatas = []\n  let positionOffset, bone, boneTo, boneData, name\n\n  mixer.clipAction(clip).play()\n  mixer.update(0)\n\n  source.updateMatrixWorld()\n\n  for (let i = 0; i < numFrames; ++i) {\n    const time = i * delta\n\n    retarget(target, source, options)\n\n    for (let j = 0; j < bones.length; ++j) {\n      name = options.names[bones[j].name] || bones[j].name\n\n      boneTo = getBoneByName(name, source.skeleton)\n\n      if (boneTo) {\n        bone = bones[j]\n        boneData = boneDatas[j] = boneDatas[j] || { bone: bone }\n\n        if (options.hip === name) {\n          if (!boneData.pos) {\n            boneData.pos = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 3),\n            }\n          }\n\n          if (options.useFirstFramePosition) {\n            if (i === 0) {\n              positionOffset = bone.position.clone()\n            }\n\n            bone.position.sub(positionOffset)\n          }\n\n          boneData.pos.times[i] = time\n\n          bone.position.toArray(boneData.pos.values, i * 3)\n        }\n\n        if (!boneData.quat) {\n          boneData.quat = {\n            times: new Float32Array(numFrames),\n            values: new Float32Array(numFrames * 4),\n          }\n        }\n\n        boneData.quat.times[i] = time\n\n        bone.quaternion.toArray(boneData.quat.values, i * 4)\n      }\n    }\n\n    mixer.update(delta)\n\n    source.updateMatrixWorld()\n  }\n\n  for (let i = 0; i < boneDatas.length; ++i) {\n    boneData = boneDatas[i]\n\n    if (boneData) {\n      if (boneData.pos) {\n        convertedTracks.push(\n          new VectorKeyframeTrack(\n            '.bones[' + boneData.bone.name + '].position',\n            boneData.pos.times,\n            boneData.pos.values,\n          ),\n        )\n      }\n\n      convertedTracks.push(\n        new QuaternionKeyframeTrack(\n          '.bones[' + boneData.bone.name + '].quaternion',\n          boneData.quat.times,\n          boneData.quat.values,\n        ),\n      )\n    }\n  }\n\n  mixer.uncacheAction(clip)\n\n  return new AnimationClip(clip.name, -1, convertedTracks)\n}\n\nfunction clone(source) {\n  const sourceLookup = new Map()\n  const cloneLookup = new Map()\n\n  const clone = source.clone()\n\n  parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n    sourceLookup.set(clonedNode, sourceNode)\n    cloneLookup.set(sourceNode, clonedNode)\n  })\n\n  clone.traverse(function (node) {\n    if (!node.isSkinnedMesh) return\n\n    const clonedMesh = node\n    const sourceMesh = sourceLookup.get(node)\n    const sourceBones = sourceMesh.skeleton.bones\n\n    clonedMesh.skeleton = sourceMesh.skeleton.clone()\n    clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix)\n\n    clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n      return cloneLookup.get(bone)\n    })\n\n    clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix)\n  })\n\n  return clone\n}\n\n// internal helper\n\nfunction getBoneByName(name, skeleton) {\n  for (let i = 0, bones = getBones(skeleton); i < bones.length; i++) {\n    if (name === bones[i].name) return bones[i]\n  }\n}\n\nfunction getBones(skeleton) {\n  return Array.isArray(skeleton) ? skeleton : skeleton.bones\n}\n\nfunction getHelperFromSkeleton(skeleton) {\n  const source = new SkeletonHelper(skeleton.bones[0])\n  source.skeleton = skeleton\n\n  return source\n}\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b)\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback)\n  }\n}\n\nexport const SkeletonUtils = { retarget, retargetClip, clone }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}