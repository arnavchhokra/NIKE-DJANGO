{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\nvar cb = new Vector3(),\n    ab = new Vector3();\n\nfunction pushIfUnique(array, object) {\n  if (array.indexOf(object) === -1) array.push(object);\n}\n\nfunction removeFromArray(array, object) {\n  var k = array.indexOf(object);\n  if (k > -1) array.splice(k, 1);\n}\n\nvar Vertex = /*#__PURE__*/function () {\n  function Vertex(v, id) {\n    _classCallCheck(this, Vertex);\n\n    _defineProperty(this, \"position\", void 0);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"faces\", void 0);\n\n    _defineProperty(this, \"neighbors\", void 0);\n\n    _defineProperty(this, \"collapseCost\", void 0);\n\n    _defineProperty(this, \"collapseNeighbor\", void 0);\n\n    _defineProperty(this, \"minCost\", 0);\n\n    _defineProperty(this, \"totalCost\", 0);\n\n    _defineProperty(this, \"costCount\", 0);\n\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n    // these will be computed in computeEdgeCostAtVertex()\n\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n\n  _createClass(Vertex, [{\n    key: \"addUniqueNeighbor\",\n    value: function addUniqueNeighbor(vertex) {\n      pushIfUnique(this.neighbors, vertex);\n    }\n  }, {\n    key: \"removeIfNonNeighbor\",\n    value: function removeIfNonNeighbor(n) {\n      var neighbors = this.neighbors;\n      var faces = this.faces;\n      var offset = neighbors.indexOf(n);\n      if (offset === -1) return;\n\n      for (var i = 0; i < faces.length; i++) {\n        if (faces[i].hasVertex(n)) return;\n      }\n\n      neighbors.splice(offset, 1);\n    }\n  }]);\n\n  return Vertex;\n}(); // we use a triangle class to represent structure of face slightly differently\n\n\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle(v1, v2, v3, a, b, c) {\n    _classCallCheck(this, Triangle);\n\n    _defineProperty(this, \"a\", void 0);\n\n    _defineProperty(this, \"b\", void 0);\n\n    _defineProperty(this, \"c\", void 0);\n\n    _defineProperty(this, \"v1\", void 0);\n\n    _defineProperty(this, \"v2\", void 0);\n\n    _defineProperty(this, \"v3\", void 0);\n\n    _defineProperty(this, \"normal\", new Vector3());\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n\n  _createClass(Triangle, [{\n    key: \"computeNormal\",\n    value: function computeNormal() {\n      var vA = this.v1.position;\n      var vB = this.v2.position;\n      var vC = this.v3.position;\n      cb.subVectors(vC, vB);\n      ab.subVectors(vA, vB);\n      cb.cross(ab).normalize();\n      this.normal.copy(cb);\n    }\n  }, {\n    key: \"hasVertex\",\n    value: function hasVertex(v) {\n      return v === this.v1 || v === this.v2 || v === this.v3;\n    }\n  }, {\n    key: \"replaceVertex\",\n    value: function replaceVertex(oldv, newv) {\n      if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n      removeFromArray(oldv.faces, this);\n      newv.faces.push(this);\n      oldv.removeIfNonNeighbor(this.v1);\n      this.v1.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v2);\n      this.v2.removeIfNonNeighbor(oldv);\n      oldv.removeIfNonNeighbor(this.v3);\n      this.v3.removeIfNonNeighbor(oldv);\n      this.v1.addUniqueNeighbor(this.v2);\n      this.v1.addUniqueNeighbor(this.v3);\n      this.v2.addUniqueNeighbor(this.v1);\n      this.v2.addUniqueNeighbor(this.v3);\n      this.v3.addUniqueNeighbor(this.v1);\n      this.v3.addUniqueNeighbor(this.v2);\n      this.computeNormal();\n    }\n  }]);\n\n  return Triangle;\n}();\n/**\r\n *\tSimplification Geometry Modifier\r\n *    - based on code and technique\r\n *\t  - by Stan Melax in 1998\r\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\r\n *    - http://www.melax.com/polychop/\r\n */\n\n\nvar SimplifyModifier = /*#__PURE__*/function () {\n  function SimplifyModifier() {\n    var _this = this;\n\n    _classCallCheck(this, SimplifyModifier);\n\n    _defineProperty(this, \"computeEdgeCollapseCost\", function (u, v) {\n      // if we collapse edge uv by moving u to v then how\n      // much different will the model change, i.e. the \"error\".\n      var edgelength = v.position.distanceTo(u.position);\n      var curvature = 0;\n      var sideFaces = [];\n      var i,\n          il = u.faces.length,\n          face,\n          sideFace; // find the \"sides\" triangles that are on the edge uv\n\n      for (i = 0; i < il; i++) {\n        face = u.faces[i];\n\n        if (face.hasVertex(v)) {\n          sideFaces.push(face);\n        }\n      } // use the triangle facing most away from the sides\n      // to determine our curvature term\n\n\n      for (i = 0; i < il; i++) {\n        var minCurvature = 1;\n        face = u.faces[i];\n\n        for (var j = 0; j < sideFaces.length; j++) {\n          sideFace = sideFaces[j]; // use dot product of face normals.\n\n          var dotProd = face.normal.dot(sideFace.normal);\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n        }\n\n        curvature = Math.max(curvature, minCurvature);\n      } // crude approach in attempt to preserve borders\n      // though it seems not to be totally correct\n\n\n      var borders = 0;\n\n      if (sideFaces.length < 2) {\n        // we add some arbitrary cost for borders,\n        // borders += 10;\n        curvature = 1;\n      }\n\n      var amt = edgelength * curvature + borders;\n      return amt;\n    });\n\n    _defineProperty(this, \"computeEdgeCostAtVertex\", function (v) {\n      // compute the edge collapse cost for all edges that start\n      // from vertex v.  Since we are only interested in reducing\n      // the object by selecting the min cost edge at each step, we\n      // only cache the cost of the least cost edge at this vertex\n      // (in member variable collapse) as well as the value of the\n      // cost (in member variable collapseCost).\n      if (v.neighbors.length === 0) {\n        // collapse if no neighbors.\n        v.collapseNeighbor = null;\n        v.collapseCost = -0.01;\n        return;\n      }\n\n      v.collapseCost = 100000;\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\n\n      for (var i = 0; i < v.neighbors.length; i++) {\n        var collapseCost = _this.computeEdgeCollapseCost(v, v.neighbors[i]);\n\n        if (!v.collapseNeighbor) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.collapseCost = collapseCost;\n          v.minCost = collapseCost;\n          v.totalCost = 0;\n          v.costCount = 0;\n        }\n\n        v.costCount++;\n        v.totalCost += collapseCost;\n\n        if (collapseCost < v.minCost) {\n          v.collapseNeighbor = v.neighbors[i];\n          v.minCost = collapseCost;\n        }\n      } // we average the cost of collapsing at this vertex\n\n\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\n    });\n\n    _defineProperty(this, \"removeFace\", function (f, faces) {\n      removeFromArray(faces, f);\n      if (f.v1) removeFromArray(f.v1.faces, f);\n      if (f.v2) removeFromArray(f.v2.faces, f);\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\n\n      var vs = [f.v1, f.v2, f.v3];\n      var v1, v2;\n\n      for (var i = 0; i < 3; i++) {\n        v1 = vs[i];\n        v2 = vs[(i + 1) % 3];\n        if (!v1 || !v2) continue;\n        v1.removeIfNonNeighbor(v2);\n        v2.removeIfNonNeighbor(v1);\n      }\n    });\n\n    _defineProperty(this, \"collapse\", function (vertices, faces, u, v) {\n      // u and v are pointers to vertices of an edge\n      // Collapse the edge uv by moving vertex u onto v\n      if (!v) {\n        // u is a vertex all by itself so just delete it..\n        _this.removeVertex(u, vertices);\n\n        return;\n      }\n\n      var i;\n      var tmpVertices = [];\n\n      for (i = 0; i < u.neighbors.length; i++) {\n        tmpVertices.push(u.neighbors[i]);\n      } // delete triangles on edge uv:\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        if (u.faces[i].hasVertex(v)) {\n          _this.removeFace(u.faces[i], faces);\n        }\n      } // update remaining triangles to have v instead of u\n\n\n      for (i = u.faces.length - 1; i >= 0; i--) {\n        u.faces[i].replaceVertex(u, v);\n      }\n\n      _this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\n\n\n      for (i = 0; i < tmpVertices.length; i++) {\n        _this.computeEdgeCostAtVertex(tmpVertices[i]);\n      }\n    });\n\n    _defineProperty(this, \"minimumCostEdge\", function (vertices) {\n      // O(n * n) approach. TODO optimize this\n      var least = vertices[0];\n\n      for (var i = 0; i < vertices.length; i++) {\n        if (vertices[i].collapseCost < least.collapseCost) {\n          least = vertices[i];\n        }\n      }\n\n      return least;\n    });\n\n    _defineProperty(this, \"modify\", function (geometry, count) {\n      geometry = geometry.clone();\n      var attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\n\n      for (var name in attributes) {\n        if (name !== 'position') geometry.deleteAttribute(name);\n      }\n\n      geometry = mergeVertices(geometry); //\n      // put data of original geometry in different data structures\n      //\n\n      var vertices = [];\n      var faces = []; // add vertices\n\n      var positionAttribute = geometry.getAttribute('position');\n\n      for (var i = 0; i < positionAttribute.count; i++) {\n        var v = new Vector3().fromBufferAttribute(positionAttribute, i);\n        var vertex = new Vertex(v, i);\n        vertices.push(vertex);\n      } // add faces\n\n\n      var geomIndex = geometry.getIndex();\n\n      if (geomIndex !== null) {\n        for (var _i = 0; _i < geomIndex.count; _i += 3) {\n          var a = geomIndex.getX(_i);\n          var b = geomIndex.getX(_i + 1);\n          var c = geomIndex.getX(_i + 2);\n          var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n          faces.push(triangle);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < positionAttribute.count; _i2 += 3) {\n          var _a = _i2;\n\n          var _b = _i2 + 1;\n\n          var _c = _i2 + 2;\n\n          var _triangle = new Triangle(vertices[_a], vertices[_b], vertices[_c], _a, _b, _c);\n\n          faces.push(_triangle);\n        }\n      } // compute all edge collapse costs\n\n\n      for (var _i3 = 0, il = vertices.length; _i3 < il; _i3++) {\n        _this.computeEdgeCostAtVertex(vertices[_i3]);\n      }\n\n      var nextVertex;\n      var z = count;\n\n      while (z--) {\n        nextVertex = _this.minimumCostEdge(vertices);\n\n        if (!nextVertex) {\n          console.log('THREE.SimplifyModifier: No next vertex');\n          break;\n        } else {\n          _this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n        }\n      } //\n\n\n      var simplifiedGeometry = new BufferGeometry();\n      var position = [];\n      var index = []; //\n\n      for (var _i4 = 0; _i4 < vertices.length; _i4++) {\n        var _vertex = vertices[_i4].position;\n        position.push(_vertex.x, _vertex.y, _vertex.z);\n      } //\n\n\n      for (var _i5 = 0; _i5 < faces.length; _i5++) {\n        var face = faces[_i5];\n\n        var _a2 = vertices.indexOf(face.v1);\n\n        var _b2 = vertices.indexOf(face.v2);\n\n        var _c2 = vertices.indexOf(face.v3);\n\n        index.push(_a2, _b2, _c2);\n      } //\n\n\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n      simplifiedGeometry.setIndex(index);\n      return simplifiedGeometry;\n    });\n  }\n\n  _createClass(SimplifyModifier, [{\n    key: \"removeVertex\",\n    value: function removeVertex(v, vertices) {\n      console.assert(v.faces.length === 0);\n\n      while (v.neighbors.length) {\n        var n = v.neighbors.pop();\n        removeFromArray(n.neighbors, v);\n      }\n\n      removeFromArray(vertices, v);\n    }\n  }]);\n\n  return SimplifyModifier;\n}();\n\nexport { SimplifyModifier };","map":{"version":3,"names":["_defineProperty","Vector3","BufferGeometry","Float32BufferAttribute","mergeVertices","cb","ab","pushIfUnique","array","object","indexOf","push","removeFromArray","k","splice","Vertex","v","id","position","faces","neighbors","collapseCost","collapseNeighbor","vertex","n","offset","i","length","hasVertex","Triangle","v1","v2","v3","a","b","c","computeNormal","addUniqueNeighbor","vA","vB","vC","subVectors","cross","normalize","normal","copy","oldv","newv","removeIfNonNeighbor","SimplifyModifier","u","edgelength","distanceTo","curvature","sideFaces","il","face","sideFace","minCurvature","j","dotProd","dot","Math","min","max","borders","amt","computeEdgeCollapseCost","minCost","totalCost","costCount","f","vs","vertices","removeVertex","tmpVertices","removeFace","replaceVertex","computeEdgeCostAtVertex","least","geometry","count","clone","attributes","name","deleteAttribute","positionAttribute","getAttribute","fromBufferAttribute","geomIndex","getIndex","getX","triangle","nextVertex","z","minimumCostEdge","console","log","collapse","simplifiedGeometry","index","x","y","setAttribute","setIndex","assert","pop"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/modifiers/SimplifyModifier.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\r\nimport { Vector3, BufferGeometry, Float32BufferAttribute } from 'three';\r\nimport { mergeVertices } from '../utils/BufferGeometryUtils.js';\r\n\r\nconst cb = new Vector3(),\r\n      ab = new Vector3();\r\n\r\nfunction pushIfUnique(array, object) {\r\n  if (array.indexOf(object) === -1) array.push(object);\r\n}\r\n\r\nfunction removeFromArray(array, object) {\r\n  const k = array.indexOf(object);\r\n  if (k > -1) array.splice(k, 1);\r\n}\r\n\r\nclass Vertex {\r\n  constructor(v, id) {\r\n    _defineProperty(this, \"position\", void 0);\r\n\r\n    _defineProperty(this, \"id\", void 0);\r\n\r\n    _defineProperty(this, \"faces\", void 0);\r\n\r\n    _defineProperty(this, \"neighbors\", void 0);\r\n\r\n    _defineProperty(this, \"collapseCost\", void 0);\r\n\r\n    _defineProperty(this, \"collapseNeighbor\", void 0);\r\n\r\n    _defineProperty(this, \"minCost\", 0);\r\n\r\n    _defineProperty(this, \"totalCost\", 0);\r\n\r\n    _defineProperty(this, \"costCount\", 0);\r\n\r\n    this.position = v;\r\n    this.id = id; // old index id\r\n\r\n    this.faces = []; // faces vertex is connected\r\n\r\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\r\n    // these will be computed in computeEdgeCostAtVertex()\r\n\r\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\r\n\r\n    this.collapseNeighbor = null; // best candinate for collapsing\r\n  }\r\n\r\n  addUniqueNeighbor(vertex) {\r\n    pushIfUnique(this.neighbors, vertex);\r\n  }\r\n\r\n  removeIfNonNeighbor(n) {\r\n    const neighbors = this.neighbors;\r\n    const faces = this.faces;\r\n    const offset = neighbors.indexOf(n);\r\n    if (offset === -1) return;\r\n\r\n    for (let i = 0; i < faces.length; i++) {\r\n      if (faces[i].hasVertex(n)) return;\r\n    }\r\n\r\n    neighbors.splice(offset, 1);\r\n  }\r\n\r\n} // we use a triangle class to represent structure of face slightly differently\r\n\r\n\r\nclass Triangle {\r\n  constructor(v1, v2, v3, a, b, c) {\r\n    _defineProperty(this, \"a\", void 0);\r\n\r\n    _defineProperty(this, \"b\", void 0);\r\n\r\n    _defineProperty(this, \"c\", void 0);\r\n\r\n    _defineProperty(this, \"v1\", void 0);\r\n\r\n    _defineProperty(this, \"v2\", void 0);\r\n\r\n    _defineProperty(this, \"v3\", void 0);\r\n\r\n    _defineProperty(this, \"normal\", new Vector3());\r\n\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.v1 = v1;\r\n    this.v2 = v2;\r\n    this.v3 = v3;\r\n    this.computeNormal();\r\n    v1.faces.push(this);\r\n    v1.addUniqueNeighbor(v2);\r\n    v1.addUniqueNeighbor(v3);\r\n    v2.faces.push(this);\r\n    v2.addUniqueNeighbor(v1);\r\n    v2.addUniqueNeighbor(v3);\r\n    v3.faces.push(this);\r\n    v3.addUniqueNeighbor(v1);\r\n    v3.addUniqueNeighbor(v2);\r\n  }\r\n\r\n  computeNormal() {\r\n    const vA = this.v1.position;\r\n    const vB = this.v2.position;\r\n    const vC = this.v3.position;\r\n    cb.subVectors(vC, vB);\r\n    ab.subVectors(vA, vB);\r\n    cb.cross(ab).normalize();\r\n    this.normal.copy(cb);\r\n  }\r\n\r\n  hasVertex(v) {\r\n    return v === this.v1 || v === this.v2 || v === this.v3;\r\n  }\r\n\r\n  replaceVertex(oldv, newv) {\r\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\r\n    removeFromArray(oldv.faces, this);\r\n    newv.faces.push(this);\r\n    oldv.removeIfNonNeighbor(this.v1);\r\n    this.v1.removeIfNonNeighbor(oldv);\r\n    oldv.removeIfNonNeighbor(this.v2);\r\n    this.v2.removeIfNonNeighbor(oldv);\r\n    oldv.removeIfNonNeighbor(this.v3);\r\n    this.v3.removeIfNonNeighbor(oldv);\r\n    this.v1.addUniqueNeighbor(this.v2);\r\n    this.v1.addUniqueNeighbor(this.v3);\r\n    this.v2.addUniqueNeighbor(this.v1);\r\n    this.v2.addUniqueNeighbor(this.v3);\r\n    this.v3.addUniqueNeighbor(this.v1);\r\n    this.v3.addUniqueNeighbor(this.v2);\r\n    this.computeNormal();\r\n  }\r\n\r\n}\r\n/**\r\n *\tSimplification Geometry Modifier\r\n *    - based on code and technique\r\n *\t  - by Stan Melax in 1998\r\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\r\n *    - http://www.melax.com/polychop/\r\n */\r\n\r\n\r\nclass SimplifyModifier {\r\n  constructor() {\r\n    _defineProperty(this, \"computeEdgeCollapseCost\", (u, v) => {\r\n      // if we collapse edge uv by moving u to v then how\r\n      // much different will the model change, i.e. the \"error\".\r\n      const edgelength = v.position.distanceTo(u.position);\r\n      let curvature = 0;\r\n      const sideFaces = [];\r\n      let i,\r\n          il = u.faces.length,\r\n          face,\r\n          sideFace; // find the \"sides\" triangles that are on the edge uv\r\n\r\n      for (i = 0; i < il; i++) {\r\n        face = u.faces[i];\r\n\r\n        if (face.hasVertex(v)) {\r\n          sideFaces.push(face);\r\n        }\r\n      } // use the triangle facing most away from the sides\r\n      // to determine our curvature term\r\n\r\n\r\n      for (i = 0; i < il; i++) {\r\n        let minCurvature = 1;\r\n        face = u.faces[i];\r\n\r\n        for (let j = 0; j < sideFaces.length; j++) {\r\n          sideFace = sideFaces[j]; // use dot product of face normals.\r\n\r\n          const dotProd = face.normal.dot(sideFace.normal);\r\n          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\r\n        }\r\n\r\n        curvature = Math.max(curvature, minCurvature);\r\n      } // crude approach in attempt to preserve borders\r\n      // though it seems not to be totally correct\r\n\r\n\r\n      const borders = 0;\r\n\r\n      if (sideFaces.length < 2) {\r\n        // we add some arbitrary cost for borders,\r\n        // borders += 10;\r\n        curvature = 1;\r\n      }\r\n\r\n      const amt = edgelength * curvature + borders;\r\n      return amt;\r\n    });\r\n\r\n    _defineProperty(this, \"computeEdgeCostAtVertex\", v => {\r\n      // compute the edge collapse cost for all edges that start\r\n      // from vertex v.  Since we are only interested in reducing\r\n      // the object by selecting the min cost edge at each step, we\r\n      // only cache the cost of the least cost edge at this vertex\r\n      // (in member variable collapse) as well as the value of the\r\n      // cost (in member variable collapseCost).\r\n      if (v.neighbors.length === 0) {\r\n        // collapse if no neighbors.\r\n        v.collapseNeighbor = null;\r\n        v.collapseCost = -0.01;\r\n        return;\r\n      }\r\n\r\n      v.collapseCost = 100000;\r\n      v.collapseNeighbor = null; // search all neighboring edges for \"least cost\" edge\r\n\r\n      for (let i = 0; i < v.neighbors.length; i++) {\r\n        const collapseCost = this.computeEdgeCollapseCost(v, v.neighbors[i]);\r\n\r\n        if (!v.collapseNeighbor) {\r\n          v.collapseNeighbor = v.neighbors[i];\r\n          v.collapseCost = collapseCost;\r\n          v.minCost = collapseCost;\r\n          v.totalCost = 0;\r\n          v.costCount = 0;\r\n        }\r\n\r\n        v.costCount++;\r\n        v.totalCost += collapseCost;\r\n\r\n        if (collapseCost < v.minCost) {\r\n          v.collapseNeighbor = v.neighbors[i];\r\n          v.minCost = collapseCost;\r\n        }\r\n      } // we average the cost of collapsing at this vertex\r\n\r\n\r\n      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;\r\n    });\r\n\r\n    _defineProperty(this, \"removeFace\", (f, faces) => {\r\n      removeFromArray(faces, f);\r\n      if (f.v1) removeFromArray(f.v1.faces, f);\r\n      if (f.v2) removeFromArray(f.v2.faces, f);\r\n      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!\r\n\r\n      const vs = [f.v1, f.v2, f.v3];\r\n      let v1, v2;\r\n\r\n      for (let i = 0; i < 3; i++) {\r\n        v1 = vs[i];\r\n        v2 = vs[(i + 1) % 3];\r\n        if (!v1 || !v2) continue;\r\n        v1.removeIfNonNeighbor(v2);\r\n        v2.removeIfNonNeighbor(v1);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"collapse\", (vertices, faces, u, v) => {\r\n      // u and v are pointers to vertices of an edge\r\n      // Collapse the edge uv by moving vertex u onto v\r\n      if (!v) {\r\n        // u is a vertex all by itself so just delete it..\r\n        this.removeVertex(u, vertices);\r\n        return;\r\n      }\r\n\r\n      let i;\r\n      const tmpVertices = [];\r\n\r\n      for (i = 0; i < u.neighbors.length; i++) {\r\n        tmpVertices.push(u.neighbors[i]);\r\n      } // delete triangles on edge uv:\r\n\r\n\r\n      for (i = u.faces.length - 1; i >= 0; i--) {\r\n        if (u.faces[i].hasVertex(v)) {\r\n          this.removeFace(u.faces[i], faces);\r\n        }\r\n      } // update remaining triangles to have v instead of u\r\n\r\n\r\n      for (i = u.faces.length - 1; i >= 0; i--) {\r\n        u.faces[i].replaceVertex(u, v);\r\n      }\r\n\r\n      this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood\r\n\r\n      for (i = 0; i < tmpVertices.length; i++) {\r\n        this.computeEdgeCostAtVertex(tmpVertices[i]);\r\n      }\r\n    });\r\n\r\n    _defineProperty(this, \"minimumCostEdge\", vertices => {\r\n      // O(n * n) approach. TODO optimize this\r\n      let least = vertices[0];\r\n\r\n      for (let i = 0; i < vertices.length; i++) {\r\n        if (vertices[i].collapseCost < least.collapseCost) {\r\n          least = vertices[i];\r\n        }\r\n      }\r\n\r\n      return least;\r\n    });\r\n\r\n    _defineProperty(this, \"modify\", (geometry, count) => {\r\n      geometry = geometry.clone();\r\n      const attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute\r\n\r\n      for (let name in attributes) {\r\n        if (name !== 'position') geometry.deleteAttribute(name);\r\n      }\r\n\r\n      geometry = mergeVertices(geometry); //\r\n      // put data of original geometry in different data structures\r\n      //\r\n\r\n      const vertices = [];\r\n      const faces = []; // add vertices\r\n\r\n      const positionAttribute = geometry.getAttribute('position');\r\n\r\n      for (let i = 0; i < positionAttribute.count; i++) {\r\n        const v = new Vector3().fromBufferAttribute(positionAttribute, i);\r\n        const vertex = new Vertex(v, i);\r\n        vertices.push(vertex);\r\n      } // add faces\r\n\r\n\r\n      const geomIndex = geometry.getIndex();\r\n\r\n      if (geomIndex !== null) {\r\n        for (let i = 0; i < geomIndex.count; i += 3) {\r\n          const a = geomIndex.getX(i);\r\n          const b = geomIndex.getX(i + 1);\r\n          const c = geomIndex.getX(i + 2);\r\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\r\n          faces.push(triangle);\r\n        }\r\n      } else {\r\n        for (let i = 0; i < positionAttribute.count; i += 3) {\r\n          const a = i;\r\n          const b = i + 1;\r\n          const c = i + 2;\r\n          const triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\r\n          faces.push(triangle);\r\n        }\r\n      } // compute all edge collapse costs\r\n\r\n\r\n      for (let i = 0, il = vertices.length; i < il; i++) {\r\n        this.computeEdgeCostAtVertex(vertices[i]);\r\n      }\r\n\r\n      let nextVertex;\r\n      let z = count;\r\n\r\n      while (z--) {\r\n        nextVertex = this.minimumCostEdge(vertices);\r\n\r\n        if (!nextVertex) {\r\n          console.log('THREE.SimplifyModifier: No next vertex');\r\n          break;\r\n        } else {\r\n          this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\r\n        }\r\n      } //\r\n\r\n\r\n      const simplifiedGeometry = new BufferGeometry();\r\n      const position = [];\r\n      let index = []; //\r\n\r\n      for (let i = 0; i < vertices.length; i++) {\r\n        const vertex = vertices[i].position;\r\n        position.push(vertex.x, vertex.y, vertex.z);\r\n      } //\r\n\r\n\r\n      for (let i = 0; i < faces.length; i++) {\r\n        const face = faces[i];\r\n        const a = vertices.indexOf(face.v1);\r\n        const b = vertices.indexOf(face.v2);\r\n        const c = vertices.indexOf(face.v3);\r\n        index.push(a, b, c);\r\n      } //\r\n\r\n\r\n      simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\r\n      simplifiedGeometry.setIndex(index);\r\n      return simplifiedGeometry;\r\n    });\r\n  }\r\n\r\n  removeVertex(v, vertices) {\r\n    console.assert(v.faces.length === 0);\r\n\r\n    while (v.neighbors.length) {\r\n      const n = v.neighbors.pop();\r\n      removeFromArray(n.neighbors, v);\r\n    }\r\n\r\n    removeFromArray(vertices, v);\r\n  }\r\n\r\n}\r\n\r\nexport { SimplifyModifier };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}