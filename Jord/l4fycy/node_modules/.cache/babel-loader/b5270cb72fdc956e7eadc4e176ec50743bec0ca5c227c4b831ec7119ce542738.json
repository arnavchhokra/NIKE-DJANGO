{"ast":null,"code":"import { toArray } from './array';\nimport { isAutoFocusAllowedCached, isVisibleCached, notHiddenInput } from './is';\nimport { orderByTabIndex } from './tabOrder';\nimport { getFocusables, getParentAutofocusables } from './tabUtils';\n/**\r\n * given list of focusable elements keeps the ones user can interact with\r\n * @param nodes\r\n * @param visibilityCache\r\n */\nexport var filterFocusable = function (nodes, visibilityCache) {\n  return toArray(nodes).filter(function (node) {\n    return isVisibleCached(visibilityCache, node);\n  }).filter(function (node) {\n    return notHiddenInput(node);\n  });\n};\nexport var filterAutoFocusable = function (nodes, cache) {\n  if (cache === void 0) {\n    cache = new Map();\n  }\n  return toArray(nodes).filter(function (node) {\n    return isAutoFocusAllowedCached(cache, node);\n  });\n};\n/**\r\n * !__WARNING__! Low level API.\r\n * @returns all tabbable nodes\r\n *\r\n * @see {@link getFocusableNodes} to get any focusable element\r\n *\r\n * @param topNodes - array of top level HTMLElements to search inside\r\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\r\n */\nexport var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {\n  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);\n};\n/**\r\n * !__WARNING__! Low level API.\r\n *\r\n * @returns anything \"focusable\", not only tabbable. The difference is in `tabIndex=-1`\r\n * (without guards, as long as they are not expected to be ever focused)\r\n *\r\n * @see {@link getTabbableNodes} to get only tabble nodes element\r\n *\r\n * @param topNodes - array of top level HTMLElements to search inside\r\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\r\n */\nexport var getFocusableNodes = function (topNodes, visibilityCache) {\n  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);\n};\n/**\r\n * return list of nodes which are expected to be auto-focused\r\n * @param topNode\r\n * @param visibilityCache\r\n */\nexport var parentAutofocusables = function (topNode, visibilityCache) {\n  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);\n};\n/*\r\n * Determines if element is contained in scope, including nested shadow DOMs\r\n */\nexport var contains = function (scope, element) {\n  if (scope.shadowRoot) {\n    return contains(scope.shadowRoot, element);\n  } else {\n    if (Object.getPrototypeOf(scope).contains !== undefined && Object.getPrototypeOf(scope).contains.call(scope, element)) {\n      return true;\n    }\n    return toArray(scope.children).some(function (child) {\n      var _a;\n      if (child instanceof HTMLIFrameElement) {\n        var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;\n        if (iframeBody) {\n          return contains(iframeBody, element);\n        }\n        return false;\n      }\n      return contains(child, element);\n    });\n  }\n};","map":{"version":3,"names":["toArray","isAutoFocusAllowedCached","isVisibleCached","notHiddenInput","orderByTabIndex","getFocusables","getParentAutofocusables","filterFocusable","nodes","visibilityCache","filter","node","filterAutoFocusable","cache","Map","getTabbableNodes","topNodes","withGuards","getFocusableNodes","parentAutofocusables","topNode","contains","scope","element","shadowRoot","Object","getPrototypeOf","undefined","call","children","some","child","_a","HTMLIFrameElement","iframeBody","contentDocument","body"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/focus-lock/dist/es2015/utils/DOMutils.js"],"sourcesContent":["import { toArray } from './array';\r\nimport { isAutoFocusAllowedCached, isVisibleCached, notHiddenInput } from './is';\r\nimport { orderByTabIndex } from './tabOrder';\r\nimport { getFocusables, getParentAutofocusables } from './tabUtils';\r\n/**\r\n * given list of focusable elements keeps the ones user can interact with\r\n * @param nodes\r\n * @param visibilityCache\r\n */\r\nexport var filterFocusable = function (nodes, visibilityCache) {\r\n    return toArray(nodes)\r\n        .filter(function (node) { return isVisibleCached(visibilityCache, node); })\r\n        .filter(function (node) { return notHiddenInput(node); });\r\n};\r\nexport var filterAutoFocusable = function (nodes, cache) {\r\n    if (cache === void 0) { cache = new Map(); }\r\n    return toArray(nodes).filter(function (node) { return isAutoFocusAllowedCached(cache, node); });\r\n};\r\n/**\r\n * !__WARNING__! Low level API.\r\n * @returns all tabbable nodes\r\n *\r\n * @see {@link getFocusableNodes} to get any focusable element\r\n *\r\n * @param topNodes - array of top level HTMLElements to search inside\r\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\r\n */\r\nexport var getTabbableNodes = function (topNodes, visibilityCache, withGuards) {\r\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);\r\n};\r\n/**\r\n * !__WARNING__! Low level API.\r\n *\r\n * @returns anything \"focusable\", not only tabbable. The difference is in `tabIndex=-1`\r\n * (without guards, as long as they are not expected to be ever focused)\r\n *\r\n * @see {@link getTabbableNodes} to get only tabble nodes element\r\n *\r\n * @param topNodes - array of top level HTMLElements to search inside\r\n * @param visibilityCache - an cache to store intermediate measurements. Expected to be a fresh `new Map` on every call\r\n */\r\nexport var getFocusableNodes = function (topNodes, visibilityCache) {\r\n    return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);\r\n};\r\n/**\r\n * return list of nodes which are expected to be auto-focused\r\n * @param topNode\r\n * @param visibilityCache\r\n */\r\nexport var parentAutofocusables = function (topNode, visibilityCache) {\r\n    return filterFocusable(getParentAutofocusables(topNode), visibilityCache);\r\n};\r\n/*\r\n * Determines if element is contained in scope, including nested shadow DOMs\r\n */\r\nexport var contains = function (scope, element) {\r\n    if (scope.shadowRoot) {\r\n        return contains(scope.shadowRoot, element);\r\n    }\r\n    else {\r\n        if (Object.getPrototypeOf(scope).contains !== undefined &&\r\n            Object.getPrototypeOf(scope).contains.call(scope, element)) {\r\n            return true;\r\n        }\r\n        return toArray(scope.children).some(function (child) {\r\n            var _a;\r\n            if (child instanceof HTMLIFrameElement) {\r\n                var iframeBody = (_a = child.contentDocument) === null || _a === void 0 ? void 0 : _a.body;\r\n                if (iframeBody) {\r\n                    return contains(iframeBody, element);\r\n                }\r\n                return false;\r\n            }\r\n            return contains(child, element);\r\n        });\r\n    }\r\n};\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}