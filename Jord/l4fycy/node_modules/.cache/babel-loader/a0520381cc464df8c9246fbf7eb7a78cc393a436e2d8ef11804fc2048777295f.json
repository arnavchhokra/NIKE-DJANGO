{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { useFBO } from './useFBO.js';\nimport { useHelper } from './useHelper.js';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { Edges } from './Edges.js';\nimport { FullScreenQuad } from 'three-stdlib';\nimport { version } from '../helpers/constants.js';\nfunction createNormalMaterial() {\n  let side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : THREE.FrontSide;\n  const viewMatrix = {\n    value: new THREE.Matrix4()\n  };\n  return Object.assign(new THREE.MeshNormalMaterial({\n    side\n  }), {\n    viewMatrix,\n    onBeforeCompile: shader => {\n      shader.uniforms.viewMatrix = viewMatrix;\n      shader.fragmentShader = \"vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n         }\\n\" + shader.fragmentShader.replace('#include <normal_fragment_maps>', \"#include <normal_fragment_maps>\\n           normal = inverseTransformDirection( normal, viewMatrix );\\n\");\n    }\n  });\n}\nconst CausticsProjectionMaterial = /* @__PURE__ */shaderMaterial({\n  causticsTexture: null,\n  causticsTextureB: null,\n  color: /* @__PURE__ */new THREE.Color(),\n  lightProjMatrix: /* @__PURE__ */new THREE.Matrix4(),\n  lightViewMatrix: /* @__PURE__ */new THREE.Matrix4()\n}, \"varying vec3 vWorldPosition;   \\n   void main() {\\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\\n     vWorldPosition = worldPosition.xyz;\\n   }\", \"varying vec3 vWorldPosition;\\n  uniform vec3 color;\\n  uniform sampler2D causticsTexture; \\n  uniform sampler2D causticsTextureB; \\n  uniform mat4 lightProjMatrix;\\n  uniform mat4 lightViewMatrix;\\n   void main() {\\n    // Apply caustics  \\n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\\n    lightSpacePos.xyz /= lightSpacePos.w;\\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \\n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\\n    gl_FragColor = vec4((front + back) * color, 1.0);\\n    #include <tonemapping_fragment>\\n    #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n   }\"));\nconst CausticsMaterial = /* @__PURE__ */shaderMaterial({\n  cameraMatrixWorld: /* @__PURE__ */new THREE.Matrix4(),\n  cameraProjectionMatrixInv: /* @__PURE__ */new THREE.Matrix4(),\n  normalTexture: null,\n  depthTexture: null,\n  lightDir: /* @__PURE__ */new THREE.Vector3(0, 1, 0),\n  lightPlaneNormal: /* @__PURE__ */new THREE.Vector3(0, 1, 0),\n  lightPlaneConstant: 0,\n  near: 0.1,\n  far: 100,\n  modelMatrix: /* @__PURE__ */new THREE.Matrix4(),\n  worldRadius: 1 / 40,\n  ior: 1.1,\n  bounces: 0,\n  resolution: 1024,\n  size: 10,\n  intensity: 0.5\n}, /* glsl */\"\\n  varying vec2 vUv;\\n  void main() {\\n      vUv = uv;\\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n  }\", /* glsl */\"  \\n  uniform mat4 cameraMatrixWorld;\\n  uniform mat4 cameraProjectionMatrixInv;\\n  uniform vec3 lightDir;\\n  uniform vec3 lightPlaneNormal;\\n  uniform float lightPlaneConstant;\\n  uniform float near;\\n  uniform float far;\\n  uniform float time;\\n  uniform float worldRadius;\\n  uniform float resolution;\\n  uniform float size;\\n  uniform float intensity;\\n  uniform float ior;\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  uniform sampler2D normalTexture;\\n  uniform sampler2D depthTexture;\\n  uniform float bounces;\\n  varying vec2 vUv;\\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\\n    float z = depth * 2.0 - 1.0;\\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\\n    // Perspective division\\n    viewSpacePosition /= viewSpacePosition.w;\\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\\n    return worldSpacePosition.xyz;\\n  }                  \\n  float sdPlane( vec3 p, vec3 n, float h ) {\\n    // n must be normalized\\n    return dot(p,n) + h;\\n  }\\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\n  }\\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\\n    rayOrigin = ro;\\n    rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = pos + rayDirection * 0.1;\\n    return rayDirection;\\n  }\\n  void main() {\\n    // Each sample consists of random offset in the x and y direction\\n    float caustic = 0.0;\\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\\n    float texelsNeeded = worldRadius / causticTexelSize;\\n    float sampleRadius = texelsNeeded / resolution;\\n    float sum = 0.0;\\n    if (texture2D(depthTexture, vUv).x == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\\n    vec2 uv1 = vUv + offset1 * sampleRadius;\\n    vec2 uv2 = vUv + offset2 * sampleRadius;\\n    vec2 uv3 = vUv + offset3 * sampleRadius;\\n    vec2 uv4 = vUv + offset4 * sampleRadius;\\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\\n    // Sanity check the depths\\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\n      return;\\n    }\\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\\n    vec3 endPos1, endPos2, endPos3, endPos4;\\n    vec3 endDir1, endDir2, endDir3, endDir4;\\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\\n    caustic += intensity * (lightPosArea / finalArea);\\n    // Calculate the area of the triangle in light spaces\\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\\n  }\");\nconst NORMALPROPS = {\n  depth: true,\n  minFilter: THREE.LinearFilter,\n  magFilter: THREE.LinearFilter,\n  type: THREE.UnsignedByteType\n};\nconst CAUSTICPROPS = {\n  minFilter: THREE.LinearMipmapLinearFilter,\n  magFilter: THREE.LinearFilter,\n  type: THREE.FloatType,\n  generateMipmaps: true\n};\nconst Caustics = /* @__PURE__ */React.forwardRef((_ref, fref) => {\n  let {\n    debug,\n    children,\n    frames = 1,\n    ior = 1.1,\n    color = 'white',\n    causticsOnly = false,\n    backside = false,\n    backsideIOR = 1.1,\n    worldRadius = 0.3125,\n    intensity = 0.05,\n    resolution = 2024,\n    lightSource = [5, 5, 5],\n    ...props\n  } = _ref;\n  extend({\n    CausticsProjectionMaterial\n  });\n  const ref = React.useRef(null);\n  const camera = React.useRef(null);\n  const scene = React.useRef(null);\n  const plane = React.useRef(null);\n  const gl = useThree(state => state.gl);\n  const helper = useHelper(debug && camera, THREE.CameraHelper);\n\n  // Buffers for front and back faces\n  const normalTarget = useFBO(resolution, resolution, NORMALPROPS);\n  const normalTargetB = useFBO(resolution, resolution, NORMALPROPS);\n  const causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);\n  const causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS);\n  // Normal materials for front and back faces\n  const [normalMat] = React.useState(() => createNormalMaterial());\n  const [normalMatB] = React.useState(() => createNormalMaterial(THREE.BackSide));\n  // The quad that catches the caustics\n  const [causticsMaterial] = React.useState(() => new CausticsMaterial());\n  const [causticsQuad] = React.useState(() => new FullScreenQuad(causticsMaterial));\n  React.useLayoutEffect(() => {\n    ref.current.updateWorldMatrix(false, true);\n  });\n  let count = 0;\n  const v = new THREE.Vector3();\n  const lpF = new THREE.Frustum();\n  const lpM = new THREE.Matrix4();\n  const lpP = new THREE.Plane();\n  const lightDir = new THREE.Vector3();\n  const lightDirInv = new THREE.Vector3();\n  const bounds = new THREE.Box3();\n  const focusPos = new THREE.Vector3();\n  const boundsVertices = [];\n  const worldVerts = [];\n  const projectedVerts = [];\n  const lightDirs = [];\n  const cameraPos = new THREE.Vector3();\n  for (let i = 0; i < 8; i++) {\n    boundsVertices.push(new THREE.Vector3());\n    worldVerts.push(new THREE.Vector3());\n    projectedVerts.push(new THREE.Vector3());\n    lightDirs.push(new THREE.Vector3());\n  }\n  useFrame(() => {\n    if (frames === Infinity || count++ < frames) {\n      var _scene$current$parent, _helper$current;\n      if (Array.isArray(lightSource)) lightDir.fromArray(lightSource).normalize();else lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v)).normalize());\n      lightDirInv.copy(lightDir).multiplyScalar(-1);\n      (_scene$current$parent = scene.current.parent) == null || _scene$current$parent.matrixWorld.identity();\n      bounds.setFromObject(scene.current, true);\n      boundsVertices[0].set(bounds.min.x, bounds.min.y, bounds.min.z);\n      boundsVertices[1].set(bounds.min.x, bounds.min.y, bounds.max.z);\n      boundsVertices[2].set(bounds.min.x, bounds.max.y, bounds.min.z);\n      boundsVertices[3].set(bounds.min.x, bounds.max.y, bounds.max.z);\n      boundsVertices[4].set(bounds.max.x, bounds.min.y, bounds.min.z);\n      boundsVertices[5].set(bounds.max.x, bounds.min.y, bounds.max.z);\n      boundsVertices[6].set(bounds.max.x, bounds.max.y, bounds.min.z);\n      boundsVertices[7].set(bounds.max.x, bounds.max.y, bounds.max.z);\n      for (let i = 0; i < 8; i++) {\n        worldVerts[i].copy(boundsVertices[i]);\n      }\n      bounds.getCenter(focusPos);\n      boundsVertices.map(v => v.sub(focusPos));\n      const lightPlane = lpP.set(lightDirInv, 0);\n      boundsVertices.map((v, i) => lightPlane.projectPoint(v, projectedVerts[i]));\n      const centralVert = projectedVerts.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(projectedVerts.length);\n      const radius = projectedVerts.map(v => v.distanceTo(centralVert)).reduce((a, b) => Math.max(a, b));\n      const dirLength = boundsVertices.map(x => x.dot(lightDir)).reduce((a, b) => Math.max(a, b));\n      // Shadows\n      camera.current.position.copy(cameraPos.copy(lightDir).multiplyScalar(dirLength).add(focusPos));\n      camera.current.lookAt(scene.current.localToWorld(focusPos));\n      const dirMatrix = lpM.lookAt(camera.current.position, focusPos, v.set(0, 1, 0));\n      camera.current.left = -radius;\n      camera.current.right = radius;\n      camera.current.top = radius;\n      camera.current.bottom = -radius;\n      const yOffset = v.set(0, radius, 0).applyMatrix4(dirMatrix);\n      const yTime = (camera.current.position.y + yOffset.y) / lightDir.y;\n      camera.current.near = 0.1;\n      camera.current.far = yTime;\n      camera.current.updateProjectionMatrix();\n      camera.current.updateMatrixWorld();\n\n      // Now find size of ground plane\n      const groundProjectedCoords = worldVerts.map((v, i) => v.add(lightDirs[i].copy(lightDir).multiplyScalar(-v.y / lightDir.y)));\n      const centerPos = groundProjectedCoords.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);\n      const maxSize = 2 * groundProjectedCoords.map(v => Math.hypot(v.x - centerPos.x, v.z - centerPos.z)).reduce((a, b) => Math.max(a, b));\n      plane.current.scale.setScalar(maxSize);\n      plane.current.position.copy(centerPos);\n      if (debug) (_helper$current = helper.current) == null || _helper$current.update();\n\n      // Inject uniforms\n      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;\n      const dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];\n      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;\n      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;\n      causticsMaterial.lightDir = lightDirInv;\n      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;\n      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant;\n      causticsMaterial.near = camera.current.near;\n      causticsMaterial.far = camera.current.far;\n      causticsMaterial.resolution = resolution;\n      causticsMaterial.size = radius;\n      causticsMaterial.intensity = intensity;\n      causticsMaterial.worldRadius = worldRadius;\n\n      // Switch the scene on\n      scene.current.visible = true;\n\n      // Render front face normals\n      gl.setRenderTarget(normalTarget);\n      gl.clear();\n      scene.current.overrideMaterial = normalMat;\n      gl.render(scene.current, camera.current);\n\n      // Render back face normals, if enabled\n      gl.setRenderTarget(normalTargetB);\n      gl.clear();\n      if (backside) {\n        scene.current.overrideMaterial = normalMatB;\n        gl.render(scene.current, camera.current);\n      }\n\n      // Remove the override material\n      scene.current.overrideMaterial = null;\n\n      // Render front face caustics\n      causticsMaterial.ior = ior;\n      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;\n      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;\n      causticsMaterial.normalTexture = normalTarget.texture;\n      causticsMaterial.depthTexture = normalTarget.depthTexture;\n      gl.setRenderTarget(causticsTarget);\n      gl.clear();\n      causticsQuad.render(gl);\n\n      // Render back face caustics, if enabled\n      causticsMaterial.ior = backsideIOR;\n      causticsMaterial.normalTexture = normalTargetB.texture;\n      causticsMaterial.depthTexture = normalTargetB.depthTexture;\n      gl.setRenderTarget(causticsTargetB);\n      gl.clear();\n      if (backside) causticsQuad.render(gl);\n\n      // Reset render target\n      gl.setRenderTarget(null);\n\n      // Switch the scene off if caustics is all that's wanted\n      if (causticsOnly) scene.current.visible = false;\n    }\n  });\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props), /*#__PURE__*/React.createElement(\"scene\", {\n    ref: scene\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\n    ref: camera,\n    up: [0, 1, 0]\n  }), children), /*#__PURE__*/React.createElement(\"mesh\", {\n    renderOrder: 2,\n    ref: plane,\n    \"rotation-x\": -Math.PI / 2\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"causticsProjectionMaterial\", {\n    transparent: true,\n    color: color,\n    causticsTexture: causticsTarget.texture,\n    causticsTextureB: causticsTargetB.texture,\n    blending: THREE.CustomBlending,\n    blendSrc: THREE.OneFactor,\n    blendDst: THREE.SrcAlphaFactor,\n    depthWrite: false\n  }), debug && /*#__PURE__*/React.createElement(Edges, null, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\n    color: \"#ffff00\",\n    toneMapped: false\n  }))));\n});\nexport { Caustics };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useFrame","useFBO","useHelper","shaderMaterial","Edges","FullScreenQuad","version","createNormalMaterial","side","arguments","length","undefined","FrontSide","viewMatrix","value","Matrix4","Object","assign","MeshNormalMaterial","onBeforeCompile","shader","uniforms","fragmentShader","replace","CausticsProjectionMaterial","causticsTexture","causticsTextureB","color","Color","lightProjMatrix","lightViewMatrix","concat","CausticsMaterial","cameraMatrixWorld","cameraProjectionMatrixInv","normalTexture","depthTexture","lightDir","Vector3","lightPlaneNormal","lightPlaneConstant","near","far","modelMatrix","worldRadius","ior","bounces","resolution","size","intensity","NORMALPROPS","depth","minFilter","LinearFilter","magFilter","type","UnsignedByteType","CAUSTICPROPS","LinearMipmapLinearFilter","FloatType","generateMipmaps","Caustics","forwardRef","_ref","fref","debug","children","frames","causticsOnly","backside","backsideIOR","lightSource","props","ref","useRef","camera","scene","plane","gl","state","helper","CameraHelper","normalTarget","normalTargetB","causticsTarget","causticsTargetB","normalMat","useState","normalMatB","BackSide","causticsMaterial","causticsQuad","useLayoutEffect","current","updateWorldMatrix","count","v","lpF","Frustum","lpM","lpP","Plane","lightDirInv","bounds","Box3","focusPos","boundsVertices","worldVerts","projectedVerts","lightDirs","cameraPos","i","push","Infinity","_scene$current$parent","_helper$current","Array","isArray","fromArray","normalize","copy","worldToLocal","getWorldPosition","multiplyScalar","parent","matrixWorld","identity","setFromObject","set","min","x","y","z","max","getCenter","map","sub","lightPlane","projectPoint","centralVert","reduce","a","b","add","divideScalar","radius","distanceTo","Math","dirLength","dot","position","lookAt","localToWorld","dirMatrix","left","right","top","bottom","yOffset","applyMatrix4","yTime","updateProjectionMatrix","updateMatrixWorld","groundProjectedCoords","centerPos","maxSize","hypot","scale","setScalar","update","matrixWorldInverse","dirLightNearPlane","setFromProjectionMatrix","multiplyMatrices","projectionMatrix","planes","projectionMatrixInverse","normal","constant","visible","setRenderTarget","clear","overrideMaterial","render","material","texture","useImperativeHandle","createElement","up","renderOrder","PI","transparent","blending","CustomBlending","blendSrc","OneFactor","blendDst","SrcAlphaFactor","depthWrite","toneMapped"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/@react-three/drei/core/Caustics.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\r\nimport * as THREE from 'three';\r\nimport * as React from 'react';\r\nimport { extend, useThree, useFrame } from '@react-three/fiber';\r\nimport { useFBO } from './useFBO.js';\r\nimport { useHelper } from './useHelper.js';\r\nimport { shaderMaterial } from './shaderMaterial.js';\r\nimport { Edges } from './Edges.js';\r\nimport { FullScreenQuad } from 'three-stdlib';\r\nimport { version } from '../helpers/constants.js';\r\n\r\nfunction createNormalMaterial(side = THREE.FrontSide) {\r\n  const viewMatrix = {\r\n    value: new THREE.Matrix4()\r\n  };\r\n  return Object.assign(new THREE.MeshNormalMaterial({\r\n    side\r\n  }), {\r\n    viewMatrix,\r\n    onBeforeCompile: shader => {\r\n      shader.uniforms.viewMatrix = viewMatrix;\r\n      shader.fragmentShader = `vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n         }\\n` + shader.fragmentShader.replace('#include <normal_fragment_maps>', `#include <normal_fragment_maps>\r\n           normal = inverseTransformDirection( normal, viewMatrix );\\n`);\r\n    }\r\n  });\r\n}\r\nconst CausticsProjectionMaterial = /* @__PURE__ */shaderMaterial({\r\n  causticsTexture: null,\r\n  causticsTextureB: null,\r\n  color: /* @__PURE__ */new THREE.Color(),\r\n  lightProjMatrix: /* @__PURE__ */new THREE.Matrix4(),\r\n  lightViewMatrix: /* @__PURE__ */new THREE.Matrix4()\r\n}, `varying vec3 vWorldPosition;   \r\n   void main() {\r\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\r\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\r\n     vWorldPosition = worldPosition.xyz;\r\n   }`, `varying vec3 vWorldPosition;\r\n  uniform vec3 color;\r\n  uniform sampler2D causticsTexture; \r\n  uniform sampler2D causticsTextureB; \r\n  uniform mat4 lightProjMatrix;\r\n  uniform mat4 lightViewMatrix;\r\n   void main() {\r\n    // Apply caustics  \r\n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\r\n    lightSpacePos.xyz /= lightSpacePos.w;\r\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \r\n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\r\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\r\n    gl_FragColor = vec4((front + back) * color, 1.0);\r\n    #include <tonemapping_fragment>\r\n    #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\r\n   }`);\r\nconst CausticsMaterial = /* @__PURE__ */shaderMaterial({\r\n  cameraMatrixWorld: /* @__PURE__ */new THREE.Matrix4(),\r\n  cameraProjectionMatrixInv: /* @__PURE__ */new THREE.Matrix4(),\r\n  normalTexture: null,\r\n  depthTexture: null,\r\n  lightDir: /* @__PURE__ */new THREE.Vector3(0, 1, 0),\r\n  lightPlaneNormal: /* @__PURE__ */new THREE.Vector3(0, 1, 0),\r\n  lightPlaneConstant: 0,\r\n  near: 0.1,\r\n  far: 100,\r\n  modelMatrix: /* @__PURE__ */new THREE.Matrix4(),\r\n  worldRadius: 1 / 40,\r\n  ior: 1.1,\r\n  bounces: 0,\r\n  resolution: 1024,\r\n  size: 10,\r\n  intensity: 0.5\r\n}, /* glsl */`\r\n  varying vec2 vUv;\r\n  void main() {\r\n      vUv = uv;\r\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  }`, /* glsl */`  \r\n  uniform mat4 cameraMatrixWorld;\r\n  uniform mat4 cameraProjectionMatrixInv;\r\n  uniform vec3 lightDir;\r\n  uniform vec3 lightPlaneNormal;\r\n  uniform float lightPlaneConstant;\r\n  uniform float near;\r\n  uniform float far;\r\n  uniform float time;\r\n  uniform float worldRadius;\r\n  uniform float resolution;\r\n  uniform float size;\r\n  uniform float intensity;\r\n  uniform float ior;\r\n  precision highp isampler2D;\r\n  precision highp usampler2D;\r\n  uniform sampler2D normalTexture;\r\n  uniform sampler2D depthTexture;\r\n  uniform float bounces;\r\n  varying vec2 vUv;\r\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\r\n    float z = depth * 2.0 - 1.0;\r\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\r\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\r\n    // Perspective division\r\n    viewSpacePosition /= viewSpacePosition.w;\r\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\r\n    return worldSpacePosition.xyz;\r\n  }                  \r\n  float sdPlane( vec3 p, vec3 n, float h ) {\r\n    // n must be normalized\r\n    return dot(p,n) + h;\r\n  }\r\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\r\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\r\n  }\r\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\r\n    rayOrigin = ro;\r\n    rayDirection = rd;\r\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\r\n    rayOrigin = pos + rayDirection * 0.1;\r\n    return rayDirection;\r\n  }\r\n  void main() {\r\n    // Each sample consists of random offset in the x and y direction\r\n    float caustic = 0.0;\r\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\r\n    float texelsNeeded = worldRadius / causticTexelSize;\r\n    float sampleRadius = texelsNeeded / resolution;\r\n    float sum = 0.0;\r\n    if (texture2D(depthTexture, vUv).x == 1.0) {\r\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n      return;\r\n    }\r\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\r\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\r\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\r\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\r\n    vec2 uv1 = vUv + offset1 * sampleRadius;\r\n    vec2 uv2 = vUv + offset2 * sampleRadius;\r\n    vec2 uv3 = vUv + offset3 * sampleRadius;\r\n    vec2 uv4 = vUv + offset4 * sampleRadius;\r\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\r\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\r\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\r\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\r\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\r\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\r\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\r\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\r\n    // Sanity check the depths\r\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\r\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n      return;\r\n    }\r\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\r\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\r\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\r\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\r\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\r\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\r\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\r\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\r\n    vec3 endPos1, endPos2, endPos3, endPos4;\r\n    vec3 endDir1, endDir2, endDir3, endDir4;\r\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\r\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\r\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\r\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\r\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\r\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\r\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\r\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\r\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\r\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\r\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\r\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\r\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\r\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\r\n    caustic += intensity * (lightPosArea / finalArea);\r\n    // Calculate the area of the triangle in light spaces\r\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\r\n  }`);\r\nconst NORMALPROPS = {\r\n  depth: true,\r\n  minFilter: THREE.LinearFilter,\r\n  magFilter: THREE.LinearFilter,\r\n  type: THREE.UnsignedByteType\r\n};\r\nconst CAUSTICPROPS = {\r\n  minFilter: THREE.LinearMipmapLinearFilter,\r\n  magFilter: THREE.LinearFilter,\r\n  type: THREE.FloatType,\r\n  generateMipmaps: true\r\n};\r\nconst Caustics = /* @__PURE__ */React.forwardRef(({\r\n  debug,\r\n  children,\r\n  frames = 1,\r\n  ior = 1.1,\r\n  color = 'white',\r\n  causticsOnly = false,\r\n  backside = false,\r\n  backsideIOR = 1.1,\r\n  worldRadius = 0.3125,\r\n  intensity = 0.05,\r\n  resolution = 2024,\r\n  lightSource = [5, 5, 5],\r\n  ...props\r\n}, fref) => {\r\n  extend({\r\n    CausticsProjectionMaterial\r\n  });\r\n  const ref = React.useRef(null);\r\n  const camera = React.useRef(null);\r\n  const scene = React.useRef(null);\r\n  const plane = React.useRef(null);\r\n  const gl = useThree(state => state.gl);\r\n  const helper = useHelper(debug && camera, THREE.CameraHelper);\r\n\r\n  // Buffers for front and back faces\r\n  const normalTarget = useFBO(resolution, resolution, NORMALPROPS);\r\n  const normalTargetB = useFBO(resolution, resolution, NORMALPROPS);\r\n  const causticsTarget = useFBO(resolution, resolution, CAUSTICPROPS);\r\n  const causticsTargetB = useFBO(resolution, resolution, CAUSTICPROPS);\r\n  // Normal materials for front and back faces\r\n  const [normalMat] = React.useState(() => createNormalMaterial());\r\n  const [normalMatB] = React.useState(() => createNormalMaterial(THREE.BackSide));\r\n  // The quad that catches the caustics\r\n  const [causticsMaterial] = React.useState(() => new CausticsMaterial());\r\n  const [causticsQuad] = React.useState(() => new FullScreenQuad(causticsMaterial));\r\n  React.useLayoutEffect(() => {\r\n    ref.current.updateWorldMatrix(false, true);\r\n  });\r\n  let count = 0;\r\n  const v = new THREE.Vector3();\r\n  const lpF = new THREE.Frustum();\r\n  const lpM = new THREE.Matrix4();\r\n  const lpP = new THREE.Plane();\r\n  const lightDir = new THREE.Vector3();\r\n  const lightDirInv = new THREE.Vector3();\r\n  const bounds = new THREE.Box3();\r\n  const focusPos = new THREE.Vector3();\r\n  const boundsVertices = [];\r\n  const worldVerts = [];\r\n  const projectedVerts = [];\r\n  const lightDirs = [];\r\n  const cameraPos = new THREE.Vector3();\r\n  for (let i = 0; i < 8; i++) {\r\n    boundsVertices.push(new THREE.Vector3());\r\n    worldVerts.push(new THREE.Vector3());\r\n    projectedVerts.push(new THREE.Vector3());\r\n    lightDirs.push(new THREE.Vector3());\r\n  }\r\n  useFrame(() => {\r\n    if (frames === Infinity || count++ < frames) {\r\n      var _scene$current$parent, _helper$current;\r\n      if (Array.isArray(lightSource)) lightDir.fromArray(lightSource).normalize();else lightDir.copy(ref.current.worldToLocal(lightSource.current.getWorldPosition(v)).normalize());\r\n      lightDirInv.copy(lightDir).multiplyScalar(-1);\r\n      (_scene$current$parent = scene.current.parent) == null || _scene$current$parent.matrixWorld.identity();\r\n      bounds.setFromObject(scene.current, true);\r\n      boundsVertices[0].set(bounds.min.x, bounds.min.y, bounds.min.z);\r\n      boundsVertices[1].set(bounds.min.x, bounds.min.y, bounds.max.z);\r\n      boundsVertices[2].set(bounds.min.x, bounds.max.y, bounds.min.z);\r\n      boundsVertices[3].set(bounds.min.x, bounds.max.y, bounds.max.z);\r\n      boundsVertices[4].set(bounds.max.x, bounds.min.y, bounds.min.z);\r\n      boundsVertices[5].set(bounds.max.x, bounds.min.y, bounds.max.z);\r\n      boundsVertices[6].set(bounds.max.x, bounds.max.y, bounds.min.z);\r\n      boundsVertices[7].set(bounds.max.x, bounds.max.y, bounds.max.z);\r\n      for (let i = 0; i < 8; i++) {\r\n        worldVerts[i].copy(boundsVertices[i]);\r\n      }\r\n      bounds.getCenter(focusPos);\r\n      boundsVertices.map(v => v.sub(focusPos));\r\n      const lightPlane = lpP.set(lightDirInv, 0);\r\n      boundsVertices.map((v, i) => lightPlane.projectPoint(v, projectedVerts[i]));\r\n      const centralVert = projectedVerts.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(projectedVerts.length);\r\n      const radius = projectedVerts.map(v => v.distanceTo(centralVert)).reduce((a, b) => Math.max(a, b));\r\n      const dirLength = boundsVertices.map(x => x.dot(lightDir)).reduce((a, b) => Math.max(a, b));\r\n      // Shadows\r\n      camera.current.position.copy(cameraPos.copy(lightDir).multiplyScalar(dirLength).add(focusPos));\r\n      camera.current.lookAt(scene.current.localToWorld(focusPos));\r\n      const dirMatrix = lpM.lookAt(camera.current.position, focusPos, v.set(0, 1, 0));\r\n      camera.current.left = -radius;\r\n      camera.current.right = radius;\r\n      camera.current.top = radius;\r\n      camera.current.bottom = -radius;\r\n      const yOffset = v.set(0, radius, 0).applyMatrix4(dirMatrix);\r\n      const yTime = (camera.current.position.y + yOffset.y) / lightDir.y;\r\n      camera.current.near = 0.1;\r\n      camera.current.far = yTime;\r\n      camera.current.updateProjectionMatrix();\r\n      camera.current.updateMatrixWorld();\r\n\r\n      // Now find size of ground plane\r\n      const groundProjectedCoords = worldVerts.map((v, i) => v.add(lightDirs[i].copy(lightDir).multiplyScalar(-v.y / lightDir.y)));\r\n      const centerPos = groundProjectedCoords.reduce((a, b) => a.add(b), v.set(0, 0, 0)).divideScalar(groundProjectedCoords.length);\r\n      const maxSize = 2 * groundProjectedCoords.map(v => Math.hypot(v.x - centerPos.x, v.z - centerPos.z)).reduce((a, b) => Math.max(a, b));\r\n      plane.current.scale.setScalar(maxSize);\r\n      plane.current.position.copy(centerPos);\r\n      if (debug) (_helper$current = helper.current) == null || _helper$current.update();\r\n\r\n      // Inject uniforms\r\n      normalMatB.viewMatrix.value = normalMat.viewMatrix.value = camera.current.matrixWorldInverse;\r\n      const dirLightNearPlane = lpF.setFromProjectionMatrix(lpM.multiplyMatrices(camera.current.projectionMatrix, camera.current.matrixWorldInverse)).planes[4];\r\n      causticsMaterial.cameraMatrixWorld = camera.current.matrixWorld;\r\n      causticsMaterial.cameraProjectionMatrixInv = camera.current.projectionMatrixInverse;\r\n      causticsMaterial.lightDir = lightDirInv;\r\n      causticsMaterial.lightPlaneNormal = dirLightNearPlane.normal;\r\n      causticsMaterial.lightPlaneConstant = dirLightNearPlane.constant;\r\n      causticsMaterial.near = camera.current.near;\r\n      causticsMaterial.far = camera.current.far;\r\n      causticsMaterial.resolution = resolution;\r\n      causticsMaterial.size = radius;\r\n      causticsMaterial.intensity = intensity;\r\n      causticsMaterial.worldRadius = worldRadius;\r\n\r\n      // Switch the scene on\r\n      scene.current.visible = true;\r\n\r\n      // Render front face normals\r\n      gl.setRenderTarget(normalTarget);\r\n      gl.clear();\r\n      scene.current.overrideMaterial = normalMat;\r\n      gl.render(scene.current, camera.current);\r\n\r\n      // Render back face normals, if enabled\r\n      gl.setRenderTarget(normalTargetB);\r\n      gl.clear();\r\n      if (backside) {\r\n        scene.current.overrideMaterial = normalMatB;\r\n        gl.render(scene.current, camera.current);\r\n      }\r\n\r\n      // Remove the override material\r\n      scene.current.overrideMaterial = null;\r\n\r\n      // Render front face caustics\r\n      causticsMaterial.ior = ior;\r\n      plane.current.material.lightProjMatrix = camera.current.projectionMatrix;\r\n      plane.current.material.lightViewMatrix = camera.current.matrixWorldInverse;\r\n      causticsMaterial.normalTexture = normalTarget.texture;\r\n      causticsMaterial.depthTexture = normalTarget.depthTexture;\r\n      gl.setRenderTarget(causticsTarget);\r\n      gl.clear();\r\n      causticsQuad.render(gl);\r\n\r\n      // Render back face caustics, if enabled\r\n      causticsMaterial.ior = backsideIOR;\r\n      causticsMaterial.normalTexture = normalTargetB.texture;\r\n      causticsMaterial.depthTexture = normalTargetB.depthTexture;\r\n      gl.setRenderTarget(causticsTargetB);\r\n      gl.clear();\r\n      if (backside) causticsQuad.render(gl);\r\n\r\n      // Reset render target\r\n      gl.setRenderTarget(null);\r\n\r\n      // Switch the scene off if caustics is all that's wanted\r\n      if (causticsOnly) scene.current.visible = false;\r\n    }\r\n  });\r\n  React.useImperativeHandle(fref, () => ref.current, []);\r\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\r\n    ref: ref\r\n  }, props), /*#__PURE__*/React.createElement(\"scene\", {\r\n    ref: scene\r\n  }, /*#__PURE__*/React.createElement(\"orthographicCamera\", {\r\n    ref: camera,\r\n    up: [0, 1, 0]\r\n  }), children), /*#__PURE__*/React.createElement(\"mesh\", {\r\n    renderOrder: 2,\r\n    ref: plane,\r\n    \"rotation-x\": -Math.PI / 2\r\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", null), /*#__PURE__*/React.createElement(\"causticsProjectionMaterial\", {\r\n    transparent: true,\r\n    color: color,\r\n    causticsTexture: causticsTarget.texture,\r\n    causticsTextureB: causticsTargetB.texture,\r\n    blending: THREE.CustomBlending,\r\n    blendSrc: THREE.OneFactor,\r\n    blendDst: THREE.SrcAlphaFactor,\r\n    depthWrite: false\r\n  }), debug && /*#__PURE__*/React.createElement(Edges, null, /*#__PURE__*/React.createElement(\"lineBasicMaterial\", {\r\n    color: \"#ffff00\",\r\n    toneMapped: false\r\n  }))));\r\n});\r\n\r\nexport { Caustics };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}