{"ast":null,"code":"import _classCallCheck from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, Vector3, Matrix4 } from 'three';\nimport { gunzipSync } from 'fflate';\nimport { Volume } from '../misc/Volume.js';\n\nvar NRRDLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(NRRDLoader, _Loader);\n\n  var _super = _createSuper(NRRDLoader);\n\n  function NRRDLoader(manager) {\n    _classCallCheck(this, NRRDLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(NRRDLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      loader.load(url, function (data) {\n        try {\n          onLoad(scope.parse(data));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(data) {\n      // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n      var _data = data;\n      var _dataPointer = 0;\n\n      var _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n\n      var _littleEndian = true;\n      var headerObject = {};\n\n      function scan(type, chunks) {\n        if (chunks === undefined || chunks === null) {\n          chunks = 1;\n        }\n\n        var _chunkSize = 1;\n        var _array_type = Uint8Array;\n\n        switch (type) {\n          // 1 byte data types\n          case 'uchar':\n            break;\n\n          case 'schar':\n            _array_type = Int8Array;\n            break;\n          // 2 byte data types\n\n          case 'ushort':\n            _array_type = Uint16Array;\n            _chunkSize = 2;\n            break;\n\n          case 'sshort':\n            _array_type = Int16Array;\n            _chunkSize = 2;\n            break;\n          // 4 byte data types\n\n          case 'uint':\n            _array_type = Uint32Array;\n            _chunkSize = 4;\n            break;\n\n          case 'sint':\n            _array_type = Int32Array;\n            _chunkSize = 4;\n            break;\n\n          case 'float':\n            _array_type = Float32Array;\n            _chunkSize = 4;\n            break;\n\n          case 'complex':\n            _array_type = Float64Array;\n            _chunkSize = 8;\n            break;\n\n          case 'double':\n            _array_type = Float64Array;\n            _chunkSize = 8;\n            break;\n        } // increase the data pointer in-place\n\n\n        var _bytes = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize)); // if required, flip the endianness of the bytes\n\n\n        if (_nativeLittleEndian != _littleEndian) {\n          // we need to flip here since the format doesn't match the native endianness\n          _bytes = flipEndianness(_bytes, _chunkSize);\n        }\n\n        if (chunks == 1) {\n          // if only one chunk was requested, just return one value\n          return _bytes[0];\n        } // return the byte array\n\n\n        return _bytes;\n      } //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n\n      function flipEndianness(array, chunkSize) {\n        var u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n\n        for (var _i2 = 0; _i2 < array.byteLength; _i2 += chunkSize) {\n          for (var j = _i2 + chunkSize - 1, k = _i2; j > k; j--, k++) {\n            var tmp = u8[k];\n            u8[k] = u8[j];\n            u8[j] = tmp;\n          }\n        }\n\n        return array;\n      } //parse the header\n\n\n      function parseHeader(header) {\n        var data, field, fn, i, l, m, _i, _len;\n\n        var lines = header.split(/\\r?\\n/);\n\n        for (_i = 0, _len = lines.length; _i < _len; _i++) {\n          l = lines[_i];\n\n          if (l.match(/NRRD\\d+/)) {\n            headerObject.isNrrd = true;\n          } else if (l.match(/^#/)) ;else if (m = l.match(/(.*):(.*)/)) {\n            field = m[1].trim();\n            data = m[2].trim();\n            fn = _fieldFunctions[field];\n\n            if (fn) {\n              fn.call(headerObject, data);\n            } else {\n              headerObject[field] = data;\n            }\n          }\n        }\n\n        if (!headerObject.isNrrd) {\n          throw new Error('Not an NRRD file');\n        }\n\n        if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n          throw new Error('Bzip is not supported');\n        }\n\n        if (!headerObject.vectors) {\n          //if no space direction is set, let's use the identity\n          headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)]; //apply spacing if defined\n\n          if (headerObject.spacings) {\n            for (i = 0; i <= 2; i++) {\n              if (!isNaN(headerObject.spacings[i])) {\n                headerObject.vectors[i].multiplyScalar(headerObject.spacings[i]);\n              }\n            }\n          }\n        }\n      } //parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n\n\n      function parseDataAsText(data, start, end) {\n        var number = '';\n        start = start || 0;\n        end = end || data.length;\n        var value; //length of the result is the product of the sizes\n\n        var lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n          return previous * current;\n        }, 1);\n        var base = 10;\n\n        if (headerObject.encoding === 'hex') {\n          base = 16;\n        }\n\n        var result = new headerObject.__array(lengthOfTheResult);\n        var resultIndex = 0;\n        var parsingFunction = parseInt;\n\n        if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n          parsingFunction = parseFloat;\n        }\n\n        for (var _i3 = start; _i3 < end; _i3++) {\n          value = data[_i3]; //if value is not a space\n\n          if ((value < 9 || value > 13) && value !== 32) {\n            number += String.fromCharCode(value);\n          } else {\n            if (number !== '') {\n              result[resultIndex] = parsingFunction(number, base);\n              resultIndex++;\n            }\n\n            number = '';\n          }\n        }\n\n        if (number !== '') {\n          result[resultIndex] = parsingFunction(number, base);\n          resultIndex++;\n        }\n\n        return result;\n      }\n\n      var _bytes = scan('uchar', data.byteLength);\n\n      var _length = _bytes.length;\n      var _header = null;\n      var _data_start = 0;\n      var i;\n\n      for (i = 1; i < _length; i++) {\n        if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n          // we found two line breaks in a row\n          // now we know what the header is\n          _header = this.parseChars(_bytes, 0, i - 2); // this is were the data starts\n\n          _data_start = i + 1;\n          break;\n        }\n      } // parse the header\n\n\n      parseHeader(_header);\n      _data = _bytes.subarray(_data_start); // the data without header\n\n      if (headerObject.encoding.substring(0, 2) === 'gz') {\n        // we need to decompress the datastream\n        // here we start the unzipping and get a typed Uint8Array back\n        _data = gunzipSync(new Uint8Array(_data)); // eslint-disable-line no-undef\n      } else if (headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex') {\n        _data = parseDataAsText(_data);\n      } else if (headerObject.encoding === 'raw') {\n        //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n        var _copy = new Uint8Array(_data.length);\n\n        for (var _i4 = 0; _i4 < _data.length; _i4++) {\n          _copy[_i4] = _data[_i4];\n        }\n\n        _data = _copy;\n      } // .. let's use the underlying array buffer\n\n\n      _data = _data.buffer;\n      var volume = new Volume();\n      volume.header = headerObject; //\n      // parse the (unzipped) data to a datastream of the correct type\n      //\n\n      volume.data = new headerObject.__array(_data); // get the min and max intensities\n\n      var min_max = volume.computeMinMax();\n      var min = min_max[0];\n      var max = min_max[1]; // attach the scalar range to the volume\n\n      volume.windowLow = min;\n      volume.windowHigh = max; // get the image dimensions\n\n      volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n      volume.xLength = volume.dimensions[0];\n      volume.yLength = volume.dimensions[1];\n      volume.zLength = volume.dimensions[2]; // spacing\n\n      var spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n      var spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n      var spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n      volume.spacing = [spacingX, spacingY, spacingZ]; // Create IJKtoRAS matrix\n\n      volume.matrix = new Matrix4();\n      var _spaceX = 1;\n      var _spaceY = 1;\n      var _spaceZ = 1;\n\n      if (headerObject.space == 'left-posterior-superior') {\n        _spaceX = -1;\n        _spaceY = -1;\n      } else if (headerObject.space === 'left-anterior-superior') {\n        _spaceX = -1;\n      }\n\n      if (!headerObject.vectors) {\n        volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n      } else {\n        var v = headerObject.vectors;\n        volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n      }\n\n      volume.inverseMatrix = new Matrix4();\n      volume.inverseMatrix.copy(volume.matrix).invert();\n      volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs); // .. and set the default threshold\n      // only if the threshold was not already set\n\n      if (volume.lowerThreshold === -Infinity) {\n        volume.lowerThreshold = min;\n      }\n\n      if (volume.upperThreshold === Infinity) {\n        volume.upperThreshold = max;\n      }\n\n      return volume;\n    }\n  }, {\n    key: \"parseChars\",\n    value: function parseChars(array, start, end) {\n      // without borders, use the whole array\n      if (start === undefined) {\n        start = 0;\n      }\n\n      if (end === undefined) {\n        end = array.length;\n      }\n\n      var output = ''; // create and append the chars\n\n      var i = 0;\n\n      for (i = start; i < end; ++i) {\n        output += String.fromCharCode(array[i]);\n      }\n\n      return output;\n    }\n  }]);\n\n  return NRRDLoader;\n}(Loader);\n\nvar _fieldFunctions = {\n  type: function type(data) {\n    switch (data) {\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8':\n      case 'uint8_t':\n        this.__array = Uint8Array;\n        break;\n\n      case 'signed char':\n      case 'int8':\n      case 'int8_t':\n        this.__array = Int8Array;\n        break;\n\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16':\n      case 'int16_t':\n        this.__array = Int16Array;\n        break;\n\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16':\n      case 'uint16_t':\n        this.__array = Uint16Array;\n        break;\n\n      case 'int':\n      case 'signed int':\n      case 'int32':\n      case 'int32_t':\n        this.__array = Int32Array;\n        break;\n\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32':\n      case 'uint32_t':\n        this.__array = Uint32Array;\n        break;\n\n      case 'float':\n        this.__array = Float32Array;\n        break;\n\n      case 'double':\n        this.__array = Float64Array;\n        break;\n\n      default:\n        throw new Error('Unsupported NRRD data type: ' + data);\n    }\n\n    return this.type = data;\n  },\n  endian: function endian(data) {\n    return this.endian = data;\n  },\n  encoding: function encoding(data) {\n    return this.encoding = data;\n  },\n  dimension: function dimension(data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function sizes(data) {\n    var i;\n    return this.sizes = function () {\n      var _ref = data.split(/\\s+/);\n\n      var _results = [];\n\n      for (var _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n\n        _results.push(parseInt(i, 10));\n      }\n\n      return _results;\n    }();\n  },\n  space: function space(data) {\n    return this.space = data;\n  },\n  'space origin': function spaceOrigin(data) {\n    return this.space_origin = data.split('(')[1].split(')')[0].split(',');\n  },\n  'space directions': function spaceDirections(data) {\n    var f, v;\n    var parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      var _results = [];\n\n      for (var _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n\n        _results.push(function () {\n          var _ref = v.slice(1, -1).split(/,/);\n\n          var _results2 = [];\n\n          for (var _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n\n            _results2.push(parseFloat(f));\n          }\n\n          return _results2;\n        }());\n      }\n\n      return _results;\n    }();\n  },\n  spacings: function spacings(data) {\n    var f;\n    var parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      var _results = [];\n\n      for (var _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n\n        _results.push(parseFloat(f));\n      }\n\n      return _results;\n    }();\n  }\n};\nexport { NRRDLoader };","map":{"version":3,"names":["Loader","FileLoader","Vector3","Matrix4","gunzipSync","Volume","NRRDLoader","manager","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","data","parse","e","console","error","itemError","_data","_dataPointer","_nativeLittleEndian","Int8Array","Int16Array","buffer","_littleEndian","headerObject","scan","type","chunks","undefined","_chunkSize","_array_type","Uint8Array","Uint16Array","Uint32Array","Int32Array","Float32Array","Float64Array","_bytes","slice","flipEndianness","array","chunkSize","u8","byteOffset","byteLength","i","j","k","tmp","parseHeader","header","field","fn","l","m","_i","_len","lines","split","length","match","isNrrd","trim","_fieldFunctions","call","Error","encoding","vectors","spacings","isNaN","multiplyScalar","parseDataAsText","start","end","number","value","lengthOfTheResult","sizes","reduce","previous","current","base","result","__array","resultIndex","parsingFunction","parseInt","parseFloat","String","fromCharCode","_length","_header","_data_start","parseChars","subarray","substring","_copy","volume","min_max","computeMinMax","min","max","windowLow","windowHigh","dimensions","xLength","yLength","zLength","spacingX","spacingY","spacingZ","spacing","matrix","_spaceX","_spaceY","_spaceZ","space","set","v","inverseMatrix","copy","invert","RASDimensions","applyMatrix4","round","toArray","map","Math","abs","lowerThreshold","Infinity","upperThreshold","output","endian","dimension","dim","_ref","_results","push","space_origin","f","parts","_results2","_j","_len2"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/loaders/NRRDLoader.js"],"sourcesContent":["import { Loader, FileLoader, Vector3, Matrix4 } from 'three';\nimport { gunzipSync } from 'fflate';\nimport { Volume } from '../misc/Volume.js';\n\nclass NRRDLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (data) {\n      try {\n        onLoad(scope.parse(data));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(data) {\n    // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n    let _data = data;\n    let _dataPointer = 0;\n\n    const _nativeLittleEndian = new Int8Array(new Int16Array([1]).buffer)[0] > 0;\n\n    const _littleEndian = true;\n    const headerObject = {};\n\n    function scan(type, chunks) {\n      if (chunks === undefined || chunks === null) {\n        chunks = 1;\n      }\n\n      let _chunkSize = 1;\n      let _array_type = Uint8Array;\n\n      switch (type) {\n        // 1 byte data types\n        case 'uchar':\n          break;\n\n        case 'schar':\n          _array_type = Int8Array;\n          break;\n        // 2 byte data types\n\n        case 'ushort':\n          _array_type = Uint16Array;\n          _chunkSize = 2;\n          break;\n\n        case 'sshort':\n          _array_type = Int16Array;\n          _chunkSize = 2;\n          break;\n        // 4 byte data types\n\n        case 'uint':\n          _array_type = Uint32Array;\n          _chunkSize = 4;\n          break;\n\n        case 'sint':\n          _array_type = Int32Array;\n          _chunkSize = 4;\n          break;\n\n        case 'float':\n          _array_type = Float32Array;\n          _chunkSize = 4;\n          break;\n\n        case 'complex':\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n\n        case 'double':\n          _array_type = Float64Array;\n          _chunkSize = 8;\n          break;\n      } // increase the data pointer in-place\n\n\n      let _bytes = new _array_type(_data.slice(_dataPointer, _dataPointer += chunks * _chunkSize)); // if required, flip the endianness of the bytes\n\n\n      if (_nativeLittleEndian != _littleEndian) {\n        // we need to flip here since the format doesn't match the native endianness\n        _bytes = flipEndianness(_bytes, _chunkSize);\n      }\n\n      if (chunks == 1) {\n        // if only one chunk was requested, just return one value\n        return _bytes[0];\n      } // return the byte array\n\n\n      return _bytes;\n    } //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n\n\n    function flipEndianness(array, chunkSize) {\n      const u8 = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);\n\n      for (let i = 0; i < array.byteLength; i += chunkSize) {\n        for (let j = i + chunkSize - 1, k = i; j > k; j--, k++) {\n          const tmp = u8[k];\n          u8[k] = u8[j];\n          u8[j] = tmp;\n        }\n      }\n\n      return array;\n    } //parse the header\n\n\n    function parseHeader(header) {\n      let data, field, fn, i, l, m, _i, _len;\n\n      const lines = header.split(/\\r?\\n/);\n\n      for (_i = 0, _len = lines.length; _i < _len; _i++) {\n        l = lines[_i];\n\n        if (l.match(/NRRD\\d+/)) {\n          headerObject.isNrrd = true;\n        } else if (l.match(/^#/)) ; else if (m = l.match(/(.*):(.*)/)) {\n          field = m[1].trim();\n          data = m[2].trim();\n          fn = _fieldFunctions[field];\n\n          if (fn) {\n            fn.call(headerObject, data);\n          } else {\n            headerObject[field] = data;\n          }\n        }\n      }\n\n      if (!headerObject.isNrrd) {\n        throw new Error('Not an NRRD file');\n      }\n\n      if (headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2') {\n        throw new Error('Bzip is not supported');\n      }\n\n      if (!headerObject.vectors) {\n        //if no space direction is set, let's use the identity\n        headerObject.vectors = [new Vector3(1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1)]; //apply spacing if defined\n\n        if (headerObject.spacings) {\n          for (i = 0; i <= 2; i++) {\n            if (!isNaN(headerObject.spacings[i])) {\n              headerObject.vectors[i].multiplyScalar(headerObject.spacings[i]);\n            }\n          }\n        }\n      }\n    } //parse the data when registred as one of this type : 'text', 'ascii', 'txt'\n\n\n    function parseDataAsText(data, start, end) {\n      let number = '';\n      start = start || 0;\n      end = end || data.length;\n      let value; //length of the result is the product of the sizes\n\n      const lengthOfTheResult = headerObject.sizes.reduce(function (previous, current) {\n        return previous * current;\n      }, 1);\n      let base = 10;\n\n      if (headerObject.encoding === 'hex') {\n        base = 16;\n      }\n\n      const result = new headerObject.__array(lengthOfTheResult);\n      let resultIndex = 0;\n      let parsingFunction = parseInt;\n\n      if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n        parsingFunction = parseFloat;\n      }\n\n      for (let i = start; i < end; i++) {\n        value = data[i]; //if value is not a space\n\n        if ((value < 9 || value > 13) && value !== 32) {\n          number += String.fromCharCode(value);\n        } else {\n          if (number !== '') {\n            result[resultIndex] = parsingFunction(number, base);\n            resultIndex++;\n          }\n\n          number = '';\n        }\n      }\n\n      if (number !== '') {\n        result[resultIndex] = parsingFunction(number, base);\n        resultIndex++;\n      }\n\n      return result;\n    }\n\n    const _bytes = scan('uchar', data.byteLength);\n\n    const _length = _bytes.length;\n    let _header = null;\n    let _data_start = 0;\n    let i;\n\n    for (i = 1; i < _length; i++) {\n      if (_bytes[i - 1] == 10 && _bytes[i] == 10) {\n        // we found two line breaks in a row\n        // now we know what the header is\n        _header = this.parseChars(_bytes, 0, i - 2); // this is were the data starts\n\n        _data_start = i + 1;\n        break;\n      }\n    } // parse the header\n\n\n    parseHeader(_header);\n    _data = _bytes.subarray(_data_start); // the data without header\n\n    if (headerObject.encoding.substring(0, 2) === 'gz') {\n      // we need to decompress the datastream\n      // here we start the unzipping and get a typed Uint8Array back\n      _data = gunzipSync(new Uint8Array(_data)); // eslint-disable-line no-undef\n    } else if (headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex') {\n      _data = parseDataAsText(_data);\n    } else if (headerObject.encoding === 'raw') {\n      //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n      const _copy = new Uint8Array(_data.length);\n\n      for (let i = 0; i < _data.length; i++) {\n        _copy[i] = _data[i];\n      }\n\n      _data = _copy;\n    } // .. let's use the underlying array buffer\n\n\n    _data = _data.buffer;\n    const volume = new Volume();\n    volume.header = headerObject; //\n    // parse the (unzipped) data to a datastream of the correct type\n    //\n\n    volume.data = new headerObject.__array(_data); // get the min and max intensities\n\n    const min_max = volume.computeMinMax();\n    const min = min_max[0];\n    const max = min_max[1]; // attach the scalar range to the volume\n\n    volume.windowLow = min;\n    volume.windowHigh = max; // get the image dimensions\n\n    volume.dimensions = [headerObject.sizes[0], headerObject.sizes[1], headerObject.sizes[2]];\n    volume.xLength = volume.dimensions[0];\n    volume.yLength = volume.dimensions[1];\n    volume.zLength = volume.dimensions[2]; // spacing\n\n    const spacingX = new Vector3(headerObject.vectors[0][0], headerObject.vectors[0][1], headerObject.vectors[0][2]).length();\n    const spacingY = new Vector3(headerObject.vectors[1][0], headerObject.vectors[1][1], headerObject.vectors[1][2]).length();\n    const spacingZ = new Vector3(headerObject.vectors[2][0], headerObject.vectors[2][1], headerObject.vectors[2][2]).length();\n    volume.spacing = [spacingX, spacingY, spacingZ]; // Create IJKtoRAS matrix\n\n    volume.matrix = new Matrix4();\n    let _spaceX = 1;\n    let _spaceY = 1;\n    const _spaceZ = 1;\n\n    if (headerObject.space == 'left-posterior-superior') {\n      _spaceX = -1;\n      _spaceY = -1;\n    } else if (headerObject.space === 'left-anterior-superior') {\n      _spaceX = -1;\n    }\n\n    if (!headerObject.vectors) {\n      volume.matrix.set(_spaceX, 0, 0, 0, 0, _spaceY, 0, 0, 0, 0, _spaceZ, 0, 0, 0, 0, 1);\n    } else {\n      const v = headerObject.vectors;\n      volume.matrix.set(_spaceX * v[0][0], _spaceX * v[1][0], _spaceX * v[2][0], 0, _spaceY * v[0][1], _spaceY * v[1][1], _spaceY * v[2][1], 0, _spaceZ * v[0][2], _spaceZ * v[1][2], _spaceZ * v[2][2], 0, 0, 0, 0, 1);\n    }\n\n    volume.inverseMatrix = new Matrix4();\n    volume.inverseMatrix.copy(volume.matrix).invert();\n    volume.RASDimensions = new Vector3(volume.xLength, volume.yLength, volume.zLength).applyMatrix4(volume.matrix).round().toArray().map(Math.abs); // .. and set the default threshold\n    // only if the threshold was not already set\n\n    if (volume.lowerThreshold === -Infinity) {\n      volume.lowerThreshold = min;\n    }\n\n    if (volume.upperThreshold === Infinity) {\n      volume.upperThreshold = max;\n    }\n\n    return volume;\n  }\n\n  parseChars(array, start, end) {\n    // without borders, use the whole array\n    if (start === undefined) {\n      start = 0;\n    }\n\n    if (end === undefined) {\n      end = array.length;\n    }\n\n    let output = ''; // create and append the chars\n\n    let i = 0;\n\n    for (i = start; i < end; ++i) {\n      output += String.fromCharCode(array[i]);\n    }\n\n    return output;\n  }\n\n}\n\nconst _fieldFunctions = {\n  type: function (data) {\n    switch (data) {\n      case 'uchar':\n      case 'unsigned char':\n      case 'uint8':\n      case 'uint8_t':\n        this.__array = Uint8Array;\n        break;\n\n      case 'signed char':\n      case 'int8':\n      case 'int8_t':\n        this.__array = Int8Array;\n        break;\n\n      case 'short':\n      case 'short int':\n      case 'signed short':\n      case 'signed short int':\n      case 'int16':\n      case 'int16_t':\n        this.__array = Int16Array;\n        break;\n\n      case 'ushort':\n      case 'unsigned short':\n      case 'unsigned short int':\n      case 'uint16':\n      case 'uint16_t':\n        this.__array = Uint16Array;\n        break;\n\n      case 'int':\n      case 'signed int':\n      case 'int32':\n      case 'int32_t':\n        this.__array = Int32Array;\n        break;\n\n      case 'uint':\n      case 'unsigned int':\n      case 'uint32':\n      case 'uint32_t':\n        this.__array = Uint32Array;\n        break;\n\n      case 'float':\n        this.__array = Float32Array;\n        break;\n\n      case 'double':\n        this.__array = Float64Array;\n        break;\n\n      default:\n        throw new Error('Unsupported NRRD data type: ' + data);\n    }\n\n    return this.type = data;\n  },\n  endian: function (data) {\n    return this.endian = data;\n  },\n  encoding: function (data) {\n    return this.encoding = data;\n  },\n  dimension: function (data) {\n    return this.dim = parseInt(data, 10);\n  },\n  sizes: function (data) {\n    let i;\n    return this.sizes = function () {\n      const _ref = data.split(/\\s+/);\n\n      const _results = [];\n\n      for (let _i = 0, _len = _ref.length; _i < _len; _i++) {\n        i = _ref[_i];\n\n        _results.push(parseInt(i, 10));\n      }\n\n      return _results;\n    }();\n  },\n  space: function (data) {\n    return this.space = data;\n  },\n  'space origin': function (data) {\n    return this.space_origin = data.split('(')[1].split(')')[0].split(',');\n  },\n  'space directions': function (data) {\n    let f, v;\n    const parts = data.match(/\\(.*?\\)/g);\n    return this.vectors = function () {\n      const _results = [];\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        v = parts[_i];\n\n        _results.push(function () {\n          const _ref = v.slice(1, -1).split(/,/);\n\n          const _results2 = [];\n\n          for (let _j = 0, _len2 = _ref.length; _j < _len2; _j++) {\n            f = _ref[_j];\n\n            _results2.push(parseFloat(f));\n          }\n\n          return _results2;\n        }());\n      }\n\n      return _results;\n    }();\n  },\n  spacings: function (data) {\n    let f;\n    const parts = data.split(/\\s+/);\n    return this.spacings = function () {\n      const _results = [];\n\n      for (let _i = 0, _len = parts.length; _i < _len; _i++) {\n        f = parts[_i];\n\n        _results.push(parseFloat(f));\n      }\n\n      return _results;\n    }();\n  }\n};\n\nexport { NRRDLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}