{"ast":null,"code":"import { Box3, Vector3, Matrix4 } from 'three';\nimport { CONTAINED } from './Constants.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\nvar boundingBox = new Box3();\nvar boxIntersection = new Vector3();\nvar xyzFields = ['x', 'y', 'z'];\nexport function raycast(nodeIndex32, geometry, side, ray, intersects) {\n  var nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    intersectTris(geometry, side, ray, offset, count, intersects);\n  } else {\n    var leftIndex = LEFT_NODE(nodeIndex32);\n\n    if (intersectRay(leftIndex, float32Array, ray, boxIntersection)) {\n      raycast(leftIndex, geometry, side, ray, intersects);\n    }\n\n    var rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);\n\n    if (intersectRay(rightIndex, float32Array, ray, boxIntersection)) {\n      raycast(rightIndex, geometry, side, ray, intersects);\n    }\n  }\n}\nexport function raycastFirst(nodeIndex32, geometry, side, ray) {\n  var nodeIndex16 = nodeIndex32 * 2,\n      float32Array = _float32Array,\n      uint16Array = _uint16Array,\n      uint32Array = _uint32Array;\n  var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n  if (isLeaf) {\n    var offset = OFFSET(nodeIndex32, uint32Array);\n    var count = COUNT(nodeIndex16, uint16Array);\n    return intersectClosestTri(geometry, side, ray, offset, count);\n  } else {\n    // consider the position of the split plane with respect to the oncoming ray; whichever direction\n    // the ray is coming from, look for an intersection among that side of the tree first\n    var splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n    var xyzAxis = xyzFields[splitAxis];\n    var rayDir = ray.direction[xyzAxis];\n    var leftToRight = rayDir >= 0; // c1 is the child to check first\n\n    var c1, c2;\n\n    if (leftToRight) {\n      c1 = LEFT_NODE(nodeIndex32);\n      c2 = RIGHT_NODE(nodeIndex32, uint32Array);\n    } else {\n      c1 = RIGHT_NODE(nodeIndex32, uint32Array);\n      c2 = LEFT_NODE(nodeIndex32);\n    }\n\n    var c1Intersection = intersectRay(c1, float32Array, ray, boxIntersection);\n    var c1Result = c1Intersection ? raycastFirst(c1, geometry, side, ray) : null; // if we got an intersection in the first node and it's closer than the second node's bounding\n    // box, we don't need to consider the second node because it couldn't possibly be a better result\n\n    if (c1Result) {\n      // check if the point is within the second bounds\n      // \"point\" is in the local frame of the bvh\n      var point = c1Result.point[xyzAxis];\n      var isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : // min bounding data\n      point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n\n      if (isOutside) {\n        return c1Result;\n      }\n    } // either there was no intersection in the first node, or there could still be a closer\n    // intersection in the second, so check the second node and then take the better of the two\n\n\n    var c2Intersection = intersectRay(c2, float32Array, ray, boxIntersection);\n    var c2Result = c2Intersection ? raycastFirst(c2, geometry, side, ray) : null;\n\n    if (c1Result && c2Result) {\n      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n    } else {\n      return c1Result || c2Result || null;\n    }\n  }\n}\nexport var shapecast = function () {\n  var _box1, _box2;\n\n  var boxStack = [];\n  var boxPool = new PrimitivePool(function () {\n    return new Box3();\n  });\n  return function shapecast() {\n    _box1 = boxPool.getPrimitive();\n    _box2 = boxPool.getPrimitive();\n    boxStack.push(_box1, _box2);\n    var result = shapecastTraverse.apply(void 0, arguments);\n    boxPool.releasePrimitive(_box1);\n    boxPool.releasePrimitive(_box2);\n    boxStack.pop();\n    boxStack.pop();\n    var length = boxStack.length;\n\n    if (length > 0) {\n      _box2 = boxStack[length - 1];\n      _box1 = boxStack[length - 2];\n    }\n\n    return result;\n  };\n\n  function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc) {\n    var nodeScoreFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var nodeIndexByteOffset = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var depth = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n\n    // Define these inside the function so it has access to the local variables needed\n    // when converting to the buffer equivalents\n    function getLeftOffset(nodeIndex32) {\n      var nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        nodeIndex32 = LEFT_NODE(nodeIndex32);\n        nodeIndex16 = nodeIndex32 * 2;\n      }\n\n      return OFFSET(nodeIndex32, uint32Array);\n    }\n\n    function getRightEndOffset(nodeIndex32) {\n      var nodeIndex16 = nodeIndex32 * 2,\n          uint16Array = _uint16Array,\n          uint32Array = _uint32Array; // traverse until we find a leaf\n\n      while (!IS_LEAF(nodeIndex16, uint16Array)) {\n        // adjust offset to point to the right node\n        nodeIndex32 = RIGHT_NODE(nodeIndex32, uint32Array);\n        nodeIndex16 = nodeIndex32 * 2;\n      } // return the end offset of the triangle range\n\n\n      return OFFSET(nodeIndex32, uint32Array) + COUNT(nodeIndex16, uint16Array);\n    }\n\n    var nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n    if (isLeaf) {\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var count = COUNT(nodeIndex16, uint16Array);\n      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);\n      return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n    } else {\n      var left = LEFT_NODE(nodeIndex32);\n      var right = RIGHT_NODE(nodeIndex32, uint32Array);\n      var c1 = left;\n      var c2 = right;\n      var score1, score2;\n      var box1, box2;\n\n      if (nodeScoreFunc) {\n        box1 = _box1;\n        box2 = _box2; // bounding data is not offset\n\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n        arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n        score1 = nodeScoreFunc(box1);\n        score2 = nodeScoreFunc(box2);\n\n        if (score2 < score1) {\n          c1 = right;\n          c2 = left;\n          var temp = score1;\n          score1 = score2;\n          score2 = temp;\n          box1 = box2; // box2 is always set before use below\n        }\n      } // Check box 1 intersection\n\n\n      if (!box1) {\n        box1 = _box1;\n        arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);\n      }\n\n      var isC1Leaf = IS_LEAF(c1 * 2, uint16Array);\n      var c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n      var c1StopTraversal;\n\n      if (c1Intersection === CONTAINED) {\n        var _offset = getLeftOffset(c1);\n\n        var end = getRightEndOffset(c1);\n\n        var _count = end - _offset;\n\n        c1StopTraversal = intersectsRangeFunc(_offset, _count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n      } else {\n        c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n\n      if (c1StopTraversal) return true; // Check box 2 intersection\n      // cached box2 will have been overwritten by previous traversal\n\n      box2 = _box2;\n      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);\n      var isC2Leaf = IS_LEAF(c2 * 2, uint16Array);\n      var c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n      var c2StopTraversal;\n\n      if (c2Intersection === CONTAINED) {\n        var _offset2 = getLeftOffset(c2);\n\n        var _end = getRightEndOffset(c2);\n\n        var _count2 = _end - _offset2;\n\n        c2StopTraversal = intersectsRangeFunc(_offset2, _count2, true, depth + 1, nodeIndexByteOffset + c2, box2);\n      } else {\n        c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n      }\n\n      if (c2StopTraversal) return true;\n      return false;\n    }\n  }\n}();\nexport var intersectsGeometry = function () {\n  var triangle = new ExtendedTriangle();\n  var triangle2 = new ExtendedTriangle();\n  var invertedMat = new Matrix4();\n  var obb = new OrientedBox();\n  var obb2 = new OrientedBox();\n  return function intersectsGeometry(nodeIndex32, geometry, otherGeometry, geometryToBvh) {\n    var cachedObb = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var nodeIndex16 = nodeIndex32 * 2,\n        float32Array = _float32Array,\n        uint16Array = _uint16Array,\n        uint32Array = _uint32Array;\n\n    if (cachedObb === null) {\n      if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n      }\n\n      obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n      cachedObb = obb;\n    }\n\n    var isLeaf = IS_LEAF(nodeIndex16, uint16Array);\n\n    if (isLeaf) {\n      var thisGeometry = geometry;\n      var thisIndex = thisGeometry.index;\n      var thisPos = thisGeometry.attributes.position;\n      var index = otherGeometry.index;\n      var pos = otherGeometry.attributes.position;\n      var offset = OFFSET(nodeIndex32, uint32Array);\n      var count = COUNT(nodeIndex16, uint16Array); // get the inverse of the geometry matrix so we can transform our triangles into the\n      // geometry space we're trying to test. We assume there are fewer triangles being checked\n      // here.\n\n      invertedMat.copy(geometryToBvh).invert();\n\n      if (otherGeometry.boundsTree) {\n        arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);\n        obb2.matrix.copy(invertedMat);\n        obb2.needsUpdate = true;\n        var res = otherGeometry.boundsTree.shapecast({\n          intersectsBounds: function intersectsBounds(box) {\n            return obb2.intersectsBox(box);\n          },\n          intersectsTriangle: function intersectsTriangle(tri) {\n            tri.a.applyMatrix4(geometryToBvh);\n            tri.b.applyMatrix4(geometryToBvh);\n            tri.c.applyMatrix4(geometryToBvh);\n            tri.needsUpdate = true;\n\n            for (var i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {\n              // this triangle needs to be transformed into the current BVH coordinate frame\n              setTriangle(triangle2, i, thisIndex, thisPos);\n              triangle2.needsUpdate = true;\n\n              if (tri.intersectsTriangle(triangle2)) {\n                return true;\n              }\n            }\n\n            return false;\n          }\n        });\n        return res;\n      } else {\n        for (var i = offset * 3, l = count + offset * 3; i < l; i += 3) {\n          // this triangle needs to be transformed into the current BVH coordinate frame\n          setTriangle(triangle, i, thisIndex, thisPos);\n          triangle.a.applyMatrix4(invertedMat);\n          triangle.b.applyMatrix4(invertedMat);\n          triangle.c.applyMatrix4(invertedMat);\n          triangle.needsUpdate = true;\n\n          for (var i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, index, pos);\n            triangle2.needsUpdate = true;\n\n            if (triangle.intersectsTriangle(triangle2)) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      var left = nodeIndex32 + 8;\n      var right = uint32Array[nodeIndex32 + 6];\n      arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);\n      var leftIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(left, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (leftIntersection) return true;\n      arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);\n      var rightIntersection = cachedObb.intersectsBox(boundingBox) && intersectsGeometry(right, geometry, otherGeometry, geometryToBvh, cachedObb);\n      if (rightIntersection) return true;\n      return false;\n    }\n  };\n}();\n\nfunction intersectRay(nodeIndex32, array, ray, target) {\n  arrayToBox(nodeIndex32, array, boundingBox);\n  return ray.intersectBox(boundingBox, target);\n}\n\nvar bufferStack = [];\n\nvar _prevBuffer;\n\nvar _float32Array;\n\nvar _uint16Array;\n\nvar _uint32Array;\n\nexport function setBuffer(buffer) {\n  if (_prevBuffer) {\n    bufferStack.push(_prevBuffer);\n  }\n\n  _prevBuffer = buffer;\n  _float32Array = new Float32Array(buffer);\n  _uint16Array = new Uint16Array(buffer);\n  _uint32Array = new Uint32Array(buffer);\n}\nexport function clearBuffer() {\n  _prevBuffer = null;\n  _float32Array = null;\n  _uint16Array = null;\n  _uint32Array = null;\n\n  if (bufferStack.length) {\n    setBuffer(bufferStack.pop());\n  }\n}","map":{"version":3,"names":["Box3","Vector3","Matrix4","CONTAINED","OrientedBox","ExtendedTriangle","intersectTris","intersectClosestTri","setTriangle","arrayToBox","PrimitivePool","COUNT","OFFSET","LEFT_NODE","RIGHT_NODE","IS_LEAF","BOUNDING_DATA_INDEX","SPLIT_AXIS","boundingBox","boxIntersection","xyzFields","raycast","nodeIndex32","geometry","side","ray","intersects","nodeIndex16","float32Array","_float32Array","uint16Array","_uint16Array","uint32Array","_uint32Array","isLeaf","offset","count","leftIndex","intersectRay","rightIndex","raycastFirst","splitAxis","xyzAxis","rayDir","direction","leftToRight","c1","c2","c1Intersection","c1Result","point","isOutside","c2Intersection","c2Result","distance","shapecast","_box1","_box2","boxStack","boxPool","getPrimitive","push","result","shapecastTraverse","releasePrimitive","pop","length","intersectsBoundsFunc","intersectsRangeFunc","nodeScoreFunc","nodeIndexByteOffset","depth","getLeftOffset","getRightEndOffset","left","right","score1","score2","box1","box2","temp","isC1Leaf","c1StopTraversal","end","isC2Leaf","c2StopTraversal","intersectsGeometry","triangle","triangle2","invertedMat","obb","obb2","otherGeometry","geometryToBvh","cachedObb","computeBoundingBox","set","min","max","thisGeometry","thisIndex","index","thisPos","attributes","position","pos","copy","invert","boundsTree","matrix","needsUpdate","res","intersectsBounds","box","intersectsBox","intersectsTriangle","tri","a","applyMatrix4","b","c","i","l","i2","l2","leftIntersection","rightIntersection","array","target","intersectBox","bufferStack","_prevBuffer","setBuffer","buffer","Float32Array","Uint16Array","Uint32Array","clearBuffer"],"sources":["D:/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/castFunctions.js"],"sourcesContent":["import { Box3, Vector3, Matrix4 } from 'three';\r\nimport { CONTAINED } from './Constants.js';\r\n\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { intersectTris, intersectClosestTri } from '../utils/GeometryRayIntersectUtilities.js';\r\nimport { setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX, SPLIT_AXIS } from './nodeBufferFunctions.js';\r\n\r\nconst boundingBox = new Box3();\r\nconst boxIntersection = new Vector3();\r\nconst xyzFields = [ 'x', 'y', 'z' ];\r\n\r\nexport function raycast( nodeIndex32, geometry, side, ray, intersects ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\tintersectTris( geometry, side, ray, offset, count, intersects );\r\n\r\n\t} else {\r\n\r\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\r\n\t\tif ( intersectRay( leftIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( leftIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\tif ( intersectRay( rightIndex, float32Array, ray, boxIntersection ) ) {\r\n\r\n\t\t\traycast( rightIndex, geometry, side, ray, intersects );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function raycastFirst( nodeIndex32, geometry, side, ray ) {\r\n\r\n\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\tif ( isLeaf ) {\r\n\r\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\treturn intersectClosestTri( geometry, side, ray, offset, count );\r\n\r\n\t} else {\r\n\r\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\r\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\r\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\t\tconst xyzAxis = xyzFields[ splitAxis ];\r\n\t\tconst rayDir = ray.direction[ xyzAxis ];\r\n\t\tconst leftToRight = rayDir >= 0;\r\n\r\n\t\t// c1 is the child to check first\r\n\t\tlet c1, c2;\r\n\t\tif ( leftToRight ) {\r\n\r\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\r\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\r\n\r\n\t\t}\r\n\r\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray, boxIntersection );\r\n\t\tconst c1Result = c1Intersection ? raycastFirst( c1, geometry, side, ray ) : null;\r\n\r\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\r\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\r\n\t\tif ( c1Result ) {\r\n\r\n\t\t\t// check if the point is within the second bounds\r\n\t\t\t// \"point\" is in the local frame of the bvh\r\n\t\t\tconst point = c1Result.point[ xyzAxis ];\r\n\t\t\tconst isOutside = leftToRight ?\r\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\r\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\r\n\r\n\t\t\tif ( isOutside ) {\r\n\r\n\t\t\t\treturn c1Result;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// either there was no intersection in the first node, or there could still be a closer\r\n\t\t// intersection in the second, so check the second node and then take the better of the two\r\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray, boxIntersection );\r\n\t\tconst c2Result = c2Intersection ? raycastFirst( c2, geometry, side, ray ) : null;\r\n\r\n\t\tif ( c1Result && c2Result ) {\r\n\r\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn c1Result || c2Result || null;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport const shapecast = ( function () {\r\n\r\n\tlet _box1, _box2;\r\n\tconst boxStack = [];\r\n\tconst boxPool = new PrimitivePool( () => new Box3() );\r\n\r\n\treturn function shapecast( ...args ) {\r\n\r\n\t\t_box1 = boxPool.getPrimitive();\r\n\t\t_box2 = boxPool.getPrimitive();\r\n\t\tboxStack.push( _box1, _box2 );\r\n\r\n\t\tconst result = shapecastTraverse( ...args );\r\n\r\n\t\tboxPool.releasePrimitive( _box1 );\r\n\t\tboxPool.releasePrimitive( _box2 );\r\n\t\tboxStack.pop();\r\n\t\tboxStack.pop();\r\n\r\n\t\tconst length = boxStack.length;\r\n\t\tif ( length > 0 ) {\r\n\r\n\t\t\t_box2 = boxStack[ length - 1 ];\r\n\t\t\t_box1 = boxStack[ length - 2 ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t};\r\n\r\n\tfunction shapecastTraverse(\r\n\t\tnodeIndex32,\r\n\t\tgeometry,\r\n\t\tintersectsBoundsFunc,\r\n\t\tintersectsRangeFunc,\r\n\t\tnodeScoreFunc = null,\r\n\t\tnodeIndexByteOffset = 0, // offset for unique node identifier\r\n\t\tdepth = 0\r\n\t) {\r\n\r\n\t\t// Define these inside the function so it has access to the local variables needed\r\n\t\t// when converting to the buffer equivalents\r\n\t\tfunction getLeftOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\r\n\r\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\t\t// traverse until we find a leaf\r\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\t\t// adjust offset to point to the right node\r\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// return the end offset of the triangle range\r\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t}\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\r\n\t\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = LEFT_NODE( nodeIndex32 );\r\n\t\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\r\n\t\t\tlet c1 = left;\r\n\t\t\tlet c2 = right;\r\n\r\n\t\t\tlet score1, score2;\r\n\t\t\tlet box1, box2;\r\n\t\t\tif ( nodeScoreFunc ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tbox2 = _box2;\r\n\r\n\t\t\t\t// bounding data is not offset\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\t\tscore1 = nodeScoreFunc( box1 );\r\n\t\t\t\tscore2 = nodeScoreFunc( box2 );\r\n\r\n\t\t\t\tif ( score2 < score1 ) {\r\n\r\n\t\t\t\t\tc1 = right;\r\n\t\t\t\t\tc2 = left;\r\n\r\n\t\t\t\t\tconst temp = score1;\r\n\t\t\t\t\tscore1 = score2;\r\n\t\t\t\t\tscore2 = temp;\r\n\r\n\t\t\t\t\tbox1 = box2;\r\n\t\t\t\t\t// box2 is always set before use below\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Check box 1 intersection\r\n\t\t\tif ( ! box1 ) {\r\n\r\n\t\t\t\tbox1 = _box1;\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\r\n\t\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\r\n\r\n\t\t\tlet c1StopTraversal;\r\n\t\t\tif ( c1Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c1 );\r\n\t\t\t\tconst end = getRightEndOffset( c1 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc1StopTraversal =\r\n\t\t\t\t\tc1Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc1,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c1StopTraversal ) return true;\r\n\r\n\t\t\t// Check box 2 intersection\r\n\t\t\t// cached box2 will have been overwritten by previous traversal\r\n\t\t\tbox2 = _box2;\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\r\n\r\n\t\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\r\n\t\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\r\n\r\n\t\t\tlet c2StopTraversal;\r\n\t\t\tif ( c2Intersection === CONTAINED ) {\r\n\r\n\t\t\t\tconst offset = getLeftOffset( c2 );\r\n\t\t\t\tconst end = getRightEndOffset( c2 );\r\n\t\t\t\tconst count = end - offset;\r\n\r\n\t\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tc2StopTraversal =\r\n\t\t\t\t\tc2Intersection &&\r\n\t\t\t\t\tshapecastTraverse(\r\n\t\t\t\t\t\tc2,\r\n\t\t\t\t\t\tgeometry,\r\n\t\t\t\t\t\tintersectsBoundsFunc,\r\n\t\t\t\t\t\tintersectsRangeFunc,\r\n\t\t\t\t\t\tnodeScoreFunc,\r\n\t\t\t\t\t\tnodeIndexByteOffset,\r\n\t\t\t\t\t\tdepth + 1\r\n\t\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( c2StopTraversal ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} )();\r\n\r\nexport const intersectsGeometry = ( function () {\r\n\r\n\tconst triangle = new ExtendedTriangle();\r\n\tconst triangle2 = new ExtendedTriangle();\r\n\tconst invertedMat = new Matrix4();\r\n\r\n\tconst obb = new OrientedBox();\r\n\tconst obb2 = new OrientedBox();\r\n\r\n\treturn function intersectsGeometry( nodeIndex32, geometry, otherGeometry, geometryToBvh, cachedObb = null ) {\r\n\r\n\t\tlet nodeIndex16 = nodeIndex32 * 2, float32Array = _float32Array, uint16Array = _uint16Array, uint32Array = _uint32Array;\r\n\r\n\t\tif ( cachedObb === null ) {\r\n\r\n\t\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\t\tcachedObb = obb;\r\n\r\n\t\t}\r\n\r\n\t\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\r\n\t\tif ( isLeaf ) {\r\n\r\n\t\t\tconst thisGeometry = geometry;\r\n\t\t\tconst thisIndex = thisGeometry.index;\r\n\t\t\tconst thisPos = thisGeometry.attributes.position;\r\n\r\n\t\t\tconst index = otherGeometry.index;\r\n\t\t\tconst pos = otherGeometry.attributes.position;\r\n\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\r\n\t\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\r\n\t\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\r\n\t\t\t// here.\r\n\t\t\tinvertedMat.copy( geometryToBvh ).invert();\r\n\r\n\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\r\n\t\t\t\tobb2.matrix.copy( invertedMat );\r\n\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsTriangle: tri => {\r\n\r\n\t\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\ttri.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\t\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t\treturn res;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( let i = offset * 3, l = ( count + offset * 3 ); i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\r\n\t\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\r\n\t\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\r\n\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\r\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst left = nodeIndex32 + 8;\r\n\t\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\r\n\t\t\tconst leftIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( left, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( leftIntersection ) return true;\r\n\r\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\r\n\t\t\tconst rightIntersection =\r\n\t\t\t\tcachedObb.intersectsBox( boundingBox ) &&\r\n\t\t\t\tintersectsGeometry( right, geometry, otherGeometry, geometryToBvh, cachedObb );\r\n\r\n\t\t\tif ( rightIntersection ) return true;\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n} )();\r\n\r\nfunction intersectRay( nodeIndex32, array, ray, target ) {\r\n\r\n\tarrayToBox( nodeIndex32, array, boundingBox );\r\n\treturn ray.intersectBox( boundingBox, target );\r\n\r\n}\r\n\r\nconst bufferStack = [];\r\nlet _prevBuffer;\r\nlet _float32Array;\r\nlet _uint16Array;\r\nlet _uint32Array;\r\nexport function setBuffer( buffer ) {\r\n\r\n\tif ( _prevBuffer ) {\r\n\r\n\t\tbufferStack.push( _prevBuffer );\r\n\r\n\t}\r\n\r\n\t_prevBuffer = buffer;\r\n\t_float32Array = new Float32Array( buffer );\r\n\t_uint16Array = new Uint16Array( buffer );\r\n\t_uint32Array = new Uint32Array( buffer );\r\n\r\n}\r\n\r\nexport function clearBuffer() {\r\n\r\n\t_prevBuffer = null;\r\n\t_float32Array = null;\r\n\t_uint16Array = null;\r\n\t_uint32Array = null;\r\n\r\n\tif ( bufferStack.length ) {\r\n\r\n\t\tsetBuffer( bufferStack.pop() );\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}