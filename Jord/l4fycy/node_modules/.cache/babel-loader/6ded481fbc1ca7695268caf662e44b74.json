{"ast":null,"code":"// Parallax Occlusion shaders from\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\n// No tangent-space transforms logic based on\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\nvar ParallaxShader = {\n  // Ordered from fastest to best quality.\n  modes: {\n    none: 'NO_PARALLAX',\n    basic: 'USE_BASIC_PARALLAX',\n    steep: 'USE_STEEP_PARALLAX',\n    occlusion: 'USE_OCLUSION_PARALLAX',\n    // a.k.a. POM\n    relief: 'USE_RELIEF_PARALLAX'\n  },\n  uniforms: {\n    bumpMap: {\n      value: null\n    },\n    map: {\n      value: null\n    },\n    parallaxScale: {\n      value: null\n    },\n    parallaxMinLayers: {\n      value: null\n    },\n    parallaxMaxLayers: {\n      value: null\n    }\n  },\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\tvUv = uv;', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvViewPosition = -mvPosition.xyz;', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\tvec2 parallaxMap( in vec3 V ) {', '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;', // No Offset Limitting: messy, floating output at grazing angles.\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\n  // Offset Limiting\n  '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\t\treturn vUv - texCoordOffset;', '\t}', '#else', '\tvec2 parallaxMap( in vec3 V ) {', // Determine number of layers from angle between V and N\n  '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\t\tfloat layerHeight = 1.0 / numLayers;', '\t\tfloat currentLayerHeight = 0.0;', // Shift of texture coordinates for each iteration\n  '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\t\tvec2 currentTextureCoords = vUv;', '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // while ( heightFromTexture > currentLayerHeight )\n  // Infinite loops are not well supported. Do a \"large\" finite\n  // loop, but not too large, as it slows down some compilers.\n  '\t\tfor ( int i = 0; i < 30; i += 1 ) {', '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tcurrentLayerHeight += layerHeight;', // Shift texture coordinates along vector V\n  '\t\t\tcurrentTextureCoords -= dtex;', '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\t\t}', '\t\t#ifdef USE_STEEP_PARALLAX', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_RELIEF_PARALLAX )', '\t\t\tvec2 deltaTexCoord = dtex / 2.0;', '\t\t\tfloat deltaHeight = layerHeight / 2.0;', // Return to the mid point of previous layer\n  '\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\tcurrentLayerHeight -= deltaHeight;', // Binary search to increase precision of Steep Parallax Mapping\n  '\t\t\tconst int numSearches = 5;', '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\t\t\t\tdeltaTexCoord /= 2.0;', '\t\t\t\tdeltaHeight /= 2.0;', '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // Shift along or against vector V\n  '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\n  '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight += deltaHeight;', '\t\t\t\t} else {', // above the surface\n  '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;', '\t\t\t\t}', '\t\t\t}', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_OCLUSION_PARALLAX )', '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;', // Heights for linear interpolation\n  '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;', '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;', // Proportions for linear interpolation\n  '\t\t\tfloat weight = nextH / ( nextH - prevH );', // Interpolation of texture coordinates\n  '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\t\t#else', // NO_PARALLAX\n  '\t\t\treturn vUv;', '\t\t#endif', '\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\tvec2 texDx = dFdx( vUv );', '\tvec2 texDy = dFdy( vUv );', '\tvec3 vSigmaX = dFdx( surfPosition );', '\tvec3 vSigmaY = dFdy( surfPosition );', '\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\tfloat fDet = dot( vSigmaX, vR1 );', '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\tvec3 vProjVtex;', '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\tvProjVtex.z = dot( surfNormal, viewPosition );', '\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\n')\n};\nexport { ParallaxShader };","map":{"version":3,"names":["ParallaxShader","modes","none","basic","steep","occlusion","relief","uniforms","bumpMap","value","map","parallaxScale","parallaxMinLayers","parallaxMaxLayers","vertexShader","join","fragmentShader"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/shaders/ParallaxShader.js"],"sourcesContent":["// Parallax Occlusion shaders from\r\n//    http://sunandblackcat.com/tipFullView.php?topicid=28\r\n// No tangent-space transforms logic based on\r\n//   http://mmikkelsen3d.blogspot.sk/2012/02/parallaxpoc-mapping-and-no-tangent.html\r\nconst ParallaxShader = {\r\n  // Ordered from fastest to best quality.\r\n  modes: {\r\n    none: 'NO_PARALLAX',\r\n    basic: 'USE_BASIC_PARALLAX',\r\n    steep: 'USE_STEEP_PARALLAX',\r\n    occlusion: 'USE_OCLUSION_PARALLAX',\r\n    // a.k.a. POM\r\n    relief: 'USE_RELIEF_PARALLAX'\r\n  },\r\n  uniforms: {\r\n    bumpMap: {\r\n      value: null\r\n    },\r\n    map: {\r\n      value: null\r\n    },\r\n    parallaxScale: {\r\n      value: null\r\n    },\r\n    parallaxMinLayers: {\r\n      value: null\r\n    },\r\n    parallaxMaxLayers: {\r\n      value: null\r\n    }\r\n  },\r\n  vertexShader: ['varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', 'void main() {', '\tvUv = uv;', '\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );', '\tvViewPosition = -mvPosition.xyz;', '\tvNormal = normalize( normalMatrix * normal );', '\tgl_Position = projectionMatrix * mvPosition;', '}'].join('\\n'),\r\n  fragmentShader: ['uniform sampler2D bumpMap;', 'uniform sampler2D map;', 'uniform float parallaxScale;', 'uniform float parallaxMinLayers;', 'uniform float parallaxMaxLayers;', 'varying vec2 vUv;', 'varying vec3 vViewPosition;', 'varying vec3 vNormal;', '#ifdef USE_BASIC_PARALLAX', '\tvec2 parallaxMap( in vec3 V ) {', '\t\tfloat initialHeight = texture2D( bumpMap, vUv ).r;', // No Offset Limitting: messy, floating output at grazing angles.\r\n  //\"vec2 texCoordOffset = parallaxScale * V.xy / V.z * initialHeight;\",\r\n  // Offset Limiting\r\n  '\t\tvec2 texCoordOffset = parallaxScale * V.xy * initialHeight;', '\t\treturn vUv - texCoordOffset;', '\t}', '#else', '\tvec2 parallaxMap( in vec3 V ) {', // Determine number of layers from angle between V and N\r\n  '\t\tfloat numLayers = mix( parallaxMaxLayers, parallaxMinLayers, abs( dot( vec3( 0.0, 0.0, 1.0 ), V ) ) );', '\t\tfloat layerHeight = 1.0 / numLayers;', '\t\tfloat currentLayerHeight = 0.0;', // Shift of texture coordinates for each iteration\r\n  '\t\tvec2 dtex = parallaxScale * V.xy / V.z / numLayers;', '\t\tvec2 currentTextureCoords = vUv;', '\t\tfloat heightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // while ( heightFromTexture > currentLayerHeight )\r\n  // Infinite loops are not well supported. Do a \"large\" finite\r\n  // loop, but not too large, as it slows down some compilers.\r\n  '\t\tfor ( int i = 0; i < 30; i += 1 ) {', '\t\t\tif ( heightFromTexture <= currentLayerHeight ) {', '\t\t\t\tbreak;', '\t\t\t}', '\t\t\tcurrentLayerHeight += layerHeight;', // Shift texture coordinates along vector V\r\n  '\t\t\tcurrentTextureCoords -= dtex;', '\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', '\t\t}', '\t\t#ifdef USE_STEEP_PARALLAX', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_RELIEF_PARALLAX )', '\t\t\tvec2 deltaTexCoord = dtex / 2.0;', '\t\t\tfloat deltaHeight = layerHeight / 2.0;', // Return to the mid point of previous layer\r\n  '\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\tcurrentLayerHeight -= deltaHeight;', // Binary search to increase precision of Steep Parallax Mapping\r\n  '\t\t\tconst int numSearches = 5;', '\t\t\tfor ( int i = 0; i < numSearches; i += 1 ) {', '\t\t\t\tdeltaTexCoord /= 2.0;', '\t\t\t\tdeltaHeight /= 2.0;', '\t\t\t\theightFromTexture = texture2D( bumpMap, currentTextureCoords ).r;', // Shift along or against vector V\r\n  '\t\t\t\tif( heightFromTexture > currentLayerHeight ) {', // Below the surface\r\n  '\t\t\t\t\tcurrentTextureCoords -= deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight += deltaHeight;', '\t\t\t\t} else {', // above the surface\r\n  '\t\t\t\t\tcurrentTextureCoords += deltaTexCoord;', '\t\t\t\t\tcurrentLayerHeight -= deltaHeight;', '\t\t\t\t}', '\t\t\t}', '\t\t\treturn currentTextureCoords;', '\t\t#elif defined( USE_OCLUSION_PARALLAX )', '\t\t\tvec2 prevTCoords = currentTextureCoords + dtex;', // Heights for linear interpolation\r\n  '\t\t\tfloat nextH = heightFromTexture - currentLayerHeight;', '\t\t\tfloat prevH = texture2D( bumpMap, prevTCoords ).r - currentLayerHeight + layerHeight;', // Proportions for linear interpolation\r\n  '\t\t\tfloat weight = nextH / ( nextH - prevH );', // Interpolation of texture coordinates\r\n  '\t\t\treturn prevTCoords * weight + currentTextureCoords * ( 1.0 - weight );', '\t\t#else', // NO_PARALLAX\r\n  '\t\t\treturn vUv;', '\t\t#endif', '\t}', '#endif', 'vec2 perturbUv( vec3 surfPosition, vec3 surfNormal, vec3 viewPosition ) {', '\tvec2 texDx = dFdx( vUv );', '\tvec2 texDy = dFdy( vUv );', '\tvec3 vSigmaX = dFdx( surfPosition );', '\tvec3 vSigmaY = dFdy( surfPosition );', '\tvec3 vR1 = cross( vSigmaY, surfNormal );', '\tvec3 vR2 = cross( surfNormal, vSigmaX );', '\tfloat fDet = dot( vSigmaX, vR1 );', '\tvec2 vProjVscr = ( 1.0 / fDet ) * vec2( dot( vR1, viewPosition ), dot( vR2, viewPosition ) );', '\tvec3 vProjVtex;', '\tvProjVtex.xy = texDx * vProjVscr.x + texDy * vProjVscr.y;', '\tvProjVtex.z = dot( surfNormal, viewPosition );', '\treturn parallaxMap( vProjVtex );', '}', 'void main() {', '\tvec2 mapUv = perturbUv( -vViewPosition, normalize( vNormal ), normalize( vViewPosition ) );', '\tgl_FragColor = texture2D( map, mapUv );', '}'].join('\\n')\r\n};\r\n\r\nexport { ParallaxShader };\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,IAAMA,cAAc,GAAG;EACrB;EACAC,KAAK,EAAE;IACLC,IAAI,EAAE,aADD;IAELC,KAAK,EAAE,oBAFF;IAGLC,KAAK,EAAE,oBAHF;IAILC,SAAS,EAAE,uBAJN;IAKL;IACAC,MAAM,EAAE;EANH,CAFc;EAUrBC,QAAQ,EAAE;IACRC,OAAO,EAAE;MACPC,KAAK,EAAE;IADA,CADD;IAIRC,GAAG,EAAE;MACHD,KAAK,EAAE;IADJ,CAJG;IAORE,aAAa,EAAE;MACbF,KAAK,EAAE;IADM,CAPP;IAURG,iBAAiB,EAAE;MACjBH,KAAK,EAAE;IADU,CAVX;IAaRI,iBAAiB,EAAE;MACjBJ,KAAK,EAAE;IADU;EAbX,CAVW;EA2BrBK,YAAY,EAAE,CAAC,mBAAD,EAAsB,6BAAtB,EAAqD,uBAArD,EAA8E,eAA9E,EAA+F,YAA/F,EAA6G,6DAA7G,EAA4K,mCAA5K,EAAiN,gDAAjN,EAAmQ,+CAAnQ,EAAoT,GAApT,EAAyTC,IAAzT,CAA8T,IAA9T,CA3BO;EA4BrBC,cAAc,EAAE,CAAC,4BAAD,EAA+B,wBAA/B,EAAyD,8BAAzD,EAAyF,kCAAzF,EAA6H,kCAA7H,EAAiK,mBAAjK,EAAsL,6BAAtL,EAAqN,uBAArN,EAA8O,2BAA9O,EAA2Q,kCAA3Q,EAA+S,sDAA/S,EAAuW;EACvX;EACA;EACA,+DAHgB,EAGiD,gCAHjD,EAGmF,IAHnF,EAGyF,OAHzF,EAGkG,kCAHlG,EAGsI;EACtJ,0GAJgB,EAI4F,wCAJ5F,EAIsI,mCAJtI,EAI2K;EAC3L,uDALgB,EAKyC,oCALzC,EAK+E,2EAL/E,EAK4J;EAC5K;EACA;EACA,uCARgB,EAQyB,qDARzB,EAQgF,YARhF,EAQ8F,MAR9F,EAQsG,uCARtG,EAQ+I;EAC/J,kCATgB,EASoB,sEATpB,EAS4F,KAT5F,EASmG,6BATnG,EASkI,iCATlI,EASqK,wCATrK,EAS+M,qCAT/M,EASsP,2CATtP,EASmS;EACnT,2CAVgB,EAU6B,uCAV7B,EAUsE;EACtF,+BAXgB,EAWiB,iDAXjB,EAWoE,2BAXpE,EAWiG,yBAXjG,EAW4H,uEAX5H,EAWqM;EACrN,oDAZgB,EAYsC;EACtD,6CAbgB,EAa+B,yCAb/B,EAa0E,cAb1E,EAa0F;EAC1G,6CAdgB,EAc+B,yCAd/B,EAc0E,OAd1E,EAcmF,MAdnF,EAc2F,iCAd3F,EAc8H,0CAd9H,EAc0K,oDAd1K,EAcgO;EAChP,0DAfgB,EAe4C,0FAf5C,EAewI;EACxJ,8CAhBgB,EAgBgC;EAChD,2EAjBgB,EAiB6D,SAjB7D,EAiBwE;EACxF,gBAlBgB,EAkBE,UAlBF,EAkBc,IAlBd,EAkBoB,QAlBpB,EAkB8B,2EAlB9B,EAkB2G,4BAlB3G,EAkByI,4BAlBzI,EAkBuK,uCAlBvK,EAkBgN,uCAlBhN,EAkByP,2CAlBzP,EAkBsS,2CAlBtS,EAkBmV,oCAlBnV,EAkByX,gGAlBzX,EAkB2d,kBAlB3d,EAkB+e,4DAlB/e,EAkB6iB,iDAlB7iB,EAkBgmB,mCAlBhmB,EAkBqoB,GAlBroB,EAkB0oB,eAlB1oB,EAkB2pB,8FAlB3pB,EAkB2vB,0CAlB3vB,EAkBuyB,GAlBvyB,EAkB4yBD,IAlB5yB,CAkBizB,IAlBjzB;AA5BK,CAAvB;AAiDA,SAASf,cAAT"},"metadata":{},"sourceType":"module"}