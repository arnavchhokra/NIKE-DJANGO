{"ast":null,"code":"import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function retargetClip(target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function getHelperFromSkeleton(skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function renameBones(skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (var i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function getBones(skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function getBoneByName(name, skeleton) {\n    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function getNearestBone(bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function findBoneTrackData(name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (var i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function getEqualsBonesNames(skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (var i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (var j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function clone(source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (var i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };","map":{"version":3,"names":["Vector3","Quaternion","Matrix4","AnimationMixer","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationClip","SkeletonHelper","Vector2","Euler","SkeletonUtils","retarget","pos","quat","scale","bindBoneMatrix","relativeMatrix","globalMatrix","target","source","options","preserveMatrix","undefined","preservePosition","preserveHipPosition","useTargetMatrix","hip","names","sourceBones","isObject3D","skeleton","bones","getBones","bindBones","bone","name","boneTo","bonesPosition","i","pose","length","push","position","clone","updateMatrixWorld","matrixWorld","identity","children","offsets","matrix","multiply","decompose","quaternion","getBoneByName","copy","invert","setFromMatrixScale","set","x","y","z","makeRotationFromQuaternion","setFromRotationMatrix","boneIndex","indexOf","wBindMatrix","boneInverses","copyPosition","parent","isBone","setPosition","retargetClip","clip","useFirstFramePosition","fps","getHelperFromSkeleton","numFrames","Math","round","duration","delta","convertedTracks","mixer","boneDatas","positionOffset","boneData","j","clipAction","play","update","time","times","Float32Array","values","sub","toArray","uncacheAction","getSkeletonOffsets","targetParentPos","targetPos","sourceParentPos","sourcePos","targetDir","sourceDir","nameKeys","Object","keys","nameValues","boneParent","getNearestBone","boneToParent","setFromMatrixPosition","subVectors","normalize","laterialAngle","angle","offset","makeRotationFromEuler","renameBones","Array","isArray","findBoneTrackData","tracks","regexp","result","trackData","exec","getEqualsBonesNames","targetSkeleton","targetBones","search","boneName","sourceLookup","Map","cloneLookup","parallelTraverse","sourceNode","clonedNode","traverse","node","isSkinnedMesh","clonedMesh","sourceMesh","get","bindMatrix","map","bind","a","b","callback"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/utils/SkeletonUtils.js"],"sourcesContent":["import { Vector3, Quaternion, Matrix4, AnimationMixer, VectorKeyframeTrack, QuaternionKeyframeTrack, AnimationClip, SkeletonHelper, Vector2, Euler } from 'three';\n\nvar SkeletonUtils = {\n  retarget: function () {\n    var pos = new Vector3(),\n        quat = new Quaternion(),\n        scale = new Vector3(),\n        bindBoneMatrix = new Matrix4(),\n        relativeMatrix = new Matrix4(),\n        globalMatrix = new Matrix4();\n    return function (target, source, options) {\n      options = options || {};\n      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;\n      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;\n      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;\n      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          bindBones,\n          bone,\n          name,\n          boneTo,\n          bonesPosition,\n          i; // reset bones\n\n      if (target.isObject3D) {\n        target.skeleton.pose();\n      } else {\n        options.useTargetMatrix = true;\n        options.preserveMatrix = false;\n      }\n\n      if (options.preservePosition) {\n        bonesPosition = [];\n\n        for (i = 0; i < bones.length; i++) {\n          bonesPosition.push(bones[i].position.clone());\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // reset matrix\n        target.updateMatrixWorld();\n        target.matrixWorld.identity(); // reset children matrix\n\n        for (i = 0; i < target.children.length; ++i) {\n          target.children[i].updateMatrixWorld(true);\n        }\n      }\n\n      if (options.offsets) {\n        bindBones = [];\n\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (options.offsets && options.offsets[name]) {\n            bone.matrix.multiply(options.offsets[name]);\n            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n            bone.updateMatrixWorld();\n          }\n\n          bindBones.push(bone.matrixWorld.clone());\n        }\n      }\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n        globalMatrix.copy(bone.matrixWorld);\n\n        if (boneTo) {\n          boneTo.updateMatrixWorld();\n\n          if (options.useTargetMatrix) {\n            relativeMatrix.copy(boneTo.matrixWorld);\n          } else {\n            relativeMatrix.copy(target.matrixWorld).invert();\n            relativeMatrix.multiply(boneTo.matrixWorld);\n          } // ignore scale to extract rotation\n\n\n          scale.setFromMatrixScale(relativeMatrix);\n          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix\n\n          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));\n\n          if (target.isObject3D) {\n            var boneIndex = bones.indexOf(bone),\n                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.copy(target.skeleton.boneInverses[boneIndex]).invert();\n            globalMatrix.multiply(wBindMatrix);\n          }\n\n          globalMatrix.copyPosition(relativeMatrix);\n        }\n\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(globalMatrix);\n        } else {\n          bone.matrix.copy(globalMatrix);\n        }\n\n        if (options.preserveHipPosition && name === options.hip) {\n          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));\n        }\n\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n        bone.updateMatrixWorld();\n      }\n\n      if (options.preservePosition) {\n        for (i = 0; i < bones.length; ++i) {\n          bone = bones[i];\n          name = options.names[bone.name] || bone.name;\n\n          if (name !== options.hip) {\n            bone.position.copy(bonesPosition[i]);\n          }\n        }\n      }\n\n      if (options.preserveMatrix) {\n        // restore matrix\n        target.updateMatrixWorld(true);\n      }\n    };\n  }(),\n  retargetClip: function (target, source, clip, options) {\n    options = options || {};\n    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;\n    options.fps = options.fps !== undefined ? options.fps : 30;\n    options.names = options.names || [];\n\n    if (!source.isObject3D) {\n      source = this.getHelperFromSkeleton(source);\n    }\n\n    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),\n        delta = 1 / options.fps,\n        convertedTracks = [],\n        mixer = new AnimationMixer(source),\n        bones = this.getBones(target.skeleton),\n        boneDatas = [],\n        positionOffset,\n        bone,\n        boneTo,\n        boneData,\n        name,\n        i,\n        j;\n    mixer.clipAction(clip).play();\n    mixer.update(0);\n    source.updateMatrixWorld();\n\n    for (i = 0; i < numFrames; ++i) {\n      var time = i * delta;\n      this.retarget(target, source, options);\n\n      for (j = 0; j < bones.length; ++j) {\n        name = options.names[bones[j].name] || bones[j].name;\n        boneTo = this.getBoneByName(name, source.skeleton);\n\n        if (boneTo) {\n          bone = bones[j];\n          boneData = boneDatas[j] = boneDatas[j] || {\n            bone: bone\n          };\n\n          if (options.hip === name) {\n            if (!boneData.pos) {\n              boneData.pos = {\n                times: new Float32Array(numFrames),\n                values: new Float32Array(numFrames * 3)\n              };\n            }\n\n            if (options.useFirstFramePosition) {\n              if (i === 0) {\n                positionOffset = bone.position.clone();\n              }\n\n              bone.position.sub(positionOffset);\n            }\n\n            boneData.pos.times[i] = time;\n            bone.position.toArray(boneData.pos.values, i * 3);\n          }\n\n          if (!boneData.quat) {\n            boneData.quat = {\n              times: new Float32Array(numFrames),\n              values: new Float32Array(numFrames * 4)\n            };\n          }\n\n          boneData.quat.times[i] = time;\n          bone.quaternion.toArray(boneData.quat.values, i * 4);\n        }\n      }\n\n      mixer.update(delta);\n      source.updateMatrixWorld();\n    }\n\n    for (i = 0; i < boneDatas.length; ++i) {\n      boneData = boneDatas[i];\n\n      if (boneData) {\n        if (boneData.pos) {\n          convertedTracks.push(new VectorKeyframeTrack('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));\n        }\n\n        convertedTracks.push(new QuaternionKeyframeTrack('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));\n      }\n    }\n\n    mixer.uncacheAction(clip);\n    return new AnimationClip(clip.name, -1, convertedTracks);\n  },\n  getHelperFromSkeleton: function (skeleton) {\n    var source = new SkeletonHelper(skeleton.bones[0]);\n    source.skeleton = skeleton;\n    return source;\n  },\n  getSkeletonOffsets: function () {\n    var targetParentPos = new Vector3(),\n        targetPos = new Vector3(),\n        sourceParentPos = new Vector3(),\n        sourcePos = new Vector3(),\n        targetDir = new Vector2(),\n        sourceDir = new Vector2();\n    return function (target, source, options) {\n      options = options || {};\n      options.hip = options.hip !== undefined ? options.hip : 'hip';\n      options.names = options.names || {};\n\n      if (!source.isObject3D) {\n        source = this.getHelperFromSkeleton(source);\n      }\n\n      var nameKeys = Object.keys(options.names),\n          nameValues = Object.values(options.names),\n          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),\n          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),\n          offsets = [],\n          bone,\n          boneTo,\n          name,\n          i;\n      target.skeleton.pose();\n\n      for (i = 0; i < bones.length; ++i) {\n        bone = bones[i];\n        name = options.names[bone.name] || bone.name;\n        boneTo = this.getBoneByName(name, sourceBones);\n\n        if (boneTo && name !== options.hip) {\n          var boneParent = this.getNearestBone(bone.parent, nameKeys),\n              boneToParent = this.getNearestBone(boneTo.parent, nameValues);\n          boneParent.updateMatrixWorld();\n          boneToParent.updateMatrixWorld();\n          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);\n          targetPos.setFromMatrixPosition(bone.matrixWorld);\n          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);\n          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);\n          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();\n          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();\n          var laterialAngle = targetDir.angle() - sourceDir.angle();\n          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));\n          bone.matrix.multiply(offset);\n          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n          bone.updateMatrixWorld();\n          offsets[name] = offset;\n        }\n      }\n\n      return offsets;\n    };\n  }(),\n  renameBones: function (skeleton, names) {\n    var bones = this.getBones(skeleton);\n\n    for (let i = 0; i < bones.length; ++i) {\n      var bone = bones[i];\n\n      if (names[bone.name]) {\n        bone.name = names[bone.name];\n      }\n    }\n\n    return this;\n  },\n  getBones: function (skeleton) {\n    return Array.isArray(skeleton) ? skeleton : skeleton.bones;\n  },\n  getBoneByName: function (name, skeleton) {\n    for (let i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {\n      if (name === bones[i].name) return bones[i];\n    }\n  },\n  getNearestBone: function (bone, names) {\n    while (bone.isBone) {\n      if (names.indexOf(bone.name) !== -1) {\n        return bone;\n      }\n\n      bone = bone.parent;\n    }\n  },\n  findBoneTrackData: function (name, tracks) {\n    var regexp = /\\[(.*)\\]\\.(.*)/,\n        result = {\n      name: name\n    };\n\n    for (let i = 0; i < tracks.length; ++i) {\n      // 1 is track name\n      // 2 is track type\n      var trackData = regexp.exec(tracks[i].name);\n\n      if (trackData && name === trackData[1]) {\n        result[trackData[2]] = i;\n      }\n    }\n\n    return result;\n  },\n  getEqualsBonesNames: function (skeleton, targetSkeleton) {\n    var sourceBones = this.getBones(skeleton),\n        targetBones = this.getBones(targetSkeleton),\n        bones = [];\n\n    search: for (let i = 0; i < sourceBones.length; i++) {\n      var boneName = sourceBones[i].name;\n\n      for (let j = 0; j < targetBones.length; j++) {\n        if (boneName === targetBones[j].name) {\n          bones.push(boneName);\n          continue search;\n        }\n      }\n    }\n\n    return bones;\n  },\n  clone: function (source) {\n    var sourceLookup = new Map();\n    var cloneLookup = new Map();\n    var clone = source.clone();\n    parallelTraverse(source, clone, function (sourceNode, clonedNode) {\n      sourceLookup.set(clonedNode, sourceNode);\n      cloneLookup.set(sourceNode, clonedNode);\n    });\n    clone.traverse(function (node) {\n      if (!node.isSkinnedMesh) return;\n      var clonedMesh = node;\n      var sourceMesh = sourceLookup.get(node);\n      var sourceBones = sourceMesh.skeleton.bones;\n      clonedMesh.skeleton = sourceMesh.skeleton.clone();\n      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);\n      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {\n        return cloneLookup.get(bone);\n      });\n      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);\n    });\n    return clone;\n  }\n};\n\nfunction parallelTraverse(a, b, callback) {\n  callback(a, b);\n\n  for (let i = 0; i < a.children.length; i++) {\n    parallelTraverse(a.children[i], b.children[i], callback);\n  }\n}\n\nexport { SkeletonUtils };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}