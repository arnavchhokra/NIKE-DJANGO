{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Arnav/Downloads/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n\nvar NodeKeywords = /*#__PURE__*/function () {\n  function NodeKeywords() {\n    _classCallCheck(this, NodeKeywords);\n\n    this.keywords = [];\n    this.nodes = [];\n    this.keywordsCallback = {};\n  }\n\n  _createClass(NodeKeywords, [{\n    key: \"getNode\",\n    value: function getNode(name) {\n      var node = this.nodes[name];\n\n      if (node === undefined && this.keywordsCallback[name] !== undefined) {\n        node = this.keywordsCallback[name](name);\n        this.nodes[name] = node;\n      }\n\n      return node;\n    }\n  }, {\n    key: \"addKeyword\",\n    value: function addKeyword(name, callback) {\n      this.keywords.push(name);\n      this.keywordsCallback[name] = callback;\n      return this;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(code) {\n      var keywordNames = this.keywords;\n      var regExp = new RegExp(\"\\\\b\".concat(keywordNames.join('\\\\b|\\\\b'), \"\\\\b\"), 'g');\n      var codeKeywords = code.match(regExp);\n      var keywordNodes = [];\n\n      if (codeKeywords !== null) {\n        var _iterator = _createForOfIteratorHelper(codeKeywords),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var keyword = _step.value;\n            var node = this.getNode(keyword);\n\n            if (node !== undefined && keywordNodes.indexOf(node) === -1) {\n              keywordNodes.push(node);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return keywordNodes;\n    }\n  }, {\n    key: \"include\",\n    value: function include(builder, code) {\n      var keywordNodes = this.parse(code);\n\n      var _iterator2 = _createForOfIteratorHelper(keywordNodes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var keywordNode = _step2.value;\n          keywordNode.build(builder);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return NodeKeywords;\n}();\n\nexport default NodeKeywords;","map":{"version":3,"names":["NodeKeywords","keywords","nodes","keywordsCallback","name","node","undefined","callback","push","code","keywordNames","regExp","RegExp","join","codeKeywords","match","keywordNodes","keyword","getNode","indexOf","builder","parse","keywordNode","build"],"sources":["C:/Users/Arnav/Downloads/l4fycy/node_modules/three-stdlib/nodes/core/NodeKeywords.js"],"sourcesContent":["class NodeKeywords {\n  constructor() {\n    this.keywords = [];\n    this.nodes = [];\n    this.keywordsCallback = {};\n  }\n\n  getNode(name) {\n    let node = this.nodes[name];\n\n    if (node === undefined && this.keywordsCallback[name] !== undefined) {\n      node = this.keywordsCallback[name](name);\n      this.nodes[name] = node;\n    }\n\n    return node;\n  }\n\n  addKeyword(name, callback) {\n    this.keywords.push(name);\n    this.keywordsCallback[name] = callback;\n    return this;\n  }\n\n  parse(code) {\n    const keywordNames = this.keywords;\n    const regExp = new RegExp(`\\\\b${keywordNames.join('\\\\b|\\\\b')}\\\\b`, 'g');\n    const codeKeywords = code.match(regExp);\n    const keywordNodes = [];\n\n    if (codeKeywords !== null) {\n      for (const keyword of codeKeywords) {\n        const node = this.getNode(keyword);\n\n        if (node !== undefined && keywordNodes.indexOf(node) === -1) {\n          keywordNodes.push(node);\n        }\n      }\n    }\n\n    return keywordNodes;\n  }\n\n  include(builder, code) {\n    const keywordNodes = this.parse(code);\n\n    for (const keywordNode of keywordNodes) {\n      keywordNode.build(builder);\n    }\n  }\n\n}\n\nexport default NodeKeywords;\n"],"mappings":";;;;IAAMA,Y;EACJ,wBAAc;IAAA;;IACZ,KAAKC,QAAL,GAAgB,EAAhB;IACA,KAAKC,KAAL,GAAa,EAAb;IACA,KAAKC,gBAAL,GAAwB,EAAxB;EACD;;;;WAED,iBAAQC,IAAR,EAAc;MACZ,IAAIC,IAAI,GAAG,KAAKH,KAAL,CAAWE,IAAX,CAAX;;MAEA,IAAIC,IAAI,KAAKC,SAAT,IAAsB,KAAKH,gBAAL,CAAsBC,IAAtB,MAAgCE,SAA1D,EAAqE;QACnED,IAAI,GAAG,KAAKF,gBAAL,CAAsBC,IAAtB,EAA4BA,IAA5B,CAAP;QACA,KAAKF,KAAL,CAAWE,IAAX,IAAmBC,IAAnB;MACD;;MAED,OAAOA,IAAP;IACD;;;WAED,oBAAWD,IAAX,EAAiBG,QAAjB,EAA2B;MACzB,KAAKN,QAAL,CAAcO,IAAd,CAAmBJ,IAAnB;MACA,KAAKD,gBAAL,CAAsBC,IAAtB,IAA8BG,QAA9B;MACA,OAAO,IAAP;IACD;;;WAED,eAAME,IAAN,EAAY;MACV,IAAMC,YAAY,GAAG,KAAKT,QAA1B;MACA,IAAMU,MAAM,GAAG,IAAIC,MAAJ,cAAiBF,YAAY,CAACG,IAAb,CAAkB,SAAlB,CAAjB,UAAoD,GAApD,CAAf;MACA,IAAMC,YAAY,GAAGL,IAAI,CAACM,KAAL,CAAWJ,MAAX,CAArB;MACA,IAAMK,YAAY,GAAG,EAArB;;MAEA,IAAIF,YAAY,KAAK,IAArB,EAA2B;QAAA,2CACHA,YADG;QAAA;;QAAA;UACzB,oDAAoC;YAAA,IAAzBG,OAAyB;YAClC,IAAMZ,IAAI,GAAG,KAAKa,OAAL,CAAaD,OAAb,CAAb;;YAEA,IAAIZ,IAAI,KAAKC,SAAT,IAAsBU,YAAY,CAACG,OAAb,CAAqBd,IAArB,MAA+B,CAAC,CAA1D,EAA6D;cAC3DW,YAAY,CAACR,IAAb,CAAkBH,IAAlB;YACD;UACF;QAPwB;UAAA;QAAA;UAAA;QAAA;MAQ1B;;MAED,OAAOW,YAAP;IACD;;;WAED,iBAAQI,OAAR,EAAiBX,IAAjB,EAAuB;MACrB,IAAMO,YAAY,GAAG,KAAKK,KAAL,CAAWZ,IAAX,CAArB;;MADqB,4CAGKO,YAHL;MAAA;;MAAA;QAGrB,uDAAwC;UAAA,IAA7BM,WAA6B;UACtCA,WAAW,CAACC,KAAZ,CAAkBH,OAAlB;QACD;MALoB;QAAA;MAAA;QAAA;MAAA;IAMtB;;;;;;AAIH,eAAepB,YAAf"},"metadata":{},"sourceType":"module"}