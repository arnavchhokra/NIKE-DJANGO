{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addNoneTerminalToCst = exports.addTerminalToCst = exports.setNodeLocationFull = exports.setNodeLocationOnlyOffset = void 0;\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\n\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  } // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n  }\n}\n\nexports.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\n\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\n    currNodeLocation.startLine = newLocationInfo.startLine;\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  } // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\n    currNodeLocation.endLine = newLocationInfo.endLine;\n  }\n}\n\nexports.setNodeLocationFull = setNodeLocationFull;\n\nfunction addTerminalToCst(node, token, tokenTypeName) {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token];\n  } else {\n    node.children[tokenTypeName].push(token);\n  }\n}\n\nexports.addTerminalToCst = addTerminalToCst;\n\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult];\n  } else {\n    node.children[ruleName].push(ruleResult);\n  }\n}\n\nexports.addNoneTerminalToCst = addNoneTerminalToCst;","map":{"version":3,"mappings":";;;;;;AAEA;;;;;;;;AAOA,SAAgBA,yBAAhB,CACEC,gBADF,EAEEC,eAFF,EAEsE;EAEpE;EACA,IAAIC,KAAK,CAACF,gBAAgB,CAACG,WAAlB,CAAL,KAAwC,IAA5C,EAAkD;IAChD;IACA;IACA;IACAH,gBAAgB,CAACG,WAAjB,GAA+BF,eAAe,CAACE,WAA/C;IACAH,gBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;EACD,CAND,CAOA;EACA;EACA;EACA;EAVA,KAWK,IAAIJ,gBAAgB,CAACI,SAAjB,GAA8BH,eAAe,CAACG,SAA9C,KAA4D,IAAhE,EAAsE;IACzEJ,gBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;EACD;AACF;;AAnBDC;AAqBA;;;;;;;;AAOA,SAAgBC,mBAAhB,CACEN,gBADF,EAEEC,eAFF,EAEkC;EAEhC;EACA,IAAIC,KAAK,CAACF,gBAAgB,CAACG,WAAlB,CAAL,KAAwC,IAA5C,EAAkD;IAChD;IACA;IACA;IACAH,gBAAgB,CAACG,WAAjB,GAA+BF,eAAe,CAACE,WAA/C;IACAH,gBAAgB,CAACO,WAAjB,GAA+BN,eAAe,CAACM,WAA/C;IACAP,gBAAgB,CAACQ,SAAjB,GAA6BP,eAAe,CAACO,SAA7C;IACAR,gBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;IACAJ,gBAAgB,CAACS,SAAjB,GAA6BR,eAAe,CAACQ,SAA7C;IACAT,gBAAgB,CAACU,OAAjB,GAA2BT,eAAe,CAACS,OAA3C;EACD,CAVD,CAWA;EACA;EACA;EACA;EAdA,KAeK,IAAIV,gBAAgB,CAACI,SAAjB,GAA8BH,eAAe,CAACG,SAA9C,KAA6D,IAAjE,EAAuE;IAC1EJ,gBAAgB,CAACI,SAAjB,GAA6BH,eAAe,CAACG,SAA7C;IACAJ,gBAAgB,CAACS,SAAjB,GAA6BR,eAAe,CAACQ,SAA7C;IACAT,gBAAgB,CAACU,OAAjB,GAA2BT,eAAe,CAACS,OAA3C;EACD;AACF;;AAzBDL;;AA2BA,SAAgBM,gBAAhB,CACEC,IADF,EAEEC,KAFF,EAGEC,aAHF,EAGuB;EAErB,IAAIF,IAAI,CAACG,QAAL,CAAcD,aAAd,MAAiCE,SAArC,EAAgD;IAC9CJ,IAAI,CAACG,QAAL,CAAcD,aAAd,IAA+B,CAACD,KAAD,CAA/B;EACD,CAFD,MAEO;IACLD,IAAI,CAACG,QAAL,CAAcD,aAAd,EAA6BG,IAA7B,CAAkCJ,KAAlC;EACD;AACF;;AAVDR;;AAYA,SAAgBa,oBAAhB,CACEN,IADF,EAEEO,QAFF,EAGEC,UAHF,EAGiB;EAEf,IAAIR,IAAI,CAACG,QAAL,CAAcI,QAAd,MAA4BH,SAAhC,EAA2C;IACzCJ,IAAI,CAACG,QAAL,CAAcI,QAAd,IAA0B,CAACC,UAAD,CAA1B;EACD,CAFD,MAEO;IACLR,IAAI,CAACG,QAAL,CAAcI,QAAd,EAAwBF,IAAxB,CAA6BG,UAA7B;EACD;AACF;;AAVDf","names":["setNodeLocationOnlyOffset","currNodeLocation","newLocationInfo","isNaN","startOffset","endOffset","exports","setNodeLocationFull","startColumn","startLine","endColumn","endLine","addTerminalToCst","node","token","tokenTypeName","children","undefined","push","addNoneTerminalToCst","ruleName","ruleResult"],"sources":["C:\\Users\\Arnav\\Downloads\\l4fycy\\node_modules\\chevrotain\\src\\parse\\cst\\cst.ts"],"sourcesContent":["import { CstNode, CstNodeLocation, IToken } from \"@chevrotain/types\"\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationOnlyOffset(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: Required<Pick<IToken, \"startOffset\" | \"endOffset\">>\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (both start/end offsets exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n  // Once the startOffset has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n  }\n}\n\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nexport function setNodeLocationFull(\n  currNodeLocation: CstNodeLocation,\n  newLocationInfo: CstNodeLocation\n): void {\n  // First (valid) update for this cst node\n  if (isNaN(currNodeLocation.startOffset) === true) {\n    // assumption1: Token location information is either NaN or a valid number\n    // assumption2: Token location information is fully valid if it exist\n    // (all start/end props exist and are numbers).\n    currNodeLocation.startOffset = newLocationInfo.startOffset\n    currNodeLocation.startColumn = newLocationInfo.startColumn\n    currNodeLocation.startLine = newLocationInfo.startLine\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n  // Once the start props has been updated with a valid number it should never receive\n  // any farther updates as the Token vector is sorted.\n  // We still have to check this this condition for every new possible location info\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset! === true) {\n    currNodeLocation.endOffset = newLocationInfo.endOffset\n    currNodeLocation.endColumn = newLocationInfo.endColumn\n    currNodeLocation.endLine = newLocationInfo.endLine\n  }\n}\n\nexport function addTerminalToCst(\n  node: CstNode,\n  token: IToken,\n  tokenTypeName: string\n): void {\n  if (node.children[tokenTypeName] === undefined) {\n    node.children[tokenTypeName] = [token]\n  } else {\n    node.children[tokenTypeName].push(token)\n  }\n}\n\nexport function addNoneTerminalToCst(\n  node: CstNode,\n  ruleName: string,\n  ruleResult: any\n): void {\n  if (node.children[ruleName] === undefined) {\n    node.children[ruleName] = [ruleResult]\n  } else {\n    node.children[ruleName].push(ruleResult)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}