{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from 'three';\nimport { SimplexNoise } from '../math/SimplexNoise.js';\n/**\r\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\r\n *\r\n *\r\n * Usage\r\n *\r\n * var myRay = new LightningStrike( paramsObject );\r\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\r\n * scene.add( myRayMesh );\r\n * ...\r\n * myRay.update( currentTime );\r\n *\r\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\r\n *\r\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\r\n *\r\n *\r\n * LightningStrike parameters\r\n *\r\n * The paramsObject can contain any of the following parameters.\r\n *\r\n * Legend:\r\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\r\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\r\n * 'Segment': A linear segment piece of a subray.\r\n * 'Leaf segment': A ray segment which cannot be smaller.\r\n *\r\n *\r\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\r\n *\r\n * @param {Vector3} sourceOffset The point where the ray starts.\r\n *\r\n * @param {Vector3} destOffset The point where the ray ends.\r\n *\r\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\r\n *\r\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\r\n *\r\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\r\n *\r\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\r\n *\r\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\r\n *\r\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\r\n *\r\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\r\n *\r\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\r\n *\r\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\r\n *\r\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\r\n *\r\n *\r\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\r\n *\r\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\r\n *\r\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\r\n *\r\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\r\n *\r\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\r\n *\r\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\r\n *\r\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\r\n *\r\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\r\n *\r\n *\r\n * These parameters cannot change after lightning creation:\r\n *\r\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\r\n *\r\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\r\n *\r\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\r\n *\r\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\r\n *\r\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\r\n *\r\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\r\n *\r\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\r\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\r\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\r\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\r\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\r\n *\r\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\r\n *\r\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\r\n *\r\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\r\n *\r\n *\r\n */\n\nvar LightningStrike = /*#__PURE__*/function (_BufferGeometry) {\n  _inherits(LightningStrike, _BufferGeometry);\n\n  var _super = _createSuper(LightningStrike);\n\n  function LightningStrike(rayParameters) {\n    var _this;\n\n    _classCallCheck(this, LightningStrike);\n\n    _this = _super.call(this);\n    _this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\n\n    rayParameters = rayParameters || {};\n\n    _this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\n\n\n    _this.createMesh();\n\n    return _this;\n  }\n\n  _createClass(LightningStrike, [{\n    key: \"update\",\n    value: function update(time) {\n      if (this.isStatic) return;\n\n      if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\n        this.updateMesh(time);\n\n        if (time < this.subrays[0].endPropagationTime) {\n          this.state = LightningStrike.RAY_PROPAGATING;\n        } else if (time > this.subrays[0].beginVanishingTime) {\n          this.state = LightningStrike.RAY_VANISHING;\n        } else {\n          this.state = LightningStrike.RAY_STEADY;\n        }\n\n        this.visible = true;\n      } else {\n        this.visible = false;\n\n        if (time < this.rayParameters.birthTime) {\n          this.state = LightningStrike.RAY_UNBORN;\n        } else {\n          this.state = LightningStrike.RAY_EXTINGUISHED;\n        }\n      }\n    }\n  }, {\n    key: \"init\",\n    value: function init(rayParameters) {\n      // Init all the state from the parameters\n      this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\n\n      this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\n      rayParameters.maxIterations = this.maxIterations;\n      this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\n      rayParameters.isStatic = this.isStatic;\n      this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\n      rayParameters.ramification = this.ramification;\n      this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\n      rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\n      this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\n      rayParameters.recursionProbability = this.recursionProbability;\n      this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\n      rayParameters.generateUVs = this.generateUVs; // Random generator\n\n      if (rayParameters.randomGenerator !== undefined) {\n        this.randomGenerator = rayParameters.randomGenerator;\n        this.seedGenerator = rayParameters.randomGenerator;\n\n        if (rayParameters.noiseSeed !== undefined) {\n          this.seedGenerator.setSeed(rayParameters.noiseSeed);\n        }\n      } else {\n        this.randomGenerator = LightningStrike.createRandomGenerator();\n        this.seedGenerator = Math;\n      } // Ray creation callbacks\n\n\n      if (rayParameters.onDecideSubrayCreation !== undefined) {\n        this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\n      } else {\n        this.createDefaultSubrayCreationCallbacks();\n\n        if (rayParameters.onSubrayCreation !== undefined) {\n          this.onSubrayCreation = rayParameters.onSubrayCreation;\n        }\n      } // Internal state\n\n\n      this.state = LightningStrike.RAY_INITIALIZED;\n      this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\n      rayParameters.maxSubrays = this.maxSubrays;\n      this.maxRaySegments = 2 * (1 << this.maxIterations);\n      this.subrays = [];\n\n      for (var i = 0; i < this.maxSubrays; i++) {\n        this.subrays.push(this.createSubray());\n      }\n\n      this.raySegments = [];\n\n      for (var _i = 0; _i < this.maxRaySegments; _i++) {\n        this.raySegments.push(this.createSegment());\n      }\n\n      this.time = 0;\n      this.timeFraction = 0;\n      this.currentSegmentCallback = null;\n      this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\n      this.numSubrays = 0;\n      this.currentSubray = null;\n      this.currentSegmentIndex = 0;\n      this.isInitialSegment = false;\n      this.subrayProbability = 0;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.vertices = null;\n      this.uvs = null;\n      this.indices = null;\n      this.positionAttribute = null;\n      this.uvsAttribute = null;\n      this.simplexX = new SimplexNoise(this.seedGenerator);\n      this.simplexY = new SimplexNoise(this.seedGenerator);\n      this.simplexZ = new SimplexNoise(this.seedGenerator); // Temp vectors\n\n      this.forwards = new Vector3();\n      this.forwardsFill = new Vector3();\n      this.side = new Vector3();\n      this.down = new Vector3();\n      this.middlePos = new Vector3();\n      this.middleLinPos = new Vector3();\n      this.newPos = new Vector3();\n      this.vPos = new Vector3();\n      this.cross1 = new Vector3();\n    }\n  }, {\n    key: \"createMesh\",\n    value: function createMesh() {\n      var maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\n      var maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\n      var maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\n      this.vertices = new Float32Array(maxVerts * 3);\n      this.indices = new Uint32Array(maxIndices);\n\n      if (this.generateUVs) {\n        this.uvs = new Float32Array(maxVerts * 2);\n      } // Populate the mesh\n\n\n      this.fillMesh(0);\n      this.setIndex(new Uint32BufferAttribute(this.indices, 1));\n      this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\n      this.setAttribute('position', this.positionAttribute);\n\n      if (this.generateUVs) {\n        this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\n        this.setAttribute('uv', this.uvsAttribute);\n      }\n\n      if (!this.isStatic) {\n        this.index.usage = DynamicDrawUsage;\n        this.positionAttribute.usage = DynamicDrawUsage;\n\n        if (this.generateUVs) {\n          this.uvsAttribute.usage = DynamicDrawUsage;\n        }\n      } // Store buffers for later modification\n\n\n      this.vertices = this.positionAttribute.array;\n      this.indices = this.index.array;\n\n      if (this.generateUVs) {\n        this.uvs = this.uvsAttribute.array;\n      }\n    }\n  }, {\n    key: \"updateMesh\",\n    value: function updateMesh(time) {\n      this.fillMesh(time);\n      this.drawRange.count = this.currentIndex;\n      this.index.needsUpdate = true;\n      this.positionAttribute.needsUpdate = true;\n\n      if (this.generateUVs) {\n        this.uvsAttribute.needsUpdate = true;\n      }\n    }\n  }, {\n    key: \"fillMesh\",\n    value: function fillMesh(time) {\n      var scope = this;\n      this.currentVertex = 0;\n      this.currentIndex = 0;\n      this.currentCoordinate = 0;\n      this.currentUVCoordinate = 0;\n      this.fractalRay(time, function fillVertices(segment) {\n        var subray = scope.currentSubray;\n\n        if (time < subray.birthTime) {\n          //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\n          return;\n        } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\n          // Eternal rays don't propagate nor vanish, but its subrays do\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else if (time < subray.endPropagationTime) {\n          if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\n            // Ray propagation has arrived to this segment\n            scope.createPrism(segment);\n            scope.onDecideSubrayCreation(segment, scope);\n          }\n        } else if (time < subray.beginVanishingTime) {\n          // Ray is steady (nor propagating nor vanishing)\n          scope.createPrism(segment);\n          scope.onDecideSubrayCreation(segment, scope);\n        } else {\n          if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\n            // Segment has not yet vanished\n            scope.createPrism(segment);\n          }\n\n          scope.onDecideSubrayCreation(segment, scope);\n        }\n      });\n    }\n  }, {\n    key: \"addNewSubray\",\n    value: function addNewSubray()\n    /*rayParameters*/\n    {\n      return this.subrays[this.numSubrays++];\n    }\n  }, {\n    key: \"initSubray\",\n    value: function initSubray(subray, rayParameters) {\n      subray.pos0.copy(rayParameters.sourceOffset);\n      subray.pos1.copy(rayParameters.destOffset);\n      subray.up0.copy(rayParameters.up0);\n      subray.up1.copy(rayParameters.up1);\n      subray.radius0 = rayParameters.radius0;\n      subray.radius1 = rayParameters.radius1;\n      subray.birthTime = rayParameters.birthTime;\n      subray.deathTime = rayParameters.deathTime;\n      subray.timeScale = rayParameters.timeScale;\n      subray.roughness = rayParameters.roughness;\n      subray.straightness = rayParameters.straightness;\n      subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\n      subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\n      subray.maxIterations = this.maxIterations;\n      subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\n      subray.recursion = 0;\n    }\n  }, {\n    key: \"fractalRay\",\n    value: function fractalRay(time, segmentCallback) {\n      this.time = time;\n      this.currentSegmentCallback = segmentCallback;\n      this.numSubrays = 0; // Add the top level subray\n\n      this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\n\n      for (var subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\n        var subray = this.subrays[subrayIndex];\n        this.currentSubray = subray;\n        this.randomGenerator.setSeed(subray.seed);\n        subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\n        subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\n        var random1 = this.randomGenerator.random;\n        subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n        subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n        this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\n        this.currentSegmentIndex = 0;\n        this.isInitialSegment = true;\n        var segment = this.getNewSegment();\n        segment.iteration = 0;\n        segment.pos0.copy(subray.pos0);\n        segment.pos1.copy(subray.pos1);\n        segment.linPos0.copy(subray.linPos0);\n        segment.linPos1.copy(subray.linPos1);\n        segment.up0.copy(subray.up0);\n        segment.up1.copy(subray.up1);\n        segment.radius0 = subray.radius0;\n        segment.radius1 = subray.radius1;\n        segment.fraction0 = 0;\n        segment.fraction1 = 1;\n        segment.positionVariationFactor = 1 - subray.straightness;\n        this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\n        this.fractalRayRecursive(segment);\n      }\n\n      this.currentSegmentCallback = null;\n      this.currentSubray = null;\n    }\n  }, {\n    key: \"fractalRayRecursive\",\n    value: function fractalRayRecursive(segment) {\n      // Leave recursion condition\n      if (segment.iteration >= this.currentSubray.maxIterations) {\n        this.currentSegmentCallback(segment);\n        return;\n      } // Interpolation\n\n\n      this.forwards.subVectors(segment.pos1, segment.pos0);\n      var lForwards = this.forwards.length();\n\n      if (lForwards < 0.000001) {\n        this.forwards.set(0, 0, 0.01);\n        lForwards = this.forwards.length();\n      }\n\n      var middleRadius = (segment.radius0 + segment.radius1) * 0.5;\n      var middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\n      var timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\n      this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\n      this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\n      var p = this.middleLinPos; // Noise\n\n      this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\n      this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\n      this.newPos.add(this.middlePos); // Recursion\n\n      var newSegment1 = this.getNewSegment();\n      newSegment1.pos0.copy(segment.pos0);\n      newSegment1.pos1.copy(this.newPos);\n      newSegment1.linPos0.copy(segment.linPos0);\n      newSegment1.linPos1.copy(this.middleLinPos);\n      newSegment1.up0.copy(segment.up0);\n      newSegment1.up1.copy(segment.up1);\n      newSegment1.radius0 = segment.radius0;\n      newSegment1.radius1 = middleRadius;\n      newSegment1.fraction0 = segment.fraction0;\n      newSegment1.fraction1 = middleFraction;\n      newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment1.iteration = segment.iteration + 1;\n      var newSegment2 = this.getNewSegment();\n      newSegment2.pos0.copy(this.newPos);\n      newSegment2.pos1.copy(segment.pos1);\n      newSegment2.linPos0.copy(this.middleLinPos);\n      newSegment2.linPos1.copy(segment.linPos1);\n      this.cross1.crossVectors(segment.up0, this.forwards.normalize());\n      newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\n      newSegment2.up1.copy(segment.up1);\n      newSegment2.radius0 = middleRadius;\n      newSegment2.radius1 = segment.radius1;\n      newSegment2.fraction0 = middleFraction;\n      newSegment2.fraction1 = segment.fraction1;\n      newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\n      newSegment2.iteration = segment.iteration + 1;\n      this.fractalRayRecursive(newSegment1);\n      this.fractalRayRecursive(newSegment2);\n    }\n  }, {\n    key: \"createPrism\",\n    value: function createPrism(segment) {\n      // Creates one triangular prism and its vertices at the segment\n      this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\n\n      if (this.isInitialSegment) {\n        this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\n        this.isInitialSegment = false;\n      }\n\n      this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\n      this.createPrismFaces();\n    }\n  }, {\n    key: \"createTriangleVerticesWithoutUVs\",\n    value: function createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\n      // Create an equilateral triangle (only vertices)\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createTriangleVerticesWithUVs\",\n    value: function createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\n      // Create an equilateral triangle (only vertices)\n      this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\n      this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\n      var p = this.vPos;\n      var v = this.vertices;\n      var uv = this.uvs;\n      p.copy(pos).sub(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0;\n      p.copy(pos).add(this.side).add(this.down);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 0.5;\n      p.copy(up).multiplyScalar(radius).add(pos);\n      v[this.currentCoordinate++] = p.x;\n      v[this.currentCoordinate++] = p.y;\n      v[this.currentCoordinate++] = p.z;\n      uv[this.currentUVCoordinate++] = u;\n      uv[this.currentUVCoordinate++] = 1;\n      this.currentVertex += 3;\n    }\n  }, {\n    key: \"createPrismFaces\",\n    value: function createPrismFaces(vertex\n    /*, index*/\n    ) {\n      var indices = this.indices;\n      var vertex = this.currentVertex - 6;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 5;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 1;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 4;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 0;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 2;\n      indices[this.currentIndex++] = vertex + 3;\n      indices[this.currentIndex++] = vertex + 5;\n    }\n  }, {\n    key: \"createDefaultSubrayCreationCallbacks\",\n    value: function createDefaultSubrayCreationCallbacks() {\n      var random1 = this.randomGenerator.random;\n\n      this.onDecideSubrayCreation = function (segment, lightningStrike) {\n        // Decide subrays creation at parent (sub)ray segment\n        var subray = lightningStrike.currentSubray;\n        var period = lightningStrike.rayParameters.subrayPeriod;\n        var dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\n        var phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\n        var phase = lightningStrike.time - phase0;\n        var currentCycle = Math.floor(phase / period);\n        var childSubraySeed = random1() * (currentCycle + 1);\n        var isActive = phase % period <= dutyCycle * period;\n        var probability = 0;\n\n        if (isActive) {\n          probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\n        }\n\n        if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\n          var childSubray = lightningStrike.addNewSubray();\n          var parentSeed = lightningStrike.randomGenerator.getSeed();\n          childSubray.seed = childSubraySeed;\n          lightningStrike.randomGenerator.setSeed(childSubraySeed);\n          childSubray.recursion = subray.recursion + 1;\n          childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\n          childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\n          childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\n          childSubray.up0.copy(subray.up0);\n          childSubray.up1.copy(subray.up1);\n          childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\n          childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\n          childSubray.birthTime = phase0 + currentCycle * period;\n          childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\n\n          if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\n            childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\n            childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\n          }\n\n          childSubray.timeScale = subray.timeScale * 2;\n          childSubray.roughness = subray.roughness;\n          childSubray.straightness = subray.straightness;\n          childSubray.propagationTimeFactor = subray.propagationTimeFactor;\n          childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\n          lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\n          lightningStrike.randomGenerator.setSeed(parentSeed);\n        }\n      };\n\n      var vec1Pos = new Vector3();\n      var vec2Forward = new Vector3();\n      var vec3Side = new Vector3();\n      var vec4Up = new Vector3();\n\n      this.onSubrayCreation = function (segment, parentSubray, childSubray, lightningStrike) {\n        // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\n        // Just use the default cone position generator\n        lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\n      };\n\n      this.subrayConePosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        // Sets childSubray pos0 and pos1 in a cone\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n\n      this.subrayCylinderPosition = function (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) {\n        // Sets childSubray pos0 and pos1 in a cylinder\n        childSubray.pos0.copy(segment.pos0);\n        vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\n        vec2Forward.copy(vec1Pos).normalize();\n        vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\n        var length = vec1Pos.length();\n        vec3Side.crossVectors(parentSubray.up0, vec2Forward);\n        var angle = 2 * Math.PI * random1();\n        vec3Side.multiplyScalar(Math.cos(angle));\n        vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\n        childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\n      };\n    }\n  }, {\n    key: \"createSubray\",\n    value: function createSubray() {\n      return {\n        seed: 0,\n        maxIterations: 0,\n        recursion: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        birthTime: 0,\n        deathTime: 0,\n        timeScale: 0,\n        roughness: 0,\n        straightness: 0,\n        propagationTimeFactor: 0,\n        vanishingTimeFactor: 0,\n        endPropagationTime: 0,\n        beginVanishingTime: 0\n      };\n    }\n  }, {\n    key: \"createSegment\",\n    value: function createSegment() {\n      return {\n        iteration: 0,\n        pos0: new Vector3(),\n        pos1: new Vector3(),\n        linPos0: new Vector3(),\n        linPos1: new Vector3(),\n        up0: new Vector3(),\n        up1: new Vector3(),\n        radius0: 0,\n        radius1: 0,\n        fraction0: 0,\n        fraction1: 0,\n        positionVariationFactor: 0\n      };\n    }\n  }, {\n    key: \"getNewSegment\",\n    value: function getNewSegment() {\n      return this.raySegments[this.currentSegmentIndex++];\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      _get(_getPrototypeOf(LightningStrike.prototype), \"copy\", this).call(this, source);\n\n      this.init(LightningStrike.copyParameters({}, source.rayParameters));\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\n    }\n  }]);\n\n  return LightningStrike;\n}(BufferGeometry);\n\nLightningStrike.prototype.isLightningStrike = true; // Ray states\n\nLightningStrike.RAY_INITIALIZED = 0;\nLightningStrike.RAY_UNBORN = 1;\nLightningStrike.RAY_PROPAGATING = 2;\nLightningStrike.RAY_STEADY = 3;\nLightningStrike.RAY_VANISHING = 4;\nLightningStrike.RAY_EXTINGUISHED = 5;\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\n\nLightningStrike.createRandomGenerator = function () {\n  var numSeeds = 2053;\n  var seeds = [];\n\n  for (var i = 0; i < numSeeds; i++) {\n    seeds.push(Math.random());\n  }\n\n  var generator = {\n    currentSeed: 0,\n    random: function random() {\n      var value = seeds[generator.currentSeed];\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\n      return value;\n    },\n    getSeed: function getSeed() {\n      return generator.currentSeed / numSeeds;\n    },\n    setSeed: function setSeed(seed) {\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\n    }\n  };\n  return generator;\n};\n\nLightningStrike.copyParameters = function (dest, source) {\n  source = source || {};\n  dest = dest || {};\n\n  var vecCopy = function vecCopy(v) {\n    if (source === dest) {\n      return v;\n    } else {\n      return v.clone();\n    }\n  };\n\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1);\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\n\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\n  return dest;\n};\n\nexport { LightningStrike };","map":{"version":3,"names":["BufferGeometry","Vector3","Uint32BufferAttribute","Float32BufferAttribute","DynamicDrawUsage","MathUtils","SimplexNoise","LightningStrike","rayParameters","type","init","copyParameters","createMesh","time","isStatic","isEternal","birthTime","deathTime","updateMesh","subrays","endPropagationTime","state","RAY_PROPAGATING","beginVanishingTime","RAY_VANISHING","RAY_STEADY","visible","RAY_UNBORN","RAY_EXTINGUISHED","maxIterations","undefined","Math","floor","ramification","maxSubrayRecursion","recursionProbability","generateUVs","randomGenerator","seedGenerator","noiseSeed","setSeed","createRandomGenerator","onDecideSubrayCreation","createDefaultSubrayCreationCallbacks","onSubrayCreation","RAY_INITIALIZED","maxSubrays","ceil","pow","max","maxRaySegments","i","push","createSubray","raySegments","createSegment","timeFraction","currentSegmentCallback","currentCreateTriangleVertices","createTriangleVerticesWithUVs","createTriangleVerticesWithoutUVs","numSubrays","currentSubray","currentSegmentIndex","isInitialSegment","subrayProbability","currentVertex","currentIndex","currentCoordinate","currentUVCoordinate","vertices","uvs","indices","positionAttribute","uvsAttribute","simplexX","simplexY","simplexZ","forwards","forwardsFill","side","down","middlePos","middleLinPos","newPos","vPos","cross1","maxDrawableSegmentsPerSubRay","maxVerts","maxIndices","Float32Array","Uint32Array","fillMesh","setIndex","setAttribute","index","usage","array","drawRange","count","needsUpdate","scope","fractalRay","fillVertices","segment","subray","recursion","createPrism","fraction0","propagationTimeFactor","vanishingTimeFactor","fraction1","pos0","copy","sourceOffset","pos1","destOffset","up0","up1","radius0","radius1","timeScale","roughness","straightness","seed","segmentCallback","initSubray","addNewSubray","subrayIndex","lerp","random1","random","linPos0","set","multiplyScalar","linPos1","getNewSegment","iteration","positionVariationFactor","fractalRayRecursive","subVectors","lForwards","length","middleRadius","middleFraction","timeDimension","lerpVectors","p","noise4d","x","y","z","add","newSegment1","newSegment2","crossVectors","normalize","createPrismFaces","pos","up","radius","COS30DEG","SIN30DEG","v","sub","u","uv","vertex","lightningStrike","period","subrayPeriod","dutyCycle","subrayDutyCycle","phase0","phase","currentCycle","childSubraySeed","isActive","probability","childSubray","parentSeed","getSeed","radius0Factor","min","minRadius","radius1Factor","vec1Pos","vec2Forward","vec3Side","vec4Up","parentSubray","subrayCylinderPosition","subrayConePosition","heightFactor","sideWidthFactor","minSideWidthFactor","angle","PI","cos","sin","source","constructor","prototype","isLightningStrike","numSeeds","seeds","generator","currentSeed","value","dest","vecCopy","clone"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/geometries/LightningStrike.js"],"sourcesContent":["import { BufferGeometry, Vector3, Uint32BufferAttribute, Float32BufferAttribute, DynamicDrawUsage, MathUtils } from 'three';\r\nimport { SimplexNoise } from '../math/SimplexNoise.js';\r\n\r\n/**\r\n * @fileoverview LightningStrike object for creating lightning strikes and voltaic arcs.\r\n *\r\n *\r\n * Usage\r\n *\r\n * var myRay = new LightningStrike( paramsObject );\r\n * var myRayMesh = new THREE.Mesh( myRay, myMaterial );\r\n * scene.add( myRayMesh );\r\n * ...\r\n * myRay.update( currentTime );\r\n *\r\n * The \"currentTime\" can vary its rate, go forwards, backwards or even jump, but it cannot be negative.\r\n *\r\n * You should normally leave the ray position to (0, 0, 0). You should control it by changing the sourceOffset and destOffset parameters.\r\n *\r\n *\r\n * LightningStrike parameters\r\n *\r\n * The paramsObject can contain any of the following parameters.\r\n *\r\n * Legend:\r\n * 'LightningStrike' (also called 'ray'): An independent voltaic arc with its ramifications and defined with a set of parameters.\r\n * 'Subray': A ramification of the ray. It is not a LightningStrike object.\r\n * 'Segment': A linear segment piece of a subray.\r\n * 'Leaf segment': A ray segment which cannot be smaller.\r\n *\r\n *\r\n * The following parameters can be changed any time and if they vary smoothly, the ray form will also change smoothly:\r\n *\r\n * @param {Vector3} sourceOffset The point where the ray starts.\r\n *\r\n * @param {Vector3} destOffset The point where the ray ends.\r\n *\r\n * @param {double} timeScale The rate at wich the ray form changes in time. Default: 1\r\n *\r\n * @param {double} roughness From 0 to 1. The higher the value, the more wrinkled is the ray. Default: 0.9\r\n *\r\n * @param {double} straightness From 0 to 1. The higher the value, the more straight will be a subray path. Default: 0.7\r\n *\r\n * @param {Vector3} up0 Ray 'up' direction at the ray starting point. Must be normalized. It should be perpendicular to the ray forward direction but it doesn't matter much.\r\n *\r\n * @param {Vector3} up1 Like the up0 parameter but at the end of the ray. Must be normalized.\r\n *\r\n * @param {double} radius0 Radius of the main ray trunk at the start point. Default: 1\r\n *\r\n * @param {double} radius1 Radius of the main ray trunk at the end point. Default: 1\r\n *\r\n * @param {double} radius0Factor The radius0 of a subray is this factor times the radius0 of its parent subray. Default: 0.5\r\n *\r\n * @param {double} radius1Factor The radius1 of a subray is this factor times the radius1 of its parent subray. Default: 0.2\r\n *\r\n * @param {minRadius} Minimum value a subray radius0 or radius1 can get. Default: 0.1\r\n *\r\n *\r\n * The following parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\r\n *\r\n * @param {boolean} isEternal If true the ray never extinguishes. Otherwise its life is controlled by the 'birthTime' and 'deathTime' parameters. Default: true if any of those two parameters is undefined.\r\n *\r\n * @param {double} birthTime The time at which the ray starts its life and begins propagating. Only if isEternal is false. Default: None.\r\n *\r\n * @param {double} deathTime The time at which the ray ends vanishing and its life. Only if isEternal is false. Default: None.\r\n *\r\n * @param {double} propagationTimeFactor From 0 to 1. Lifetime factor at which the ray ends propagating and enters the steady phase. For example, 0.1 means it is propagating 1/10 of its lifetime. Default: 0.1\r\n *\r\n * @param {double} vanishingTimeFactor From 0 to 1. Lifetime factor at which the ray ends the steady phase and begins vanishing. For example, 0.9 means it is vanishing 1/10 of its lifetime. Default: 0.9\r\n *\r\n * @param {double} subrayPeriod Subrays cycle periodically. This is their time period. Default: 4\r\n *\r\n * @param {double} subrayDutyCycle From 0 to 1. This is the fraction of time a subray is active. Default: 0.6\r\n *\r\n *\r\n * These parameters cannot change after lightning creation:\r\n *\r\n * @param {integer} maxIterations: Greater than 0. The number of ray's leaf segments is 2**maxIterations. Default: 9\r\n *\r\n * @param {boolean} isStatic Set to true only for rays which won't change over time and are not attached to moving objects (Rare case). It is used to set the vertex buffers non-dynamic. You can omit calling update() for these rays.\r\n *\r\n * @param {integer} ramification Greater than 0. Maximum number of child subrays a subray can have. Default: 5\r\n *\r\n * @param {integer} maxSubrayRecursion Greater than 0. Maximum level of recursion (subray descendant generations). Default: 3\r\n *\r\n * @param {double} recursionProbability From 0 to 1. The lower the value, the less chance each new generation of subrays has to generate new subrays. Default: 0.6\r\n *\r\n * @param {boolean} generateUVs If true, the ray geometry will have uv coordinates generated. u runs along the ray, and v across its perimeter. Default: false.\r\n *\r\n * @param {Object} randomGenerator Set here your random number generator which will seed the SimplexNoise and other decisions during ray tree creation.\r\n * It can be used to generate repeatable rays. For that, set also the noiseSeed parameter, and each ray created with that generator and seed pair will be identical in time.\r\n * The randomGenerator parameter should be an object with a random() function similar to Math.random, but seedable.\r\n * It must have also a getSeed() method, which returns the current seed, and a setSeed( seed ) method, which accepts as seed a fractional number from 0 to 1, as well as any other number.\r\n * The default value is an internal generator for some uses and Math.random for others (It is non-repeatable even if noiseSeed is supplied)\r\n *\r\n * @param {double} noiseSeed Seed used to make repeatable rays (see the randomGenerator)\r\n *\r\n * @param {function} onDecideSubrayCreation Set this to change the callback which decides subray creation. You can look at the default callback in the code (createDefaultSubrayCreationCallbacks)for more info.\r\n *\r\n * @param {function} onSubrayCreation This is another callback, more simple than the previous one. It can be used to adapt the form of subrays or other parameters once a subray has been created and initialized. It is used in the examples to adapt subrays to a sphere or to a plane.\r\n *\r\n *\r\n */\r\n\r\nclass LightningStrike extends BufferGeometry {\r\n  constructor(rayParameters) {\r\n    super();\r\n    this.type = 'LightningStrike'; // Set parameters, and set undefined parameters to default values\r\n\r\n    rayParameters = rayParameters || {};\r\n    this.init(LightningStrike.copyParameters(rayParameters, rayParameters)); // Creates and populates the mesh\r\n\r\n    this.createMesh();\r\n  }\r\n\r\n  update(time) {\r\n    if (this.isStatic) return;\r\n\r\n    if (this.rayParameters.isEternal || this.rayParameters.birthTime <= time && time <= this.rayParameters.deathTime) {\r\n      this.updateMesh(time);\r\n\r\n      if (time < this.subrays[0].endPropagationTime) {\r\n        this.state = LightningStrike.RAY_PROPAGATING;\r\n      } else if (time > this.subrays[0].beginVanishingTime) {\r\n        this.state = LightningStrike.RAY_VANISHING;\r\n      } else {\r\n        this.state = LightningStrike.RAY_STEADY;\r\n      }\r\n\r\n      this.visible = true;\r\n    } else {\r\n      this.visible = false;\r\n\r\n      if (time < this.rayParameters.birthTime) {\r\n        this.state = LightningStrike.RAY_UNBORN;\r\n      } else {\r\n        this.state = LightningStrike.RAY_EXTINGUISHED;\r\n      }\r\n    }\r\n  }\r\n\r\n  init(rayParameters) {\r\n    // Init all the state from the parameters\r\n    this.rayParameters = rayParameters; // These parameters cannot change after lightning creation:\r\n\r\n    this.maxIterations = rayParameters.maxIterations !== undefined ? Math.floor(rayParameters.maxIterations) : 9;\r\n    rayParameters.maxIterations = this.maxIterations;\r\n    this.isStatic = rayParameters.isStatic !== undefined ? rayParameters.isStatic : false;\r\n    rayParameters.isStatic = this.isStatic;\r\n    this.ramification = rayParameters.ramification !== undefined ? Math.floor(rayParameters.ramification) : 5;\r\n    rayParameters.ramification = this.ramification;\r\n    this.maxSubrayRecursion = rayParameters.maxSubrayRecursion !== undefined ? Math.floor(rayParameters.maxSubrayRecursion) : 3;\r\n    rayParameters.maxSubrayRecursion = this.maxSubrayRecursion;\r\n    this.recursionProbability = rayParameters.recursionProbability !== undefined ? rayParameters.recursionProbability : 0.6;\r\n    rayParameters.recursionProbability = this.recursionProbability;\r\n    this.generateUVs = rayParameters.generateUVs !== undefined ? rayParameters.generateUVs : false;\r\n    rayParameters.generateUVs = this.generateUVs; // Random generator\r\n\r\n    if (rayParameters.randomGenerator !== undefined) {\r\n      this.randomGenerator = rayParameters.randomGenerator;\r\n      this.seedGenerator = rayParameters.randomGenerator;\r\n\r\n      if (rayParameters.noiseSeed !== undefined) {\r\n        this.seedGenerator.setSeed(rayParameters.noiseSeed);\r\n      }\r\n    } else {\r\n      this.randomGenerator = LightningStrike.createRandomGenerator();\r\n      this.seedGenerator = Math;\r\n    } // Ray creation callbacks\r\n\r\n\r\n    if (rayParameters.onDecideSubrayCreation !== undefined) {\r\n      this.onDecideSubrayCreation = rayParameters.onDecideSubrayCreation;\r\n    } else {\r\n      this.createDefaultSubrayCreationCallbacks();\r\n\r\n      if (rayParameters.onSubrayCreation !== undefined) {\r\n        this.onSubrayCreation = rayParameters.onSubrayCreation;\r\n      }\r\n    } // Internal state\r\n\r\n\r\n    this.state = LightningStrike.RAY_INITIALIZED;\r\n    this.maxSubrays = Math.ceil(1 + Math.pow(this.ramification, Math.max(0, this.maxSubrayRecursion - 1)));\r\n    rayParameters.maxSubrays = this.maxSubrays;\r\n    this.maxRaySegments = 2 * (1 << this.maxIterations);\r\n    this.subrays = [];\r\n\r\n    for (let i = 0; i < this.maxSubrays; i++) {\r\n      this.subrays.push(this.createSubray());\r\n    }\r\n\r\n    this.raySegments = [];\r\n\r\n    for (let i = 0; i < this.maxRaySegments; i++) {\r\n      this.raySegments.push(this.createSegment());\r\n    }\r\n\r\n    this.time = 0;\r\n    this.timeFraction = 0;\r\n    this.currentSegmentCallback = null;\r\n    this.currentCreateTriangleVertices = this.generateUVs ? this.createTriangleVerticesWithUVs : this.createTriangleVerticesWithoutUVs;\r\n    this.numSubrays = 0;\r\n    this.currentSubray = null;\r\n    this.currentSegmentIndex = 0;\r\n    this.isInitialSegment = false;\r\n    this.subrayProbability = 0;\r\n    this.currentVertex = 0;\r\n    this.currentIndex = 0;\r\n    this.currentCoordinate = 0;\r\n    this.currentUVCoordinate = 0;\r\n    this.vertices = null;\r\n    this.uvs = null;\r\n    this.indices = null;\r\n    this.positionAttribute = null;\r\n    this.uvsAttribute = null;\r\n    this.simplexX = new SimplexNoise(this.seedGenerator);\r\n    this.simplexY = new SimplexNoise(this.seedGenerator);\r\n    this.simplexZ = new SimplexNoise(this.seedGenerator); // Temp vectors\r\n\r\n    this.forwards = new Vector3();\r\n    this.forwardsFill = new Vector3();\r\n    this.side = new Vector3();\r\n    this.down = new Vector3();\r\n    this.middlePos = new Vector3();\r\n    this.middleLinPos = new Vector3();\r\n    this.newPos = new Vector3();\r\n    this.vPos = new Vector3();\r\n    this.cross1 = new Vector3();\r\n  }\r\n\r\n  createMesh() {\r\n    const maxDrawableSegmentsPerSubRay = 1 << this.maxIterations;\r\n    const maxVerts = 3 * (maxDrawableSegmentsPerSubRay + 1) * this.maxSubrays;\r\n    const maxIndices = 18 * maxDrawableSegmentsPerSubRay * this.maxSubrays;\r\n    this.vertices = new Float32Array(maxVerts * 3);\r\n    this.indices = new Uint32Array(maxIndices);\r\n\r\n    if (this.generateUVs) {\r\n      this.uvs = new Float32Array(maxVerts * 2);\r\n    } // Populate the mesh\r\n\r\n\r\n    this.fillMesh(0);\r\n    this.setIndex(new Uint32BufferAttribute(this.indices, 1));\r\n    this.positionAttribute = new Float32BufferAttribute(this.vertices, 3);\r\n    this.setAttribute('position', this.positionAttribute);\r\n\r\n    if (this.generateUVs) {\r\n      this.uvsAttribute = new Float32BufferAttribute(new Float32Array(this.uvs), 2);\r\n      this.setAttribute('uv', this.uvsAttribute);\r\n    }\r\n\r\n    if (!this.isStatic) {\r\n      this.index.usage = DynamicDrawUsage;\r\n      this.positionAttribute.usage = DynamicDrawUsage;\r\n\r\n      if (this.generateUVs) {\r\n        this.uvsAttribute.usage = DynamicDrawUsage;\r\n      }\r\n    } // Store buffers for later modification\r\n\r\n\r\n    this.vertices = this.positionAttribute.array;\r\n    this.indices = this.index.array;\r\n\r\n    if (this.generateUVs) {\r\n      this.uvs = this.uvsAttribute.array;\r\n    }\r\n  }\r\n\r\n  updateMesh(time) {\r\n    this.fillMesh(time);\r\n    this.drawRange.count = this.currentIndex;\r\n    this.index.needsUpdate = true;\r\n    this.positionAttribute.needsUpdate = true;\r\n\r\n    if (this.generateUVs) {\r\n      this.uvsAttribute.needsUpdate = true;\r\n    }\r\n  }\r\n\r\n  fillMesh(time) {\r\n    const scope = this;\r\n    this.currentVertex = 0;\r\n    this.currentIndex = 0;\r\n    this.currentCoordinate = 0;\r\n    this.currentUVCoordinate = 0;\r\n    this.fractalRay(time, function fillVertices(segment) {\r\n      const subray = scope.currentSubray;\r\n\r\n      if (time < subray.birthTime) {\r\n        //&& ( ! this.rayParameters.isEternal || scope.currentSubray.recursion > 0 ) ) {\r\n        return;\r\n      } else if (this.rayParameters.isEternal && scope.currentSubray.recursion == 0) {\r\n        // Eternal rays don't propagate nor vanish, but its subrays do\r\n        scope.createPrism(segment);\r\n        scope.onDecideSubrayCreation(segment, scope);\r\n      } else if (time < subray.endPropagationTime) {\r\n        if (scope.timeFraction >= segment.fraction0 * subray.propagationTimeFactor) {\r\n          // Ray propagation has arrived to this segment\r\n          scope.createPrism(segment);\r\n          scope.onDecideSubrayCreation(segment, scope);\r\n        }\r\n      } else if (time < subray.beginVanishingTime) {\r\n        // Ray is steady (nor propagating nor vanishing)\r\n        scope.createPrism(segment);\r\n        scope.onDecideSubrayCreation(segment, scope);\r\n      } else {\r\n        if (scope.timeFraction <= subray.vanishingTimeFactor + segment.fraction1 * (1 - subray.vanishingTimeFactor)) {\r\n          // Segment has not yet vanished\r\n          scope.createPrism(segment);\r\n        }\r\n\r\n        scope.onDecideSubrayCreation(segment, scope);\r\n      }\r\n    });\r\n  }\r\n\r\n  addNewSubray()\r\n  /*rayParameters*/\r\n  {\r\n    return this.subrays[this.numSubrays++];\r\n  }\r\n\r\n  initSubray(subray, rayParameters) {\r\n    subray.pos0.copy(rayParameters.sourceOffset);\r\n    subray.pos1.copy(rayParameters.destOffset);\r\n    subray.up0.copy(rayParameters.up0);\r\n    subray.up1.copy(rayParameters.up1);\r\n    subray.radius0 = rayParameters.radius0;\r\n    subray.radius1 = rayParameters.radius1;\r\n    subray.birthTime = rayParameters.birthTime;\r\n    subray.deathTime = rayParameters.deathTime;\r\n    subray.timeScale = rayParameters.timeScale;\r\n    subray.roughness = rayParameters.roughness;\r\n    subray.straightness = rayParameters.straightness;\r\n    subray.propagationTimeFactor = rayParameters.propagationTimeFactor;\r\n    subray.vanishingTimeFactor = rayParameters.vanishingTimeFactor;\r\n    subray.maxIterations = this.maxIterations;\r\n    subray.seed = rayParameters.noiseSeed !== undefined ? rayParameters.noiseSeed : 0;\r\n    subray.recursion = 0;\r\n  }\r\n\r\n  fractalRay(time, segmentCallback) {\r\n    this.time = time;\r\n    this.currentSegmentCallback = segmentCallback;\r\n    this.numSubrays = 0; // Add the top level subray\r\n\r\n    this.initSubray(this.addNewSubray(), this.rayParameters); // Process all subrays that are being generated until consuming all of them\r\n\r\n    for (let subrayIndex = 0; subrayIndex < this.numSubrays; subrayIndex++) {\r\n      const subray = this.subrays[subrayIndex];\r\n      this.currentSubray = subray;\r\n      this.randomGenerator.setSeed(subray.seed);\r\n      subray.endPropagationTime = MathUtils.lerp(subray.birthTime, subray.deathTime, subray.propagationTimeFactor);\r\n      subray.beginVanishingTime = MathUtils.lerp(subray.deathTime, subray.birthTime, 1 - subray.vanishingTimeFactor);\r\n      const random1 = this.randomGenerator.random;\r\n      subray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n      subray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n      this.timeFraction = (time - subray.birthTime) / (subray.deathTime - subray.birthTime);\r\n      this.currentSegmentIndex = 0;\r\n      this.isInitialSegment = true;\r\n      const segment = this.getNewSegment();\r\n      segment.iteration = 0;\r\n      segment.pos0.copy(subray.pos0);\r\n      segment.pos1.copy(subray.pos1);\r\n      segment.linPos0.copy(subray.linPos0);\r\n      segment.linPos1.copy(subray.linPos1);\r\n      segment.up0.copy(subray.up0);\r\n      segment.up1.copy(subray.up1);\r\n      segment.radius0 = subray.radius0;\r\n      segment.radius1 = subray.radius1;\r\n      segment.fraction0 = 0;\r\n      segment.fraction1 = 1;\r\n      segment.positionVariationFactor = 1 - subray.straightness;\r\n      this.subrayProbability = this.ramification * Math.pow(this.recursionProbability, subray.recursion) / (1 << subray.maxIterations);\r\n      this.fractalRayRecursive(segment);\r\n    }\r\n\r\n    this.currentSegmentCallback = null;\r\n    this.currentSubray = null;\r\n  }\r\n\r\n  fractalRayRecursive(segment) {\r\n    // Leave recursion condition\r\n    if (segment.iteration >= this.currentSubray.maxIterations) {\r\n      this.currentSegmentCallback(segment);\r\n      return;\r\n    } // Interpolation\r\n\r\n\r\n    this.forwards.subVectors(segment.pos1, segment.pos0);\r\n    let lForwards = this.forwards.length();\r\n\r\n    if (lForwards < 0.000001) {\r\n      this.forwards.set(0, 0, 0.01);\r\n      lForwards = this.forwards.length();\r\n    }\r\n\r\n    const middleRadius = (segment.radius0 + segment.radius1) * 0.5;\r\n    const middleFraction = (segment.fraction0 + segment.fraction1) * 0.5;\r\n    const timeDimension = this.time * this.currentSubray.timeScale * Math.pow(2, segment.iteration);\r\n    this.middlePos.lerpVectors(segment.pos0, segment.pos1, 0.5);\r\n    this.middleLinPos.lerpVectors(segment.linPos0, segment.linPos1, 0.5);\r\n    const p = this.middleLinPos; // Noise\r\n\r\n    this.newPos.set(this.simplexX.noise4d(p.x, p.y, p.z, timeDimension), this.simplexY.noise4d(p.x, p.y, p.z, timeDimension), this.simplexZ.noise4d(p.x, p.y, p.z, timeDimension));\r\n    this.newPos.multiplyScalar(segment.positionVariationFactor * lForwards);\r\n    this.newPos.add(this.middlePos); // Recursion\r\n\r\n    const newSegment1 = this.getNewSegment();\r\n    newSegment1.pos0.copy(segment.pos0);\r\n    newSegment1.pos1.copy(this.newPos);\r\n    newSegment1.linPos0.copy(segment.linPos0);\r\n    newSegment1.linPos1.copy(this.middleLinPos);\r\n    newSegment1.up0.copy(segment.up0);\r\n    newSegment1.up1.copy(segment.up1);\r\n    newSegment1.radius0 = segment.radius0;\r\n    newSegment1.radius1 = middleRadius;\r\n    newSegment1.fraction0 = segment.fraction0;\r\n    newSegment1.fraction1 = middleFraction;\r\n    newSegment1.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\r\n    newSegment1.iteration = segment.iteration + 1;\r\n    const newSegment2 = this.getNewSegment();\r\n    newSegment2.pos0.copy(this.newPos);\r\n    newSegment2.pos1.copy(segment.pos1);\r\n    newSegment2.linPos0.copy(this.middleLinPos);\r\n    newSegment2.linPos1.copy(segment.linPos1);\r\n    this.cross1.crossVectors(segment.up0, this.forwards.normalize());\r\n    newSegment2.up0.crossVectors(this.forwards, this.cross1).normalize();\r\n    newSegment2.up1.copy(segment.up1);\r\n    newSegment2.radius0 = middleRadius;\r\n    newSegment2.radius1 = segment.radius1;\r\n    newSegment2.fraction0 = middleFraction;\r\n    newSegment2.fraction1 = segment.fraction1;\r\n    newSegment2.positionVariationFactor = segment.positionVariationFactor * this.currentSubray.roughness;\r\n    newSegment2.iteration = segment.iteration + 1;\r\n    this.fractalRayRecursive(newSegment1);\r\n    this.fractalRayRecursive(newSegment2);\r\n  }\r\n\r\n  createPrism(segment) {\r\n    // Creates one triangular prism and its vertices at the segment\r\n    this.forwardsFill.subVectors(segment.pos1, segment.pos0).normalize();\r\n\r\n    if (this.isInitialSegment) {\r\n      this.currentCreateTriangleVertices(segment.pos0, segment.up0, this.forwardsFill, segment.radius0, 0);\r\n      this.isInitialSegment = false;\r\n    }\r\n\r\n    this.currentCreateTriangleVertices(segment.pos1, segment.up0, this.forwardsFill, segment.radius1, segment.fraction1);\r\n    this.createPrismFaces();\r\n  }\r\n\r\n  createTriangleVerticesWithoutUVs(pos, up, forwards, radius) {\r\n    // Create an equilateral triangle (only vertices)\r\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\r\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\r\n    const p = this.vPos;\r\n    const v = this.vertices;\r\n    p.copy(pos).sub(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    p.copy(pos).add(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    p.copy(up).multiplyScalar(radius).add(pos);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    this.currentVertex += 3;\r\n  }\r\n\r\n  createTriangleVerticesWithUVs(pos, up, forwards, radius, u) {\r\n    // Create an equilateral triangle (only vertices)\r\n    this.side.crossVectors(up, forwards).multiplyScalar(radius * LightningStrike.COS30DEG);\r\n    this.down.copy(up).multiplyScalar(-radius * LightningStrike.SIN30DEG);\r\n    const p = this.vPos;\r\n    const v = this.vertices;\r\n    const uv = this.uvs;\r\n    p.copy(pos).sub(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    uv[this.currentUVCoordinate++] = u;\r\n    uv[this.currentUVCoordinate++] = 0;\r\n    p.copy(pos).add(this.side).add(this.down);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    uv[this.currentUVCoordinate++] = u;\r\n    uv[this.currentUVCoordinate++] = 0.5;\r\n    p.copy(up).multiplyScalar(radius).add(pos);\r\n    v[this.currentCoordinate++] = p.x;\r\n    v[this.currentCoordinate++] = p.y;\r\n    v[this.currentCoordinate++] = p.z;\r\n    uv[this.currentUVCoordinate++] = u;\r\n    uv[this.currentUVCoordinate++] = 1;\r\n    this.currentVertex += 3;\r\n  }\r\n\r\n  createPrismFaces(vertex\r\n  /*, index*/\r\n  ) {\r\n    const indices = this.indices;\r\n    var vertex = this.currentVertex - 6;\r\n    indices[this.currentIndex++] = vertex + 1;\r\n    indices[this.currentIndex++] = vertex + 2;\r\n    indices[this.currentIndex++] = vertex + 5;\r\n    indices[this.currentIndex++] = vertex + 1;\r\n    indices[this.currentIndex++] = vertex + 5;\r\n    indices[this.currentIndex++] = vertex + 4;\r\n    indices[this.currentIndex++] = vertex + 0;\r\n    indices[this.currentIndex++] = vertex + 1;\r\n    indices[this.currentIndex++] = vertex + 4;\r\n    indices[this.currentIndex++] = vertex + 0;\r\n    indices[this.currentIndex++] = vertex + 4;\r\n    indices[this.currentIndex++] = vertex + 3;\r\n    indices[this.currentIndex++] = vertex + 2;\r\n    indices[this.currentIndex++] = vertex + 0;\r\n    indices[this.currentIndex++] = vertex + 3;\r\n    indices[this.currentIndex++] = vertex + 2;\r\n    indices[this.currentIndex++] = vertex + 3;\r\n    indices[this.currentIndex++] = vertex + 5;\r\n  }\r\n\r\n  createDefaultSubrayCreationCallbacks() {\r\n    const random1 = this.randomGenerator.random;\r\n\r\n    this.onDecideSubrayCreation = (segment, lightningStrike) => {\r\n      // Decide subrays creation at parent (sub)ray segment\r\n      const subray = lightningStrike.currentSubray;\r\n      const period = lightningStrike.rayParameters.subrayPeriod;\r\n      const dutyCycle = lightningStrike.rayParameters.subrayDutyCycle;\r\n      const phase0 = lightningStrike.rayParameters.isEternal && subray.recursion == 0 ? -random1() * period : MathUtils.lerp(subray.birthTime, subray.endPropagationTime, segment.fraction0) - random1() * period;\r\n      const phase = lightningStrike.time - phase0;\r\n      const currentCycle = Math.floor(phase / period);\r\n      const childSubraySeed = random1() * (currentCycle + 1);\r\n      const isActive = phase % period <= dutyCycle * period;\r\n      let probability = 0;\r\n\r\n      if (isActive) {\r\n        probability = lightningStrike.subrayProbability; // Distribution test: probability *= segment.fraction0 > 0.5 && segment.fraction0 < 0.9 ? 1 / 0.4 : 0;\r\n      }\r\n\r\n      if (subray.recursion < lightningStrike.maxSubrayRecursion && lightningStrike.numSubrays < lightningStrike.maxSubrays && random1() < probability) {\r\n        const childSubray = lightningStrike.addNewSubray();\r\n        const parentSeed = lightningStrike.randomGenerator.getSeed();\r\n        childSubray.seed = childSubraySeed;\r\n        lightningStrike.randomGenerator.setSeed(childSubraySeed);\r\n        childSubray.recursion = subray.recursion + 1;\r\n        childSubray.maxIterations = Math.max(1, subray.maxIterations - 1);\r\n        childSubray.linPos0.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n        childSubray.linPos1.set(random1(), random1(), random1()).multiplyScalar(1000);\r\n        childSubray.up0.copy(subray.up0);\r\n        childSubray.up1.copy(subray.up1);\r\n        childSubray.radius0 = segment.radius0 * lightningStrike.rayParameters.radius0Factor;\r\n        childSubray.radius1 = Math.min(lightningStrike.rayParameters.minRadius, segment.radius1 * lightningStrike.rayParameters.radius1Factor);\r\n        childSubray.birthTime = phase0 + currentCycle * period;\r\n        childSubray.deathTime = childSubray.birthTime + period * dutyCycle;\r\n\r\n        if (!lightningStrike.rayParameters.isEternal && subray.recursion == 0) {\r\n          childSubray.birthTime = Math.max(childSubray.birthTime, subray.birthTime);\r\n          childSubray.deathTime = Math.min(childSubray.deathTime, subray.deathTime);\r\n        }\r\n\r\n        childSubray.timeScale = subray.timeScale * 2;\r\n        childSubray.roughness = subray.roughness;\r\n        childSubray.straightness = subray.straightness;\r\n        childSubray.propagationTimeFactor = subray.propagationTimeFactor;\r\n        childSubray.vanishingTimeFactor = subray.vanishingTimeFactor;\r\n        lightningStrike.onSubrayCreation(segment, subray, childSubray, lightningStrike);\r\n        lightningStrike.randomGenerator.setSeed(parentSeed);\r\n      }\r\n    };\r\n\r\n    const vec1Pos = new Vector3();\r\n    const vec2Forward = new Vector3();\r\n    const vec3Side = new Vector3();\r\n    const vec4Up = new Vector3();\r\n\r\n    this.onSubrayCreation = (segment, parentSubray, childSubray, lightningStrike) => {\r\n      // Decide childSubray origin and destination positions (pos0 and pos1) and possibly other properties of childSubray\r\n      // Just use the default cone position generator\r\n      lightningStrike.subrayCylinderPosition(segment, parentSubray, childSubray, 0.5, 0.6, 0.2);\r\n    };\r\n\r\n    this.subrayConePosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\r\n      // Sets childSubray pos0 and pos1 in a cone\r\n      childSubray.pos0.copy(segment.pos0);\r\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\r\n      vec2Forward.copy(vec1Pos).normalize();\r\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * (random1() * heightFactor));\r\n      const length = vec1Pos.length();\r\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\r\n      const angle = 2 * Math.PI * random1();\r\n      vec3Side.multiplyScalar(Math.cos(angle));\r\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\r\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\r\n    };\r\n\r\n    this.subrayCylinderPosition = (segment, parentSubray, childSubray, heightFactor, sideWidthFactor, minSideWidthFactor) => {\r\n      // Sets childSubray pos0 and pos1 in a cylinder\r\n      childSubray.pos0.copy(segment.pos0);\r\n      vec1Pos.subVectors(parentSubray.pos1, parentSubray.pos0);\r\n      vec2Forward.copy(vec1Pos).normalize();\r\n      vec1Pos.multiplyScalar(segment.fraction0 + (1 - segment.fraction0) * ((2 * random1() - 1) * heightFactor));\r\n      const length = vec1Pos.length();\r\n      vec3Side.crossVectors(parentSubray.up0, vec2Forward);\r\n      const angle = 2 * Math.PI * random1();\r\n      vec3Side.multiplyScalar(Math.cos(angle));\r\n      vec4Up.copy(parentSubray.up0).multiplyScalar(Math.sin(angle));\r\n      childSubray.pos1.copy(vec3Side).add(vec4Up).multiplyScalar(length * sideWidthFactor * (minSideWidthFactor + random1() * (1 - minSideWidthFactor))).add(vec1Pos).add(parentSubray.pos0);\r\n    };\r\n  }\r\n\r\n  createSubray() {\r\n    return {\r\n      seed: 0,\r\n      maxIterations: 0,\r\n      recursion: 0,\r\n      pos0: new Vector3(),\r\n      pos1: new Vector3(),\r\n      linPos0: new Vector3(),\r\n      linPos1: new Vector3(),\r\n      up0: new Vector3(),\r\n      up1: new Vector3(),\r\n      radius0: 0,\r\n      radius1: 0,\r\n      birthTime: 0,\r\n      deathTime: 0,\r\n      timeScale: 0,\r\n      roughness: 0,\r\n      straightness: 0,\r\n      propagationTimeFactor: 0,\r\n      vanishingTimeFactor: 0,\r\n      endPropagationTime: 0,\r\n      beginVanishingTime: 0\r\n    };\r\n  }\r\n\r\n  createSegment() {\r\n    return {\r\n      iteration: 0,\r\n      pos0: new Vector3(),\r\n      pos1: new Vector3(),\r\n      linPos0: new Vector3(),\r\n      linPos1: new Vector3(),\r\n      up0: new Vector3(),\r\n      up1: new Vector3(),\r\n      radius0: 0,\r\n      radius1: 0,\r\n      fraction0: 0,\r\n      fraction1: 0,\r\n      positionVariationFactor: 0\r\n    };\r\n  }\r\n\r\n  getNewSegment() {\r\n    return this.raySegments[this.currentSegmentIndex++];\r\n  }\r\n\r\n  copy(source) {\r\n    super.copy(source);\r\n    this.init(LightningStrike.copyParameters({}, source.rayParameters));\r\n    return this;\r\n  }\r\n\r\n  clone() {\r\n    return new this.constructor(LightningStrike.copyParameters({}, this.rayParameters));\r\n  }\r\n\r\n}\r\n\r\nLightningStrike.prototype.isLightningStrike = true; // Ray states\r\n\r\nLightningStrike.RAY_INITIALIZED = 0;\r\nLightningStrike.RAY_UNBORN = 1;\r\nLightningStrike.RAY_PROPAGATING = 2;\r\nLightningStrike.RAY_STEADY = 3;\r\nLightningStrike.RAY_VANISHING = 4;\r\nLightningStrike.RAY_EXTINGUISHED = 5;\r\nLightningStrike.COS30DEG = Math.cos(30 * Math.PI / 180);\r\nLightningStrike.SIN30DEG = Math.sin(30 * Math.PI / 180);\r\n\r\nLightningStrike.createRandomGenerator = () => {\r\n  const numSeeds = 2053;\r\n  const seeds = [];\r\n\r\n  for (let i = 0; i < numSeeds; i++) {\r\n    seeds.push(Math.random());\r\n  }\r\n\r\n  const generator = {\r\n    currentSeed: 0,\r\n    random: function () {\r\n      const value = seeds[generator.currentSeed];\r\n      generator.currentSeed = (generator.currentSeed + 1) % numSeeds;\r\n      return value;\r\n    },\r\n    getSeed: function () {\r\n      return generator.currentSeed / numSeeds;\r\n    },\r\n    setSeed: function (seed) {\r\n      generator.currentSeed = Math.floor(seed * numSeeds) % numSeeds;\r\n    }\r\n  };\r\n  return generator;\r\n};\r\n\r\nLightningStrike.copyParameters = (dest, source) => {\r\n  source = source || {};\r\n  dest = dest || {};\r\n\r\n  const vecCopy = v => {\r\n    if (source === dest) {\r\n      return v;\r\n    } else {\r\n      return v.clone();\r\n    }\r\n  };\r\n\r\n  dest.sourceOffset = source.sourceOffset !== undefined ? vecCopy(source.sourceOffset) : new Vector3(0, 100, 0), dest.destOffset = source.destOffset !== undefined ? vecCopy(source.destOffset) : new Vector3(0, 0, 0), dest.timeScale = source.timeScale !== undefined ? source.timeScale : 1, dest.roughness = source.roughness !== undefined ? source.roughness : 0.9, dest.straightness = source.straightness !== undefined ? source.straightness : 0.7, dest.up0 = source.up0 !== undefined ? vecCopy(source.up0) : new Vector3(0, 0, 1);\r\n  dest.up1 = source.up1 !== undefined ? vecCopy(source.up1) : new Vector3(0, 0, 1), dest.radius0 = source.radius0 !== undefined ? source.radius0 : 1, dest.radius1 = source.radius1 !== undefined ? source.radius1 : 1, dest.radius0Factor = source.radius0Factor !== undefined ? source.radius0Factor : 0.5, dest.radius1Factor = source.radius1Factor !== undefined ? source.radius1Factor : 0.2, dest.minRadius = source.minRadius !== undefined ? source.minRadius : 0.2, // These parameters should not be changed after lightning creation. They can be changed but the ray will change its form abruptly:\r\n  dest.isEternal = source.isEternal !== undefined ? source.isEternal : source.birthTime === undefined || source.deathTime === undefined, dest.birthTime = source.birthTime, dest.deathTime = source.deathTime, dest.propagationTimeFactor = source.propagationTimeFactor !== undefined ? source.propagationTimeFactor : 0.1, dest.vanishingTimeFactor = source.vanishingTimeFactor !== undefined ? source.vanishingTimeFactor : 0.9, dest.subrayPeriod = source.subrayPeriod !== undefined ? source.subrayPeriod : 4, dest.subrayDutyCycle = source.subrayDutyCycle !== undefined ? source.subrayDutyCycle : 0.6; // These parameters cannot change after lightning creation:\r\n\r\n  dest.maxIterations = source.maxIterations !== undefined ? source.maxIterations : 9;\r\n  dest.isStatic = source.isStatic !== undefined ? source.isStatic : false;\r\n  dest.ramification = source.ramification !== undefined ? source.ramification : 5;\r\n  dest.maxSubrayRecursion = source.maxSubrayRecursion !== undefined ? source.maxSubrayRecursion : 3;\r\n  dest.recursionProbability = source.recursionProbability !== undefined ? source.recursionProbability : 0.6;\r\n  dest.generateUVs = source.generateUVs !== undefined ? source.generateUVs : false;\r\n  dest.randomGenerator = source.randomGenerator, dest.noiseSeed = source.noiseSeed, dest.onDecideSubrayCreation = source.onDecideSubrayCreation, dest.onSubrayCreation = source.onSubrayCreation;\r\n  return dest;\r\n};\r\n\r\nexport { LightningStrike };\r\n"],"mappings":";;;;;;AAAA,SAASA,cAAT,EAAyBC,OAAzB,EAAkCC,qBAAlC,EAAyDC,sBAAzD,EAAiFC,gBAAjF,EAAmGC,SAAnG,QAAoH,OAApH;AACA,SAASC,YAAT,QAA6B,yBAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEMC,e;;;;;EACJ,yBAAYC,aAAZ,EAA2B;IAAA;;IAAA;;IACzB;IACA,MAAKC,IAAL,GAAY,iBAAZ,CAFyB,CAEM;;IAE/BD,aAAa,GAAGA,aAAa,IAAI,EAAjC;;IACA,MAAKE,IAAL,CAAUH,eAAe,CAACI,cAAhB,CAA+BH,aAA/B,EAA8CA,aAA9C,CAAV,EALyB,CAKgD;;;IAEzE,MAAKI,UAAL;;IAPyB;EAQ1B;;;;WAED,gBAAOC,IAAP,EAAa;MACX,IAAI,KAAKC,QAAT,EAAmB;;MAEnB,IAAI,KAAKN,aAAL,CAAmBO,SAAnB,IAAgC,KAAKP,aAAL,CAAmBQ,SAAnB,IAAgCH,IAAhC,IAAwCA,IAAI,IAAI,KAAKL,aAAL,CAAmBS,SAAvG,EAAkH;QAChH,KAAKC,UAAL,CAAgBL,IAAhB;;QAEA,IAAIA,IAAI,GAAG,KAAKM,OAAL,CAAa,CAAb,EAAgBC,kBAA3B,EAA+C;UAC7C,KAAKC,KAAL,GAAad,eAAe,CAACe,eAA7B;QACD,CAFD,MAEO,I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"},"metadata":{},"sourceType":"module"}