{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\n\nvar _m1 = new Matrix4();\n\nvar _obj = new Object3D();\n\nvar _offset = new Vector3();\n\nvar Geometry = /*#__PURE__*/function (_EventDispatcher) {\n  _inherits(Geometry, _EventDispatcher);\n\n  var _super = _createSuper(Geometry);\n\n  function Geometry() {\n    var _this;\n\n    _classCallCheck(this, Geometry);\n\n    _this = _super.call(this);\n    _this.isGeometry = true;\n    _this.uuid = MathUtils.generateUUID();\n    _this.name = '';\n    _this.type = 'Geometry';\n    _this.vertices = [];\n    _this.colors = [];\n    _this.faces = [];\n    _this.faceVertexUvs = [[]];\n    _this.morphTargets = [];\n    _this.morphNormals = [];\n    _this.skinWeights = [];\n    _this.skinIndices = [];\n    _this.lineDistances = [];\n    _this.boundingBox = null;\n    _this.boundingSphere = null; // update flags\n\n    _this.elementsNeedUpdate = false;\n    _this.verticesNeedUpdate = false;\n    _this.uvsNeedUpdate = false;\n    _this.normalsNeedUpdate = false;\n    _this.colorsNeedUpdate = false;\n    _this.lineDistancesNeedUpdate = false;\n    _this.groupsNeedUpdate = false;\n    return _this;\n  }\n\n  _createClass(Geometry, [{\n    key: \"applyMatrix4\",\n    value: function applyMatrix4(matrix) {\n      var normalMatrix = new Matrix3().getNormalMatrix(matrix);\n\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var vertex = this.vertices[i];\n        vertex.applyMatrix4(matrix);\n      }\n\n      for (var _i = 0, _il = this.faces.length; _i < _il; _i++) {\n        var face = this.faces[_i];\n        face.normal.applyMatrix3(normalMatrix).normalize();\n\n        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\n        }\n      }\n\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n\n      this.verticesNeedUpdate = true;\n      this.normalsNeedUpdate = true;\n      return this;\n    }\n  }, {\n    key: \"rotateX\",\n    value: function rotateX(angle) {\n      // rotate geometry around world x-axis\n      _m1.makeRotationX(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateY\",\n    value: function rotateY(angle) {\n      // rotate geometry around world y-axis\n      _m1.makeRotationY(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"rotateZ\",\n    value: function rotateZ(angle) {\n      // rotate geometry around world z-axis\n      _m1.makeRotationZ(angle);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(x, y, z) {\n      // translate geometry\n      _m1.makeTranslation(x, y, z);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(x, y, z) {\n      // scale geometry\n      _m1.makeScale(x, y, z);\n\n      this.applyMatrix4(_m1);\n      return this;\n    }\n  }, {\n    key: \"lookAt\",\n    value: function lookAt(vector) {\n      _obj.lookAt(vector);\n\n      _obj.updateMatrix();\n\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n  }, {\n    key: \"fromBufferGeometry\",\n    value: function fromBufferGeometry(geometry) {\n      var scope = this;\n      var index = geometry.index !== null ? geometry.index : undefined;\n      var attributes = geometry.attributes;\n\n      if (attributes.position === undefined) {\n        console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\n        return this;\n      }\n\n      var position = attributes.position;\n      var normal = attributes.normal;\n      var color = attributes.color;\n      var uv = attributes.uv;\n      var uv2 = attributes.uv2;\n      if (uv2 !== undefined) this.faceVertexUvs[1] = [];\n\n      for (var i = 0; i < position.count; i++) {\n        scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\n\n        if (color !== undefined) {\n          scope.colors.push(new Color().fromBufferAttribute(color, i));\n        }\n      }\n\n      function addFace(a, b, c, materialIndex) {\n        var vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\n        var vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\n        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\n        scope.faces.push(face);\n\n        if (uv !== undefined) {\n          scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\n        }\n\n        if (uv2 !== undefined) {\n          scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\n        }\n      }\n\n      var groups = geometry.groups;\n\n      if (groups.length > 0) {\n        for (var _i2 = 0; _i2 < groups.length; _i2++) {\n          var group = groups[_i2];\n          var start = group.start;\n          var count = group.count;\n\n          for (var j = start, jl = start + count; j < jl; j += 3) {\n            if (index !== undefined) {\n              addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\n            } else {\n              addFace(j, j + 1, j + 2, group.materialIndex);\n            }\n          }\n        }\n      } else {\n        if (index !== undefined) {\n          for (var _i3 = 0; _i3 < index.count; _i3 += 3) {\n            addFace(index.getX(_i3), index.getX(_i3 + 1), index.getX(_i3 + 2));\n          }\n        } else {\n          for (var _i4 = 0; _i4 < position.count; _i4 += 3) {\n            addFace(_i4, _i4 + 1, _i4 + 2);\n          }\n        }\n      }\n\n      this.computeFaceNormals();\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"center\",\n    value: function center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      this.computeBoundingSphere();\n      var center = this.boundingSphere.center;\n      var radius = this.boundingSphere.radius;\n      var s = radius === 0 ? 1 : 1.0 / radius;\n      var matrix = new Matrix4();\n      matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\n      this.applyMatrix4(matrix);\n      return this;\n    }\n  }, {\n    key: \"computeFaceNormals\",\n    value: function computeFaceNormals() {\n      var cb = new Vector3(),\n          ab = new Vector3();\n\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vA = this.vertices[face.a];\n        var vB = this.vertices[face.b];\n        var vC = this.vertices[face.c];\n        cb.subVectors(vC, vB);\n        ab.subVectors(vA, vB);\n        cb.cross(ab);\n        cb.normalize();\n        face.normal.copy(cb);\n      }\n    }\n  }, {\n    key: \"computeVertexNormals\",\n    value: function computeVertexNormals() {\n      var areaWeighted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var vertices = new Array(this.vertices.length);\n\n      for (var v = 0, vl = this.vertices.length; v < vl; v++) {\n        vertices[v] = new Vector3();\n      }\n\n      if (areaWeighted) {\n        // vertex normals weighted by triangle areas\n        // http://www.iquilezles.org/www/articles/normals/normals.htm\n        var cb = new Vector3(),\n            ab = new Vector3();\n\n        for (var f = 0, fl = this.faces.length; f < fl; f++) {\n          var face = this.faces[f];\n          var vA = this.vertices[face.a];\n          var vB = this.vertices[face.b];\n          var vC = this.vertices[face.c];\n          cb.subVectors(vC, vB);\n          ab.subVectors(vA, vB);\n          cb.cross(ab);\n          vertices[face.a].add(cb);\n          vertices[face.b].add(cb);\n          vertices[face.c].add(cb);\n        }\n      } else {\n        this.computeFaceNormals();\n\n        for (var _f = 0, _fl = this.faces.length; _f < _fl; _f++) {\n          var _face = this.faces[_f];\n\n          vertices[_face.a].add(_face.normal);\n\n          vertices[_face.b].add(_face.normal);\n\n          vertices[_face.c].add(_face.normal);\n        }\n      }\n\n      for (var _v = 0, _vl = this.vertices.length; _v < _vl; _v++) {\n        vertices[_v].normalize();\n      }\n\n      for (var _f2 = 0, _fl2 = this.faces.length; _f2 < _fl2; _f2++) {\n        var _face2 = this.faces[_f2];\n        var vertexNormals = _face2.vertexNormals;\n\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(vertices[_face2.a]);\n          vertexNormals[1].copy(vertices[_face2.b]);\n          vertexNormals[2].copy(vertices[_face2.c]);\n        } else {\n          vertexNormals[0] = vertices[_face2.a].clone();\n          vertexNormals[1] = vertices[_face2.b].clone();\n          vertexNormals[2] = vertices[_face2.c].clone();\n        }\n      }\n\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeFlatVertexNormals\",\n    value: function computeFlatVertexNormals() {\n      this.computeFaceNormals();\n\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n        var vertexNormals = face.vertexNormals;\n\n        if (vertexNormals.length === 3) {\n          vertexNormals[0].copy(face.normal);\n          vertexNormals[1].copy(face.normal);\n          vertexNormals[2].copy(face.normal);\n        } else {\n          vertexNormals[0] = face.normal.clone();\n          vertexNormals[1] = face.normal.clone();\n          vertexNormals[2] = face.normal.clone();\n        }\n      }\n\n      if (this.faces.length > 0) {\n        this.normalsNeedUpdate = true;\n      }\n    }\n  }, {\n    key: \"computeMorphNormals\",\n    value: function computeMorphNormals() {\n      // save original normals\n      // - create temp variables on first access\n      //   otherwise just copy (for faster repeated calls)\n      for (var f = 0, fl = this.faces.length; f < fl; f++) {\n        var face = this.faces[f];\n\n        if (!face.__originalFaceNormal) {\n          face.__originalFaceNormal = face.normal.clone();\n        } else {\n          face.__originalFaceNormal.copy(face.normal);\n        }\n\n        if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\n\n        for (var i = 0, il = face.vertexNormals.length; i < il; i++) {\n          if (!face.__originalVertexNormals[i]) {\n            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\n          } else {\n            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\n          }\n        }\n      } // use temp geometry to compute face and vertex normals for each morph\n\n\n      var tmpGeo = new Geometry();\n      tmpGeo.faces = this.faces;\n\n      for (var _i5 = 0, _il2 = this.morphTargets.length; _i5 < _il2; _i5++) {\n        // create on first access\n        if (!this.morphNormals[_i5]) {\n          this.morphNormals[_i5] = {};\n          this.morphNormals[_i5].faceNormals = [];\n          this.morphNormals[_i5].vertexNormals = [];\n          var dstNormalsFace = this.morphNormals[_i5].faceNormals;\n          var dstNormalsVertex = this.morphNormals[_i5].vertexNormals;\n\n          for (var _f3 = 0, _fl3 = this.faces.length; _f3 < _fl3; _f3++) {\n            var faceNormal = new Vector3();\n            var vertexNormals = {\n              a: new Vector3(),\n              b: new Vector3(),\n              c: new Vector3()\n            };\n            dstNormalsFace.push(faceNormal);\n            dstNormalsVertex.push(vertexNormals);\n          }\n        }\n\n        var morphNormals = this.morphNormals[_i5]; // set vertices to morph target\n\n        tmpGeo.vertices = this.morphTargets[_i5].vertices; // compute morph normals\n\n        tmpGeo.computeFaceNormals();\n        tmpGeo.computeVertexNormals(); // store morph normals\n\n        for (var _f4 = 0, _fl4 = this.faces.length; _f4 < _fl4; _f4++) {\n          var _face3 = this.faces[_f4];\n          var _faceNormal = morphNormals.faceNormals[_f4];\n          var _vertexNormals = morphNormals.vertexNormals[_f4];\n\n          _faceNormal.copy(_face3.normal);\n\n          _vertexNormals.a.copy(_face3.vertexNormals[0]);\n\n          _vertexNormals.b.copy(_face3.vertexNormals[1]);\n\n          _vertexNormals.c.copy(_face3.vertexNormals[2]);\n        }\n      } // restore original normals\n\n\n      for (var _f5 = 0, _fl5 = this.faces.length; _f5 < _fl5; _f5++) {\n        var _face4 = this.faces[_f5];\n        _face4.normal = _face4.__originalFaceNormal;\n        _face4.vertexNormals = _face4.__originalVertexNormals;\n      }\n    }\n  }, {\n    key: \"computeBoundingBox\",\n    value: function computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n\n      this.boundingBox.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"computeBoundingSphere\",\n    value: function computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n\n      this.boundingSphere.setFromPoints(this.vertices);\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(geometry, matrix) {\n      var materialIndexOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      if (!(geometry && geometry.isGeometry)) {\n        console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\n        return;\n      }\n\n      var normalMatrix;\n      var vertexOffset = this.vertices.length,\n          vertices1 = this.vertices,\n          vertices2 = geometry.vertices,\n          faces1 = this.faces,\n          faces2 = geometry.faces,\n          colors1 = this.colors,\n          colors2 = geometry.colors;\n\n      if (matrix !== undefined) {\n        normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      } // vertices\n\n\n      for (var i = 0, il = vertices2.length; i < il; i++) {\n        var vertex = vertices2[i];\n        var vertexCopy = vertex.clone();\n        if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\n        vertices1.push(vertexCopy);\n      } // colors\n\n\n      for (var _i6 = 0, _il3 = colors2.length; _i6 < _il3; _i6++) {\n        colors1.push(colors2[_i6].clone());\n      } // faces\n\n\n      for (var _i7 = 0, _il4 = faces2.length; _i7 < _il4; _i7++) {\n        var face = faces2[_i7];\n        var normal = void 0,\n            color = void 0;\n        var faceVertexNormals = face.vertexNormals,\n            faceVertexColors = face.vertexColors;\n        var faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\n        faceCopy.normal.copy(face.normal);\n\n        if (normalMatrix !== undefined) {\n          faceCopy.normal.applyMatrix3(normalMatrix).normalize();\n        }\n\n        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {\n          normal = faceVertexNormals[j].clone();\n\n          if (normalMatrix !== undefined) {\n            normal.applyMatrix3(normalMatrix).normalize();\n          }\n\n          faceCopy.vertexNormals.push(normal);\n        }\n\n        faceCopy.color.copy(face.color);\n\n        for (var _j = 0, _jl = faceVertexColors.length; _j < _jl; _j++) {\n          color = faceVertexColors[_j];\n          faceCopy.vertexColors.push(color.clone());\n        }\n\n        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n        faces1.push(faceCopy);\n      } // uvs\n\n\n      for (var _i8 = 0, _il5 = geometry.faceVertexUvs.length; _i8 < _il5; _i8++) {\n        var faceVertexUvs2 = geometry.faceVertexUvs[_i8];\n        if (this.faceVertexUvs[_i8] === undefined) this.faceVertexUvs[_i8] = [];\n\n        for (var _j2 = 0, _jl2 = faceVertexUvs2.length; _j2 < _jl2; _j2++) {\n          var uvs2 = faceVertexUvs2[_j2],\n              uvsCopy = [];\n\n          for (var k = 0, kl = uvs2.length; k < kl; k++) {\n            uvsCopy.push(uvs2[k].clone());\n          }\n\n          this.faceVertexUvs[_i8].push(uvsCopy);\n        }\n      }\n    }\n  }, {\n    key: \"mergeMesh\",\n    value: function mergeMesh(mesh) {\n      if (!(mesh && mesh.isMesh)) {\n        console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\n        return;\n      }\n\n      if (mesh.matrixAutoUpdate) mesh.updateMatrix();\n      this.merge(mesh.geometry, mesh.matrix);\n    }\n    /*\r\n     * Checks for duplicate vertices with hashmap.\r\n     * Duplicated vertices are removed\r\n     * and faces' vertices are updated.\r\n     */\n\n  }, {\n    key: \"mergeVertices\",\n    value: function mergeVertices() {\n      var precisionPoints = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4;\n      var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n\n      var unique = [],\n          changes = [];\n      var precision = Math.pow(10, precisionPoints);\n\n      for (var i = 0, il = this.vertices.length; i < il; i++) {\n        var v = this.vertices[i];\n        var key = \"\".concat(Math.round(v.x * precision), \"_\").concat(Math.round(v.y * precision), \"_\").concat(Math.round(v.z * precision));\n\n        if (verticesMap[key] === undefined) {\n          verticesMap[key] = i;\n          unique.push(this.vertices[i]);\n          changes[i] = unique.length - 1;\n        } else {\n          //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n          changes[i] = changes[verticesMap[key]];\n        }\n      } // if faces are completely degenerate after merging vertices, we\n      // have to remove them from the geometry.\n\n\n      var faceIndicesToRemove = [];\n\n      for (var _i9 = 0, _il6 = this.faces.length; _i9 < _il6; _i9++) {\n        var face = this.faces[_i9];\n        face.a = changes[face.a];\n        face.b = changes[face.b];\n        face.c = changes[face.c];\n        var indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\n        // we have to remove the face as nothing can be saved\n\n        for (var n = 0; n < 3; n++) {\n          if (indices[n] === indices[(n + 1) % 3]) {\n            faceIndicesToRemove.push(_i9);\n            break;\n          }\n        }\n      }\n\n      for (var _i10 = faceIndicesToRemove.length - 1; _i10 >= 0; _i10--) {\n        var idx = faceIndicesToRemove[_i10];\n        this.faces.splice(idx, 1);\n\n        for (var j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\n          this.faceVertexUvs[j].splice(idx, 1);\n        }\n      } // Use unique set of vertices\n\n\n      var diff = this.vertices.length - unique.length;\n      this.vertices = unique;\n      return diff;\n    }\n  }, {\n    key: \"setFromPoints\",\n    value: function setFromPoints(points) {\n      this.vertices = [];\n\n      for (var i = 0, l = points.length; i < l; i++) {\n        var point = points[i];\n        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sortFacesByMaterialIndex\",\n    value: function sortFacesByMaterialIndex() {\n      var faces = this.faces;\n      var length = faces.length; // tag faces\n\n      for (var i = 0; i < length; i++) {\n        faces[i]._id = i;\n      } // sort faces\n\n\n      function materialIndexSort(a, b) {\n        return a.materialIndex - b.materialIndex;\n      }\n\n      faces.sort(materialIndexSort); // sort uvs\n\n      var uvs1 = this.faceVertexUvs[0];\n      var uvs2 = this.faceVertexUvs[1];\n      var newUvs1, newUvs2;\n      if (uvs1 && uvs1.length === length) newUvs1 = [];\n      if (uvs2 && uvs2.length === length) newUvs2 = [];\n\n      for (var _i11 = 0; _i11 < length; _i11++) {\n        var id = faces[_i11]._id;\n        if (newUvs1) newUvs1.push(uvs1[id]);\n        if (newUvs2) newUvs2.push(uvs2[id]);\n      }\n\n      if (newUvs1) this.faceVertexUvs[0] = newUvs1;\n      if (newUvs2) this.faceVertexUvs[1] = newUvs2;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var data = {\n        metadata: {\n          version: 4.5,\n          type: 'Geometry',\n          generator: 'Geometry.toJSON'\n        }\n      }; // standard Geometry serialization\n\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== '') data.name = this.name;\n\n      if (this.parameters !== undefined) {\n        var parameters = this.parameters;\n\n        for (var key in parameters) {\n          if (parameters[key] !== undefined) data[key] = parameters[key];\n        }\n\n        return data;\n      }\n\n      var vertices = [];\n\n      for (var i = 0; i < this.vertices.length; i++) {\n        var vertex = this.vertices[i];\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n\n      var faces = [];\n      var normals = [];\n      var normalsHash = {};\n      var colors = [];\n      var colorsHash = {};\n      var uvs = [];\n      var uvsHash = {};\n\n      for (var _i12 = 0; _i12 < this.faces.length; _i12++) {\n        var face = this.faces[_i12];\n        var hasMaterial = true;\n        var hasFaceUv = false; // deprecated\n\n        var hasFaceVertexUv = this.faceVertexUvs[0][_i12] !== undefined;\n        var hasFaceNormal = face.normal.length() > 0;\n        var hasFaceVertexNormal = face.vertexNormals.length > 0;\n        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\n        var hasFaceVertexColor = face.vertexColors.length > 0;\n        var faceType = 0;\n        faceType = setBit(faceType, 0, 0); // isQuad\n\n        faceType = setBit(faceType, 1, hasMaterial);\n        faceType = setBit(faceType, 2, hasFaceUv);\n        faceType = setBit(faceType, 3, hasFaceVertexUv);\n        faceType = setBit(faceType, 4, hasFaceNormal);\n        faceType = setBit(faceType, 5, hasFaceVertexNormal);\n        faceType = setBit(faceType, 6, hasFaceColor);\n        faceType = setBit(faceType, 7, hasFaceVertexColor);\n        faces.push(faceType);\n        faces.push(face.a, face.b, face.c);\n        faces.push(face.materialIndex);\n\n        if (hasFaceVertexUv) {\n          var faceVertexUvs = this.faceVertexUvs[0][_i12];\n          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\n        }\n\n        if (hasFaceNormal) {\n          faces.push(getNormalIndex(face.normal));\n        }\n\n        if (hasFaceVertexNormal) {\n          var vertexNormals = face.vertexNormals;\n          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\n        }\n\n        if (hasFaceColor) {\n          faces.push(getColorIndex(face.color));\n        }\n\n        if (hasFaceVertexColor) {\n          var vertexColors = face.vertexColors;\n          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\n        }\n      }\n\n      function setBit(value, position, enabled) {\n        return enabled ? value | 1 << position : value & ~(1 << position);\n      }\n\n      function getNormalIndex(normal) {\n        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\n\n        if (normalsHash[hash] !== undefined) {\n          return normalsHash[hash];\n        }\n\n        normalsHash[hash] = normals.length / 3;\n        normals.push(normal.x, normal.y, normal.z);\n        return normalsHash[hash];\n      }\n\n      function getColorIndex(color) {\n        var hash = color.r.toString() + color.g.toString() + color.b.toString();\n\n        if (colorsHash[hash] !== undefined) {\n          return colorsHash[hash];\n        }\n\n        colorsHash[hash] = colors.length;\n        colors.push(color.getHex());\n        return colorsHash[hash];\n      }\n\n      function getUvIndex(uv) {\n        var hash = uv.x.toString() + uv.y.toString();\n\n        if (uvsHash[hash] !== undefined) {\n          return uvsHash[hash];\n        }\n\n        uvsHash[hash] = uvs.length / 2;\n        uvs.push(uv.x, uv.y);\n        return uvsHash[hash];\n      }\n\n      data.data = {};\n      data.data.vertices = vertices;\n      data.data.normals = normals;\n      if (colors.length > 0) data.data.colors = colors;\n      if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\n\n      data.data.faces = faces;\n      return data;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      /*\r\n      // Handle primitives\r\n      const parameters = this.parameters;\r\n      if ( parameters !== undefined ) {\r\n      const values = [];\r\n      for ( const key in parameters ) {\r\n      values.push( parameters[ key ] );\r\n      }\r\n      const geometry = Object.create( this.constructor.prototype );\r\n      this.constructor.apply( geometry, values );\r\n      return geometry;\r\n      }\r\n      return new this.constructor().copy( this );\r\n      */\n      return new Geometry().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      // reset\n      this.vertices = [];\n      this.colors = [];\n      this.faces = [];\n      this.faceVertexUvs = [[]];\n      this.morphTargets = [];\n      this.morphNormals = [];\n      this.skinWeights = [];\n      this.skinIndices = [];\n      this.lineDistances = [];\n      this.boundingBox = null;\n      this.boundingSphere = null; // name\n\n      this.name = source.name; // vertices\n\n      var vertices = source.vertices;\n\n      for (var i = 0, il = vertices.length; i < il; i++) {\n        this.vertices.push(vertices[i].clone());\n      } // colors\n\n\n      var colors = source.colors;\n\n      for (var _i13 = 0, _il7 = colors.length; _i13 < _il7; _i13++) {\n        this.colors.push(colors[_i13].clone());\n      } // faces\n\n\n      var faces = source.faces;\n\n      for (var _i14 = 0, _il8 = faces.length; _i14 < _il8; _i14++) {\n        this.faces.push(faces[_i14].clone());\n      } // face vertex uvs\n\n\n      for (var _i15 = 0, _il9 = source.faceVertexUvs.length; _i15 < _il9; _i15++) {\n        var faceVertexUvs = source.faceVertexUvs[_i15];\n\n        if (this.faceVertexUvs[_i15] === undefined) {\n          this.faceVertexUvs[_i15] = [];\n        }\n\n        for (var j = 0, jl = faceVertexUvs.length; j < jl; j++) {\n          var uvs = faceVertexUvs[j],\n              uvsCopy = [];\n\n          for (var k = 0, kl = uvs.length; k < kl; k++) {\n            var uv = uvs[k];\n            uvsCopy.push(uv.clone());\n          }\n\n          this.faceVertexUvs[_i15].push(uvsCopy);\n        }\n      } // morph targets\n\n\n      var morphTargets = source.morphTargets;\n\n      for (var _i16 = 0, _il10 = morphTargets.length; _i16 < _il10; _i16++) {\n        var morphTarget = {};\n        morphTarget.name = morphTargets[_i16].name; // vertices\n\n        if (morphTargets[_i16].vertices !== undefined) {\n          morphTarget.vertices = [];\n\n          for (var _j3 = 0, _jl3 = morphTargets[_i16].vertices.length; _j3 < _jl3; _j3++) {\n            morphTarget.vertices.push(morphTargets[_i16].vertices[_j3].clone());\n          }\n        } // normals\n\n\n        if (morphTargets[_i16].normals !== undefined) {\n          morphTarget.normals = [];\n\n          for (var _j4 = 0, _jl4 = morphTargets[_i16].normals.length; _j4 < _jl4; _j4++) {\n            morphTarget.normals.push(morphTargets[_i16].normals[_j4].clone());\n          }\n        }\n\n        this.morphTargets.push(morphTarget);\n      } // morph normals\n\n\n      var morphNormals = source.morphNormals;\n\n      for (var _i17 = 0, _il11 = morphNormals.length; _i17 < _il11; _i17++) {\n        var morphNormal = {}; // vertex normals\n\n        if (morphNormals[_i17].vertexNormals !== undefined) {\n          morphNormal.vertexNormals = [];\n\n          for (var _j5 = 0, _jl5 = morphNormals[_i17].vertexNormals.length; _j5 < _jl5; _j5++) {\n            var srcVertexNormal = morphNormals[_i17].vertexNormals[_j5];\n            var destVertexNormal = {};\n            destVertexNormal.a = srcVertexNormal.a.clone();\n            destVertexNormal.b = srcVertexNormal.b.clone();\n            destVertexNormal.c = srcVertexNormal.c.clone();\n            morphNormal.vertexNormals.push(destVertexNormal);\n          }\n        } // face normals\n\n\n        if (morphNormals[_i17].faceNormals !== undefined) {\n          morphNormal.faceNormals = [];\n\n          for (var _j6 = 0, _jl6 = morphNormals[_i17].faceNormals.length; _j6 < _jl6; _j6++) {\n            morphNormal.faceNormals.push(morphNormals[_i17].faceNormals[_j6].clone());\n          }\n        }\n\n        this.morphNormals.push(morphNormal);\n      } // skin weights\n\n\n      var skinWeights = source.skinWeights;\n\n      for (var _i18 = 0, _il12 = skinWeights.length; _i18 < _il12; _i18++) {\n        this.skinWeights.push(skinWeights[_i18].clone());\n      } // skin indices\n\n\n      var skinIndices = source.skinIndices;\n\n      for (var _i19 = 0, _il13 = skinIndices.length; _i19 < _il13; _i19++) {\n        this.skinIndices.push(skinIndices[_i19].clone());\n      } // line distances\n\n\n      var lineDistances = source.lineDistances;\n\n      for (var _i20 = 0, _il14 = lineDistances.length; _i20 < _il14; _i20++) {\n        this.lineDistances.push(lineDistances[_i20]);\n      } // bounding box\n\n\n      var boundingBox = source.boundingBox;\n\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      } // bounding sphere\n\n\n      var boundingSphere = source.boundingSphere;\n\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      } // update flags\n\n\n      this.elementsNeedUpdate = source.elementsNeedUpdate;\n      this.verticesNeedUpdate = source.verticesNeedUpdate;\n      this.uvsNeedUpdate = source.uvsNeedUpdate;\n      this.normalsNeedUpdate = source.normalsNeedUpdate;\n      this.colorsNeedUpdate = source.colorsNeedUpdate;\n      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\n      this.groupsNeedUpdate = source.groupsNeedUpdate;\n      return this;\n    }\n  }, {\n    key: \"toBufferGeometry\",\n    value: function toBufferGeometry() {\n      var geometry = new DirectGeometry().fromGeometry(this);\n      var buffergeometry = new BufferGeometry();\n      var positions = new Float32Array(geometry.vertices.length * 3);\n      buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\n\n      if (geometry.normals.length > 0) {\n        var normals = new Float32Array(geometry.normals.length * 3);\n        buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\n      }\n\n      if (geometry.colors.length > 0) {\n        var colors = new Float32Array(geometry.colors.length * 3);\n        buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\n      }\n\n      if (geometry.uvs.length > 0) {\n        var uvs = new Float32Array(geometry.uvs.length * 2);\n        buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\n      }\n\n      if (geometry.uvs2.length > 0) {\n        var uvs2 = new Float32Array(geometry.uvs2.length * 2);\n        buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\n      } // groups\n\n\n      buffergeometry.groups = geometry.groups; // morphs\n\n      for (var name in geometry.morphTargets) {\n        var array = [];\n        var morphTargets = geometry.morphTargets[name];\n\n        for (var i = 0, l = morphTargets.length; i < l; i++) {\n          var morphTarget = morphTargets[i];\n          var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\n          attribute.name = morphTarget.name;\n          array.push(attribute.copyVector3sArray(morphTarget.data));\n        }\n\n        buffergeometry.morphAttributes[name] = array;\n      } // skinning\n\n\n      if (geometry.skinIndices.length > 0) {\n        var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\n        buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\n      }\n\n      if (geometry.skinWeights.length > 0) {\n        var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\n        buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\n      } //\n\n\n      if (geometry.boundingSphere !== null) {\n        buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        buffergeometry.boundingBox = geometry.boundingBox.clone();\n      }\n\n      return buffergeometry;\n    }\n  }, {\n    key: \"computeTangents\",\n    value: function computeTangents() {\n      console.error('THREE.Geometry: .computeTangents() has been removed.');\n    }\n  }, {\n    key: \"computeLineDistances\",\n    value: function computeLineDistances() {\n      console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\n    }\n  }, {\n    key: \"applyMatrix\",\n    value: function applyMatrix(matrix) {\n      console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\n      return this.applyMatrix4(matrix);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.dispatchEvent({\n        type: 'dispose'\n      });\n    }\n  }]);\n\n  return Geometry;\n}(EventDispatcher);\n\nGeometry.createBufferGeometryFromObject = function (object) {\n  var buffergeometry = new BufferGeometry();\n  var geometry = object.geometry;\n\n  if (object.isPoints || object.isLine) {\n    var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\n    var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\n\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\n      var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\n    }\n\n    if (geometry.boundingSphere !== null) {\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\n    }\n\n    if (geometry.boundingBox !== null) {\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\n    }\n  } else if (object.isMesh) {\n    buffergeometry = geometry.toBufferGeometry();\n  }\n\n  return buffergeometry;\n};\n\nvar DirectGeometry = /*#__PURE__*/function () {\n  function DirectGeometry() {\n    _classCallCheck(this, DirectGeometry);\n\n    this.vertices = [];\n    this.normals = [];\n    this.colors = [];\n    this.uvs = [];\n    this.uvs2 = [];\n    this.groups = [];\n    this.morphTargets = {};\n    this.skinWeights = [];\n    this.skinIndices = []; // this.lineDistances = [];\n\n    this.boundingBox = null;\n    this.boundingSphere = null; // update flags\n\n    this.verticesNeedUpdate = false;\n    this.normalsNeedUpdate = false;\n    this.colorsNeedUpdate = false;\n    this.uvsNeedUpdate = false;\n    this.groupsNeedUpdate = false;\n  }\n\n  _createClass(DirectGeometry, [{\n    key: \"computeGroups\",\n    value: function computeGroups(geometry) {\n      var groups = [];\n      var group, i;\n      var materialIndex = undefined;\n      var faces = geometry.faces;\n\n      for (i = 0; i < faces.length; i++) {\n        var face = faces[i]; // materials\n\n        if (face.materialIndex !== materialIndex) {\n          materialIndex = face.materialIndex;\n\n          if (group !== undefined) {\n            group.count = i * 3 - group.start;\n            groups.push(group);\n          }\n\n          group = {\n            start: i * 3,\n            materialIndex: materialIndex\n          };\n        }\n      }\n\n      if (group !== undefined) {\n        group.count = i * 3 - group.start;\n        groups.push(group);\n      }\n\n      this.groups = groups;\n    }\n  }, {\n    key: \"fromGeometry\",\n    value: function fromGeometry(geometry) {\n      var faces = geometry.faces;\n      var vertices = geometry.vertices;\n      var faceVertexUvs = geometry.faceVertexUvs;\n      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\n      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\n\n      var morphTargets = geometry.morphTargets;\n      var morphTargetsLength = morphTargets.length;\n      var morphTargetsPosition;\n\n      if (morphTargetsLength > 0) {\n        morphTargetsPosition = [];\n\n        for (var i = 0; i < morphTargetsLength; i++) {\n          morphTargetsPosition[i] = {\n            name: morphTargets[i].name,\n            data: []\n          };\n        }\n\n        this.morphTargets.position = morphTargetsPosition;\n      }\n\n      var morphNormals = geometry.morphNormals;\n      var morphNormalsLength = morphNormals.length;\n      var morphTargetsNormal;\n\n      if (morphNormalsLength > 0) {\n        morphTargetsNormal = [];\n\n        for (var _i21 = 0; _i21 < morphNormalsLength; _i21++) {\n          morphTargetsNormal[_i21] = {\n            name: morphNormals[_i21].name,\n            data: []\n          };\n        }\n\n        this.morphTargets.normal = morphTargetsNormal;\n      } // skins\n\n\n      var skinIndices = geometry.skinIndices;\n      var skinWeights = geometry.skinWeights;\n      var hasSkinIndices = skinIndices.length === vertices.length;\n      var hasSkinWeights = skinWeights.length === vertices.length; //\n\n      if (vertices.length > 0 && faces.length === 0) {\n        console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\n      }\n\n      for (var _i22 = 0; _i22 < faces.length; _i22++) {\n        var face = faces[_i22];\n        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\n        var vertexNormals = face.vertexNormals;\n\n        if (vertexNormals.length === 3) {\n          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\n        } else {\n          var normal = face.normal;\n          this.normals.push(normal, normal, normal);\n        }\n\n        var vertexColors = face.vertexColors;\n\n        if (vertexColors.length === 3) {\n          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\n        } else {\n          var color = face.color;\n          this.colors.push(color, color, color);\n        }\n\n        if (hasFaceVertexUv === true) {\n          var vertexUvs = faceVertexUvs[0][_i22];\n\n          if (vertexUvs !== undefined) {\n            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\n          } else {\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', _i22);\n            this.uvs.push(new Vector2(), new Vector2(), new Vector2());\n          }\n        }\n\n        if (hasFaceVertexUv2 === true) {\n          var _vertexUvs = faceVertexUvs[1][_i22];\n\n          if (_vertexUvs !== undefined) {\n            this.uvs2.push(_vertexUvs[0], _vertexUvs[1], _vertexUvs[2]);\n          } else {\n            console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', _i22);\n            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\n          }\n        } // morphs\n\n\n        for (var j = 0; j < morphTargetsLength; j++) {\n          var morphTarget = morphTargets[j].vertices;\n          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\n        }\n\n        for (var _j7 = 0; _j7 < morphNormalsLength; _j7++) {\n          var morphNormal = morphNormals[_j7].vertexNormals[_i22];\n\n          morphTargetsNormal[_j7].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\n        } // skins\n\n\n        if (hasSkinIndices) {\n          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\n        }\n\n        if (hasSkinWeights) {\n          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\n        }\n      }\n\n      this.computeGroups(geometry);\n      this.verticesNeedUpdate = geometry.verticesNeedUpdate;\n      this.normalsNeedUpdate = geometry.normalsNeedUpdate;\n      this.colorsNeedUpdate = geometry.colorsNeedUpdate;\n      this.uvsNeedUpdate = geometry.uvsNeedUpdate;\n      this.groupsNeedUpdate = geometry.groupsNeedUpdate;\n\n      if (geometry.boundingSphere !== null) {\n        this.boundingSphere = geometry.boundingSphere.clone();\n      }\n\n      if (geometry.boundingBox !== null) {\n        this.boundingBox = geometry.boundingBox.clone();\n      }\n\n      return this;\n    }\n  }]);\n\n  return DirectGeometry;\n}();\n\nvar Face3 = /*#__PURE__*/function () {\n  function Face3(a, b, c, normal, color) {\n    var materialIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    _classCallCheck(this, Face3);\n\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\n    this.color = color && color.isColor ? color : new Color();\n    this.vertexColors = Array.isArray(color) ? color : [];\n    this.materialIndex = materialIndex;\n  }\n\n  _createClass(Face3, [{\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(source) {\n      this.a = source.a;\n      this.b = source.b;\n      this.c = source.c;\n      this.normal.copy(source.normal);\n      this.color.copy(source.color);\n      this.materialIndex = source.materialIndex;\n\n      for (var i = 0, il = source.vertexNormals.length; i < il; i++) {\n        this.vertexNormals[i] = source.vertexNormals[i].clone();\n      }\n\n      for (var _i23 = 0, _il15 = source.vertexColors.length; _i23 < _il15; _i23++) {\n        this.vertexColors[_i23] = source.vertexColors[_i23].clone();\n      }\n\n      return this;\n    }\n  }]);\n\n  return Face3;\n}();\n\nexport { Face3, Geometry };","map":{"version":3,"names":["Matrix4","Object3D","Vector3","EventDispatcher","MathUtils","Matrix3","Color","Box3","Sphere","BufferGeometry","BufferAttribute","Float32BufferAttribute","Vector2","_m1","_obj","_offset","Geometry","isGeometry","uuid","generateUUID","name","type","vertices","colors","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","boundingSphere","elementsNeedUpdate","verticesNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","matrix","normalMatrix","getNormalMatrix","i","il","length","vertex","applyMatrix4","face","normal","applyMatrix3","normalize","j","jl","vertexNormals","computeBoundingBox","computeBoundingSphere","angle","makeRotationX","makeRotationY","makeRotationZ","x","y","z","makeTranslation","makeScale","vector","lookAt","updateMatrix","geometry","scope","index","undefined","attributes","position","console","error","color","uv","uv2","count","push","fromBufferAttribute","addFace","a","b","c","materialIndex","vertexColors","clone","Face3","groups","group","start","getX","computeFaceNormals","getCenter","negate","translate","center","radius","s","set","cb","ab","f","fl","vA","vB","vC","subVectors","cross","copy","areaWeighted","Array","v","vl","add","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","dstNormalsFace","dstNormalsVertex","faceNormal","computeVertexNormals","setFromPoints","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","colors1","colors2","vertexCopy","faceVertexNormals","faceVertexColors","faceCopy","faceVertexUvs2","uvs2","uvsCopy","k","kl","mesh","isMesh","matrixAutoUpdate","merge","precisionPoints","verticesMap","unique","changes","precision","Math","pow","key","round","faceIndicesToRemove","indices","n","idx","splice","diff","points","l","point","_id","materialIndexSort","sort","uvs1","newUvs1","newUvs2","id","data","metadata","version","generator","parameters","normals","normalsHash","colorsHash","uvs","uvsHash","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","r","g","hasFaceVertexColor","faceType","setBit","getUvIndex","getNormalIndex","getColorIndex","value","enabled","hash","toString","getHex","source","morphTarget","morphNormal","srcVertexNormal","destVertexNormal","DirectGeometry","fromGeometry","buffergeometry","positions","Float32Array","setAttribute","copyVector3sArray","copyColorsArray","copyVector2sArray","array","attribute","morphAttributes","copyVector4sArray","warn","dispatchEvent","createBufferGeometryFromObject","object","isPoints","isLine","copyArray","toBufferGeometry","hasFaceVertexUv2","morphTargetsLength","morphTargetsPosition","morphNormalsLength","morphTargetsNormal","hasSkinIndices","hasSkinWeights","vertexUvs","computeGroups","isVector3","isArray","isColor","constructor"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/deprecated/Geometry.js"],"sourcesContent":["import { Matrix4, Object3D, Vector3, EventDispatcher, MathUtils, Matrix3, Color, Box3, Sphere, BufferGeometry, BufferAttribute, Float32BufferAttribute, Vector2 } from 'three';\r\n\r\nconst _m1 = new Matrix4();\r\n\r\nconst _obj = new Object3D();\r\n\r\nconst _offset = new Vector3();\r\n\r\nclass Geometry extends EventDispatcher {\r\n  constructor() {\r\n    super();\r\n    this.isGeometry = true;\r\n    this.uuid = MathUtils.generateUUID();\r\n    this.name = '';\r\n    this.type = 'Geometry';\r\n    this.vertices = [];\r\n    this.colors = [];\r\n    this.faces = [];\r\n    this.faceVertexUvs = [[]];\r\n    this.morphTargets = [];\r\n    this.morphNormals = [];\r\n    this.skinWeights = [];\r\n    this.skinIndices = [];\r\n    this.lineDistances = [];\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null; // update flags\r\n\r\n    this.elementsNeedUpdate = false;\r\n    this.verticesNeedUpdate = false;\r\n    this.uvsNeedUpdate = false;\r\n    this.normalsNeedUpdate = false;\r\n    this.colorsNeedUpdate = false;\r\n    this.lineDistancesNeedUpdate = false;\r\n    this.groupsNeedUpdate = false;\r\n  }\r\n\r\n  applyMatrix4(matrix) {\r\n    const normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n\r\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\r\n      const vertex = this.vertices[i];\r\n      vertex.applyMatrix4(matrix);\r\n    }\r\n\r\n    for (let i = 0, il = this.faces.length; i < il; i++) {\r\n      const face = this.faces[i];\r\n      face.normal.applyMatrix3(normalMatrix).normalize();\r\n\r\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\r\n        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();\r\n      }\r\n    }\r\n\r\n    if (this.boundingBox !== null) {\r\n      this.computeBoundingBox();\r\n    }\r\n\r\n    if (this.boundingSphere !== null) {\r\n      this.computeBoundingSphere();\r\n    }\r\n\r\n    this.verticesNeedUpdate = true;\r\n    this.normalsNeedUpdate = true;\r\n    return this;\r\n  }\r\n\r\n  rotateX(angle) {\r\n    // rotate geometry around world x-axis\r\n    _m1.makeRotationX(angle);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  rotateY(angle) {\r\n    // rotate geometry around world y-axis\r\n    _m1.makeRotationY(angle);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  rotateZ(angle) {\r\n    // rotate geometry around world z-axis\r\n    _m1.makeRotationZ(angle);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  translate(x, y, z) {\r\n    // translate geometry\r\n    _m1.makeTranslation(x, y, z);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  scale(x, y, z) {\r\n    // scale geometry\r\n    _m1.makeScale(x, y, z);\r\n\r\n    this.applyMatrix4(_m1);\r\n    return this;\r\n  }\r\n\r\n  lookAt(vector) {\r\n    _obj.lookAt(vector);\r\n\r\n    _obj.updateMatrix();\r\n\r\n    this.applyMatrix4(_obj.matrix);\r\n    return this;\r\n  }\r\n\r\n  fromBufferGeometry(geometry) {\r\n    const scope = this;\r\n    const index = geometry.index !== null ? geometry.index : undefined;\r\n    const attributes = geometry.attributes;\r\n\r\n    if (attributes.position === undefined) {\r\n      console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');\r\n      return this;\r\n    }\r\n\r\n    const position = attributes.position;\r\n    const normal = attributes.normal;\r\n    const color = attributes.color;\r\n    const uv = attributes.uv;\r\n    const uv2 = attributes.uv2;\r\n    if (uv2 !== undefined) this.faceVertexUvs[1] = [];\r\n\r\n    for (let i = 0; i < position.count; i++) {\r\n      scope.vertices.push(new Vector3().fromBufferAttribute(position, i));\r\n\r\n      if (color !== undefined) {\r\n        scope.colors.push(new Color().fromBufferAttribute(color, i));\r\n      }\r\n    }\r\n\r\n    function addFace(a, b, c, materialIndex) {\r\n      const vertexColors = color === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];\r\n      const vertexNormals = normal === undefined ? [] : [new Vector3().fromBufferAttribute(normal, a), new Vector3().fromBufferAttribute(normal, b), new Vector3().fromBufferAttribute(normal, c)];\r\n      const face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);\r\n      scope.faces.push(face);\r\n\r\n      if (uv !== undefined) {\r\n        scope.faceVertexUvs[0].push([new Vector2().fromBufferAttribute(uv, a), new Vector2().fromBufferAttribute(uv, b), new Vector2().fromBufferAttribute(uv, c)]);\r\n      }\r\n\r\n      if (uv2 !== undefined) {\r\n        scope.faceVertexUvs[1].push([new Vector2().fromBufferAttribute(uv2, a), new Vector2().fromBufferAttribute(uv2, b), new Vector2().fromBufferAttribute(uv2, c)]);\r\n      }\r\n    }\r\n\r\n    const groups = geometry.groups;\r\n\r\n    if (groups.length > 0) {\r\n      for (let i = 0; i < groups.length; i++) {\r\n        const group = groups[i];\r\n        const start = group.start;\r\n        const count = group.count;\r\n\r\n        for (let j = start, jl = start + count; j < jl; j += 3) {\r\n          if (index !== undefined) {\r\n            addFace(index.getX(j), index.getX(j + 1), index.getX(j + 2), group.materialIndex);\r\n          } else {\r\n            addFace(j, j + 1, j + 2, group.materialIndex);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      if (index !== undefined) {\r\n        for (let i = 0; i < index.count; i += 3) {\r\n          addFace(index.getX(i), index.getX(i + 1), index.getX(i + 2));\r\n        }\r\n      } else {\r\n        for (let i = 0; i < position.count; i += 3) {\r\n          addFace(i, i + 1, i + 2);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.computeFaceNormals();\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      this.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      this.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  center() {\r\n    this.computeBoundingBox();\r\n    this.boundingBox.getCenter(_offset).negate();\r\n    this.translate(_offset.x, _offset.y, _offset.z);\r\n    return this;\r\n  }\r\n\r\n  normalize() {\r\n    this.computeBoundingSphere();\r\n    const center = this.boundingSphere.center;\r\n    const radius = this.boundingSphere.radius;\r\n    const s = radius === 0 ? 1 : 1.0 / radius;\r\n    const matrix = new Matrix4();\r\n    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);\r\n    this.applyMatrix4(matrix);\r\n    return this;\r\n  }\r\n\r\n  computeFaceNormals() {\r\n    const cb = new Vector3(),\r\n          ab = new Vector3();\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      const vA = this.vertices[face.a];\r\n      const vB = this.vertices[face.b];\r\n      const vC = this.vertices[face.c];\r\n      cb.subVectors(vC, vB);\r\n      ab.subVectors(vA, vB);\r\n      cb.cross(ab);\r\n      cb.normalize();\r\n      face.normal.copy(cb);\r\n    }\r\n  }\r\n\r\n  computeVertexNormals(areaWeighted = true) {\r\n    const vertices = new Array(this.vertices.length);\r\n\r\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\r\n      vertices[v] = new Vector3();\r\n    }\r\n\r\n    if (areaWeighted) {\r\n      // vertex normals weighted by triangle areas\r\n      // http://www.iquilezles.org/www/articles/normals/normals.htm\r\n      const cb = new Vector3(),\r\n            ab = new Vector3();\r\n\r\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n        const face = this.faces[f];\r\n        const vA = this.vertices[face.a];\r\n        const vB = this.vertices[face.b];\r\n        const vC = this.vertices[face.c];\r\n        cb.subVectors(vC, vB);\r\n        ab.subVectors(vA, vB);\r\n        cb.cross(ab);\r\n        vertices[face.a].add(cb);\r\n        vertices[face.b].add(cb);\r\n        vertices[face.c].add(cb);\r\n      }\r\n    } else {\r\n      this.computeFaceNormals();\r\n\r\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n        const face = this.faces[f];\r\n        vertices[face.a].add(face.normal);\r\n        vertices[face.b].add(face.normal);\r\n        vertices[face.c].add(face.normal);\r\n      }\r\n    }\r\n\r\n    for (let v = 0, vl = this.vertices.length; v < vl; v++) {\r\n      vertices[v].normalize();\r\n    }\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      const vertexNormals = face.vertexNormals;\r\n\r\n      if (vertexNormals.length === 3) {\r\n        vertexNormals[0].copy(vertices[face.a]);\r\n        vertexNormals[1].copy(vertices[face.b]);\r\n        vertexNormals[2].copy(vertices[face.c]);\r\n      } else {\r\n        vertexNormals[0] = vertices[face.a].clone();\r\n        vertexNormals[1] = vertices[face.b].clone();\r\n        vertexNormals[2] = vertices[face.c].clone();\r\n      }\r\n    }\r\n\r\n    if (this.faces.length > 0) {\r\n      this.normalsNeedUpdate = true;\r\n    }\r\n  }\r\n\r\n  computeFlatVertexNormals() {\r\n    this.computeFaceNormals();\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      const vertexNormals = face.vertexNormals;\r\n\r\n      if (vertexNormals.length === 3) {\r\n        vertexNormals[0].copy(face.normal);\r\n        vertexNormals[1].copy(face.normal);\r\n        vertexNormals[2].copy(face.normal);\r\n      } else {\r\n        vertexNormals[0] = face.normal.clone();\r\n        vertexNormals[1] = face.normal.clone();\r\n        vertexNormals[2] = face.normal.clone();\r\n      }\r\n    }\r\n\r\n    if (this.faces.length > 0) {\r\n      this.normalsNeedUpdate = true;\r\n    }\r\n  }\r\n\r\n  computeMorphNormals() {\r\n    // save original normals\r\n    // - create temp variables on first access\r\n    //   otherwise just copy (for faster repeated calls)\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n\r\n      if (!face.__originalFaceNormal) {\r\n        face.__originalFaceNormal = face.normal.clone();\r\n      } else {\r\n        face.__originalFaceNormal.copy(face.normal);\r\n      }\r\n\r\n      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];\r\n\r\n      for (let i = 0, il = face.vertexNormals.length; i < il; i++) {\r\n        if (!face.__originalVertexNormals[i]) {\r\n          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();\r\n        } else {\r\n          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);\r\n        }\r\n      }\r\n    } // use temp geometry to compute face and vertex normals for each morph\r\n\r\n\r\n    const tmpGeo = new Geometry();\r\n    tmpGeo.faces = this.faces;\r\n\r\n    for (let i = 0, il = this.morphTargets.length; i < il; i++) {\r\n      // create on first access\r\n      if (!this.morphNormals[i]) {\r\n        this.morphNormals[i] = {};\r\n        this.morphNormals[i].faceNormals = [];\r\n        this.morphNormals[i].vertexNormals = [];\r\n        const dstNormalsFace = this.morphNormals[i].faceNormals;\r\n        const dstNormalsVertex = this.morphNormals[i].vertexNormals;\r\n\r\n        for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n          const faceNormal = new Vector3();\r\n          const vertexNormals = {\r\n            a: new Vector3(),\r\n            b: new Vector3(),\r\n            c: new Vector3()\r\n          };\r\n          dstNormalsFace.push(faceNormal);\r\n          dstNormalsVertex.push(vertexNormals);\r\n        }\r\n      }\r\n\r\n      const morphNormals = this.morphNormals[i]; // set vertices to morph target\r\n\r\n      tmpGeo.vertices = this.morphTargets[i].vertices; // compute morph normals\r\n\r\n      tmpGeo.computeFaceNormals();\r\n      tmpGeo.computeVertexNormals(); // store morph normals\r\n\r\n      for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n        const face = this.faces[f];\r\n        const faceNormal = morphNormals.faceNormals[f];\r\n        const vertexNormals = morphNormals.vertexNormals[f];\r\n        faceNormal.copy(face.normal);\r\n        vertexNormals.a.copy(face.vertexNormals[0]);\r\n        vertexNormals.b.copy(face.vertexNormals[1]);\r\n        vertexNormals.c.copy(face.vertexNormals[2]);\r\n      }\r\n    } // restore original normals\r\n\r\n\r\n    for (let f = 0, fl = this.faces.length; f < fl; f++) {\r\n      const face = this.faces[f];\r\n      face.normal = face.__originalFaceNormal;\r\n      face.vertexNormals = face.__originalVertexNormals;\r\n    }\r\n  }\r\n\r\n  computeBoundingBox() {\r\n    if (this.boundingBox === null) {\r\n      this.boundingBox = new Box3();\r\n    }\r\n\r\n    this.boundingBox.setFromPoints(this.vertices);\r\n  }\r\n\r\n  computeBoundingSphere() {\r\n    if (this.boundingSphere === null) {\r\n      this.boundingSphere = new Sphere();\r\n    }\r\n\r\n    this.boundingSphere.setFromPoints(this.vertices);\r\n  }\r\n\r\n  merge(geometry, matrix, materialIndexOffset = 0) {\r\n    if (!(geometry && geometry.isGeometry)) {\r\n      console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry);\r\n      return;\r\n    }\r\n\r\n    let normalMatrix;\r\n    const vertexOffset = this.vertices.length,\r\n          vertices1 = this.vertices,\r\n          vertices2 = geometry.vertices,\r\n          faces1 = this.faces,\r\n          faces2 = geometry.faces,\r\n          colors1 = this.colors,\r\n          colors2 = geometry.colors;\r\n\r\n    if (matrix !== undefined) {\r\n      normalMatrix = new Matrix3().getNormalMatrix(matrix);\r\n    } // vertices\r\n\r\n\r\n    for (let i = 0, il = vertices2.length; i < il; i++) {\r\n      const vertex = vertices2[i];\r\n      const vertexCopy = vertex.clone();\r\n      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);\r\n      vertices1.push(vertexCopy);\r\n    } // colors\r\n\r\n\r\n    for (let i = 0, il = colors2.length; i < il; i++) {\r\n      colors1.push(colors2[i].clone());\r\n    } // faces\r\n\r\n\r\n    for (let i = 0, il = faces2.length; i < il; i++) {\r\n      const face = faces2[i];\r\n      let normal, color;\r\n      const faceVertexNormals = face.vertexNormals,\r\n            faceVertexColors = face.vertexColors;\r\n      const faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);\r\n      faceCopy.normal.copy(face.normal);\r\n\r\n      if (normalMatrix !== undefined) {\r\n        faceCopy.normal.applyMatrix3(normalMatrix).normalize();\r\n      }\r\n\r\n      for (let j = 0, jl = faceVertexNormals.length; j < jl; j++) {\r\n        normal = faceVertexNormals[j].clone();\r\n\r\n        if (normalMatrix !== undefined) {\r\n          normal.applyMatrix3(normalMatrix).normalize();\r\n        }\r\n\r\n        faceCopy.vertexNormals.push(normal);\r\n      }\r\n\r\n      faceCopy.color.copy(face.color);\r\n\r\n      for (let j = 0, jl = faceVertexColors.length; j < jl; j++) {\r\n        color = faceVertexColors[j];\r\n        faceCopy.vertexColors.push(color.clone());\r\n      }\r\n\r\n      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n      faces1.push(faceCopy);\r\n    } // uvs\r\n\r\n\r\n    for (let i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {\r\n      const faceVertexUvs2 = geometry.faceVertexUvs[i];\r\n      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];\r\n\r\n      for (let j = 0, jl = faceVertexUvs2.length; j < jl; j++) {\r\n        const uvs2 = faceVertexUvs2[j],\r\n              uvsCopy = [];\r\n\r\n        for (let k = 0, kl = uvs2.length; k < kl; k++) {\r\n          uvsCopy.push(uvs2[k].clone());\r\n        }\r\n\r\n        this.faceVertexUvs[i].push(uvsCopy);\r\n      }\r\n    }\r\n  }\r\n\r\n  mergeMesh(mesh) {\r\n    if (!(mesh && mesh.isMesh)) {\r\n      console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh);\r\n      return;\r\n    }\r\n\r\n    if (mesh.matrixAutoUpdate) mesh.updateMatrix();\r\n    this.merge(mesh.geometry, mesh.matrix);\r\n  }\r\n  /*\r\n   * Checks for duplicate vertices with hashmap.\r\n   * Duplicated vertices are removed\r\n   * and faces' vertices are updated.\r\n   */\r\n\r\n\r\n  mergeVertices(precisionPoints = 4) {\r\n    const verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\r\n    const unique = [],\r\n          changes = [];\r\n    const precision = Math.pow(10, precisionPoints);\r\n\r\n    for (let i = 0, il = this.vertices.length; i < il; i++) {\r\n      const v = this.vertices[i];\r\n      const key = `${Math.round(v.x * precision)}_${Math.round(v.y * precision)}_${Math.round(v.z * precision)}`;\r\n\r\n      if (verticesMap[key] === undefined) {\r\n        verticesMap[key] = i;\r\n        unique.push(this.vertices[i]);\r\n        changes[i] = unique.length - 1;\r\n      } else {\r\n        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n        changes[i] = changes[verticesMap[key]];\r\n      }\r\n    } // if faces are completely degenerate after merging vertices, we\r\n    // have to remove them from the geometry.\r\n\r\n\r\n    const faceIndicesToRemove = [];\r\n\r\n    for (let i = 0, il = this.faces.length; i < il; i++) {\r\n      const face = this.faces[i];\r\n      face.a = changes[face.a];\r\n      face.b = changes[face.b];\r\n      face.c = changes[face.c];\r\n      const indices = [face.a, face.b, face.c]; // if any duplicate vertices are found in a Face3\r\n      // we have to remove the face as nothing can be saved\r\n\r\n      for (let n = 0; n < 3; n++) {\r\n        if (indices[n] === indices[(n + 1) % 3]) {\r\n          faceIndicesToRemove.push(i);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = faceIndicesToRemove.length - 1; i >= 0; i--) {\r\n      const idx = faceIndicesToRemove[i];\r\n      this.faces.splice(idx, 1);\r\n\r\n      for (let j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {\r\n        this.faceVertexUvs[j].splice(idx, 1);\r\n      }\r\n    } // Use unique set of vertices\r\n\r\n\r\n    const diff = this.vertices.length - unique.length;\r\n    this.vertices = unique;\r\n    return diff;\r\n  }\r\n\r\n  setFromPoints(points) {\r\n    this.vertices = [];\r\n\r\n    for (let i = 0, l = points.length; i < l; i++) {\r\n      const point = points[i];\r\n      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  sortFacesByMaterialIndex() {\r\n    const faces = this.faces;\r\n    const length = faces.length; // tag faces\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      faces[i]._id = i;\r\n    } // sort faces\r\n\r\n\r\n    function materialIndexSort(a, b) {\r\n      return a.materialIndex - b.materialIndex;\r\n    }\r\n\r\n    faces.sort(materialIndexSort); // sort uvs\r\n\r\n    const uvs1 = this.faceVertexUvs[0];\r\n    const uvs2 = this.faceVertexUvs[1];\r\n    let newUvs1, newUvs2;\r\n    if (uvs1 && uvs1.length === length) newUvs1 = [];\r\n    if (uvs2 && uvs2.length === length) newUvs2 = [];\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      const id = faces[i]._id;\r\n      if (newUvs1) newUvs1.push(uvs1[id]);\r\n      if (newUvs2) newUvs2.push(uvs2[id]);\r\n    }\r\n\r\n    if (newUvs1) this.faceVertexUvs[0] = newUvs1;\r\n    if (newUvs2) this.faceVertexUvs[1] = newUvs2;\r\n  }\r\n\r\n  toJSON() {\r\n    const data = {\r\n      metadata: {\r\n        version: 4.5,\r\n        type: 'Geometry',\r\n        generator: 'Geometry.toJSON'\r\n      }\r\n    }; // standard Geometry serialization\r\n\r\n    data.uuid = this.uuid;\r\n    data.type = this.type;\r\n    if (this.name !== '') data.name = this.name;\r\n\r\n    if (this.parameters !== undefined) {\r\n      const parameters = this.parameters;\r\n\r\n      for (let key in parameters) {\r\n        if (parameters[key] !== undefined) data[key] = parameters[key];\r\n      }\r\n\r\n      return data;\r\n    }\r\n\r\n    const vertices = [];\r\n\r\n    for (let i = 0; i < this.vertices.length; i++) {\r\n      const vertex = this.vertices[i];\r\n      vertices.push(vertex.x, vertex.y, vertex.z);\r\n    }\r\n\r\n    const faces = [];\r\n    const normals = [];\r\n    const normalsHash = {};\r\n    const colors = [];\r\n    const colorsHash = {};\r\n    const uvs = [];\r\n    const uvsHash = {};\r\n\r\n    for (let i = 0; i < this.faces.length; i++) {\r\n      const face = this.faces[i];\r\n      const hasMaterial = true;\r\n      const hasFaceUv = false; // deprecated\r\n\r\n      const hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;\r\n      const hasFaceNormal = face.normal.length() > 0;\r\n      const hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n      const hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n      const hasFaceVertexColor = face.vertexColors.length > 0;\r\n      let faceType = 0;\r\n      faceType = setBit(faceType, 0, 0); // isQuad\r\n\r\n      faceType = setBit(faceType, 1, hasMaterial);\r\n      faceType = setBit(faceType, 2, hasFaceUv);\r\n      faceType = setBit(faceType, 3, hasFaceVertexUv);\r\n      faceType = setBit(faceType, 4, hasFaceNormal);\r\n      faceType = setBit(faceType, 5, hasFaceVertexNormal);\r\n      faceType = setBit(faceType, 6, hasFaceColor);\r\n      faceType = setBit(faceType, 7, hasFaceVertexColor);\r\n      faces.push(faceType);\r\n      faces.push(face.a, face.b, face.c);\r\n      faces.push(face.materialIndex);\r\n\r\n      if (hasFaceVertexUv) {\r\n        const faceVertexUvs = this.faceVertexUvs[0][i];\r\n        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));\r\n      }\r\n\r\n      if (hasFaceNormal) {\r\n        faces.push(getNormalIndex(face.normal));\r\n      }\r\n\r\n      if (hasFaceVertexNormal) {\r\n        const vertexNormals = face.vertexNormals;\r\n        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));\r\n      }\r\n\r\n      if (hasFaceColor) {\r\n        faces.push(getColorIndex(face.color));\r\n      }\r\n\r\n      if (hasFaceVertexColor) {\r\n        const vertexColors = face.vertexColors;\r\n        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));\r\n      }\r\n    }\r\n\r\n    function setBit(value, position, enabled) {\r\n      return enabled ? value | 1 << position : value & ~(1 << position);\r\n    }\r\n\r\n    function getNormalIndex(normal) {\r\n      const hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n      if (normalsHash[hash] !== undefined) {\r\n        return normalsHash[hash];\r\n      }\r\n\r\n      normalsHash[hash] = normals.length / 3;\r\n      normals.push(normal.x, normal.y, normal.z);\r\n      return normalsHash[hash];\r\n    }\r\n\r\n    function getColorIndex(color) {\r\n      const hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n      if (colorsHash[hash] !== undefined) {\r\n        return colorsHash[hash];\r\n      }\r\n\r\n      colorsHash[hash] = colors.length;\r\n      colors.push(color.getHex());\r\n      return colorsHash[hash];\r\n    }\r\n\r\n    function getUvIndex(uv) {\r\n      const hash = uv.x.toString() + uv.y.toString();\r\n\r\n      if (uvsHash[hash] !== undefined) {\r\n        return uvsHash[hash];\r\n      }\r\n\r\n      uvsHash[hash] = uvs.length / 2;\r\n      uvs.push(uv.x, uv.y);\r\n      return uvsHash[hash];\r\n    }\r\n\r\n    data.data = {};\r\n    data.data.vertices = vertices;\r\n    data.data.normals = normals;\r\n    if (colors.length > 0) data.data.colors = colors;\r\n    if (uvs.length > 0) data.data.uvs = [uvs]; // temporal backward compatibility\r\n\r\n    data.data.faces = faces;\r\n    return data;\r\n  }\r\n\r\n  clone() {\r\n    /*\r\n    // Handle primitives\r\n    const parameters = this.parameters;\r\n    if ( parameters !== undefined ) {\r\n    const values = [];\r\n    for ( const key in parameters ) {\r\n    values.push( parameters[ key ] );\r\n    }\r\n    const geometry = Object.create( this.constructor.prototype );\r\n    this.constructor.apply( geometry, values );\r\n    return geometry;\r\n    }\r\n    return new this.constructor().copy( this );\r\n    */\r\n    return new Geometry().copy(this);\r\n  }\r\n\r\n  copy(source) {\r\n    // reset\r\n    this.vertices = [];\r\n    this.colors = [];\r\n    this.faces = [];\r\n    this.faceVertexUvs = [[]];\r\n    this.morphTargets = [];\r\n    this.morphNormals = [];\r\n    this.skinWeights = [];\r\n    this.skinIndices = [];\r\n    this.lineDistances = [];\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null; // name\r\n\r\n    this.name = source.name; // vertices\r\n\r\n    const vertices = source.vertices;\r\n\r\n    for (let i = 0, il = vertices.length; i < il; i++) {\r\n      this.vertices.push(vertices[i].clone());\r\n    } // colors\r\n\r\n\r\n    const colors = source.colors;\r\n\r\n    for (let i = 0, il = colors.length; i < il; i++) {\r\n      this.colors.push(colors[i].clone());\r\n    } // faces\r\n\r\n\r\n    const faces = source.faces;\r\n\r\n    for (let i = 0, il = faces.length; i < il; i++) {\r\n      this.faces.push(faces[i].clone());\r\n    } // face vertex uvs\r\n\r\n\r\n    for (let i = 0, il = source.faceVertexUvs.length; i < il; i++) {\r\n      const faceVertexUvs = source.faceVertexUvs[i];\r\n\r\n      if (this.faceVertexUvs[i] === undefined) {\r\n        this.faceVertexUvs[i] = [];\r\n      }\r\n\r\n      for (let j = 0, jl = faceVertexUvs.length; j < jl; j++) {\r\n        const uvs = faceVertexUvs[j],\r\n              uvsCopy = [];\r\n\r\n        for (let k = 0, kl = uvs.length; k < kl; k++) {\r\n          const uv = uvs[k];\r\n          uvsCopy.push(uv.clone());\r\n        }\r\n\r\n        this.faceVertexUvs[i].push(uvsCopy);\r\n      }\r\n    } // morph targets\r\n\r\n\r\n    const morphTargets = source.morphTargets;\r\n\r\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\r\n      const morphTarget = {};\r\n      morphTarget.name = morphTargets[i].name; // vertices\r\n\r\n      if (morphTargets[i].vertices !== undefined) {\r\n        morphTarget.vertices = [];\r\n\r\n        for (let j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {\r\n          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());\r\n        }\r\n      } // normals\r\n\r\n\r\n      if (morphTargets[i].normals !== undefined) {\r\n        morphTarget.normals = [];\r\n\r\n        for (let j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {\r\n          morphTarget.normals.push(morphTargets[i].normals[j].clone());\r\n        }\r\n      }\r\n\r\n      this.morphTargets.push(morphTarget);\r\n    } // morph normals\r\n\r\n\r\n    const morphNormals = source.morphNormals;\r\n\r\n    for (let i = 0, il = morphNormals.length; i < il; i++) {\r\n      const morphNormal = {}; // vertex normals\r\n\r\n      if (morphNormals[i].vertexNormals !== undefined) {\r\n        morphNormal.vertexNormals = [];\r\n\r\n        for (let j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {\r\n          const srcVertexNormal = morphNormals[i].vertexNormals[j];\r\n          const destVertexNormal = {};\r\n          destVertexNormal.a = srcVertexNormal.a.clone();\r\n          destVertexNormal.b = srcVertexNormal.b.clone();\r\n          destVertexNormal.c = srcVertexNormal.c.clone();\r\n          morphNormal.vertexNormals.push(destVertexNormal);\r\n        }\r\n      } // face normals\r\n\r\n\r\n      if (morphNormals[i].faceNormals !== undefined) {\r\n        morphNormal.faceNormals = [];\r\n\r\n        for (let j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {\r\n          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());\r\n        }\r\n      }\r\n\r\n      this.morphNormals.push(morphNormal);\r\n    } // skin weights\r\n\r\n\r\n    const skinWeights = source.skinWeights;\r\n\r\n    for (let i = 0, il = skinWeights.length; i < il; i++) {\r\n      this.skinWeights.push(skinWeights[i].clone());\r\n    } // skin indices\r\n\r\n\r\n    const skinIndices = source.skinIndices;\r\n\r\n    for (let i = 0, il = skinIndices.length; i < il; i++) {\r\n      this.skinIndices.push(skinIndices[i].clone());\r\n    } // line distances\r\n\r\n\r\n    const lineDistances = source.lineDistances;\r\n\r\n    for (let i = 0, il = lineDistances.length; i < il; i++) {\r\n      this.lineDistances.push(lineDistances[i]);\r\n    } // bounding box\r\n\r\n\r\n    const boundingBox = source.boundingBox;\r\n\r\n    if (boundingBox !== null) {\r\n      this.boundingBox = boundingBox.clone();\r\n    } // bounding sphere\r\n\r\n\r\n    const boundingSphere = source.boundingSphere;\r\n\r\n    if (boundingSphere !== null) {\r\n      this.boundingSphere = boundingSphere.clone();\r\n    } // update flags\r\n\r\n\r\n    this.elementsNeedUpdate = source.elementsNeedUpdate;\r\n    this.verticesNeedUpdate = source.verticesNeedUpdate;\r\n    this.uvsNeedUpdate = source.uvsNeedUpdate;\r\n    this.normalsNeedUpdate = source.normalsNeedUpdate;\r\n    this.colorsNeedUpdate = source.colorsNeedUpdate;\r\n    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\r\n    this.groupsNeedUpdate = source.groupsNeedUpdate;\r\n    return this;\r\n  }\r\n\r\n  toBufferGeometry() {\r\n    const geometry = new DirectGeometry().fromGeometry(this);\r\n    const buffergeometry = new BufferGeometry();\r\n    const positions = new Float32Array(geometry.vertices.length * 3);\r\n    buffergeometry.setAttribute('position', new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));\r\n\r\n    if (geometry.normals.length > 0) {\r\n      const normals = new Float32Array(geometry.normals.length * 3);\r\n      buffergeometry.setAttribute('normal', new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));\r\n    }\r\n\r\n    if (geometry.colors.length > 0) {\r\n      const colors = new Float32Array(geometry.colors.length * 3);\r\n      buffergeometry.setAttribute('color', new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));\r\n    }\r\n\r\n    if (geometry.uvs.length > 0) {\r\n      const uvs = new Float32Array(geometry.uvs.length * 2);\r\n      buffergeometry.setAttribute('uv', new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));\r\n    }\r\n\r\n    if (geometry.uvs2.length > 0) {\r\n      const uvs2 = new Float32Array(geometry.uvs2.length * 2);\r\n      buffergeometry.setAttribute('uv2', new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));\r\n    } // groups\r\n\r\n\r\n    buffergeometry.groups = geometry.groups; // morphs\r\n\r\n    for (let name in geometry.morphTargets) {\r\n      const array = [];\r\n      const morphTargets = geometry.morphTargets[name];\r\n\r\n      for (let i = 0, l = morphTargets.length; i < l; i++) {\r\n        const morphTarget = morphTargets[i];\r\n        const attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);\r\n        attribute.name = morphTarget.name;\r\n        array.push(attribute.copyVector3sArray(morphTarget.data));\r\n      }\r\n\r\n      buffergeometry.morphAttributes[name] = array;\r\n    } // skinning\r\n\r\n\r\n    if (geometry.skinIndices.length > 0) {\r\n      const skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);\r\n      buffergeometry.setAttribute('skinIndex', skinIndices.copyVector4sArray(geometry.skinIndices));\r\n    }\r\n\r\n    if (geometry.skinWeights.length > 0) {\r\n      const skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);\r\n      buffergeometry.setAttribute('skinWeight', skinWeights.copyVector4sArray(geometry.skinWeights));\r\n    } //\r\n\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n\r\n    return buffergeometry;\r\n  }\r\n\r\n  computeTangents() {\r\n    console.error('THREE.Geometry: .computeTangents() has been removed.');\r\n  }\r\n\r\n  computeLineDistances() {\r\n    console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');\r\n  }\r\n\r\n  applyMatrix(matrix) {\r\n    console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');\r\n    return this.applyMatrix4(matrix);\r\n  }\r\n\r\n  dispose() {\r\n    this.dispatchEvent({\r\n      type: 'dispose'\r\n    });\r\n  }\r\n\r\n}\r\n\r\nGeometry.createBufferGeometryFromObject = object => {\r\n  let buffergeometry = new BufferGeometry();\r\n  const geometry = object.geometry;\r\n\r\n  if (object.isPoints || object.isLine) {\r\n    const positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);\r\n    const colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);\r\n    buffergeometry.setAttribute('position', positions.copyVector3sArray(geometry.vertices));\r\n    buffergeometry.setAttribute('color', colors.copyColorsArray(geometry.colors));\r\n\r\n    if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {\r\n      const lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);\r\n      buffergeometry.setAttribute('lineDistance', lineDistances.copyArray(geometry.lineDistances));\r\n    }\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      buffergeometry.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      buffergeometry.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n  } else if (object.isMesh) {\r\n    buffergeometry = geometry.toBufferGeometry();\r\n  }\r\n\r\n  return buffergeometry;\r\n};\r\n\r\nclass DirectGeometry {\r\n  constructor() {\r\n    this.vertices = [];\r\n    this.normals = [];\r\n    this.colors = [];\r\n    this.uvs = [];\r\n    this.uvs2 = [];\r\n    this.groups = [];\r\n    this.morphTargets = {};\r\n    this.skinWeights = [];\r\n    this.skinIndices = []; // this.lineDistances = [];\r\n\r\n    this.boundingBox = null;\r\n    this.boundingSphere = null; // update flags\r\n\r\n    this.verticesNeedUpdate = false;\r\n    this.normalsNeedUpdate = false;\r\n    this.colorsNeedUpdate = false;\r\n    this.uvsNeedUpdate = false;\r\n    this.groupsNeedUpdate = false;\r\n  }\r\n\r\n  computeGroups(geometry) {\r\n    const groups = [];\r\n    let group, i;\r\n    let materialIndex = undefined;\r\n    const faces = geometry.faces;\r\n\r\n    for (i = 0; i < faces.length; i++) {\r\n      const face = faces[i]; // materials\r\n\r\n      if (face.materialIndex !== materialIndex) {\r\n        materialIndex = face.materialIndex;\r\n\r\n        if (group !== undefined) {\r\n          group.count = i * 3 - group.start;\r\n          groups.push(group);\r\n        }\r\n\r\n        group = {\r\n          start: i * 3,\r\n          materialIndex\r\n        };\r\n      }\r\n    }\r\n\r\n    if (group !== undefined) {\r\n      group.count = i * 3 - group.start;\r\n      groups.push(group);\r\n    }\r\n\r\n    this.groups = groups;\r\n  }\r\n\r\n  fromGeometry(geometry) {\r\n    const faces = geometry.faces;\r\n    const vertices = geometry.vertices;\r\n    const faceVertexUvs = geometry.faceVertexUvs;\r\n    const hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;\r\n    const hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0; // morphs\r\n\r\n    const morphTargets = geometry.morphTargets;\r\n    const morphTargetsLength = morphTargets.length;\r\n    let morphTargetsPosition;\r\n\r\n    if (morphTargetsLength > 0) {\r\n      morphTargetsPosition = [];\r\n\r\n      for (let i = 0; i < morphTargetsLength; i++) {\r\n        morphTargetsPosition[i] = {\r\n          name: morphTargets[i].name,\r\n          data: []\r\n        };\r\n      }\r\n\r\n      this.morphTargets.position = morphTargetsPosition;\r\n    }\r\n\r\n    const morphNormals = geometry.morphNormals;\r\n    const morphNormalsLength = morphNormals.length;\r\n    let morphTargetsNormal;\r\n\r\n    if (morphNormalsLength > 0) {\r\n      morphTargetsNormal = [];\r\n\r\n      for (let i = 0; i < morphNormalsLength; i++) {\r\n        morphTargetsNormal[i] = {\r\n          name: morphNormals[i].name,\r\n          data: []\r\n        };\r\n      }\r\n\r\n      this.morphTargets.normal = morphTargetsNormal;\r\n    } // skins\r\n\r\n\r\n    const skinIndices = geometry.skinIndices;\r\n    const skinWeights = geometry.skinWeights;\r\n    const hasSkinIndices = skinIndices.length === vertices.length;\r\n    const hasSkinWeights = skinWeights.length === vertices.length; //\r\n\r\n    if (vertices.length > 0 && faces.length === 0) {\r\n      console.error('THREE.DirectGeometry: Faceless geometries are not supported.');\r\n    }\r\n\r\n    for (let i = 0; i < faces.length; i++) {\r\n      const face = faces[i];\r\n      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);\r\n      const vertexNormals = face.vertexNormals;\r\n\r\n      if (vertexNormals.length === 3) {\r\n        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);\r\n      } else {\r\n        const normal = face.normal;\r\n        this.normals.push(normal, normal, normal);\r\n      }\r\n\r\n      const vertexColors = face.vertexColors;\r\n\r\n      if (vertexColors.length === 3) {\r\n        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);\r\n      } else {\r\n        const color = face.color;\r\n        this.colors.push(color, color, color);\r\n      }\r\n\r\n      if (hasFaceVertexUv === true) {\r\n        const vertexUvs = faceVertexUvs[0][i];\r\n\r\n        if (vertexUvs !== undefined) {\r\n          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\r\n        } else {\r\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i);\r\n          this.uvs.push(new Vector2(), new Vector2(), new Vector2());\r\n        }\r\n      }\r\n\r\n      if (hasFaceVertexUv2 === true) {\r\n        const vertexUvs = faceVertexUvs[1][i];\r\n\r\n        if (vertexUvs !== undefined) {\r\n          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);\r\n        } else {\r\n          console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i);\r\n          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());\r\n        }\r\n      } // morphs\r\n\r\n\r\n      for (let j = 0; j < morphTargetsLength; j++) {\r\n        const morphTarget = morphTargets[j].vertices;\r\n        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);\r\n      }\r\n\r\n      for (let j = 0; j < morphNormalsLength; j++) {\r\n        const morphNormal = morphNormals[j].vertexNormals[i];\r\n        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);\r\n      } // skins\r\n\r\n\r\n      if (hasSkinIndices) {\r\n        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);\r\n      }\r\n\r\n      if (hasSkinWeights) {\r\n        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);\r\n      }\r\n    }\r\n\r\n    this.computeGroups(geometry);\r\n    this.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n    this.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n    this.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n    this.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n    this.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n    if (geometry.boundingSphere !== null) {\r\n      this.boundingSphere = geometry.boundingSphere.clone();\r\n    }\r\n\r\n    if (geometry.boundingBox !== null) {\r\n      this.boundingBox = geometry.boundingBox.clone();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nclass Face3 {\r\n  constructor(a, b, c, normal, color, materialIndex = 0) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.normal = normal && normal.isVector3 ? normal : new Vector3();\r\n    this.vertexNormals = Array.isArray(normal) ? normal : [];\r\n    this.color = color && color.isColor ? color : new Color();\r\n    this.vertexColors = Array.isArray(color) ? color : [];\r\n    this.materialIndex = materialIndex;\r\n  }\r\n\r\n  clone() {\r\n    return new this.constructor().copy(this);\r\n  }\r\n\r\n  copy(source) {\r\n    this.a = source.a;\r\n    this.b = source.b;\r\n    this.c = source.c;\r\n    this.normal.copy(source.normal);\r\n    this.color.copy(source.color);\r\n    this.materialIndex = source.materialIndex;\r\n\r\n    for (let i = 0, il = source.vertexNormals.length; i < il; i++) {\r\n      this.vertexNormals[i] = source.vertexNormals[i].clone();\r\n    }\r\n\r\n    for (let i = 0, il = source.vertexColors.length; i < il; i++) {\r\n      this.vertexColors[i] = source.vertexColors[i].clone();\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n}\r\n\r\nexport { Face3, Geometry };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}