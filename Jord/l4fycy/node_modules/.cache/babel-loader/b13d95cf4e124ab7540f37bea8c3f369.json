{"ast":null,"code":"import _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _possibleConstructorReturn from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, BoxGeometry } from 'three';\nvar tempNormal = new Vector3();\n\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\n  var totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\n\n  var centerLength = Math.max(sideLength - 2 * radius, 0);\n  var halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\n\n  tempNormal.copy(normal);\n  tempNormal[projectionAxis] = 0;\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\n\n  var arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\n\n  var arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\n\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\n    return arcAngleRatio * arcUvRatio;\n  } else {\n    // total amount of UV space alloted to the plane between the arcs\n    var lenUv = centerLength / (totArcLength + centerLength);\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\n  }\n}\n\nvar RoundedBoxGeometry = /*#__PURE__*/function (_BoxGeometry) {\n  _inherits(RoundedBoxGeometry, _BoxGeometry);\n\n  var _super = _createSuper(RoundedBoxGeometry);\n\n  function RoundedBoxGeometry() {\n    var _this;\n\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var segments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;\n\n    _classCallCheck(this, RoundedBoxGeometry);\n\n    // ensure segments is odd so we have a plane connecting the rounded corners\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\n\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\n    _this = _super.call(this, 1, 1, 1, segments, segments, segments); // if we just have one segment we're the same as a regular box\n\n    if (segments === 1) return _possibleConstructorReturn(_this);\n\n    var geometry2 = _this.toNonIndexed();\n\n    _this.index = null;\n    _this.attributes.position = geometry2.attributes.position;\n    _this.attributes.normal = geometry2.attributes.normal;\n    _this.attributes.uv = geometry2.attributes.uv; //\n\n    var position = new Vector3();\n    var normal = new Vector3();\n    var box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\n    var positions = _this.attributes.position.array;\n    var normals = _this.attributes.normal.array;\n    var uvs = _this.attributes.uv.array;\n    var faceTris = positions.length / 6;\n    var faceDirVector = new Vector3();\n    var halfSegmentSize = 0.5 / segments;\n\n    for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {\n      position.fromArray(positions, i);\n      normal.copy(position);\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\n      normal.normalize();\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\n      normals[i + 0] = normal.x;\n      normals[i + 1] = normal.y;\n      normals[i + 2] = normal.z;\n      var side = Math.floor(i / faceTris);\n\n      switch (side) {\n        case 0:\n          // right\n          // generate UVs along Z then Y\n          faceDirVector.set(1, 0, 0);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 1:\n          // left\n          // generate UVs along Z then Y\n          faceDirVector.set(-1, 0, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\n          break;\n\n        case 2:\n          // top\n          // generate UVs along X then Z\n          faceDirVector.set(0, 1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 3:\n          // bottom\n          // generate UVs along X then Z\n          faceDirVector.set(0, -1, 0);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\n          break;\n\n        case 4:\n          // front\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, 1);\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n\n        case 5:\n          // back\n          // generate UVs along X then Y\n          faceDirVector.set(0, 0, -1);\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\n          break;\n      }\n    }\n\n    return _this;\n  }\n\n  return _createClass(RoundedBoxGeometry);\n}(BoxGeometry);\n\nexport { RoundedBoxGeometry };","map":{"version":3,"names":["Vector3","BoxGeometry","tempNormal","getUv","faceDirVector","normal","uvAxis","projectionAxis","radius","sideLength","totArcLength","Math","PI","centerLength","max","halfArc","copy","normalize","arcUvRatio","arcAngleRatio","angleTo","sign","lenUv","RoundedBoxGeometry","width","height","depth","segments","min","geometry2","toNonIndexed","index","attributes","position","uv","box","divideScalar","subScalar","positions","array","normals","uvs","faceTris","length","halfSegmentSize","i","j","fromArray","x","y","z","side","floor","set"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/geometries/RoundedBoxGeometry.js"],"sourcesContent":["import { Vector3, BoxGeometry } from 'three';\r\n\r\nconst tempNormal = new Vector3();\r\n\r\nfunction getUv(faceDirVector, normal, uvAxis, projectionAxis, radius, sideLength) {\r\n  const totArcLength = 2 * Math.PI * radius / 4; // length of the planes between the arcs on each axis\r\n\r\n  const centerLength = Math.max(sideLength - 2 * radius, 0);\r\n  const halfArc = Math.PI / 4; // Get the vector projected onto the Y plane\r\n\r\n  tempNormal.copy(normal);\r\n  tempNormal[projectionAxis] = 0;\r\n  tempNormal.normalize(); // total amount of UV space alloted to a single arc\r\n\r\n  const arcUvRatio = 0.5 * totArcLength / (totArcLength + centerLength); // the distance along one arc the point is at\r\n\r\n  const arcAngleRatio = 1.0 - tempNormal.angleTo(faceDirVector) / halfArc;\r\n\r\n  if (Math.sign(tempNormal[uvAxis]) === 1) {\r\n    return arcAngleRatio * arcUvRatio;\r\n  } else {\r\n    // total amount of UV space alloted to the plane between the arcs\r\n    const lenUv = centerLength / (totArcLength + centerLength);\r\n    return lenUv + arcUvRatio + arcUvRatio * (1.0 - arcAngleRatio);\r\n  }\r\n}\r\n\r\nclass RoundedBoxGeometry extends BoxGeometry {\r\n  constructor(width = 1, height = 1, depth = 1, segments = 2, radius = 0.1) {\r\n    // ensure segments is odd so we have a plane connecting the rounded corners\r\n    segments = segments * 2 + 1; // ensure radius isn't bigger than shortest side\r\n\r\n    radius = Math.min(width / 2, height / 2, depth / 2, radius);\r\n    super(1, 1, 1, segments, segments, segments); // if we just have one segment we're the same as a regular box\r\n\r\n    if (segments === 1) return;\r\n    const geometry2 = this.toNonIndexed();\r\n    this.index = null;\r\n    this.attributes.position = geometry2.attributes.position;\r\n    this.attributes.normal = geometry2.attributes.normal;\r\n    this.attributes.uv = geometry2.attributes.uv; //\r\n\r\n    const position = new Vector3();\r\n    const normal = new Vector3();\r\n    const box = new Vector3(width, height, depth).divideScalar(2).subScalar(radius);\r\n    const positions = this.attributes.position.array;\r\n    const normals = this.attributes.normal.array;\r\n    const uvs = this.attributes.uv.array;\r\n    const faceTris = positions.length / 6;\r\n    const faceDirVector = new Vector3();\r\n    const halfSegmentSize = 0.5 / segments;\r\n\r\n    for (let i = 0, j = 0; i < positions.length; i += 3, j += 2) {\r\n      position.fromArray(positions, i);\r\n      normal.copy(position);\r\n      normal.x -= Math.sign(normal.x) * halfSegmentSize;\r\n      normal.y -= Math.sign(normal.y) * halfSegmentSize;\r\n      normal.z -= Math.sign(normal.z) * halfSegmentSize;\r\n      normal.normalize();\r\n      positions[i + 0] = box.x * Math.sign(position.x) + normal.x * radius;\r\n      positions[i + 1] = box.y * Math.sign(position.y) + normal.y * radius;\r\n      positions[i + 2] = box.z * Math.sign(position.z) + normal.z * radius;\r\n      normals[i + 0] = normal.x;\r\n      normals[i + 1] = normal.y;\r\n      normals[i + 2] = normal.z;\r\n      const side = Math.floor(i / faceTris);\r\n\r\n      switch (side) {\r\n        case 0:\r\n          // right\r\n          // generate UVs along Z then Y\r\n          faceDirVector.set(1, 0, 0);\r\n          uvs[j + 0] = getUv(faceDirVector, normal, 'z', 'y', radius, depth);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\r\n          break;\r\n\r\n        case 1:\r\n          // left\r\n          // generate UVs along Z then Y\r\n          faceDirVector.set(-1, 0, 0);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'z', 'y', radius, depth);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'z', radius, height);\r\n          break;\r\n\r\n        case 2:\r\n          // top\r\n          // generate UVs along X then Z\r\n          faceDirVector.set(0, 1, 0);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\r\n          uvs[j + 1] = getUv(faceDirVector, normal, 'z', 'x', radius, depth);\r\n          break;\r\n\r\n        case 3:\r\n          // bottom\r\n          // generate UVs along X then Z\r\n          faceDirVector.set(0, -1, 0);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'z', radius, width);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'z', 'x', radius, depth);\r\n          break;\r\n\r\n        case 4:\r\n          // front\r\n          // generate UVs along X then Y\r\n          faceDirVector.set(0, 0, 1);\r\n          uvs[j + 0] = 1.0 - getUv(faceDirVector, normal, 'x', 'y', radius, width);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\r\n          break;\r\n\r\n        case 5:\r\n          // back\r\n          // generate UVs along X then Y\r\n          faceDirVector.set(0, 0, -1);\r\n          uvs[j + 0] = getUv(faceDirVector, normal, 'x', 'y', radius, width);\r\n          uvs[j + 1] = 1.0 - getUv(faceDirVector, normal, 'y', 'x', radius, height);\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport { RoundedBoxGeometry };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}