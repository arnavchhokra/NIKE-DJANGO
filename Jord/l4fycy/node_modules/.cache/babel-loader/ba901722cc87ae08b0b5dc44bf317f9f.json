{"ast":null,"code":"import _classCallCheck from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\n/**\r\n * See https://github.com/kchapelier/PRWM for more informations about this file format\r\n */\n\nvar bigEndianPlatform = null;\n/**\r\n * Check if the endianness of the platform is big-endian (most significant bit first)\r\n * @returns {boolean} True if big-endian, false if little-endian\r\n */\n\nfunction _isBigEndianPlatform() {\n  if (bigEndianPlatform === null) {\n    var buffer = new ArrayBuffer(2),\n        uint8Array = new Uint8Array(buffer),\n        uint16Array = new Uint16Array(buffer);\n    uint8Array[0] = 0xaa; // set first byte\n\n    uint8Array[1] = 0xbb; // set second byte\n\n    bigEndianPlatform = uint16Array[0] === 0xaabb;\n  }\n\n  return bigEndianPlatform;\n} // match the values defined in the spec to the TypedArray types\n\n\nvar InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\n\nvar getMethods = {\n  Uint16Array: 'getUint16',\n  Uint32Array: 'getUint32',\n  Int16Array: 'getInt16',\n  Int32Array: 'getInt32',\n  Float32Array: 'getFloat32',\n  Float64Array: 'getFloat64'\n};\n\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\n  var bytesPerElement = viewType.BYTES_PER_ELEMENT;\n  var result;\n\n  if (fromBigEndian === _isBigEndianPlatform() || bytesPerElement === 1) {\n    result = new viewType(sourceArrayBuffer, position, length);\n  } else {\n    var readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\n        getMethod = getMethods[viewType.name],\n        littleEndian = !fromBigEndian;\n    result = new viewType(length);\n\n    for (var i = 0; i < length; i++) {\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\n    }\n  }\n\n  return result;\n}\n\nfunction decodePrwm(buffer) {\n  var array = new Uint8Array(buffer),\n      version = array[0];\n  var flags = array[1];\n  var indexedGeometry = !!(flags >> 7 & 0x01),\n      indicesType = flags >> 6 & 0x01,\n      bigEndian = (flags >> 5 & 0x01) === 1,\n      attributesNumber = flags & 0x1f;\n  var valuesNumber = 0,\n      indicesNumber = 0;\n\n  if (bigEndian) {\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\n  } else {\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\n  }\n  /** PRELIMINARY CHECKS **/\n\n\n  if (version === 0) {\n    throw new Error('PRWM decoder: Invalid format version: 0');\n  } else if (version !== 1) {\n    throw new Error('PRWM decoder: Unsupported format version: ' + version);\n  }\n\n  if (!indexedGeometry) {\n    if (indicesType !== 0) {\n      throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\n    } else if (indicesNumber !== 0) {\n      throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\n    }\n  }\n  /** PARSING **/\n\n\n  var pos = 8;\n  var attributes = {};\n\n  for (var i = 0; i < attributesNumber; i++) {\n    var attributeName = '';\n\n    while (pos < array.length) {\n      var char = array[pos];\n      pos++;\n\n      if (char === 0) {\n        break;\n      } else {\n        attributeName += String.fromCharCode(char);\n      }\n    }\n\n    flags = array[pos];\n    var attributeType = flags >> 7 & 0x01;\n    var cardinality = (flags >> 4 & 0x03) + 1;\n    var encodingType = flags & 0x0f;\n    var arrayType = InvertedEncodingTypes[encodingType];\n    pos++; // padding to next multiple of 4\n\n    pos = Math.ceil(pos / 4) * 4;\n    var values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\n    attributes[attributeName] = {\n      type: attributeType,\n      cardinality: cardinality,\n      values: values\n    };\n  }\n\n  pos = Math.ceil(pos / 4) * 4;\n  var indices = null;\n\n  if (indexedGeometry) {\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\n  }\n\n  return {\n    version: version,\n    attributes: attributes,\n    indices: indices\n  };\n} // Define the public interface\n\n\nvar PRWMLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(PRWMLoader, _Loader);\n\n  var _super = _createSuper(PRWMLoader);\n\n  function PRWMLoader(manager) {\n    _classCallCheck(this, PRWMLoader);\n\n    return _super.call(this, manager);\n  }\n\n  _createClass(PRWMLoader, [{\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var scope = this;\n      var loader = new FileLoader(scope.manager);\n      loader.setPath(scope.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(scope.requestHeader);\n      loader.setWithCredentials(scope.withCredentials);\n      url = url.replace(/\\*/g, _isBigEndianPlatform() ? 'be' : 'le');\n      loader.load(url, function (arrayBuffer) {\n        try {\n          onLoad(scope.parse(arrayBuffer));\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          } else {\n            console.error(e);\n          }\n\n          scope.manager.itemError(url);\n        }\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(arrayBuffer) {\n      var data = decodePrwm(arrayBuffer),\n          attributesKey = Object.keys(data.attributes),\n          bufferGeometry = new BufferGeometry();\n\n      for (var i = 0; i < attributesKey.length; i++) {\n        var attribute = data.attributes[attributesKey[i]];\n        bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\n      }\n\n      if (data.indices !== null) {\n        bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\n      }\n\n      return bufferGeometry;\n    }\n  }], [{\n    key: \"isBigEndianPlatform\",\n    value: function isBigEndianPlatform() {\n      return _isBigEndianPlatform();\n    }\n  }]);\n\n  return PRWMLoader;\n}(Loader);\n\nexport { PRWMLoader };","map":{"version":3,"names":["Loader","FileLoader","BufferGeometry","BufferAttribute","bigEndianPlatform","isBigEndianPlatform","buffer","ArrayBuffer","uint8Array","Uint8Array","uint16Array","Uint16Array","InvertedEncodingTypes","Float32Array","Int8Array","Int16Array","Int32Array","Uint32Array","getMethods","Float64Array","copyFromBuffer","sourceArrayBuffer","viewType","position","length","fromBigEndian","bytesPerElement","BYTES_PER_ELEMENT","result","readView","DataView","getMethod","name","littleEndian","i","decodePrwm","array","version","flags","indexedGeometry","indicesType","bigEndian","attributesNumber","valuesNumber","indicesNumber","Error","pos","attributes","attributeName","char","String","fromCharCode","attributeType","cardinality","encodingType","arrayType","Math","ceil","values","type","indices","PRWMLoader","manager","url","onLoad","onProgress","onError","scope","loader","setPath","path","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","replace","load","arrayBuffer","parse","e","console","error","itemError","data","attributesKey","Object","keys","bufferGeometry","attribute","setAttribute","normalized","setIndex"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/loaders/PRWMLoader.js"],"sourcesContent":["import { Loader, FileLoader, BufferGeometry, BufferAttribute } from 'three';\r\n\r\n/**\r\n * See https://github.com/kchapelier/PRWM for more informations about this file format\r\n */\r\n\r\nlet bigEndianPlatform = null;\r\n/**\r\n * Check if the endianness of the platform is big-endian (most significant bit first)\r\n * @returns {boolean} True if big-endian, false if little-endian\r\n */\r\n\r\nfunction isBigEndianPlatform() {\r\n  if (bigEndianPlatform === null) {\r\n    const buffer = new ArrayBuffer(2),\r\n          uint8Array = new Uint8Array(buffer),\r\n          uint16Array = new Uint16Array(buffer);\r\n    uint8Array[0] = 0xaa; // set first byte\r\n\r\n    uint8Array[1] = 0xbb; // set second byte\r\n\r\n    bigEndianPlatform = uint16Array[0] === 0xaabb;\r\n  }\r\n\r\n  return bigEndianPlatform;\r\n} // match the values defined in the spec to the TypedArray types\r\n\r\n\r\nconst InvertedEncodingTypes = [null, Float32Array, null, Int8Array, Int16Array, null, Int32Array, Uint8Array, Uint16Array, null, Uint32Array]; // define the method to use on a DataView, corresponding the TypedArray type\r\n\r\nconst getMethods = {\r\n  Uint16Array: 'getUint16',\r\n  Uint32Array: 'getUint32',\r\n  Int16Array: 'getInt16',\r\n  Int32Array: 'getInt32',\r\n  Float32Array: 'getFloat32',\r\n  Float64Array: 'getFloat64'\r\n};\r\n\r\nfunction copyFromBuffer(sourceArrayBuffer, viewType, position, length, fromBigEndian) {\r\n  const bytesPerElement = viewType.BYTES_PER_ELEMENT;\r\n  let result;\r\n\r\n  if (fromBigEndian === isBigEndianPlatform() || bytesPerElement === 1) {\r\n    result = new viewType(sourceArrayBuffer, position, length);\r\n  } else {\r\n    const readView = new DataView(sourceArrayBuffer, position, length * bytesPerElement),\r\n          getMethod = getMethods[viewType.name],\r\n          littleEndian = !fromBigEndian;\r\n    result = new viewType(length);\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      result[i] = readView[getMethod](i * bytesPerElement, littleEndian);\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nfunction decodePrwm(buffer) {\r\n  const array = new Uint8Array(buffer),\r\n        version = array[0];\r\n  let flags = array[1];\r\n  const indexedGeometry = !!(flags >> 7 & 0x01),\r\n        indicesType = flags >> 6 & 0x01,\r\n        bigEndian = (flags >> 5 & 0x01) === 1,\r\n        attributesNumber = flags & 0x1f;\r\n  let valuesNumber = 0,\r\n      indicesNumber = 0;\r\n\r\n  if (bigEndian) {\r\n    valuesNumber = (array[2] << 16) + (array[3] << 8) + array[4];\r\n    indicesNumber = (array[5] << 16) + (array[6] << 8) + array[7];\r\n  } else {\r\n    valuesNumber = array[2] + (array[3] << 8) + (array[4] << 16);\r\n    indicesNumber = array[5] + (array[6] << 8) + (array[7] << 16);\r\n  }\r\n  /** PRELIMINARY CHECKS **/\r\n\r\n\r\n  if (version === 0) {\r\n    throw new Error('PRWM decoder: Invalid format version: 0');\r\n  } else if (version !== 1) {\r\n    throw new Error('PRWM decoder: Unsupported format version: ' + version);\r\n  }\r\n\r\n  if (!indexedGeometry) {\r\n    if (indicesType !== 0) {\r\n      throw new Error('PRWM decoder: Indices type must be set to 0 for non-indexed geometries');\r\n    } else if (indicesNumber !== 0) {\r\n      throw new Error('PRWM decoder: Number of indices must be set to 0 for non-indexed geometries');\r\n    }\r\n  }\r\n  /** PARSING **/\r\n\r\n\r\n  let pos = 8;\r\n  const attributes = {};\r\n\r\n  for (let i = 0; i < attributesNumber; i++) {\r\n    let attributeName = '';\r\n\r\n    while (pos < array.length) {\r\n      const char = array[pos];\r\n      pos++;\r\n\r\n      if (char === 0) {\r\n        break;\r\n      } else {\r\n        attributeName += String.fromCharCode(char);\r\n      }\r\n    }\r\n\r\n    flags = array[pos];\r\n    const attributeType = flags >> 7 & 0x01;\r\n    const cardinality = (flags >> 4 & 0x03) + 1;\r\n    const encodingType = flags & 0x0f;\r\n    const arrayType = InvertedEncodingTypes[encodingType];\r\n    pos++; // padding to next multiple of 4\r\n\r\n    pos = Math.ceil(pos / 4) * 4;\r\n    const values = copyFromBuffer(buffer, arrayType, pos, cardinality * valuesNumber, bigEndian);\r\n    pos += arrayType.BYTES_PER_ELEMENT * cardinality * valuesNumber;\r\n    attributes[attributeName] = {\r\n      type: attributeType,\r\n      cardinality: cardinality,\r\n      values: values\r\n    };\r\n  }\r\n\r\n  pos = Math.ceil(pos / 4) * 4;\r\n  let indices = null;\r\n\r\n  if (indexedGeometry) {\r\n    indices = copyFromBuffer(buffer, indicesType === 1 ? Uint32Array : Uint16Array, pos, indicesNumber, bigEndian);\r\n  }\r\n\r\n  return {\r\n    version: version,\r\n    attributes: attributes,\r\n    indices: indices\r\n  };\r\n} // Define the public interface\r\n\r\n\r\nclass PRWMLoader extends Loader {\r\n  constructor(manager) {\r\n    super(manager);\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const scope = this;\r\n    const loader = new FileLoader(scope.manager);\r\n    loader.setPath(scope.path);\r\n    loader.setResponseType('arraybuffer');\r\n    loader.setRequestHeader(scope.requestHeader);\r\n    loader.setWithCredentials(scope.withCredentials);\r\n    url = url.replace(/\\*/g, isBigEndianPlatform() ? 'be' : 'le');\r\n    loader.load(url, function (arrayBuffer) {\r\n      try {\r\n        onLoad(scope.parse(arrayBuffer));\r\n      } catch (e) {\r\n        if (onError) {\r\n          onError(e);\r\n        } else {\r\n          console.error(e);\r\n        }\r\n\r\n        scope.manager.itemError(url);\r\n      }\r\n    }, onProgress, onError);\r\n  }\r\n\r\n  parse(arrayBuffer) {\r\n    const data = decodePrwm(arrayBuffer),\r\n          attributesKey = Object.keys(data.attributes),\r\n          bufferGeometry = new BufferGeometry();\r\n\r\n    for (let i = 0; i < attributesKey.length; i++) {\r\n      const attribute = data.attributes[attributesKey[i]];\r\n      bufferGeometry.setAttribute(attributesKey[i], new BufferAttribute(attribute.values, attribute.cardinality, attribute.normalized));\r\n    }\r\n\r\n    if (data.indices !== null) {\r\n      bufferGeometry.setIndex(new BufferAttribute(data.indices, 1));\r\n    }\r\n\r\n    return bufferGeometry;\r\n  }\r\n\r\n  static isBigEndianPlatform() {\r\n    return isBigEndianPlatform();\r\n  }\r\n\r\n}\r\n\r\nexport { PRWMLoader };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}