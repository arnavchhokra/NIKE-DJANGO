{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { InterleavedBufferAttribute, Matrix4, MeshLambertMaterial, MeshBasicMaterial, MeshPhongMaterial, Color, DoubleSide, Mesh } from \"three\";\nclass ColladaExporter {\n  constructor() {\n    __publicField(this, \"options\");\n    __publicField(this, \"geometryInfo\");\n    __publicField(this, \"materialMap\");\n    __publicField(this, \"imageMap\");\n    __publicField(this, \"textures\");\n    __publicField(this, \"libraryImages\");\n    __publicField(this, \"libraryGeometries\");\n    __publicField(this, \"libraryEffects\");\n    __publicField(this, \"libraryMaterials\");\n    __publicField(this, \"canvas\");\n    __publicField(this, \"ctx\");\n    __publicField(this, \"transMat\");\n    __publicField(this, \"getFuncs\", [\"getX\", \"getY\", \"getZ\", \"getW\"]);\n    this.options = {\n      version: \"1.4.1\",\n      author: null,\n      textureDirectory: \"\",\n      upAxis: \"Y_UP\",\n      unitName: null,\n      unitMeter: null\n    };\n    this.geometryInfo = /* @__PURE__ */new WeakMap();\n    this.materialMap = /* @__PURE__ */new WeakMap();\n    this.imageMap = /* @__PURE__ */new WeakMap();\n    this.textures = [];\n    this.libraryImages = [];\n    this.libraryGeometries = [];\n    this.libraryEffects = [];\n    this.libraryMaterials = [];\n    this.canvas = null;\n    this.ctx = null;\n    this.transMat = null;\n  }\n  parse(object, onDone) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.options = {\n      ...this.options,\n      ...options\n    };\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error(\"ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.\");\n      return null;\n    }\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error(\"ColladaExporter: unitMeter needs to be specified if unitName is specified.\");\n      return null;\n    }\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error(\"ColladaExporter: unitName needs to be specified if unitMeter is specified.\");\n      return null;\n    }\n    if (this.options.textureDirectory !== \"\") {\n      this.options.textureDirectory = \"\".concat(this.options.textureDirectory, \"/\").replace(/\\\\/g, \"/\").replace(/\\/+/g, \"/\");\n    }\n    if (this.options.version !== \"1.4.1\" && this.options.version !== \"1.5.0\") {\n      console.warn(\"ColladaExporter : Version \".concat(this.options.version, \" not supported for export. Only 1.4.1 and 1.5.0.\"));\n      return null;\n    }\n    const libraryVisualScenes = this.processObject(object);\n    const specLink = this.options.version === \"1.4.1\" ? \"http://www.collada.org/2005/11/COLLADASchema\" : \"https://www.khronos.org/collada/\";\n    let dae = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\" ?>\".concat(\"<COLLADA xmlns=\\\"\".concat(specLink, \"\\\" version=\\\"\").concat(this.options.version, \"\\\">\"), \"<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>\", this.options.author !== null ? \"<author>\".concat(this.options.author, \"</author>\") : \"\", \"</contributor>\", \"<created>\".concat(( /* @__PURE__ */new Date()).toISOString(), \"</created>\"), \"<modified>\".concat(( /* @__PURE__ */new Date()).toISOString(), \"</modified>\"), \"<up_axis>Y_UP</up_axis></asset>\");\n    dae += \"<library_images>\".concat(this.libraryImages.join(\"\"), \"</library_images>\");\n    dae += \"<library_effects>\".concat(this.libraryEffects.join(\"\"), \"</library_effects>\");\n    dae += \"<library_materials>\".concat(this.libraryMaterials.join(\"\"), \"</library_materials>\");\n    dae += \"<library_geometries>\".concat(this.libraryGeometries.join(\"\"), \"</library_geometries>\");\n    dae += \"<library_visual_scenes><visual_scene id=\\\"Scene\\\" name=\\\"scene\\\">\".concat(libraryVisualScenes, \"</visual_scene></library_visual_scenes>\");\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>';\n    dae += \"</COLLADA>\";\n    const res = {\n      data: this.format(dae),\n      textures: this.textures\n    };\n    if (typeof onDone === \"function\") {\n      requestAnimationFrame(() => onDone(res));\n    }\n    return res;\n  }\n  // Convert the urdf xml into a well-formatted, indented format\n  format(urdf) {\n    var _a, _b;\n    const IS_END_TAG = /^<\\//;\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/;\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/;\n    const pad = (ch, num) => num > 0 ? ch + pad(ch, num - 1) : \"\";\n    let tagnum = 0;\n    return (_b = (_a = urdf.match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)) == null ? void 0 : _a.map(tag => {\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n        tagnum--;\n      }\n      const res = \"\".concat(pad(\"  \", tagnum)).concat(tag);\n      if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n        tagnum++;\n      }\n      return res;\n    }).join(\"\\n\")) != null ? _b : \"\";\n  }\n  // Convert an image into a png format for saving\n  base64ToBuffer(str) {\n    const b = atob(str);\n    const buf = new Uint8Array(b.length);\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i);\n    }\n    return buf;\n  }\n  imageToData(image, ext) {\n    var _a;\n    this.canvas = this.canvas || document.createElement(\"canvas\");\n    this.ctx = this.ctx || this.canvas.getContext(\"2d\");\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width;\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height;\n    (_a = this.ctx) == null ? void 0 : _a.drawImage(image, 0, 0);\n    const base64data = this.canvas.toDataURL(\"image/\".concat(ext), 1).replace(/^data:image\\/(png|jpg);base64,/, \"\");\n    return this.base64ToBuffer(base64data);\n  }\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  attrBufferToArray(attr) {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      const TypedArrayConstructor = attr.array.constructor;\n      const arr = new TypedArrayConstructor(attr.count * attr.itemSize);\n      const size = attr.itemSize;\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i);\n        }\n      }\n      return arr;\n    } else {\n      return attr.array;\n    }\n  }\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  subArray(arr, st, ct) {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct);\n    } else {\n      const TypedArrayConstructor = arr.constructor;\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct);\n    }\n  }\n  // Returns the string for a geometry's attribute\n  getAttribute(attr, name, params, type) {\n    const array = this.attrBufferToArray(attr);\n    const res = Array.isArray(array) ? \"\".concat(\"<source id=\\\"\".concat(name, \"\\\"><float_array id=\\\"\").concat(name, \"-array\\\" count=\\\"\").concat(array.length, \"\\\">\") + array.join(\" \"), \"</float_array><technique_common>\", \"<accessor source=\\\"#\".concat(name, \"-array\\\" count=\\\"\").concat(Math.floor(array.length / attr.itemSize), \"\\\" stride=\\\"\").concat(attr.itemSize, \"\\\">\")).concat(params.map(n => \"<param name=\\\"\".concat(n, \"\\\" type=\\\"\").concat(type, \"\\\" />\")).join(\"\"), \"</accessor></technique_common></source>\") : \"\";\n    return res;\n  }\n  // Returns the string for a node's transform information\n  getTransform(o) {\n    o.updateMatrix();\n    this.transMat = this.transMat || new Matrix4();\n    this.transMat.copy(o.matrix);\n    this.transMat.transpose();\n    return \"<matrix>\".concat(this.transMat.toArray().join(\" \"), \"</matrix>\");\n  }\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  processGeometry(g) {\n    let info = this.geometryInfo.get(g);\n    if (!info) {\n      const bufferGeometry = g;\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error(\"THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.\");\n      }\n      const meshid = \"Mesh\".concat(this.libraryGeometries.length + 1);\n      const indexCount = bufferGeometry.index ? bufferGeometry.index.count * bufferGeometry.index.itemSize : bufferGeometry.attributes.position.count;\n      const groups = bufferGeometry.groups != null && bufferGeometry.groups.length !== 0 ? bufferGeometry.groups : [{\n        start: 0,\n        count: indexCount,\n        materialIndex: 0\n      }];\n      const gname = g.name ? \" name=\\\"\".concat(g.name, \"\\\"\") : \"\";\n      let gnode = \"<geometry id=\\\"\".concat(meshid, \"\\\"\").concat(gname, \"><mesh>\");\n      const posName = \"\".concat(meshid, \"-position\");\n      const vertName = \"\".concat(meshid, \"-vertices\");\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, [\"X\", \"Y\", \"Z\"], \"float\");\n      gnode += \"<vertices id=\\\"\".concat(vertName, \"\\\"><input semantic=\\\"POSITION\\\" source=\\\"#\").concat(posName, \"\\\" /></vertices>\");\n      let triangleInputs = \"<input semantic=\\\"VERTEX\\\" source=\\\"#\".concat(vertName, \"\\\" offset=\\\"0\\\" />\");\n      if (\"normal\" in bufferGeometry.attributes) {\n        const normName = \"\".concat(meshid, \"-normal\");\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, [\"X\", \"Y\", \"Z\"], \"float\");\n        triangleInputs += \"<input semantic=\\\"NORMAL\\\" source=\\\"#\".concat(normName, \"\\\" offset=\\\"0\\\" />\");\n      }\n      if (\"uv\" in bufferGeometry.attributes) {\n        const uvName = \"\".concat(meshid, \"-texcoord\");\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(uvName, \"\\\" offset=\\\"0\\\" set=\\\"0\\\" />\");\n      }\n      if (\"uv2\" in bufferGeometry.attributes) {\n        const uvName = \"\".concat(meshid, \"-texcoord2\");\n        gnode += this.getAttribute(bufferGeometry.attributes.uv2, uvName, [\"S\", \"T\"], \"float\");\n        triangleInputs += \"<input semantic=\\\"TEXCOORD\\\" source=\\\"#\".concat(uvName, \"\\\" offset=\\\"0\\\" set=\\\"1\\\" />\");\n      }\n      if (\"color\" in bufferGeometry.attributes) {\n        const colName = \"\".concat(meshid, \"-color\");\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, [\"X\", \"Y\", \"Z\"], \"uint8\");\n        triangleInputs += \"<input semantic=\\\"COLOR\\\" source=\\\"#\".concat(colName, \"\\\" offset=\\\"0\\\" />\");\n      }\n      let indexArray = null;\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index);\n      } else {\n        indexArray = new Array(indexCount);\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i;\n      }\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i];\n        const subarr = this.subArray(indexArray, group.start, group.count);\n        const polycount = subarr.length / 3;\n        gnode += \"<triangles material=\\\"MESH_MATERIAL_\".concat(group.materialIndex, \"\\\" count=\\\"\").concat(polycount, \"\\\">\");\n        gnode += triangleInputs;\n        gnode += \"<p>\".concat(subarr.join(\" \"), \"</p>\");\n        gnode += \"</triangles>\";\n      }\n      gnode += \"</mesh></geometry>\";\n      this.libraryGeometries.push(gnode);\n      info = {\n        meshid,\n        bufferGeometry\n      };\n      this.geometryInfo.set(g, info);\n    }\n    return info;\n  }\n  // Process the given texture into the image library\n  // Returns the image library\n  processTexture(tex) {\n    let texid = this.imageMap.get(tex);\n    if (texid == null) {\n      texid = \"image-\".concat(this.libraryImages.length + 1);\n      const ext = \"png\";\n      const name = tex.name || texid;\n      let imageNode = \"<image id=\\\"\".concat(texid, \"\\\" name=\\\"\").concat(name, \"\\\">\");\n      if (this.options.version === \"1.5.0\") {\n        imageNode += \"<init_from><ref>\".concat(this.options.textureDirectory).concat(name, \".\").concat(ext, \"</ref></init_from>\");\n      } else {\n        imageNode += \"<init_from>\".concat(this.options.textureDirectory).concat(name, \".\").concat(ext, \"</init_from>\");\n      }\n      imageNode += \"</image>\";\n      this.libraryImages.push(imageNode);\n      this.imageMap.set(tex, texid);\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex\n      });\n    }\n    return texid;\n  }\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  processMaterial(m) {\n    let matid = this.materialMap.get(m);\n    if (matid == null) {\n      matid = \"Mat\".concat(this.libraryEffects.length + 1);\n      let type = \"phong\";\n      if (m instanceof MeshLambertMaterial) {\n        type = \"lambert\";\n      } else if (m instanceof MeshBasicMaterial) {\n        type = \"constant\";\n        if (m.map !== null) {\n          console.warn(\"ColladaExporter: Texture maps not supported with MeshBasicMaterial.\");\n        }\n      }\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0);\n        const diffuse = m.color ? m.color : new Color(0, 0, 0);\n        const specular = m.specular ? m.specular : new Color(1, 1, 1);\n        const shininess = m.shininess || 0;\n        const reflectivity = m.reflectivity || 0;\n        let transparencyNode = \"\";\n        if (m.transparent) {\n          transparencyNode += \"<transparent>\".concat(m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : \"<float>1</float>\", \"</transparent>\");\n          if (m.opacity < 1) {\n            transparencyNode += \"<transparency><float>\".concat(m.opacity, \"</float></transparency>\");\n          }\n        }\n        const techniqueNode = \"\".concat(\"<technique sid=\\\"common\\\"><\".concat(type, \">\"), \"<emission>\", m.emissiveMap ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"emission\\\">\".concat(emissive.r, \" \").concat(emissive.g, \" \").concat(emissive.b, \" 1</color>\"), \"</emission>\").concat(type !== \"constant\" ? \"<diffuse>\".concat(m.map ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />' : \"<color sid=\\\"diffuse\\\">\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color>\"), \"</diffuse>\") : \"\").concat(type !== \"constant\" ? \"<bump>\".concat(m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : \"\", \"</bump>\") : \"\").concat(type === \"phong\" ? \"\".concat(\"<specular><color sid=\\\"specular\\\">\".concat(specular.r, \" \").concat(specular.g, \" \").concat(specular.b, \" 1</color></specular>\"), \"<shininess>\", m.specularMap ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />' : \"<float sid=\\\"shininess\\\">\".concat(shininess, \"</float>\"), \"</shininess>\") : \"\", \"<reflective><color>\".concat(diffuse.r, \" \").concat(diffuse.g, \" \").concat(diffuse.b, \" 1</color></reflective>\"), \"<reflectivity><float>\".concat(reflectivity, \"</float></reflectivity>\")).concat(transparencyNode, \"</\".concat(type, \"></technique>\"));\n        const effectnode = \"\".concat(\"<effect id=\\\"\".concat(matid, \"-effect\\\">\"), \"<profile_COMMON>\", m.map ? \"<newparam sid=\\\"diffuse-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.map), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"diffuse-sampler\\\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>\") : \"\").concat(m.specularMap ? \"<newparam sid=\\\"specular-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.specularMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"specular-sampler\\\"><sampler2D><source>specular-surface</source></sampler2D></newparam>\") : \"\").concat(m.emissiveMap ? \"<newparam sid=\\\"emissive-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.emissiveMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"emissive-sampler\\\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>\") : \"\").concat(m.normalMap ? \"<newparam sid=\\\"bump-surface\\\"><surface type=\\\"2D\\\">\".concat(\"<init_from>\".concat(this.processTexture(m.normalMap), \"</init_from>\"), \"</surface></newparam><newparam sid=\\\"bump-sampler\\\"><sampler2D><source>bump-surface</source></sampler2D></newparam>\") : \"\").concat(techniqueNode).concat(m.side === DoubleSide ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>' : \"\", \"</profile_COMMON></effect>\");\n        const materialName = m.name ? \" name=\\\"\".concat(m.name, \"\\\"\") : \"\";\n        const materialNode = \"<material id=\\\"\".concat(matid, \"\\\"\").concat(materialName, \"><instance_effect url=\\\"#\").concat(matid, \"-effect\\\" /></material>\");\n        this.libraryMaterials.push(materialNode);\n        this.libraryEffects.push(effectnode);\n        this.materialMap.set(m, matid);\n      }\n    }\n    return matid;\n  }\n  // Recursively process the object into a scene\n  processObject(o) {\n    let node = \"<node name=\\\"\".concat(o.name, \"\\\">\");\n    node += this.getTransform(o);\n    const a = new Mesh();\n    a.geometry;\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      const geomInfo = this.processGeometry(o.geometry);\n      const meshid = geomInfo.meshid;\n      const geometry = geomInfo.bufferGeometry;\n      let matids = null;\n      let matidsArray;\n      const mat = o.material || new MeshBasicMaterial();\n      const materials = Array.isArray(mat) ? mat : [mat];\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length);\n      } else {\n        matidsArray = new Array(materials.length);\n      }\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]));\n      node += \"\".concat(\"<instance_geometry url=\\\"#\".concat(meshid, \"\\\">\") + (matids != null ? \"<bind_material><technique_common>\".concat(matids.map((id, i) => \"\".concat(\"<instance_material symbol=\\\"MESH_MATERIAL_\".concat(i, \"\\\" target=\\\"#\").concat(id, \"\\\" >\"), \"<bind_vertex_input semantic=\\\"TEXCOORD\\\" input_semantic=\\\"TEXCOORD\\\" input_set=\\\"0\\\" /></instance_material>\")).join(\"\"), \"</technique_common></bind_material>\") : \"\"), \"</instance_geometry>\");\n    }\n    o.children.forEach(c => node += this.processObject(c));\n    node += \"</node>\";\n    return node;\n  }\n}\nexport { ColladaExporter };","map":{"version":3,"names":["ColladaExporter","constructor","__publicField","options","version","author","textureDirectory","upAxis","unitName","unitMeter","geometryInfo","WeakMap","materialMap","imageMap","textures","libraryImages","libraryGeometries","libraryEffects","libraryMaterials","canvas","ctx","transMat","parse","object","onDone","arguments","length","undefined","match","console","error","concat","replace","warn","libraryVisualScenes","processObject","specLink","dae","Date","toISOString","join","res","data","format","requestAnimationFrame","urdf","IS_END_TAG","IS_SELF_CLOSING","HAS_TEXT","pad","ch","num","tagnum","_b","_a","map","tag","test","base64ToBuffer","str","b","atob","buf","Uint8Array","i","l","charCodeAt","imageToData","image","ext","document","createElement","getContext","width","SVGAnimatedLength","height","drawImage","base64data","toDataURL","attrBufferToArray","attr","InterleavedBufferAttribute","isInterleavedBufferAttribute","TypedArrayConstructor","array","arr","count","itemSize","size","j","getFuncs","subArray","st","ct","Array","isArray","slice","buffer","BYTES_PER_ELEMENT","getAttribute","name","params","type","Math","floor","n","getTransform","o","updateMatrix","Matrix4","copy","matrix","transpose","toArray","processGeometry","g","info","get","bufferGeometry","isBufferGeometry","Error","meshid","indexCount","index","attributes","position","groups","start","materialIndex","gname","gnode","posName","vertName","triangleInputs","normName","normal","uvName","uv","uv2","colName","color","indexArray","group","subarr","polycount","push","set","processTexture","tex","texid","imageNode","directory","original","processMaterial","m","matid","MeshLambertMaterial","MeshBasicMaterial","MeshPhongMaterial","emissive","Color","diffuse","specular","shininess","reflectivity","transparencyNode","transparent","opacity","techniqueNode","emissiveMap","r","normalMap","specularMap","effectnode","side","DoubleSide","materialName","materialNode","node","a","Mesh","geometry","isMesh","geomInfo","matids","matidsArray","mat","material","materials","fill","_","id","children","forEach","c"],"sources":["D:\\Repos\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\src\\exporters\\ColladaExporter.ts"],"sourcesContent":["import {\n  BufferAttribute,\n  BufferGeometry,\n  Color,\n  DoubleSide,\n  InterleavedBufferAttribute,\n  Material,\n  Matrix4,\n  Mesh,\n  MeshBasicMaterial,\n  MeshLambertMaterial,\n  MeshPhongMaterial,\n  Object3D,\n  Texture,\n} from 'three'\nimport type { TypedArray, TypedArrayConstructors } from '../types/shared'\n\n/**\n * https://github.com/gkjohnson/collada-exporter-js\n *\n * Usage:\n *  const exporter = new ColladaExporter();\n *\n *  const data = exporter.parse(mesh);\n *\n * Format Definition:\n *  https://www.khronos.org/collada/\n */\n\nexport interface ColladaExporterOptions {\n  author?: string\n  textureDirectory?: string\n  version?: string\n}\n\nexport interface ColladaExporterResult {\n  data: string\n  textures: object[]\n}\n\ntype GeometryInfo = { meshid: string; bufferGeometry: BufferGeometry }\n\ntype MaterialRepresentation = MeshPhongMaterial | MeshBasicMaterial | MeshLambertMaterial\n\nclass ColladaExporter {\n  private options: {\n    version: string\n    author: string | null\n    textureDirectory: string\n    upAxis: string\n    unitName: string | null\n    unitMeter: string | null\n  }\n\n  private geometryInfo: WeakMap<BufferGeometry, GeometryInfo>\n  private materialMap: WeakMap<MaterialRepresentation, string>\n  private imageMap: WeakMap<Texture, string>\n  private textures: {\n    directory: string\n    name: string\n    ext: string\n    data: Uint8Array\n    original: Texture\n  }[]\n\n  private libraryImages: string[]\n  private libraryGeometries: string[]\n  private libraryEffects: string[]\n  private libraryMaterials: string[]\n\n  private canvas: HTMLCanvasElement | null\n  private ctx: CanvasRenderingContext2D | null\n\n  private transMat: Matrix4 | null\n\n  private getFuncs = ['getX', 'getY', 'getZ', 'getW'] as const\n\n  constructor() {\n    this.options = {\n      version: '1.4.1',\n      author: null,\n      textureDirectory: '',\n      upAxis: 'Y_UP',\n      unitName: null,\n      unitMeter: null,\n    }\n\n    this.geometryInfo = new WeakMap()\n    this.materialMap = new WeakMap()\n    this.imageMap = new WeakMap()\n    this.textures = []\n\n    this.libraryImages = []\n    this.libraryGeometries = []\n    this.libraryEffects = []\n    this.libraryMaterials = []\n\n    this.canvas = null\n    this.ctx = null\n\n    this.transMat = null\n  }\n\n  public parse(\n    object: Object3D,\n    onDone: (res: ColladaExporterResult) => void,\n    options: ColladaExporterOptions = {},\n  ): ColladaExporterResult | null {\n    this.options = { ...this.options, ...options }\n\n    if (this.options.upAxis.match(/^[XYZ]_UP$/) === null) {\n      console.error('ColladaExporter: Invalid upAxis: valid values are X_UP, Y_UP or Z_UP.')\n      return null\n    }\n\n    if (this.options.unitName !== null && this.options.unitMeter === null) {\n      console.error('ColladaExporter: unitMeter needs to be specified if unitName is specified.')\n      return null\n    }\n\n    if (this.options.unitMeter !== null && this.options.unitName === null) {\n      console.error('ColladaExporter: unitName needs to be specified if unitMeter is specified.')\n      return null\n    }\n\n    if (this.options.textureDirectory !== '') {\n      this.options.textureDirectory = `${this.options.textureDirectory}/`.replace(/\\\\/g, '/').replace(/\\/+/g, '/')\n    }\n\n    if (this.options.version !== '1.4.1' && this.options.version !== '1.5.0') {\n      console.warn(`ColladaExporter : Version ${this.options.version} not supported for export. Only 1.4.1 and 1.5.0.`)\n      return null\n    }\n\n    const libraryVisualScenes = this.processObject(object)\n\n    const specLink =\n      this.options.version === '1.4.1'\n        ? 'http://www.collada.org/2005/11/COLLADASchema'\n        : 'https://www.khronos.org/collada/'\n    let dae = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\" ?>${`<COLLADA xmlns=\"${specLink}\" version=\"${this.options.version}\">`}<asset><contributor><authoring_tool>three.js Collada Exporter</authoring_tool>${\n      this.options.author !== null ? `<author>${this.options.author}</author>` : ''\n    }</contributor>${`<created>${new Date().toISOString()}</created>`}${`<modified>${new Date().toISOString()}</modified>`}<up_axis>Y_UP</up_axis></asset>`\n\n    dae += `<library_images>${this.libraryImages.join('')}</library_images>`\n\n    dae += `<library_effects>${this.libraryEffects.join('')}</library_effects>`\n\n    dae += `<library_materials>${this.libraryMaterials.join('')}</library_materials>`\n\n    dae += `<library_geometries>${this.libraryGeometries.join('')}</library_geometries>`\n\n    dae += `<library_visual_scenes><visual_scene id=\"Scene\" name=\"scene\">${libraryVisualScenes}</visual_scene></library_visual_scenes>`\n\n    dae += '<scene><instance_visual_scene url=\"#Scene\"/></scene>'\n\n    dae += '</COLLADA>'\n\n    const res = {\n      data: this.format(dae),\n      textures: this.textures,\n    }\n\n    if (typeof onDone === 'function') {\n      requestAnimationFrame(() => onDone(res))\n    }\n\n    return res\n  }\n\n  // Convert the urdf xml into a well-formatted, indented format\n  private format(urdf: string): string {\n    const IS_END_TAG = /^<\\//\n    const IS_SELF_CLOSING = /(\\?>$)|(\\/>$)/\n    const HAS_TEXT = /<[^>]+>[^<]*<\\/[^<]+>/\n\n    const pad = (ch: string, num: number): string => (num > 0 ? ch + pad(ch, num - 1) : '')\n\n    let tagnum = 0\n\n    return (\n      urdf\n        .match(/(<[^>]+>[^<]+<\\/[^<]+>)|(<[^>]+>)/g)\n        ?.map((tag) => {\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && IS_END_TAG.test(tag)) {\n            tagnum--\n          }\n\n          const res = `${pad('  ', tagnum)}${tag}`\n\n          if (!HAS_TEXT.test(tag) && !IS_SELF_CLOSING.test(tag) && !IS_END_TAG.test(tag)) {\n            tagnum++\n          }\n\n          return res\n        })\n        .join('\\n') ?? ''\n    )\n  }\n\n  // Convert an image into a png format for saving\n  private base64ToBuffer(str: string): Uint8Array {\n    const b = atob(str)\n    const buf = new Uint8Array(b.length)\n\n    for (let i = 0, l = buf.length; i < l; i++) {\n      buf[i] = b.charCodeAt(i)\n    }\n\n    return buf\n  }\n\n  private imageToData(image: CanvasImageSource, ext: string): Uint8Array {\n    this.canvas = this.canvas || document.createElement('canvas')\n    this.ctx = this.ctx || this.canvas.getContext('2d')\n\n    this.canvas.width = image.width instanceof SVGAnimatedLength ? 0 : image.width\n    this.canvas.height = image.height instanceof SVGAnimatedLength ? 0 : image.height\n\n    this.ctx?.drawImage(image, 0, 0)\n\n    // Get the base64 encoded data\n    const base64data = this.canvas.toDataURL(`image/${ext}`, 1).replace(/^data:image\\/(png|jpg);base64,/, '')\n\n    // Convert to a uint8 array\n    return this.base64ToBuffer(base64data)\n  }\n\n  // gets the attribute array. Generate a new array if the attribute is interleaved\n  private attrBufferToArray(attr: InterleavedBufferAttribute | BufferAttribute): number[] | ArrayLike<number> {\n    if (attr instanceof InterleavedBufferAttribute && attr.isInterleavedBufferAttribute) {\n      // use the typed array constructor to save on memory\n      const TypedArrayConstructor: TypedArrayConstructors = attr.array.constructor\n      // @ts-ignore\n      const arr: number[] = new TypedArrayConstructor(attr.count * attr.itemSize)\n      const size = attr.itemSize\n\n      for (let i = 0, l = attr.count; i < l; i++) {\n        for (let j = 0; j < size; j++) {\n          arr[i * size + j] = attr[this.getFuncs[j]](i)\n        }\n      }\n\n      return arr\n    } else {\n      return attr.array\n    }\n  }\n\n  // Returns an array of the same type starting at the `st` index,\n  // and `ct` length\n  private subArray(arr: number[] | ArrayLike<number>, st: number, ct: number): TypedArray | number[] {\n    if (Array.isArray(arr)) {\n      return arr.slice(st, st + ct)\n    } else {\n      const TypedArrayConstructor: TypedArrayConstructors = arr.constructor\n      // @ts-ignore\n      return new TypedArrayConstructor(arr.buffer, st * arr.BYTES_PER_ELEMENT, ct)\n    }\n  }\n\n  // Returns the string for a geometry's attribute\n  private getAttribute(\n    attr: InterleavedBufferAttribute | BufferAttribute,\n    name: string,\n    params: string[],\n    type: string,\n  ): string {\n    const array = this.attrBufferToArray(attr)\n    const res = Array.isArray(array)\n      ? `${\n          `<source id=\"${name}\">` + `<float_array id=\"${name}-array\" count=\"${array.length}\">` + array.join(' ')\n        }</float_array><technique_common>${`<accessor source=\"#${name}-array\" count=\"${Math.floor(\n          array.length / attr.itemSize,\n        )}\" stride=\"${attr.itemSize}\">`}${params\n          .map((n) => `<param name=\"${n}\" type=\"${type}\" />`)\n          .join('')}</accessor></technique_common></source>`\n      : ''\n\n    return res\n  }\n\n  // Returns the string for a node's transform information\n  private getTransform(o: Object3D): string {\n    // ensure the object's matrix is up to date\n    // before saving the transform\n    o.updateMatrix()\n\n    this.transMat = this.transMat || new Matrix4()\n    this.transMat.copy(o.matrix)\n    this.transMat.transpose()\n    return `<matrix>${this.transMat.toArray().join(' ')}</matrix>`\n  }\n\n  // Process the given piece of geometry into the geometry library\n  // Returns the mesh id\n  private processGeometry(g: BufferGeometry): GeometryInfo {\n    let info = this.geometryInfo.get(g)\n\n    if (!info) {\n      // convert the geometry to bufferGeometry if it isn't already\n      const bufferGeometry = g\n\n      if (!bufferGeometry.isBufferGeometry) {\n        throw new Error('THREE.ColladaExporter: Geometry is not of type THREE.BufferGeometry.')\n      }\n\n      const meshid = `Mesh${this.libraryGeometries.length + 1}`\n\n      const indexCount = bufferGeometry.index\n        ? bufferGeometry.index.count * bufferGeometry.index.itemSize\n        : bufferGeometry.attributes.position.count\n\n      const groups =\n        bufferGeometry.groups != null && bufferGeometry.groups.length !== 0\n          ? bufferGeometry.groups\n          : [{ start: 0, count: indexCount, materialIndex: 0 }]\n\n      const gname = g.name ? ` name=\"${g.name}\"` : ''\n      let gnode = `<geometry id=\"${meshid}\"${gname}><mesh>`\n\n      // define the geometry node and the vertices for the geometry\n      const posName = `${meshid}-position`\n      const vertName = `${meshid}-vertices`\n      gnode += this.getAttribute(bufferGeometry.attributes.position, posName, ['X', 'Y', 'Z'], 'float')\n      gnode += `<vertices id=\"${vertName}\"><input semantic=\"POSITION\" source=\"#${posName}\" /></vertices>`\n\n      // NOTE: We're not optimizing the attribute arrays here, so they're all the same length and\n      // can therefore share the same triangle indices. However, MeshLab seems to have trouble opening\n      // models with attributes that share an offset.\n      // MeshLab Bug#424: https://sourceforge.net/p/meshlab/bugs/424/\n\n      // serialize normals\n      let triangleInputs = `<input semantic=\"VERTEX\" source=\"#${vertName}\" offset=\"0\" />`\n      if ('normal' in bufferGeometry.attributes) {\n        const normName = `${meshid}-normal`\n        gnode += this.getAttribute(bufferGeometry.attributes.normal, normName, ['X', 'Y', 'Z'], 'float')\n        triangleInputs += `<input semantic=\"NORMAL\" source=\"#${normName}\" offset=\"0\" />`\n      }\n\n      // serialize uvs\n      if ('uv' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord`\n        gnode += this.getAttribute(bufferGeometry.attributes.uv, uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"0\" />`\n      }\n\n      // serialize lightmap uvs\n      if ('uv2' in bufferGeometry.attributes) {\n        const uvName = `${meshid}-texcoord2`\n        gnode += this.getAttribute(bufferGeometry.attributes.uv2, uvName, ['S', 'T'], 'float')\n        triangleInputs += `<input semantic=\"TEXCOORD\" source=\"#${uvName}\" offset=\"0\" set=\"1\" />`\n      }\n\n      // serialize colors\n      if ('color' in bufferGeometry.attributes) {\n        const colName = `${meshid}-color`\n        gnode += this.getAttribute(bufferGeometry.attributes.color, colName, ['X', 'Y', 'Z'], 'uint8')\n        triangleInputs += `<input semantic=\"COLOR\" source=\"#${colName}\" offset=\"0\" />`\n      }\n\n      let indexArray: number[] | ArrayLike<number> | null = null\n      if (bufferGeometry.index) {\n        indexArray = this.attrBufferToArray(bufferGeometry.index)\n      } else {\n        indexArray = new Array(indexCount)\n        for (let i = 0, l = indexArray.length; i < l && Array.isArray(indexArray); i++) indexArray[i] = i\n      }\n\n      for (let i = 0, l = groups.length; i < l; i++) {\n        const group = groups[i]\n        const subarr = this.subArray(indexArray, group.start, group.count)\n        const polycount = subarr.length / 3\n        gnode += `<triangles material=\"MESH_MATERIAL_${group.materialIndex}\" count=\"${polycount}\">`\n        gnode += triangleInputs\n\n        gnode += `<p>${subarr.join(' ')}</p>`\n        gnode += '</triangles>'\n      }\n\n      gnode += '</mesh></geometry>'\n\n      this.libraryGeometries.push(gnode)\n\n      info = { meshid, bufferGeometry }\n      this.geometryInfo.set(g, info)\n    }\n\n    return info\n  }\n\n  // Process the given texture into the image library\n  // Returns the image library\n  private processTexture(tex: Texture): string {\n    let texid = this.imageMap.get(tex)\n    if (texid == null) {\n      texid = `image-${this.libraryImages.length + 1}`\n\n      const ext = 'png'\n      const name = tex.name || texid\n      let imageNode = `<image id=\"${texid}\" name=\"${name}\">`\n\n      if (this.options.version === '1.5.0') {\n        imageNode += `<init_from><ref>${this.options.textureDirectory}${name}.${ext}</ref></init_from>`\n      } else {\n        // version image node 1.4.1\n        imageNode += `<init_from>${this.options.textureDirectory}${name}.${ext}</init_from>`\n      }\n\n      imageNode += '</image>'\n\n      this.libraryImages.push(imageNode)\n      this.imageMap.set(tex, texid)\n      this.textures.push({\n        directory: this.options.textureDirectory,\n        name,\n        ext,\n        data: this.imageToData(tex.image, ext),\n        original: tex,\n      })\n    }\n\n    return texid\n  }\n\n  // Process the given material into the material and effect libraries\n  // Returns the material id\n  private processMaterial(m: MaterialRepresentation): string {\n    let matid = this.materialMap.get(m)\n\n    if (matid == null) {\n      matid = `Mat${this.libraryEffects.length + 1}`\n\n      let type = 'phong'\n\n      if (m instanceof MeshLambertMaterial) {\n        type = 'lambert'\n      } else if (m instanceof MeshBasicMaterial) {\n        type = 'constant'\n\n        if (m.map !== null) {\n          // The Collada spec does not support diffuse texture maps with the\n          // constant shader type.\n          // mrdoob/three.js#15469\n          console.warn('ColladaExporter: Texture maps not supported with MeshBasicMaterial.')\n        }\n      }\n\n      if (m instanceof MeshPhongMaterial) {\n        const emissive = m.emissive ? m.emissive : new Color(0, 0, 0)\n        const diffuse = m.color ? m.color : new Color(0, 0, 0)\n        const specular = m.specular ? m.specular : new Color(1, 1, 1)\n        const shininess = m.shininess || 0\n        const reflectivity = m.reflectivity || 0\n\n        // Do not export and alpha map for the reasons mentioned in issue (#13792)\n        // in three.js alpha maps are black and white, but collada expects the alpha\n        // channel to specify the transparency\n        let transparencyNode = ''\n        if (m.transparent) {\n          transparencyNode += `<transparent>${\n            m.map ? '<texture texture=\"diffuse-sampler\"></texture>' : '<float>1</float>'\n          }</transparent>`\n\n          if (m.opacity < 1) {\n            transparencyNode += `<transparency><float>${m.opacity}</float></transparency>`\n          }\n        }\n\n        const techniqueNode = `${`<technique sid=\"common\"><${type}>`}<emission>${\n          m.emissiveMap\n            ? '<texture texture=\"emissive-sampler\" texcoord=\"TEXCOORD\" />'\n            : `<color sid=\"emission\">${emissive.r} ${emissive.g} ${emissive.b} 1</color>`\n        }</emission>${\n          type !== 'constant'\n            ? `<diffuse>${\n                m.map\n                  ? '<texture texture=\"diffuse-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<color sid=\"diffuse\">${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color>`\n              }</diffuse>`\n            : ''\n        }${\n          type !== 'constant'\n            ? `<bump>${m.normalMap ? '<texture texture=\"bump-sampler\" texcoord=\"TEXCOORD\" />' : ''}</bump>`\n            : ''\n        }${\n          type === 'phong'\n            ? `${`<specular><color sid=\"specular\">${specular.r} ${specular.g} ${specular.b} 1</color></specular>`}<shininess>${\n                m.specularMap\n                  ? '<texture texture=\"specular-sampler\" texcoord=\"TEXCOORD\" />'\n                  : `<float sid=\"shininess\">${shininess}</float>`\n              }</shininess>`\n            : ''\n        }${`<reflective><color>${diffuse.r} ${diffuse.g} ${diffuse.b} 1</color></reflective>`}${`<reflectivity><float>${reflectivity}</float></reflectivity>`}${transparencyNode}${`</${type}></technique>`}`\n\n        const effectnode = `${`<effect id=\"${matid}-effect\">`}<profile_COMMON>${\n          m.map\n            ? `<newparam sid=\"diffuse-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.map,\n              )}</init_from>`}</surface></newparam><newparam sid=\"diffuse-sampler\"><sampler2D><source>diffuse-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.specularMap\n            ? `<newparam sid=\"specular-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.specularMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"specular-sampler\"><sampler2D><source>specular-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.emissiveMap\n            ? `<newparam sid=\"emissive-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.emissiveMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"emissive-sampler\"><sampler2D><source>emissive-surface</source></sampler2D></newparam>`\n            : ''\n        }${\n          m.normalMap\n            ? `<newparam sid=\"bump-surface\"><surface type=\"2D\">${`<init_from>${this.processTexture(\n                m.normalMap,\n              )}</init_from>`}</surface></newparam><newparam sid=\"bump-sampler\"><sampler2D><source>bump-surface</source></sampler2D></newparam>`\n            : ''\n        }${techniqueNode}${\n          m.side === DoubleSide\n            ? '<extra><technique profile=\"THREEJS\"><double_sided sid=\"double_sided\" type=\"int\">1</double_sided></technique></extra>'\n            : ''\n        }</profile_COMMON></effect>`\n\n        const materialName = m.name ? ` name=\"${m.name}\"` : ''\n        const materialNode = `<material id=\"${matid}\"${materialName}><instance_effect url=\"#${matid}-effect\" /></material>`\n\n        this.libraryMaterials.push(materialNode)\n        this.libraryEffects.push(effectnode)\n        this.materialMap.set(m, matid)\n      }\n    }\n\n    return matid\n  }\n\n  // Recursively process the object into a scene\n  private processObject(o: Object3D): string {\n    let node = `<node name=\"${o.name}\">`\n\n    node += this.getTransform(o)\n    const a: Mesh<BufferGeometry, Material | Material[]> = new Mesh()\n    a.geometry\n\n    if (o instanceof Mesh && o.isMesh && o.geometry !== null) {\n      // function returns the id associated with the mesh and a \"BufferGeometry\" version\n      // of the geometry in case it's not a geometry.\n      const geomInfo = this.processGeometry(o.geometry)\n      const meshid = geomInfo.meshid\n      const geometry = geomInfo.bufferGeometry\n\n      // ids of the materials to bind to the geometry\n      let matids = null\n      let matidsArray\n\n      // get a list of materials to bind to the sub groups of the geometry.\n      // If the amount of subgroups is greater than the materials, than reuse\n      // the materials.\n      const mat: MaterialRepresentation | MaterialRepresentation[] = o.material || new MeshBasicMaterial()\n      const materials = Array.isArray(mat) ? mat : [mat]\n\n      if (geometry.groups.length > materials.length) {\n        matidsArray = new Array(geometry.groups.length)\n      } else {\n        matidsArray = new Array(materials.length)\n      }\n\n      matids = matidsArray.fill(null).map((_, i) => this.processMaterial(materials[i % materials.length]))\n\n      node += `${\n        `<instance_geometry url=\"#${meshid}\">` +\n        (matids != null\n          ? `<bind_material><technique_common>${matids\n              .map(\n                (id, i) =>\n                  `${`<instance_material symbol=\"MESH_MATERIAL_${i}\" target=\"#${id}\" >`}<bind_vertex_input semantic=\"TEXCOORD\" input_semantic=\"TEXCOORD\" input_set=\"0\" /></instance_material>`,\n              )\n              .join('')}</technique_common></bind_material>`\n          : '')\n      }</instance_geometry>`\n    }\n\n    o.children.forEach((c) => (node += this.processObject(c)))\n\n    node += '</node>'\n\n    return node\n  }\n}\n\nexport { ColladaExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}