{"ast":null,"code":"import { Triangle, Vector3 } from 'three';\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nvar MeshSurfaceSampler = function () {\n  var _face = new Triangle();\n\n  var _color = new Vector3();\n\n  function MeshSurfaceSampler(mesh) {\n    var geometry = mesh.geometry;\n\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n    }\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n      geometry = geometry.toNonIndexed();\n    }\n\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n\n  MeshSurfaceSampler.prototype = {\n    constructor: MeshSurfaceSampler,\n    setWeightAttribute: function setWeightAttribute(name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    },\n    build: function build() {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\n\n      for (var i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n\n        _face.a.fromBufferAttribute(positionAttribute, i);\n\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      } // Store cumulative total face weights in an array, where weight index\n      // corresponds to face index.\n\n\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n\n      for (var _i = 0; _i < faceWeights.length; _i++) {\n        cumulativeTotal += faceWeights[_i];\n        this.distribution[_i] = cumulativeTotal;\n      }\n\n      return this;\n    },\n    setRandomGenerator: function setRandomGenerator(randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    },\n    sample: function sample(targetPosition, targetNormal, targetColor) {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    },\n    binarySearch: function binarySearch(x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n\n      return index;\n    },\n    sampleFace: function sampleFace(faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n      if (targetNormal !== undefined) {\n        _face.getNormal(targetNormal);\n      }\n\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n\n      return this;\n    }\n  };\n  return MeshSurfaceSampler;\n}();\n\nexport { MeshSurfaceSampler };","map":{"version":3,"names":["Triangle","Vector3","MeshSurfaceSampler","_face","_color","mesh","geometry","isBufferGeometry","attributes","position","itemSize","Error","index","console","warn","toNonIndexed","randomFunction","Math","random","positionAttribute","getAttribute","colorAttribute","weightAttribute","distribution","prototype","constructor","setWeightAttribute","name","build","faceWeights","Float32Array","count","i","faceWeight","getX","a","fromBufferAttribute","b","c","getArea","cumulativeTotal","length","setRandomGenerator","sample","targetPosition","targetNormal","targetColor","faceIndex","binarySearch","sampleFace","x","dist","start","end","mid","ceil","u","v","set","addScaledVector","undefined","getNormal","r","g","y","z"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/math/MeshSurfaceSampler.js"],"sourcesContent":["import { Triangle, Vector3 } from 'three';\n\n/**\n * Utility class for sampling weighted random points on the surface of a mesh.\n *\n * Building the sampler is a one-time O(n) operation. Once built, any number of\n * random samples may be selected in O(logn) time. Memory usage is O(n).\n *\n * References:\n * - http://www.joesfer.com/?p=84\n * - https://stackoverflow.com/a/4322940/1314762\n */\n\nvar MeshSurfaceSampler = function () {\n  var _face = new Triangle();\n\n  var _color = new Vector3();\n\n  function MeshSurfaceSampler(mesh) {\n    var geometry = mesh.geometry;\n\n    if (!geometry.isBufferGeometry || geometry.attributes.position.itemSize !== 3) {\n      throw new Error('THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh.');\n    }\n\n    if (geometry.index) {\n      console.warn('THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.');\n      geometry = geometry.toNonIndexed();\n    }\n\n    this.geometry = geometry;\n    this.randomFunction = Math.random;\n    this.positionAttribute = this.geometry.getAttribute('position');\n    this.colorAttribute = this.geometry.getAttribute('color');\n    this.weightAttribute = null;\n    this.distribution = null;\n  }\n\n  MeshSurfaceSampler.prototype = {\n    constructor: MeshSurfaceSampler,\n    setWeightAttribute: function (name) {\n      this.weightAttribute = name ? this.geometry.getAttribute(name) : null;\n      return this;\n    },\n    build: function () {\n      var positionAttribute = this.positionAttribute;\n      var weightAttribute = this.weightAttribute;\n      var faceWeights = new Float32Array(positionAttribute.count / 3); // Accumulate weights for each mesh face.\n\n      for (let i = 0; i < positionAttribute.count; i += 3) {\n        var faceWeight = 1;\n\n        if (weightAttribute) {\n          faceWeight = weightAttribute.getX(i) + weightAttribute.getX(i + 1) + weightAttribute.getX(i + 2);\n        }\n\n        _face.a.fromBufferAttribute(positionAttribute, i);\n\n        _face.b.fromBufferAttribute(positionAttribute, i + 1);\n\n        _face.c.fromBufferAttribute(positionAttribute, i + 2);\n\n        faceWeight *= _face.getArea();\n        faceWeights[i / 3] = faceWeight;\n      } // Store cumulative total face weights in an array, where weight index\n      // corresponds to face index.\n\n\n      this.distribution = new Float32Array(positionAttribute.count / 3);\n      var cumulativeTotal = 0;\n\n      for (let i = 0; i < faceWeights.length; i++) {\n        cumulativeTotal += faceWeights[i];\n        this.distribution[i] = cumulativeTotal;\n      }\n\n      return this;\n    },\n    setRandomGenerator: function (randomFunction) {\n      this.randomFunction = randomFunction;\n      return this;\n    },\n    sample: function (targetPosition, targetNormal, targetColor) {\n      var cumulativeTotal = this.distribution[this.distribution.length - 1];\n      var faceIndex = this.binarySearch(this.randomFunction() * cumulativeTotal);\n      return this.sampleFace(faceIndex, targetPosition, targetNormal, targetColor);\n    },\n    binarySearch: function (x) {\n      var dist = this.distribution;\n      var start = 0;\n      var end = dist.length - 1;\n      var index = -1;\n\n      while (start <= end) {\n        var mid = Math.ceil((start + end) / 2);\n\n        if (mid === 0 || dist[mid - 1] <= x && dist[mid] > x) {\n          index = mid;\n          break;\n        } else if (x < dist[mid]) {\n          end = mid - 1;\n        } else {\n          start = mid + 1;\n        }\n      }\n\n      return index;\n    },\n    sampleFace: function (faceIndex, targetPosition, targetNormal, targetColor) {\n      var u = this.randomFunction();\n      var v = this.randomFunction();\n\n      if (u + v > 1) {\n        u = 1 - u;\n        v = 1 - v;\n      }\n\n      _face.a.fromBufferAttribute(this.positionAttribute, faceIndex * 3);\n\n      _face.b.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 1);\n\n      _face.c.fromBufferAttribute(this.positionAttribute, faceIndex * 3 + 2);\n\n      targetPosition.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n      if (targetNormal !== undefined) {\n        _face.getNormal(targetNormal);\n      }\n\n      if (targetColor !== undefined && this.colorAttribute !== undefined) {\n        _face.a.fromBufferAttribute(this.colorAttribute, faceIndex * 3);\n\n        _face.b.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 1);\n\n        _face.c.fromBufferAttribute(this.colorAttribute, faceIndex * 3 + 2);\n\n        _color.set(0, 0, 0).addScaledVector(_face.a, u).addScaledVector(_face.b, v).addScaledVector(_face.c, 1 - (u + v));\n\n        targetColor.r = _color.x;\n        targetColor.g = _color.y;\n        targetColor.b = _color.z;\n      }\n\n      return this;\n    }\n  };\n  return MeshSurfaceSampler;\n}();\n\nexport { MeshSurfaceSampler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}