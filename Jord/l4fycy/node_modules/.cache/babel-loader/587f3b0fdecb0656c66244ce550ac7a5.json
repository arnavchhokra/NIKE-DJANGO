{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeProduction = exports.serializeGrammar = exports.Terminal = exports.Alternation = exports.RepetitionWithSeparator = exports.Repetition = exports.RepetitionMandatoryWithSeparator = exports.RepetitionMandatory = exports.Option = exports.Alternative = exports.Rule = exports.NonTerminal = exports.AbstractProduction = void 0;\n\nvar map_1 = __importDefault(require(\"lodash/map\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar isString_1 = __importDefault(require(\"lodash/isString\"));\n\nvar isRegExp_1 = __importDefault(require(\"lodash/isRegExp\"));\n\nvar pickBy_1 = __importDefault(require(\"lodash/pickBy\"));\n\nvar assign_1 = __importDefault(require(\"lodash/assign\")); // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n\n\nfunction tokenLabel(tokType) {\n  if (hasTokenLabel(tokType)) {\n    return tokType.LABEL;\n  } else {\n    return tokType.name;\n  }\n} // TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\n\n\nfunction hasTokenLabel(obj) {\n  return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== \"\";\n}\n\nvar AbstractProduction =\n/** @class */\nfunction () {\n  function AbstractProduction(_definition) {\n    this._definition = _definition;\n  }\n\n  Object.defineProperty(AbstractProduction.prototype, \"definition\", {\n    get: function get() {\n      return this._definition;\n    },\n    set: function set(value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  AbstractProduction.prototype.accept = function (visitor) {\n    visitor.visit(this);\n    (0, forEach_1.default)(this.definition, function (prod) {\n      prod.accept(visitor);\n    });\n  };\n\n  return AbstractProduction;\n}();\n\nexports.AbstractProduction = AbstractProduction;\n\nvar NonTerminal =\n/** @class */\nfunction (_super) {\n  __extends(NonTerminal, _super);\n\n  function NonTerminal(options) {\n    var _this = _super.call(this, []) || this;\n\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  Object.defineProperty(NonTerminal.prototype, \"definition\", {\n    get: function get() {\n      if (this.referencedRule !== undefined) {\n        return this.referencedRule.definition;\n      }\n\n      return [];\n    },\n    set: function set(definition) {// immutable\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  NonTerminal.prototype.accept = function (visitor) {\n    visitor.visit(this); // don't visit children of a reference, we will get cyclic infinite loops if we do so\n  };\n\n  return NonTerminal;\n}(AbstractProduction);\n\nexports.NonTerminal = NonTerminal;\n\nvar Rule =\n/** @class */\nfunction (_super) {\n  __extends(Rule, _super);\n\n  function Rule(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.orgText = \"\";\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Rule;\n}(AbstractProduction);\n\nexports.Rule = Rule;\n\nvar Alternative =\n/** @class */\nfunction (_super) {\n  __extends(Alternative, _super);\n\n  function Alternative(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.ignoreAmbiguities = false;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Alternative;\n}(AbstractProduction);\n\nexports.Alternative = Alternative;\n\nvar Option =\n/** @class */\nfunction (_super) {\n  __extends(Option, _super);\n\n  function Option(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Option;\n}(AbstractProduction);\n\nexports.Option = Option;\n\nvar RepetitionMandatory =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionMandatory, _super);\n\n  function RepetitionMandatory(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return RepetitionMandatory;\n}(AbstractProduction);\n\nexports.RepetitionMandatory = RepetitionMandatory;\n\nvar RepetitionMandatoryWithSeparator =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionMandatoryWithSeparator, _super);\n\n  function RepetitionMandatoryWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return RepetitionMandatoryWithSeparator;\n}(AbstractProduction);\n\nexports.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;\n\nvar Repetition =\n/** @class */\nfunction (_super) {\n  __extends(Repetition, _super);\n\n  function Repetition(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return Repetition;\n}(AbstractProduction);\n\nexports.Repetition = Repetition;\n\nvar RepetitionWithSeparator =\n/** @class */\nfunction (_super) {\n  __extends(RepetitionWithSeparator, _super);\n\n  function RepetitionWithSeparator(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  return RepetitionWithSeparator;\n}(AbstractProduction);\n\nexports.RepetitionWithSeparator = RepetitionWithSeparator;\n\nvar Alternation =\n/** @class */\nfunction (_super) {\n  __extends(Alternation, _super);\n\n  function Alternation(options) {\n    var _this = _super.call(this, options.definition) || this;\n\n    _this.idx = 1;\n    _this.ignoreAmbiguities = false;\n    _this.hasPredicates = false;\n    (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n    return _this;\n  }\n\n  Object.defineProperty(Alternation.prototype, \"definition\", {\n    get: function get() {\n      return this._definition;\n    },\n    set: function set(value) {\n      this._definition = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Alternation;\n}(AbstractProduction);\n\nexports.Alternation = Alternation;\n\nvar Terminal =\n/** @class */\nfunction () {\n  function Terminal(options) {\n    this.idx = 1;\n    (0, assign_1.default)(this, (0, pickBy_1.default)(options, function (v) {\n      return v !== undefined;\n    }));\n  }\n\n  Terminal.prototype.accept = function (visitor) {\n    visitor.visit(this);\n  };\n\n  return Terminal;\n}();\n\nexports.Terminal = Terminal;\n\nfunction serializeGrammar(topRules) {\n  return (0, map_1.default)(topRules, serializeProduction);\n}\n\nexports.serializeGrammar = serializeGrammar;\n\nfunction serializeProduction(node) {\n  function convertDefinition(definition) {\n    return (0, map_1.default)(definition, serializeProduction);\n  }\n  /* istanbul ignore else */\n\n\n  if (node instanceof NonTerminal) {\n    var serializedNonTerminal = {\n      type: \"NonTerminal\",\n      name: node.nonTerminalName,\n      idx: node.idx\n    };\n\n    if ((0, isString_1.default)(node.label)) {\n      serializedNonTerminal.label = node.label;\n    }\n\n    return serializedNonTerminal;\n  } else if (node instanceof Alternative) {\n    return {\n      type: \"Alternative\",\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Option) {\n    return {\n      type: \"Option\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatory) {\n    return {\n      type: \"RepetitionMandatory\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\n    return {\n      type: \"RepetitionMandatoryWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof RepetitionWithSeparator) {\n    return {\n      type: \"RepetitionWithSeparator\",\n      idx: node.idx,\n      separator: serializeProduction(new Terminal({\n        terminalType: node.separator\n      })),\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Repetition) {\n    return {\n      type: \"Repetition\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Alternation) {\n    return {\n      type: \"Alternation\",\n      idx: node.idx,\n      definition: convertDefinition(node.definition)\n    };\n  } else if (node instanceof Terminal) {\n    var serializedTerminal = {\n      type: \"Terminal\",\n      name: node.terminalType.name,\n      label: tokenLabel(node.terminalType),\n      idx: node.idx\n    };\n\n    if ((0, isString_1.default)(node.label)) {\n      serializedTerminal.terminalLabel = node.label;\n    }\n\n    var pattern = node.terminalType.PATTERN;\n\n    if (node.terminalType.PATTERN) {\n      serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;\n    }\n\n    return serializedTerminal;\n  } else if (node instanceof Rule) {\n    return {\n      type: \"Rule\",\n      name: node.name,\n      orgText: node.orgText,\n      definition: convertDefinition(node.definition)\n    };\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.serializeProduction = serializeProduction;","map":{"version":3,"mappings":"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","names":["tokenLabel","tokType","hasTokenLabel","LABEL","name","obj","_definition","Object","AbstractProduction","value","visitor","visit","definition","prod","accept","exports","__extends","options","_super","_this","v","undefined","NonTerminal","referencedRule","Alternation","Terminal","serializeGrammar","topRules","serializeProduction","node","convertDefinition","serializedNonTerminal","type","nonTerminalName","idx","label","Alternative","Option","RepetitionMandatory","RepetitionMandatoryWithSeparator","separator","terminalType","RepetitionWithSeparator","Repetition","serializedTerminal","terminalLabel","pattern","PATTERN","source","Rule","orgText","Error"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\@chevrotain\\gast\\src\\model.ts"],"sourcesContent":["import map from \"lodash/map\"\r\nimport forEach from \"lodash/forEach\"\r\nimport isString from \"lodash/isString\"\r\nimport isRegExp from \"lodash/isRegExp\"\r\nimport pickBy from \"lodash/pickBy\"\r\nimport assign from \"lodash/assign\"\r\nimport {\r\n  IGASTVisitor,\r\n  IProduction,\r\n  IProductionWithOccurrence,\r\n  ISerializedGast,\r\n  TokenType\r\n} from \"@chevrotain/types\"\r\n\r\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\r\nfunction tokenLabel(tokType: TokenType): string {\r\n  if (hasTokenLabel(tokType)) {\r\n    return tokType.LABEL\r\n  } else {\r\n    return tokType.name\r\n  }\r\n}\r\n\r\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\r\nfunction hasTokenLabel(\r\n  obj: TokenType\r\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\r\n  return isString(obj.LABEL) && obj.LABEL !== \"\"\r\n}\r\n\r\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\r\n  implements IProduction\r\n{\r\n  public get definition(): T[] {\r\n    return this._definition\r\n  }\r\n  public set definition(value: T[]) {\r\n    this._definition = value\r\n  }\r\n\r\n  constructor(protected _definition: T[]) {}\r\n\r\n  accept(visitor: IGASTVisitor): void {\r\n    visitor.visit(this)\r\n    forEach(this.definition, (prod) => {\r\n      prod.accept(visitor)\r\n    })\r\n  }\r\n}\r\n\r\nexport class NonTerminal\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public nonTerminalName!: string\r\n  public label?: string\r\n  public referencedRule!: Rule\r\n  public idx: number = 1\r\n\r\n  constructor(options: {\r\n    nonTerminalName: string\r\n    label?: string\r\n    referencedRule?: Rule\r\n    idx?: number\r\n  }) {\r\n    super([])\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n\r\n  set definition(definition: IProduction[]) {\r\n    // immutable\r\n  }\r\n\r\n  get definition(): IProduction[] {\r\n    if (this.referencedRule !== undefined) {\r\n      return this.referencedRule.definition\r\n    }\r\n    return []\r\n  }\r\n\r\n  accept(visitor: IGASTVisitor): void {\r\n    visitor.visit(this)\r\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\r\n  }\r\n}\r\n\r\nexport class Rule extends AbstractProduction {\r\n  public name!: string\r\n  public orgText: string = \"\"\r\n\r\n  constructor(options: {\r\n    name: string\r\n    definition: IProduction[]\r\n    orgText?: string\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class Alternative extends AbstractProduction {\r\n  public ignoreAmbiguities: boolean = false\r\n\r\n  constructor(options: {\r\n    definition: IProduction[]\r\n    ignoreAmbiguities?: boolean\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class Option\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public idx: number = 1\r\n  public maxLookahead?: number\r\n\r\n  constructor(options: {\r\n    definition: IProduction[]\r\n    idx?: number\r\n    maxLookahead?: number\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class RepetitionMandatory\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public idx: number = 1\r\n  public maxLookahead?: number\r\n\r\n  constructor(options: {\r\n    definition: IProduction[]\r\n    idx?: number\r\n    maxLookahead?: number\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class RepetitionMandatoryWithSeparator\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public separator!: TokenType\r\n  public idx: number = 1\r\n  public maxLookahead?: number\r\n\r\n  constructor(options: {\r\n    definition: IProduction[]\r\n    separator: TokenType\r\n    idx?: number\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class Repetition\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public separator!: TokenType\r\n  public idx: number = 1\r\n  public maxLookahead?: number\r\n\r\n  constructor(options: {\r\n    definition: IProduction[]\r\n    idx?: number\r\n    maxLookahead?: number\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class RepetitionWithSeparator\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public separator!: TokenType\r\n  public idx: number = 1\r\n  public maxLookahead?: number\r\n\r\n  constructor(options: {\r\n    definition: IProduction[]\r\n    separator: TokenType\r\n    idx?: number\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class Alternation\r\n  extends AbstractProduction<Alternative>\r\n  implements IProductionWithOccurrence\r\n{\r\n  public idx: number = 1\r\n  public ignoreAmbiguities: boolean = false\r\n  public hasPredicates: boolean = false\r\n  public maxLookahead?: number\r\n\r\n  public get definition(): Alternative[] {\r\n    return this._definition\r\n  }\r\n  public set definition(value: Alternative[]) {\r\n    this._definition = value\r\n  }\r\n\r\n  constructor(options: {\r\n    definition: Alternative[]\r\n    idx?: number\r\n    ignoreAmbiguities?: boolean\r\n    hasPredicates?: boolean\r\n    maxLookahead?: number\r\n  }) {\r\n    super(options.definition)\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n}\r\n\r\nexport class Terminal implements IProductionWithOccurrence {\r\n  public terminalType!: TokenType\r\n  public label?: string\r\n  public idx: number = 1\r\n\r\n  constructor(options: {\r\n    terminalType: TokenType\r\n    label?: string\r\n    idx?: number\r\n  }) {\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined)\r\n    )\r\n  }\r\n\r\n  accept(visitor: IGASTVisitor): void {\r\n    visitor.visit(this)\r\n  }\r\n}\r\n\r\nexport interface ISerializedBasic extends ISerializedGast {\r\n  type:\r\n    | \"Alternative\"\r\n    | \"Option\"\r\n    | \"RepetitionMandatory\"\r\n    | \"Repetition\"\r\n    | \"Alternation\"\r\n  idx?: number\r\n}\r\n\r\nexport interface ISerializedGastRule extends ISerializedGast {\r\n  type: \"Rule\"\r\n  name: string\r\n  orgText: string\r\n}\r\n\r\nexport interface ISerializedNonTerminal extends ISerializedGast {\r\n  type: \"NonTerminal\"\r\n  name: string\r\n  label?: string\r\n  idx: number\r\n}\r\n\r\nexport interface ISerializedTerminal extends ISerializedGast {\r\n  type: \"Terminal\"\r\n  name: string\r\n  terminalLabel?: string\r\n  label?: string\r\n  pattern?: string\r\n  idx: number\r\n}\r\n\r\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\r\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\"\r\n  idx: number\r\n  separator: ISerializedTerminal\r\n}\r\n\r\nexport type ISerializedGastAny =\r\n  | ISerializedBasic\r\n  | ISerializedGastRule\r\n  | ISerializedNonTerminal\r\n  | ISerializedTerminal\r\n  | ISerializedTerminalWithSeparator\r\n\r\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\r\n  return map(topRules, serializeProduction)\r\n}\r\n\r\nexport function serializeProduction(node: IProduction): ISerializedGast {\r\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\r\n    return map(definition, serializeProduction)\r\n  }\r\n  /* istanbul ignore else */\r\n  if (node instanceof NonTerminal) {\r\n    const serializedNonTerminal: ISerializedNonTerminal = {\r\n      type: \"NonTerminal\",\r\n      name: node.nonTerminalName,\r\n      idx: node.idx\r\n    }\r\n\r\n    if (isString(node.label)) {\r\n      serializedNonTerminal.label = node.label\r\n    }\r\n\r\n    return serializedNonTerminal\r\n  } else if (node instanceof Alternative) {\r\n    return <ISerializedBasic>{\r\n      type: \"Alternative\",\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else if (node instanceof Option) {\r\n    return <ISerializedBasic>{\r\n      type: \"Option\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else if (node instanceof RepetitionMandatory) {\r\n    return <ISerializedBasic>{\r\n      type: \"RepetitionMandatory\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\r\n    return <ISerializedTerminalWithSeparator>{\r\n      type: \"RepetitionMandatoryWithSeparator\",\r\n      idx: node.idx,\r\n      separator: <ISerializedTerminal>(\r\n        serializeProduction(new Terminal({ terminalType: node.separator }))\r\n      ),\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else if (node instanceof RepetitionWithSeparator) {\r\n    return <ISerializedTerminalWithSeparator>{\r\n      type: \"RepetitionWithSeparator\",\r\n      idx: node.idx,\r\n      separator: <ISerializedTerminal>(\r\n        serializeProduction(new Terminal({ terminalType: node.separator }))\r\n      ),\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else if (node instanceof Repetition) {\r\n    return <ISerializedBasic>{\r\n      type: \"Repetition\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else if (node instanceof Alternation) {\r\n    return <ISerializedBasic>{\r\n      type: \"Alternation\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else if (node instanceof Terminal) {\r\n    const serializedTerminal = <ISerializedTerminal>{\r\n      type: \"Terminal\",\r\n      name: node.terminalType.name,\r\n      label: tokenLabel(node.terminalType),\r\n      idx: node.idx\r\n    }\r\n\r\n    if (isString(node.label)) {\r\n      serializedTerminal.terminalLabel = node.label\r\n    }\r\n\r\n    const pattern = node.terminalType.PATTERN\r\n    if (node.terminalType.PATTERN) {\r\n      serializedTerminal.pattern = isRegExp(pattern)\r\n        ? (<any>pattern).source\r\n        : pattern\r\n    }\r\n\r\n    return serializedTerminal\r\n  } else if (node instanceof Rule) {\r\n    return <ISerializedGastRule>{\r\n      type: \"Rule\",\r\n      name: node.name,\r\n      orgText: node.orgText,\r\n      definition: convertDefinition(node.definition)\r\n    }\r\n  } else {\r\n    throw Error(\"non exhaustive match\")\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}