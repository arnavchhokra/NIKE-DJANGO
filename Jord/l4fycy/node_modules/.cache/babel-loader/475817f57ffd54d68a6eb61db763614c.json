{"ast":null,"code":"import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from 'three';\n/**\r\n * This class has been made to hold a slice of a volume data\r\n * @class\r\n * @param   {Volume} volume    The associated volume\r\n * @param   {number}       [index=0] The index of the slice\r\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\r\n * @see Volume\r\n */\n\nvar VolumeSlice = function VolumeSlice(volume, index, axis) {\n  var slice = this;\n  /**\r\n   * @member {Volume} volume The associated volume\r\n   */\n\n  this.volume = volume;\n  /**\r\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\r\n   */\n\n  index = index || 0;\n  Object.defineProperty(this, 'index', {\n    get: function get() {\n      return index;\n    },\n    set: function set(value) {\n      index = value;\n      slice.geometryNeedsUpdate = true;\n      return index;\n    }\n  });\n  /**\r\n   * @member {String} axis The normal axis\r\n   */\n\n  this.axis = axis || 'z';\n  /**\r\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\r\n   */\n\n  /**\r\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\r\n   */\n\n  this.canvas = document.createElement('canvas');\n  /**\r\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\r\n   */\n\n  /**\r\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\r\n   */\n\n  this.canvasBuffer = document.createElement('canvas');\n  this.updateGeometry();\n  var canvasMap = new Texture(this.canvas);\n  canvasMap.minFilter = LinearFilter;\n  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n  var material = new MeshBasicMaterial({\n    map: canvasMap,\n    side: DoubleSide,\n    transparent: true\n  });\n  /**\r\n   * @member {Mesh} mesh The mesh ready to get used in the scene\r\n   */\n\n  this.mesh = new Mesh(this.geometry, material);\n  this.mesh.matrixAutoUpdate = false;\n  /**\r\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\r\n   */\n\n  this.geometryNeedsUpdate = true;\n  this.repaint();\n  /**\r\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\r\n   */\n\n  /**\r\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\r\n   */\n\n  /**\r\n   * @member {Function} sliceAccess Function that allow the slice to access right data\r\n   * @see Volume.extractPerpendicularPlane\r\n   * @param {Number} i The first coordinate\r\n   * @param {Number} j The second coordinate\r\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\r\n   */\n};\n\nVolumeSlice.prototype = {\n  constructor: VolumeSlice,\n\n  /**\r\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\r\n   * @memberof VolumeSlice\r\n   */\n  repaint: function repaint() {\n    if (this.geometryNeedsUpdate) {\n      this.updateGeometry();\n    }\n\n    var iLength = this.iLength,\n        jLength = this.jLength,\n        sliceAccess = this.sliceAccess,\n        volume = this.volume,\n        canvas = this.canvasBuffer,\n        ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\n\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\n    var data = imgData.data;\n    var volumeData = volume.data;\n    var upperThreshold = volume.upperThreshold;\n    var lowerThreshold = volume.lowerThreshold;\n    var windowLow = volume.windowLow;\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\n\n    var pixelCount = 0;\n\n    if (volume.dataType === 'label') {\n      //this part is currently useless but will be used when colortables will be handled\n      for (var j = 0; j < jLength; j++) {\n        for (var i = 0; i < iLength; i++) {\n          var label = volumeData[sliceAccess(i, j)];\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\n          var color = this.colorMap[label];\n          data[4 * pixelCount] = color >> 24 & 0xff;\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\n          data[4 * pixelCount + 3] = color & 0xff;\n          pixelCount++;\n        }\n      }\n    } else {\n      for (var _j = 0; _j < jLength; _j++) {\n        for (var _i = 0; _i < iLength; _i++) {\n          var value = volumeData[sliceAccess(_i, _j)];\n          var alpha = 0xff; //apply threshold\n\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\n\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\n          data[4 * pixelCount] = value;\n          data[4 * pixelCount + 1] = value;\n          data[4 * pixelCount + 2] = value;\n          data[4 * pixelCount + 3] = alpha;\n          pixelCount++;\n        }\n      }\n    }\n\n    ctx.putImageData(imgData, 0, 0);\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\n    this.mesh.material.map.needsUpdate = true;\n  },\n\n  /**\r\n   * @member {Function} Refresh the geometry according to axis and index\r\n   * @see Volume.extractPerpendicularPlane\r\n   * @memberof VolumeSlice\r\n   */\n  updateGeometry: function updateGeometry() {\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\n    this.sliceAccess = extracted.sliceAccess;\n    this.jLength = extracted.jLength;\n    this.iLength = extracted.iLength;\n    this.matrix = extracted.matrix;\n    this.canvas.width = extracted.planeWidth;\n    this.canvas.height = extracted.planeHeight;\n    this.canvasBuffer.width = this.iLength;\n    this.canvasBuffer.height = this.jLength;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\n\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\n\n    if (this.mesh) {\n      this.mesh.geometry = this.geometry; //reset mesh matrix\n\n      this.mesh.matrix.identity();\n      this.mesh.applyMatrix4(this.matrix);\n    }\n\n    this.geometryNeedsUpdate = false;\n  }\n};\nexport { VolumeSlice };","map":{"version":3,"names":["Texture","LinearFilter","ClampToEdgeWrapping","MeshBasicMaterial","DoubleSide","Mesh","PlaneGeometry","VolumeSlice","volume","index","axis","slice","Object","defineProperty","get","set","value","geometryNeedsUpdate","canvas","document","createElement","canvasBuffer","updateGeometry","canvasMap","minFilter","wrapS","wrapT","material","map","side","transparent","mesh","geometry","matrixAutoUpdate","repaint","prototype","constructor","iLength","jLength","sliceAccess","ctx","ctxBuffer","imgData","getImageData","data","volumeData","upperThreshold","lowerThreshold","windowLow","windowHigh","pixelCount","dataType","j","i","label","colorMap","length","color","alpha","Math","floor","putImageData","drawImage","width","height","needsUpdate","extracted","extractPerpendicularPlane","matrix","planeWidth","planeHeight","getContext","dispose","identity","applyMatrix4"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/misc/VolumeSlice.js"],"sourcesContent":["import { Texture, LinearFilter, ClampToEdgeWrapping, MeshBasicMaterial, DoubleSide, Mesh, PlaneGeometry } from 'three';\r\n\r\n/**\r\n * This class has been made to hold a slice of a volume data\r\n * @class\r\n * @param   {Volume} volume    The associated volume\r\n * @param   {number}       [index=0] The index of the slice\r\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\r\n * @see Volume\r\n */\r\n\r\nvar VolumeSlice = function (volume, index, axis) {\r\n  var slice = this;\r\n  /**\r\n   * @member {Volume} volume The associated volume\r\n   */\r\n\r\n  this.volume = volume;\r\n  /**\r\n   * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\r\n   */\r\n\r\n  index = index || 0;\r\n  Object.defineProperty(this, 'index', {\r\n    get: function () {\r\n      return index;\r\n    },\r\n    set: function (value) {\r\n      index = value;\r\n      slice.geometryNeedsUpdate = true;\r\n      return index;\r\n    }\r\n  });\r\n  /**\r\n   * @member {String} axis The normal axis\r\n   */\r\n\r\n  this.axis = axis || 'z';\r\n  /**\r\n   * @member {HTMLCanvasElement} canvas The final canvas used for the texture\r\n   */\r\n\r\n  /**\r\n   * @member {CanvasRenderingContext2D} ctx Context of the canvas\r\n   */\r\n\r\n  this.canvas = document.createElement('canvas');\r\n  /**\r\n   * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\r\n   */\r\n\r\n  /**\r\n   * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\r\n   */\r\n\r\n  this.canvasBuffer = document.createElement('canvas');\r\n  this.updateGeometry();\r\n  var canvasMap = new Texture(this.canvas);\r\n  canvasMap.minFilter = LinearFilter;\r\n  canvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\r\n  var material = new MeshBasicMaterial({\r\n    map: canvasMap,\r\n    side: DoubleSide,\r\n    transparent: true\r\n  });\r\n  /**\r\n   * @member {Mesh} mesh The mesh ready to get used in the scene\r\n   */\r\n\r\n  this.mesh = new Mesh(this.geometry, material);\r\n  this.mesh.matrixAutoUpdate = false;\r\n  /**\r\n   * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\r\n   */\r\n\r\n  this.geometryNeedsUpdate = true;\r\n  this.repaint();\r\n  /**\r\n   * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\r\n   */\r\n\r\n  /**\r\n   * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\r\n   */\r\n\r\n  /**\r\n   * @member {Function} sliceAccess Function that allow the slice to access right data\r\n   * @see Volume.extractPerpendicularPlane\r\n   * @param {Number} i The first coordinate\r\n   * @param {Number} j The second coordinate\r\n   * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\r\n   */\r\n};\r\n\r\nVolumeSlice.prototype = {\r\n  constructor: VolumeSlice,\r\n\r\n  /**\r\n   * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\r\n   * @memberof VolumeSlice\r\n   */\r\n  repaint: function () {\r\n    if (this.geometryNeedsUpdate) {\r\n      this.updateGeometry();\r\n    }\r\n\r\n    var iLength = this.iLength,\r\n        jLength = this.jLength,\r\n        sliceAccess = this.sliceAccess,\r\n        volume = this.volume,\r\n        canvas = this.canvasBuffer,\r\n        ctx = this.ctxBuffer; // get the imageData and pixel array from the canvas\r\n\r\n    var imgData = ctx.getImageData(0, 0, iLength, jLength);\r\n    var data = imgData.data;\r\n    var volumeData = volume.data;\r\n    var upperThreshold = volume.upperThreshold;\r\n    var lowerThreshold = volume.lowerThreshold;\r\n    var windowLow = volume.windowLow;\r\n    var windowHigh = volume.windowHigh; // manipulate some pixel elements\r\n\r\n    var pixelCount = 0;\r\n\r\n    if (volume.dataType === 'label') {\r\n      //this part is currently useless but will be used when colortables will be handled\r\n      for (let j = 0; j < jLength; j++) {\r\n        for (let i = 0; i < iLength; i++) {\r\n          var label = volumeData[sliceAccess(i, j)];\r\n          label = label >= this.colorMap.length ? label % this.colorMap.length + 1 : label;\r\n          var color = this.colorMap[label];\r\n          data[4 * pixelCount] = color >> 24 & 0xff;\r\n          data[4 * pixelCount + 1] = color >> 16 & 0xff;\r\n          data[4 * pixelCount + 2] = color >> 8 & 0xff;\r\n          data[4 * pixelCount + 3] = color & 0xff;\r\n          pixelCount++;\r\n        }\r\n      }\r\n    } else {\r\n      for (let j = 0; j < jLength; j++) {\r\n        for (let i = 0; i < iLength; i++) {\r\n          var value = volumeData[sliceAccess(i, j)];\r\n          var alpha = 0xff; //apply threshold\r\n\r\n          alpha = upperThreshold >= value ? lowerThreshold <= value ? alpha : 0 : 0; //apply window level\r\n\r\n          value = Math.floor(255 * (value - windowLow) / (windowHigh - windowLow));\r\n          value = value > 255 ? 255 : value < 0 ? 0 : value | 0;\r\n          data[4 * pixelCount] = value;\r\n          data[4 * pixelCount + 1] = value;\r\n          data[4 * pixelCount + 2] = value;\r\n          data[4 * pixelCount + 3] = alpha;\r\n          pixelCount++;\r\n        }\r\n      }\r\n    }\r\n\r\n    ctx.putImageData(imgData, 0, 0);\r\n    this.ctx.drawImage(canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height);\r\n    this.mesh.material.map.needsUpdate = true;\r\n  },\r\n\r\n  /**\r\n   * @member {Function} Refresh the geometry according to axis and index\r\n   * @see Volume.extractPerpendicularPlane\r\n   * @memberof VolumeSlice\r\n   */\r\n  updateGeometry: function () {\r\n    var extracted = this.volume.extractPerpendicularPlane(this.axis, this.index);\r\n    this.sliceAccess = extracted.sliceAccess;\r\n    this.jLength = extracted.jLength;\r\n    this.iLength = extracted.iLength;\r\n    this.matrix = extracted.matrix;\r\n    this.canvas.width = extracted.planeWidth;\r\n    this.canvas.height = extracted.planeHeight;\r\n    this.canvasBuffer.width = this.iLength;\r\n    this.canvasBuffer.height = this.jLength;\r\n    this.ctx = this.canvas.getContext('2d');\r\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\r\n    if (this.geometry) this.geometry.dispose(); // dispose existing geometry\r\n\r\n    this.geometry = new PlaneGeometry(extracted.planeWidth, extracted.planeHeight);\r\n\r\n    if (this.mesh) {\r\n      this.mesh.geometry = this.geometry; //reset mesh matrix\r\n\r\n      this.mesh.matrix.identity();\r\n      this.mesh.applyMatrix4(this.matrix);\r\n    }\r\n\r\n    this.geometryNeedsUpdate = false;\r\n  }\r\n};\r\n\r\nexport { VolumeSlice };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}