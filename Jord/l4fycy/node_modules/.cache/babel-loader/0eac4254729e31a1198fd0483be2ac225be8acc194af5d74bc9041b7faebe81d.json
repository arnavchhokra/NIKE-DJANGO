{"ast":null,"code":"import { DataTexture, FloatType, UnsignedIntType, RGBAFormat, RGIntegerFormat, NearestFilter, BufferAttribute } from 'three';\nimport { FloatVertexAttributeTexture, UIntVertexAttributeTexture } from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, RIGHT_NODE, OFFSET, SPLIT_AXIS } from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\nexport class MeshBVHUniformStruct {\n  constructor() {\n    this.index = new UIntVertexAttributeTexture();\n    this.position = new FloatVertexAttributeTexture();\n    this.bvhBounds = new DataTexture();\n    this.bvhContents = new DataTexture();\n    this._cachedIndexAttr = null;\n    this.index.overrideItemSize = 3;\n  }\n  updateFrom(bvh) {\n    const {\n      geometry\n    } = bvh;\n    bvhToTextures(bvh, this.bvhBounds, this.bvhContents);\n    this.position.updateFrom(geometry.attributes.position);\n\n    // dereference a new index attribute if we're using indirect storage\n    if (bvh.indirect) {\n      const indirectBuffer = bvh._indirectBuffer;\n      if (this._cachedIndexAttr === null || this._cachedIndexAttr.count !== indirectBuffer.length) {\n        if (geometry.index) {\n          this._cachedIndexAttr = geometry.index.clone();\n        } else {\n          const array = getIndexArray(getVertexCount(geometry));\n          this._cachedIndexAttr = new BufferAttribute(array, 1, false);\n        }\n      }\n      dereferenceIndex(geometry, indirectBuffer, this._cachedIndexAttr);\n      this.index.updateFrom(this._cachedIndexAttr);\n    } else {\n      this.index.updateFrom(geometry.index);\n    }\n  }\n  dispose() {\n    const {\n      index,\n      position,\n      bvhBounds,\n      bvhContents\n    } = this;\n    if (index) index.dispose();\n    if (position) position.dispose();\n    if (bvhBounds) bvhBounds.dispose();\n    if (bvhContents) bvhContents.dispose();\n  }\n}\nfunction dereferenceIndex(geometry, indirectBuffer, target) {\n  const unpacked = target.array;\n  const indexArray = geometry.index ? geometry.index.array : null;\n  for (let i = 0, l = indirectBuffer.length; i < l; i++) {\n    const i3 = 3 * i;\n    const v3 = 3 * indirectBuffer[i];\n    for (let c = 0; c < 3; c++) {\n      unpacked[i3 + c] = indexArray ? indexArray[v3 + c] : v3 + c;\n    }\n  }\n}\nfunction bvhToTextures(bvh, boundsTexture, contentsTexture) {\n  const roots = bvh._roots;\n  if (roots.length !== 1) {\n    throw new Error('MeshBVHUniformStruct: Multi-root BVHs not supported.');\n  }\n  const root = roots[0];\n  const uint16Array = new Uint16Array(root);\n  const uint32Array = new Uint32Array(root);\n  const float32Array = new Float32Array(root);\n\n  // Both bounds need two elements per node so compute the height so it's twice as long as\n  // the width so we can expand the row by two and still have a square texture\n  const nodeCount = root.byteLength / BYTES_PER_NODE;\n  const boundsDimension = 2 * Math.ceil(Math.sqrt(nodeCount / 2));\n  const boundsArray = new Float32Array(4 * boundsDimension * boundsDimension);\n  const contentsDimension = Math.ceil(Math.sqrt(nodeCount));\n  const contentsArray = new Uint32Array(2 * contentsDimension * contentsDimension);\n  for (let i = 0; i < nodeCount; i++) {\n    const nodeIndex32 = i * BYTES_PER_NODE / 4;\n    const nodeIndex16 = nodeIndex32 * 2;\n    const boundsIndex = BOUNDING_DATA_INDEX(nodeIndex32);\n    for (let b = 0; b < 3; b++) {\n      boundsArray[8 * i + 0 + b] = float32Array[boundsIndex + 0 + b];\n      boundsArray[8 * i + 4 + b] = float32Array[boundsIndex + 3 + b];\n    }\n    if (IS_LEAF(nodeIndex16, uint16Array)) {\n      const count = COUNT(nodeIndex16, uint16Array);\n      const offset = OFFSET(nodeIndex32, uint32Array);\n      const mergedLeafCount = 0xffff0000 | count;\n      contentsArray[i * 2 + 0] = mergedLeafCount;\n      contentsArray[i * 2 + 1] = offset;\n    } else {\n      const rightIndex = 4 * RIGHT_NODE(nodeIndex32, uint32Array) / BYTES_PER_NODE;\n      const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);\n      contentsArray[i * 2 + 0] = splitAxis;\n      contentsArray[i * 2 + 1] = rightIndex;\n    }\n  }\n  boundsTexture.image.data = boundsArray;\n  boundsTexture.image.width = boundsDimension;\n  boundsTexture.image.height = boundsDimension;\n  boundsTexture.format = RGBAFormat;\n  boundsTexture.type = FloatType;\n  boundsTexture.internalFormat = 'RGBA32F';\n  boundsTexture.minFilter = NearestFilter;\n  boundsTexture.magFilter = NearestFilter;\n  boundsTexture.generateMipmaps = false;\n  boundsTexture.needsUpdate = true;\n  boundsTexture.dispose();\n  contentsTexture.image.data = contentsArray;\n  contentsTexture.image.width = contentsDimension;\n  contentsTexture.image.height = contentsDimension;\n  contentsTexture.format = RGIntegerFormat;\n  contentsTexture.type = UnsignedIntType;\n  contentsTexture.internalFormat = 'RG32UI';\n  contentsTexture.minFilter = NearestFilter;\n  contentsTexture.magFilter = NearestFilter;\n  contentsTexture.generateMipmaps = false;\n  contentsTexture.needsUpdate = true;\n  contentsTexture.dispose();\n}","map":{"version":3,"names":["DataTexture","FloatType","UnsignedIntType","RGBAFormat","RGIntegerFormat","NearestFilter","BufferAttribute","FloatVertexAttributeTexture","UIntVertexAttributeTexture","BYTES_PER_NODE","BOUNDING_DATA_INDEX","COUNT","IS_LEAF","RIGHT_NODE","OFFSET","SPLIT_AXIS","getIndexArray","getVertexCount","MeshBVHUniformStruct","constructor","index","position","bvhBounds","bvhContents","_cachedIndexAttr","overrideItemSize","updateFrom","bvh","geometry","bvhToTextures","attributes","indirect","indirectBuffer","_indirectBuffer","count","length","clone","array","dereferenceIndex","dispose","target","unpacked","indexArray","i","l","i3","v3","c","boundsTexture","contentsTexture","roots","_roots","Error","root","uint16Array","Uint16Array","uint32Array","Uint32Array","float32Array","Float32Array","nodeCount","byteLength","boundsDimension","Math","ceil","sqrt","boundsArray","contentsDimension","contentsArray","nodeIndex32","nodeIndex16","boundsIndex","b","offset","mergedLeafCount","rightIndex","splitAxis","image","data","width","height","format","type","internalFormat","minFilter","magFilter","generateMipmaps","needsUpdate"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js"],"sourcesContent":["import {\r\n\tDataTexture,\r\n\tFloatType,\r\n\tUnsignedIntType,\r\n\tRGBAFormat,\r\n\tRGIntegerFormat,\r\n\tNearestFilter,\r\n\tBufferAttribute,\r\n} from 'three';\r\nimport {\r\n\tFloatVertexAttributeTexture,\r\n\tUIntVertexAttributeTexture,\r\n} from './VertexAttributeTexture.js';\r\nimport { BYTES_PER_NODE } from '../core/Constants.js';\r\nimport {\r\n\tBOUNDING_DATA_INDEX,\r\n\tCOUNT,\r\n\tIS_LEAF,\r\n\tRIGHT_NODE,\r\n\tOFFSET,\r\n\tSPLIT_AXIS,\r\n} from '../core/utils/nodeBufferUtils.js';\r\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\r\n\r\nexport class MeshBVHUniformStruct {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.index = new UIntVertexAttributeTexture();\r\n\t\tthis.position = new FloatVertexAttributeTexture();\r\n\t\tthis.bvhBounds = new DataTexture();\r\n\t\tthis.bvhContents = new DataTexture();\r\n\t\tthis._cachedIndexAttr = null;\r\n\r\n\t\tthis.index.overrideItemSize = 3;\r\n\r\n\t}\r\n\r\n\tupdateFrom( bvh ) {\r\n\r\n\t\tconst { geometry } = bvh;\r\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\r\n\r\n\t\tthis.position.updateFrom( geometry.attributes.position );\r\n\r\n\t\t// dereference a new index attribute if we're using indirect storage\r\n\t\tif ( bvh.indirect ) {\r\n\r\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\r\n\t\t\tif (\r\n\t\t\t\tthis._cachedIndexAttr === null ||\r\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\r\n\t\t\t) {\r\n\r\n\t\t\t\tif ( geometry.index ) {\r\n\r\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\r\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\r\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.index.updateFrom( geometry.index );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\r\n\r\n\t\tif ( index ) index.dispose();\r\n\t\tif ( position ) position.dispose();\r\n\t\tif ( bvhBounds ) bvhBounds.dispose();\r\n\t\tif ( bvhContents ) bvhContents.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\r\n\r\n\tconst unpacked = target.array;\r\n\tconst indexArray = geometry.index ? geometry.index.array : null;\r\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\r\n\r\n\t\tconst i3 = 3 * i;\r\n\t\tconst v3 = 3 * indirectBuffer[ i ];\r\n\t\tfor ( let c = 0; c < 3; c ++ ) {\r\n\r\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\r\n\r\n\tconst roots = bvh._roots;\r\n\r\n\tif ( roots.length !== 1 ) {\r\n\r\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\r\n\r\n\t}\r\n\r\n\tconst root = roots[ 0 ];\r\n\tconst uint16Array = new Uint16Array( root );\r\n\tconst uint32Array = new Uint32Array( root );\r\n\tconst float32Array = new Float32Array( root );\r\n\r\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\r\n\t// the width so we can expand the row by two and still have a square texture\r\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\r\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\r\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\r\n\r\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\r\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\r\n\r\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\r\n\r\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\r\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\r\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\r\n\t\tfor ( let b = 0; b < 3; b ++ ) {\r\n\r\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\r\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\r\n\r\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\r\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\r\n\r\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\r\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\r\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\r\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\r\n\r\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\r\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tboundsTexture.image.data = boundsArray;\r\n\tboundsTexture.image.width = boundsDimension;\r\n\tboundsTexture.image.height = boundsDimension;\r\n\tboundsTexture.format = RGBAFormat;\r\n\tboundsTexture.type = FloatType;\r\n\tboundsTexture.internalFormat = 'RGBA32F';\r\n\tboundsTexture.minFilter = NearestFilter;\r\n\tboundsTexture.magFilter = NearestFilter;\r\n\tboundsTexture.generateMipmaps = false;\r\n\tboundsTexture.needsUpdate = true;\r\n\tboundsTexture.dispose();\r\n\r\n\tcontentsTexture.image.data = contentsArray;\r\n\tcontentsTexture.image.width = contentsDimension;\r\n\tcontentsTexture.image.height = contentsDimension;\r\n\tcontentsTexture.format = RGIntegerFormat;\r\n\tcontentsTexture.type = UnsignedIntType;\r\n\tcontentsTexture.internalFormat = 'RG32UI';\r\n\tcontentsTexture.minFilter = NearestFilter;\r\n\tcontentsTexture.magFilter = NearestFilter;\r\n\tcontentsTexture.generateMipmaps = false;\r\n\tcontentsTexture.needsUpdate = true;\r\n\tcontentsTexture.dispose();\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}