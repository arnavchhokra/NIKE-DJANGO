{"ast":null,"code":"import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\n/**\r\n * This is a helper for visualising a given light's shadow map.\r\n * It works for shadow casting lights: DirectionalLight and SpotLight.\r\n * It renders out the shadow map and displays it on a HUD.\r\n *\r\n * Example usage:\r\n *\t1) Import ShadowMapViewer into your app.\r\n *\r\n *\t2) Create a shadow casting light and name it optionally:\r\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\r\n *\t\tlight.castShadow = true;\r\n *\t\tlight.name = 'Sun';\r\n *\r\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\r\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\r\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\r\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\r\n *\r\n *\t4) Render the shadow map viewer in your render loop:\r\n *\t\tshadowMapViewer.render( renderer );\r\n *\r\n *\t5) Optionally: Update the shadow map viewer on window resize:\r\n *\t\tshadowMapViewer.updateForWindowResize();\r\n *\r\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\r\n */\n\nvar ShadowMapViewer = function ShadowMapViewer(light) {\n  //- Internals\n  var scope = this;\n  var doRenderLabel = light.name !== undefined && light.name !== '';\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\n\n  var frame = {\n    x: 10,\n    y: 10,\n    width: 256,\n    height: 256\n  };\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\n  camera.position.set(0, 0, 2);\n  var scene = new Scene(); //HUD for shadow map\n\n  var shader = UnpackDepthRGBAShader;\n  var uniforms = UniformsUtils.clone(shader.uniforms);\n  var material = new ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: shader.vertexShader,\n    fragmentShader: shader.fragmentShader\n  });\n  var plane = new PlaneGeometry(frame.width, frame.height);\n  var mesh = new Mesh(plane, material);\n  scene.add(mesh); //Label for light's name\n\n  var labelCanvas, labelMesh;\n\n  if (doRenderLabel) {\n    labelCanvas = document.createElement('canvas');\n    var context = labelCanvas.getContext('2d');\n    context.font = 'Bold 20px Arial';\n    var labelWidth = context.measureText(light.name).width;\n    labelCanvas.width = labelWidth;\n    labelCanvas.height = 25; //25 to account for g, p, etc.\n\n    context.font = 'Bold 20px Arial';\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\n    context.fillText(light.name, 0, 20);\n    var labelTexture = new Texture(labelCanvas);\n    labelTexture.magFilter = LinearFilter;\n    labelTexture.minFilter = LinearFilter;\n    labelTexture.needsUpdate = true;\n    var labelMaterial = new MeshBasicMaterial({\n      map: labelTexture,\n      side: DoubleSide\n    });\n    labelMaterial.transparent = true;\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\n    labelMesh = new Mesh(labelPlane, labelMaterial);\n    scene.add(labelMesh);\n  }\n\n  function resetPosition() {\n    scope.position.set(scope.position.x, scope.position.y);\n  } //- API\n  // Set to false to disable displaying this shadow map\n\n\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\n\n  this.size = {\n    width: frame.width,\n    height: frame.height,\n    set: function set(width, height) {\n      this.width = width;\n      this.height = height;\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\n\n      resetPosition();\n    }\n  }; // Set the position of the displayed shadow map on the HUD\n\n  this.position = {\n    x: frame.x,\n    y: frame.y,\n    set: function set(x, y) {\n      this.x = x;\n      this.y = y;\n      var width = scope.size.width;\n      var height = scope.size.height;\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\n\n      if (doRenderLabel) {\n        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\n      }\n    }\n  };\n\n  this.render = function (renderer) {\n    if (this.enabled) {\n      //Because a light's .shadowMap is only initialised after the first render pass\n      //we have to make sure the correct map is sent into the shader, otherwise we\n      //always end up with the scene's first added shadow casting light's shadowMap\n      //in the shader\n      //See: https://github.com/mrdoob/three.js/issues/5932\n      uniforms.tDiffuse.value = light.shadow.map.texture;\n      userAutoClearSetting = renderer.autoClear;\n      renderer.autoClear = false; // To allow render overlay\n\n      renderer.clearDepth();\n      renderer.render(scene, camera);\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\n    }\n  };\n\n  this.updateForWindowResize = function () {\n    if (this.enabled) {\n      camera.left = window.innerWidth / -2;\n      camera.right = window.innerWidth / 2;\n      camera.top = window.innerHeight / 2;\n      camera.bottom = window.innerHeight / -2;\n      camera.updateProjectionMatrix();\n      this.update();\n    }\n  };\n\n  this.update = function () {\n    this.position.set(this.position.x, this.position.y);\n    this.size.set(this.size.width, this.size.height);\n  }; //Force an update to set position/size\n\n\n  this.update();\n};\n\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\nexport { ShadowMapViewer };","map":{"version":3,"names":["OrthographicCamera","Scene","UniformsUtils","ShaderMaterial","PlaneGeometry","Mesh","Texture","LinearFilter","MeshBasicMaterial","DoubleSide","UnpackDepthRGBAShader","ShadowMapViewer","light","scope","doRenderLabel","name","undefined","userAutoClearSetting","frame","x","y","width","height","camera","window","innerWidth","innerHeight","position","set","scene","shader","uniforms","clone","material","vertexShader","fragmentShader","plane","mesh","add","labelCanvas","labelMesh","document","createElement","context","getContext","font","labelWidth","measureText","fillStyle","fillText","labelTexture","magFilter","minFilter","needsUpdate","labelMaterial","map","side","transparent","labelPlane","resetPosition","enabled","size","scale","render","renderer","tDiffuse","value","shadow","texture","autoClear","clearDepth","updateForWindowResize","left","right","top","bottom","updateProjectionMatrix","update","prototype","constructor"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-stdlib/utils/ShadowMapViewer.js"],"sourcesContent":["import { OrthographicCamera, Scene, UniformsUtils, ShaderMaterial, PlaneGeometry, Mesh, Texture, LinearFilter, MeshBasicMaterial, DoubleSide } from 'three';\r\nimport { UnpackDepthRGBAShader } from '../shaders/UnpackDepthRGBAShader.js';\r\n\r\n/**\r\n * This is a helper for visualising a given light's shadow map.\r\n * It works for shadow casting lights: DirectionalLight and SpotLight.\r\n * It renders out the shadow map and displays it on a HUD.\r\n *\r\n * Example usage:\r\n *\t1) Import ShadowMapViewer into your app.\r\n *\r\n *\t2) Create a shadow casting light and name it optionally:\r\n *\t\tvar light = new DirectionalLight( 0xffffff, 1 );\r\n *\t\tlight.castShadow = true;\r\n *\t\tlight.name = 'Sun';\r\n *\r\n *\t3) Create a shadow map viewer for that light and set its size and position optionally:\r\n *\t\tvar shadowMapViewer = new ShadowMapViewer( light );\r\n *\t\tshadowMapViewer.size.set( 128, 128 );\t//width, height  default: 256, 256\r\n *\t\tshadowMapViewer.position.set( 10, 10 );\t//x, y in pixel\t default: 0, 0 (top left corner)\r\n *\r\n *\t4) Render the shadow map viewer in your render loop:\r\n *\t\tshadowMapViewer.render( renderer );\r\n *\r\n *\t5) Optionally: Update the shadow map viewer on window resize:\r\n *\t\tshadowMapViewer.updateForWindowResize();\r\n *\r\n *\t6) If you set the position or size members directly, you need to call shadowMapViewer.update();\r\n */\r\n\r\nvar ShadowMapViewer = function (light) {\r\n  //- Internals\r\n  var scope = this;\r\n  var doRenderLabel = light.name !== undefined && light.name !== '';\r\n  var userAutoClearSetting; //Holds the initial position and dimension of the HUD\r\n\r\n  var frame = {\r\n    x: 10,\r\n    y: 10,\r\n    width: 256,\r\n    height: 256\r\n  };\r\n  var camera = new OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);\r\n  camera.position.set(0, 0, 2);\r\n  var scene = new Scene(); //HUD for shadow map\r\n\r\n  var shader = UnpackDepthRGBAShader;\r\n  var uniforms = UniformsUtils.clone(shader.uniforms);\r\n  var material = new ShaderMaterial({\r\n    uniforms: uniforms,\r\n    vertexShader: shader.vertexShader,\r\n    fragmentShader: shader.fragmentShader\r\n  });\r\n  var plane = new PlaneGeometry(frame.width, frame.height);\r\n  var mesh = new Mesh(plane, material);\r\n  scene.add(mesh); //Label for light's name\r\n\r\n  var labelCanvas, labelMesh;\r\n\r\n  if (doRenderLabel) {\r\n    labelCanvas = document.createElement('canvas');\r\n    var context = labelCanvas.getContext('2d');\r\n    context.font = 'Bold 20px Arial';\r\n    var labelWidth = context.measureText(light.name).width;\r\n    labelCanvas.width = labelWidth;\r\n    labelCanvas.height = 25; //25 to account for g, p, etc.\r\n\r\n    context.font = 'Bold 20px Arial';\r\n    context.fillStyle = 'rgba( 255, 0, 0, 1 )';\r\n    context.fillText(light.name, 0, 20);\r\n    var labelTexture = new Texture(labelCanvas);\r\n    labelTexture.magFilter = LinearFilter;\r\n    labelTexture.minFilter = LinearFilter;\r\n    labelTexture.needsUpdate = true;\r\n    var labelMaterial = new MeshBasicMaterial({\r\n      map: labelTexture,\r\n      side: DoubleSide\r\n    });\r\n    labelMaterial.transparent = true;\r\n    var labelPlane = new PlaneGeometry(labelCanvas.width, labelCanvas.height);\r\n    labelMesh = new Mesh(labelPlane, labelMaterial);\r\n    scene.add(labelMesh);\r\n  }\r\n\r\n  function resetPosition() {\r\n    scope.position.set(scope.position.x, scope.position.y);\r\n  } //- API\r\n  // Set to false to disable displaying this shadow map\r\n\r\n\r\n  this.enabled = true; // Set the size of the displayed shadow map on the HUD\r\n\r\n  this.size = {\r\n    width: frame.width,\r\n    height: frame.height,\r\n    set: function (width, height) {\r\n      this.width = width;\r\n      this.height = height;\r\n      mesh.scale.set(this.width / frame.width, this.height / frame.height, 1); //Reset the position as it is off when we scale stuff\r\n\r\n      resetPosition();\r\n    }\r\n  }; // Set the position of the displayed shadow map on the HUD\r\n\r\n  this.position = {\r\n    x: frame.x,\r\n    y: frame.y,\r\n    set: function (x, y) {\r\n      this.x = x;\r\n      this.y = y;\r\n      var width = scope.size.width;\r\n      var height = scope.size.height;\r\n      mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);\r\n\r\n      if (doRenderLabel) {\r\n        labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);\r\n      }\r\n    }\r\n  };\r\n\r\n  this.render = function (renderer) {\r\n    if (this.enabled) {\r\n      //Because a light's .shadowMap is only initialised after the first render pass\r\n      //we have to make sure the correct map is sent into the shader, otherwise we\r\n      //always end up with the scene's first added shadow casting light's shadowMap\r\n      //in the shader\r\n      //See: https://github.com/mrdoob/three.js/issues/5932\r\n      uniforms.tDiffuse.value = light.shadow.map.texture;\r\n      userAutoClearSetting = renderer.autoClear;\r\n      renderer.autoClear = false; // To allow render overlay\r\n\r\n      renderer.clearDepth();\r\n      renderer.render(scene, camera);\r\n      renderer.autoClear = userAutoClearSetting; //Restore user's setting\r\n    }\r\n  };\r\n\r\n  this.updateForWindowResize = function () {\r\n    if (this.enabled) {\r\n      camera.left = window.innerWidth / -2;\r\n      camera.right = window.innerWidth / 2;\r\n      camera.top = window.innerHeight / 2;\r\n      camera.bottom = window.innerHeight / -2;\r\n      camera.updateProjectionMatrix();\r\n      this.update();\r\n    }\r\n  };\r\n\r\n  this.update = function () {\r\n    this.position.set(this.position.x, this.position.y);\r\n    this.size.set(this.size.width, this.size.height);\r\n  }; //Force an update to set position/size\r\n\r\n\r\n  this.update();\r\n};\r\n\r\nShadowMapViewer.prototype.constructor = ShadowMapViewer;\r\n\r\nexport { ShadowMapViewer };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}