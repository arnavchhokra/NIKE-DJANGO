{"ast":null,"code":"import { ShaderLib, Mesh, BoxGeometry, ShaderMaterial, UniformsUtils, BackSide, Scene, PerspectiveCamera } from \"three\";\nimport { Pass } from \"./Pass.js\";\nclass CubeTexturePass extends Pass {\n  constructor(camera, tCube) {\n    let opacity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    super();\n    this.camera = camera;\n    this.needsSwap = false;\n    this.cubeShader = ShaderLib[\"cube\"];\n    this.cubeMesh = new Mesh(new BoxGeometry(10, 10, 10), new ShaderMaterial({\n      uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n      vertexShader: this.cubeShader.vertexShader,\n      fragmentShader: this.cubeShader.fragmentShader,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    }));\n    Object.defineProperty(this.cubeMesh.material, \"envMap\", {\n      get: function () {\n        return this.uniforms.tCube.value;\n      }\n    });\n    this.tCube = tCube;\n    this.opacity = opacity;\n    this.cubeScene = new Scene();\n    this.cubeCamera = new PerspectiveCamera();\n    this.cubeScene.add(this.cubeMesh);\n  }\n  render(renderer, writeBuffer, readBuffer) {\n    const oldAutoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix);\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld);\n    this.cubeMesh.material.uniforms.tCube.value = this.tCube;\n    this.cubeMesh.material.uniforms.tFlip.value = this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ? -1 : 1;\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity;\n    this.cubeMesh.material.transparent = this.opacity < 1;\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n    if (this.clear) renderer.clear();\n    renderer.render(this.cubeScene, this.cubeCamera);\n    renderer.autoClear = oldAutoClear;\n  }\n  dispose() {\n    this.cubeMesh.geometry.dispose();\n    this.cubeMesh.material.dispose();\n  }\n}\nexport { CubeTexturePass };","map":{"version":3,"names":["CubeTexturePass","Pass","constructor","camera","tCube","opacity","arguments","length","undefined","needsSwap","cubeShader","ShaderLib","cubeMesh","Mesh","BoxGeometry","ShaderMaterial","uniforms","UniformsUtils","clone","vertexShader","fragmentShader","depthTest","depthWrite","side","BackSide","Object","defineProperty","material","get","value","cubeScene","Scene","cubeCamera","PerspectiveCamera","add","render","renderer","writeBuffer","readBuffer","oldAutoClear","autoClear","projectionMatrix","copy","quaternion","setFromRotationMatrix","matrixWorld","tFlip","isCubeTexture","isRenderTargetTexture","transparent","setRenderTarget","renderToScreen","clear","dispose","geometry"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\src\\postprocessing\\CubeTexturePass.js"],"sourcesContent":["import { BackSide, BoxGeometry, Mesh, PerspectiveCamera, Scene, ShaderLib, ShaderMaterial, UniformsUtils } from 'three'\nimport { Pass } from './Pass'\n\nclass CubeTexturePass extends Pass {\n  constructor(camera, tCube, opacity = 1) {\n    super()\n\n    this.camera = camera\n\n    this.needsSwap = false\n\n    this.cubeShader = ShaderLib['cube']\n    this.cubeMesh = new Mesh(\n      new BoxGeometry(10, 10, 10),\n      new ShaderMaterial({\n        uniforms: UniformsUtils.clone(this.cubeShader.uniforms),\n        vertexShader: this.cubeShader.vertexShader,\n        fragmentShader: this.cubeShader.fragmentShader,\n        depthTest: false,\n        depthWrite: false,\n        side: BackSide,\n      }),\n    )\n\n    Object.defineProperty(this.cubeMesh.material, 'envMap', {\n      get: function () {\n        return this.uniforms.tCube.value\n      },\n    })\n\n    this.tCube = tCube\n    this.opacity = opacity\n\n    this.cubeScene = new Scene()\n    this.cubeCamera = new PerspectiveCamera()\n    this.cubeScene.add(this.cubeMesh)\n  }\n\n  render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive*/) {\n    const oldAutoClear = renderer.autoClear\n    renderer.autoClear = false\n\n    this.cubeCamera.projectionMatrix.copy(this.camera.projectionMatrix)\n    this.cubeCamera.quaternion.setFromRotationMatrix(this.camera.matrixWorld)\n\n    this.cubeMesh.material.uniforms.tCube.value = this.tCube\n    this.cubeMesh.material.uniforms.tFlip.value =\n      this.tCube.isCubeTexture && this.tCube.isRenderTargetTexture === false ? -1 : 1\n    this.cubeMesh.material.uniforms.opacity.value = this.opacity\n    this.cubeMesh.material.transparent = this.opacity < 1.0\n\n    renderer.setRenderTarget(this.renderToScreen ? null : readBuffer)\n    if (this.clear) renderer.clear()\n    renderer.render(this.cubeScene, this.cubeCamera)\n\n    renderer.autoClear = oldAutoClear\n  }\n\n  dispose() {\n    this.cubeMesh.geometry.dispose()\n    this.cubeMesh.material.dispose()\n  }\n}\n\nexport { CubeTexturePass }\n"],"mappings":";;AAGA,MAAMA,eAAA,SAAwBC,IAAA,CAAK;EACjCC,YAAYC,MAAA,EAAQC,KAAA,EAAoB;IAAA,IAAbC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAU;IACnC,MAAO;IAEP,KAAKH,MAAA,GAASA,MAAA;IAEd,KAAKM,SAAA,GAAY;IAEjB,KAAKC,UAAA,GAAaC,SAAA,CAAU,MAAM;IAClC,KAAKC,QAAA,GAAW,IAAIC,IAAA,CAClB,IAAIC,WAAA,CAAY,IAAI,IAAI,EAAE,GAC1B,IAAIC,cAAA,CAAe;MACjBC,QAAA,EAAUC,aAAA,CAAcC,KAAA,CAAM,KAAKR,UAAA,CAAWM,QAAQ;MACtDG,YAAA,EAAc,KAAKT,UAAA,CAAWS,YAAA;MAC9BC,cAAA,EAAgB,KAAKV,UAAA,CAAWU,cAAA;MAChCC,SAAA,EAAW;MACXC,UAAA,EAAY;MACZC,IAAA,EAAMC;IACd,CAAO,CACF;IAEDC,MAAA,CAAOC,cAAA,CAAe,KAAKd,QAAA,CAASe,QAAA,EAAU,UAAU;MACtDC,GAAA,EAAK,SAAAA,CAAA,EAAY;QACf,OAAO,KAAKZ,QAAA,CAASZ,KAAA,CAAMyB,KAAA;MAC5B;IACP,CAAK;IAED,KAAKzB,KAAA,GAAQA,KAAA;IACb,KAAKC,OAAA,GAAUA,OAAA;IAEf,KAAKyB,SAAA,GAAY,IAAIC,KAAA,CAAO;IAC5B,KAAKC,UAAA,GAAa,IAAIC,iBAAA,CAAmB;IACzC,KAAKH,SAAA,CAAUI,GAAA,CAAI,KAAKtB,QAAQ;EACjC;EAEDuB,OAAOC,QAAA,EAAUC,WAAA,EAAaC,UAAA,EAAwC;IACpE,MAAMC,YAAA,GAAeH,QAAA,CAASI,SAAA;IAC9BJ,QAAA,CAASI,SAAA,GAAY;IAErB,KAAKR,UAAA,CAAWS,gBAAA,CAAiBC,IAAA,CAAK,KAAKvC,MAAA,CAAOsC,gBAAgB;IAClE,KAAKT,UAAA,CAAWW,UAAA,CAAWC,qBAAA,CAAsB,KAAKzC,MAAA,CAAO0C,WAAW;IAExE,KAAKjC,QAAA,CAASe,QAAA,CAASX,QAAA,CAASZ,KAAA,CAAMyB,KAAA,GAAQ,KAAKzB,KAAA;IACnD,KAAKQ,QAAA,CAASe,QAAA,CAASX,QAAA,CAAS8B,KAAA,CAAMjB,KAAA,GACpC,KAAKzB,KAAA,CAAM2C,aAAA,IAAiB,KAAK3C,KAAA,CAAM4C,qBAAA,KAA0B,QAAQ,KAAK;IAChF,KAAKpC,QAAA,CAASe,QAAA,CAASX,QAAA,CAASX,OAAA,CAAQwB,KAAA,GAAQ,KAAKxB,OAAA;IACrD,KAAKO,QAAA,CAASe,QAAA,CAASsB,WAAA,GAAc,KAAK5C,OAAA,GAAU;IAEpD+B,QAAA,CAASc,eAAA,CAAgB,KAAKC,cAAA,GAAiB,OAAOb,UAAU;IAChE,IAAI,KAAKc,KAAA,EAAOhB,QAAA,CAASgB,KAAA,CAAO;IAChChB,QAAA,CAASD,MAAA,CAAO,KAAKL,SAAA,EAAW,KAAKE,UAAU;IAE/CI,QAAA,CAASI,SAAA,GAAYD,YAAA;EACtB;EAEDc,QAAA,EAAU;IACR,KAAKzC,QAAA,CAAS0C,QAAA,CAASD,OAAA,CAAS;IAChC,KAAKzC,QAAA,CAASe,QAAA,CAAS0B,OAAA,CAAS;EACjC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}