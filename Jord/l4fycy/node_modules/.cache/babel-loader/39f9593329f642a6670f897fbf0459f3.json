{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.canMatchCharCode = exports.firstCharOptimizedIndices = exports.getOptimizedStartCodesIndices = exports.failedOptimizationPrefixMsg = void 0;\n\nvar regexp_to_ast_1 = require(\"regexp-to-ast\");\n\nvar isArray_1 = __importDefault(require(\"lodash/isArray\"));\n\nvar every_1 = __importDefault(require(\"lodash/every\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar find_1 = __importDefault(require(\"lodash/find\"));\n\nvar values_1 = __importDefault(require(\"lodash/values\"));\n\nvar includes_1 = __importDefault(require(\"lodash/includes\"));\n\nvar utils_1 = require(\"@chevrotain/utils\");\n\nvar reg_exp_parser_1 = require(\"./reg_exp_parser\");\n\nvar lexer_1 = require(\"./lexer\");\n\nvar complementErrorMessage = \"Complement Sets are not supported for first char optimization\";\nexports.failedOptimizationPrefixMsg = 'Unable to use \"first char\" lexer optimizations:\\n';\n\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations) {\n  if (ensureOptimizations === void 0) {\n    ensureOptimizations = false;\n  }\n\n  try {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);\n    var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n    return firstChars;\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        (0, utils_1.PRINT_WARNING)(\"\".concat(exports.failedOptimizationPrefixMsg) + \"\\tUnable to optimize: < \".concat(regExp.toString(), \" >\\n\") + \"\\tComplement Sets cannot be automatically optimized.\\n\" + \"\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\");\n      }\n    } else {\n      var msgSuffix = \"\";\n\n      if (ensureOptimizations) {\n        msgSuffix = \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" + \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\n      }\n\n      (0, utils_1.PRINT_ERROR)(\"\".concat(exports.failedOptimizationPrefixMsg, \"\\n\") + \"\\tFailed parsing: < \".concat(regExp.toString(), \" >\\n\") + \"\\tUsing the regexp-to-ast library version: \".concat(regexp_to_ast_1.VERSION, \"\\n\") + \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" + msgSuffix);\n    }\n  }\n\n  return [];\n}\n\nexports.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;\n\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (var i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n      }\n\n      break;\n\n    case \"Alternative\":\n      var terms = ast.value;\n\n      for (var i = 0; i < terms.length; i++) {\n        var term = terms[i]; // skip terms that cannot effect the first char results\n\n        switch (term.type) {\n          case \"EndAnchor\": // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n\n          case \"GroupBackReference\": // assertions do not affect potential starting codes\n\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue;\n        }\n\n        var atom = term;\n\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\n            break;\n\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage);\n            }\n\n            (0, forEach_1.default)(atom.value, function (code) {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase);\n              } else {\n                // range\n                var range = code; // cannot optimize when ignoreCase is\n\n                if (ignoreCase === true) {\n                  for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  }\n                } // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                  } // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n\n\n                  if (range.to >= lexer_1.minOptimizationVal) {\n                    var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;\n                    var maxUnOptVal = range.to;\n                    var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);\n                    var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);\n\n                    for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                      result[currOptIdx] = currOptIdx;\n                    }\n                  }\n                }\n              }\n            });\n            break;\n\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw Error(\"Non Exhaustive Match\");\n        } // reached a mandatory production, no more **start** codes can be found on this alternative\n\n\n        var isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n\n        if ( // A group may be optional due to empty contents /(?:)/\n        // or if everything inside it is optional /((a)?)/\n        atom.type === \"Group\" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier\n        atom.type !== \"Group\" && isOptionalQuantifier === false) {\n          break;\n        }\n      }\n\n      break;\n\n    /* istanbul ignore next */\n\n    default:\n      throw Error(\"non exhaustive match!\");\n  } // console.log(Object.keys(result).length)\n\n\n  return (0, values_1.default)(result);\n}\n\nexports.firstCharOptimizedIndices = firstCharOptimizedIndices;\n\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n  var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);\n  result[optimizedCharIdx] = optimizedCharIdx;\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result);\n  }\n}\n\nfunction handleIgnoreCase(code, result) {\n  var char = String.fromCharCode(code);\n  var upperChar = char.toUpperCase();\n  /* istanbul ignore else */\n\n  if (upperChar !== char) {\n    var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));\n    result[optimizedCharIdx] = optimizedCharIdx;\n  } else {\n    var lowerChar = char.toLowerCase();\n\n    if (lowerChar !== char) {\n      var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));\n      result[optimizedCharIdx] = optimizedCharIdx;\n    }\n  }\n}\n\nfunction findCode(setNode, targetCharCodes) {\n  return (0, find_1.default)(setNode.value, function (codeOrRange) {\n    if (typeof codeOrRange === \"number\") {\n      return (0, includes_1.default)(targetCharCodes, codeOrRange);\n    } else {\n      // range\n      var range_1 = codeOrRange;\n      return (0, find_1.default)(targetCharCodes, function (targetCode) {\n        return range_1.from <= targetCode && targetCode <= range_1.to;\n      }) !== undefined;\n    }\n  });\n}\n\nfunction isWholeOptional(ast) {\n  var quantifier = ast.quantifier;\n\n  if (quantifier && quantifier.atLeast === 0) {\n    return true;\n  }\n\n  if (!ast.value) {\n    return false;\n  }\n\n  return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);\n}\n\nvar CharCodeFinder =\n/** @class */\nfunction (_super) {\n  __extends(CharCodeFinder, _super);\n\n  function CharCodeFinder(targetCharCodes) {\n    var _this = _super.call(this) || this;\n\n    _this.targetCharCodes = targetCharCodes;\n    _this.found = false;\n    return _this;\n  }\n\n  CharCodeFinder.prototype.visitChildren = function (node) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return;\n    } // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n\n\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node);\n        return;\n\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node);\n        return;\n    }\n\n    _super.prototype.visitChildren.call(this, node);\n  };\n\n  CharCodeFinder.prototype.visitCharacter = function (node) {\n    if ((0, includes_1.default)(this.targetCharCodes, node.value)) {\n      this.found = true;\n    }\n  };\n\n  CharCodeFinder.prototype.visitSet = function (node) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true;\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true;\n      }\n    }\n  };\n\n  return CharCodeFinder;\n}(regexp_to_ast_1.BaseRegExpVisitor);\n\nfunction canMatchCharCode(charCodes, pattern) {\n  if (pattern instanceof RegExp) {\n    var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);\n    var charCodeFinder = new CharCodeFinder(charCodes);\n    charCodeFinder.visit(ast);\n    return charCodeFinder.found;\n  } else {\n    return (0, find_1.default)(pattern, function (char) {\n      return (0, includes_1.default)(charCodes, char.charCodeAt(0));\n    }) !== undefined;\n  }\n}\n\nexports.canMatchCharCode = canMatchCharCode;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAWA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA,IAAMA,sBAAsB,GAC1B,+DADF;AAEaC,sCACX,mDADW;;AAGb,SAAgBC,6BAAhB,CACEC,MADF,EAEEC,mBAFF,EAE6B;EAA3B;IAAAA;EAA2B;;EAE3B,IAAI;IACF,IAAMC,GAAG,GAAG,mCAAaF,MAAb,CAAZ;IACA,IAAMG,UAAU,GAAGC,yBAAyB,CAC1CF,GAAG,CAACG,KADsC,EAE1C,EAF0C,EAG1CH,GAAG,CAACI,KAAJ,CAAUC,UAHgC,CAA5C;IAKA,OAAOJ,UAAP;EACD,CARD,CAQE,OAAOK,CAAP,EAAU;IACV;IACA;IACA;IACA,IAAIA,CAAC,CAACC,OAAF,KAAcZ,sBAAlB,EAA0C;MACxC,IAAII,mBAAJ,EAAyB;QACvB,2BACE,UAAGH,mCAAH,IACE,kCAA2BE,MAAM,CAACU,QAAP,EAA3B,EAA4C,MAA5C,CADF,GAEE,wDAFF,GAGE,6DAHF,GAIE,6FALJ;MAOD;IACF,CAVD,MAUO;MACL,IAAIC,SAAS,GAAG,EAAhB;;MACA,IAAIV,mBAAJ,EAAyB;QACvBU,SAAS,GACP,kEACA,iGAFF;MAGD;;MACD,yBACE,UAAGb,mCAAH,EAA8B,IAA9B,IACE,8BAAuBE,MAAM,CAACU,QAAP,EAAvB,EAAwC,MAAxC,CADF,GAEE,qDAA8CE,uBAA9C,EAAqD,IAArD,CAFF,GAGE,yEAHF,GAIED,SALJ;IAOD;EACF;;EAED,OAAO,EAAP;AACD;;AA5CDb;;AA8CA,SAAgBM,yBAAhB,CACEF,GADF,EAEEW,MAFF,EAGEN,UAHF,EAGqB;EAEnB,QAAQL,GAAG,CAACY,IAAZ;IACE,KAAK,aAAL;MACE,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,GAAG,CAACG,KAAJ,CAAUW,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;QACzCX,yBAAyB,CAACF,GAAG,CAACG,KAAJ,CAAUU,CAAV,CAAD,EAAeF,MAAf,EAAuBN,UAAvB,CAAzB;MACD;;MACD;;IACF,KAAK,aAAL;MACE,IAAMU,KAAK,GAAGf,GAAG,CAACG,KAAlB;;MACA,KAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGE,KAAK,CAACD,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;QACrC,IAAMG,IAAI,GAAGD,KAAK,CAACF,CAAD,CAAlB,CADqC,CAGrC;;QACA,QAAQG,IAAI,CAACJ,IAAb;UACE,KAAK,WAAL,CADF,CAEE;UACA;UACA;;UACA,KAAK,oBAAL,CALF,CAME;;UACA,KAAK,WAAL;UACA,KAAK,mBAAL;UACA,KAAK,aAAL;UACA,KAAK,cAAL;UACA,KAAK,iBAAL;YACE;QAZJ;;QAeA,IAAMK,IAAI,GAAGD,IAAb;;QACA,QAAQC,IAAI,CAACL,IAAb;UACE,KAAK,WAAL;YACEM,uBAAuB,CAACD,IAAI,CAACd,KAAN,EAAaQ,MAAb,EAAqBN,UAArB,CAAvB;YACA;;UACF,KAAK,KAAL;YACE,IAAIY,IAAI,CAACE,UAAL,KAAoB,IAAxB,EAA8B;cAC5B,MAAMC,KAAK,CAACzB,sBAAD,CAAX;YACD;;YACD,uBAAQsB,IAAI,CAACd,KAAb,EAAoB,UAACkB,IAAD,EAAK;cACvB,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;gBAC5BH,uBAAuB,CAACG,IAAD,EAAOV,MAAP,EAAeN,UAAf,CAAvB;cACD,CAFD,MAEO;gBACL;gBACA,IAAMiB,KAAK,GAAGD,IAAd,CAFK,CAGL;;gBACA,IAAIhB,UAAU,KAAK,IAAnB,EAAyB;kBACvB,KACE,IAAIkB,SAAS,GAAGD,KAAK,CAACE,IADxB,EAEED,SAAS,IAAID,KAAK,CAACG,EAFrB,EAGEF,SAAS,EAHX,EAIE;oBACAL,uBAAuB,CAACK,SAAD,EAAYZ,MAAZ,EAAoBN,UAApB,CAAvB;kBACD;gBACF,CARD,CASA;gBATA,KAUK;kBACH;kBACA,KACE,IAAIkB,SAAS,GAAGD,KAAK,CAACE,IADxB,EAEED,SAAS,IAAID,KAAK,CAACG,EAAnB,IAAyBF,SAAS,GAAGG,0BAFvC,EAGEH,SAAS,EAHX,EAIE;oBACAL,uBAAuB,CAACK,SAAD,EAAYZ,MAAZ,EAAoBN,UAApB,CAAvB;kBACD,CARE,CAUH;;;kBACA,IAAIiB,KAAK,CAACG,EAAN,IAAYC,0BAAhB,EAAoC;oBAClC,IAAMC,WAAW,GACfL,KAAK,CAACE,IAAN,IAAcE,0BAAd,GACIJ,KAAK,CAACE,IADV,GAEIE,0BAHN;oBAIA,IAAME,WAAW,GAAGN,KAAK,CAACG,EAA1B;oBACA,IAAMI,SAAS,GAAG,sCAAyBF,WAAzB,CAAlB;oBACA,IAAMG,SAAS,GAAG,sCAAyBF,WAAzB,CAAlB;;oBAEA,KACE,IAAIG,UAAU,GAAGF,SADnB,EAEEE,UAAU,IAAID,SAFhB,EAGEC,UAAU,EAHZ,EAIE;sBACApB,MAAM,CAACoB,UAAD,CAAN,GAAqBA,UAArB;oBACD;kBACF;gBACF;cACF;YACF,CA/CD;YAgDA;;UACF,KAAK,OAAL;YACE7B,yBAAyB,CAACe,IAAI,CAACd,KAAN,EAAaQ,MAAb,EAAqBN,UAArB,CAAzB;YACA;;UACF;;UACA;YACE,MAAMe,KAAK,CAAC,sBAAD,CAAX;QA9DJ,CApBqC,CAqFrC;;;QACA,IAAMY,oBAAoB,GACxBf,IAAI,CAACgB,UAAL,KAAoBC,SAApB,IAAiCjB,IAAI,CAACgB,UAAL,CAAgBE,OAAhB,KAA4B,CAD/D;;QAEA,KACE;QACA;QACClB,IAAI,CAACL,IAAL,KAAc,OAAd,IAAyBwB,eAAe,CAACnB,IAAD,CAAf,KAA0B,KAApD,IACA;QACCA,IAAI,CAACL,IAAL,KAAc,OAAd,IAAyBoB,oBAAoB,KAAK,KALrD,EAME;UACA;QACD;MACF;;MACD;;IACF;;IACA;MACE,MAAMZ,KAAK,CAAC,uBAAD,CAAX;EA7GJ,CAFmB,CAkHnB;;;EACA,OAAO,sBAAOT,MAAP,CAAP;AACD;;AAvHDf;;AAyHA,SAASsB,uBAAT,CACEG,IADF,EAEEV,MAFF,EAGEN,UAHF,EAGqB;EAEnB,IAAMgC,gBAAgB,GAAG,sCAAyBhB,IAAzB,CAAzB;EACAV,MAAM,CAAC0B,gBAAD,CAAN,GAA2BA,gBAA3B;;EAEA,IAAIhC,UAAU,KAAK,IAAnB,EAAyB;IACvBiC,gBAAgB,CAACjB,IAAD,EAAOV,MAAP,CAAhB;EACD;AACF;;AAED,SAAS2B,gBAAT,CACEjB,IADF,EAEEV,MAFF,EAEwC;EAEtC,IAAM4B,IAAI,GAAGC,MAAM,CAACC,YAAP,CAAoBpB,IAApB,CAAb;EACA,IAAMqB,SAAS,GAAGH,IAAI,CAACI,WAAL,EAAlB;EACA;;EACA,IAAID,SAAS,KAAKH,IAAlB,EAAwB;IACtB,IAAMF,gBAAgB,GAAG,sCAAyBK,SAAS,CAACE,UAAV,CAAqB,CAArB,CAAzB,CAAzB;IACAjC,MAAM,CAAC0B,gBAAD,CAAN,GAA2BA,gBAA3B;EACD,CAHD,MAGO;IACL,IAAMQ,SAAS,GAAGN,IAAI,CAACO,WAAL,EAAlB;;IACA,IAAID,SAAS,KAAKN,IAAlB,EAAwB;MACtB,IAAMF,gBAAgB,GAAG,sCAAyBQ,SAAS,CAACD,UAAV,CAAqB,CAArB,CAAzB,CAAzB;MACAjC,MAAM,CAAC0B,gBAAD,CAAN,GAA2BA,gBAA3B;IACD;EACF;AACF;;AAED,SAASU,QAAT,CAAkBC,OAAlB,EAAgCC,eAAhC,EAAyD;EACvD,OAAO,oBAAKD,OAAO,CAAC7C,KAAb,EAAoB,UAAC+C,WAAD,EAAY;IACrC,IAAI,OAAOA,WAAP,KAAuB,QAA3B,EAAqC;MACnC,OAAO,wBAASD,eAAT,EAA0BC,WAA1B,CAAP;IACD,CAFD,MAEO;MACL;MACA,IAAMC,OAAK,GAAQD,WAAnB;MACA,OACE,oBACED,eADF,EAEE,UAACG,UAAD,EAAW;QAAK,cAAK,CAAC5B,IAAN,IAAc4B,UAAd,IAA4BA,UAAU,IAAID,OAAK,CAAC1B,EAAhD;MAAkD,CAFpE,MAGMS,SAJR;IAMD;EACF,CAbM,CAAP;AAcD;;AAED,SAASE,eAAT,CAAyBpC,GAAzB,EAAiC;EAC/B,IAAMiC,UAAU,GAAIjC,GAAY,CAACiC,UAAjC;;EACA,IAAIA,UAAU,IAAIA,UAAU,CAACE,OAAX,KAAuB,CAAzC,EAA4C;IAC1C,OAAO,IAAP;EACD;;EAED,IAAI,CAACnC,GAAG,CAACG,KAAT,EAAgB;IACd,OAAO,KAAP;EACD;;EAED,OAAO,uBAAQH,GAAG,CAACG,KAAZ,IACH,qBAAMH,GAAG,CAACG,KAAV,EAAiBiC,eAAjB,CADG,GAEHA,eAAe,CAACpC,GAAG,CAACG,KAAL,CAFnB;AAGD;;AAED;AAAA;AAAA;EAA6BkD;;EAG3B,wBAAoBJ,eAApB,EAA6C;IAA7C,YACEK,qBAAO,IADT;;IAAoBC;IAFpBA,cAAiB,KAAjB;;EAIC;;EAEDC,mDAAcC,IAAd,EAA2B;IACzB;IACA,IAAI,KAAKC,KAAL,KAAe,IAAnB,EAAyB;MACvB;IACD,CAJwB,CAMzB;IACA;;;IACA,QAAQD,IAAI,CAAC7C,IAAb;MACE,KAAK,WAAL;QACE,KAAK+C,cAAL,CAAoBF,IAApB;QACA;;MACF,KAAK,mBAAL;QACE,KAAKG,sBAAL,CAA4BH,IAA5B;QACA;IANJ;;IASAH,iBAAMO,aAAN,CAAmBC,IAAnB,CAAmB,IAAnB,EAAoBL,IAApB;EACD,CAlBD;;EAoBAD,oDAAeC,IAAf,EAA8B;IAC5B,IAAI,wBAAS,KAAKR,eAAd,EAA+BQ,IAAI,CAACtD,KAApC,CAAJ,EAAgD;MAC9C,KAAKuD,KAAL,GAAa,IAAb;IACD;EACF,CAJD;;EAMAF,8CAASC,IAAT,EAAkB;IAChB,IAAIA,IAAI,CAACtC,UAAT,EAAqB;MACnB,IAAI4B,QAAQ,CAACU,IAAD,EAAO,KAAKR,eAAZ,CAAR,KAAyCf,SAA7C,EAAwD;QACtD,KAAKwB,KAAL,GAAa,IAAb;MACD;IACF,CAJD,MAIO;MACL,IAAIX,QAAQ,CAACU,IAAD,EAAO,KAAKR,eAAZ,CAAR,KAAyCf,SAA7C,EAAwD;QACtD,KAAKwB,KAAL,GAAa,IAAb;MACD;IACF;EACF,CAVD;;EAWF;AAAC,CA5CD,CAA6BhD,iCAA7B;;AA8CA,SAAgBqD,gBAAhB,CACEC,SADF,EAEEC,OAFF,EAE0B;EAExB,IAAIA,OAAO,YAAYC,MAAvB,EAA+B;IAC7B,IAAMlE,GAAG,GAAG,mCAAaiE,OAAb,CAAZ;IACA,IAAME,cAAc,GAAG,IAAIX,cAAJ,CAAmBQ,SAAnB,CAAvB;IACAG,cAAc,CAACC,KAAf,CAAqBpE,GAArB;IACA,OAAOmE,cAAc,CAACT,KAAtB;EACD,CALD,MAKO;IACL,OACE,oBAAUO,OAAV,EAAmB,UAAC1B,IAAD,EAAK;MACtB,OAAO,wBAASyB,SAAT,EAA6BzB,IAAK,CAACK,UAAN,CAAiB,CAAjB,CAA7B,CAAP;IACD,CAFD,MAEOV,SAHT;EAKD;AACF;;AAhBDtC","names":["complementErrorMessage","exports","getOptimizedStartCodesIndices","regExp","ensureOptimizations","ast","firstChars","firstCharOptimizedIndices","value","flags","ignoreCase","e","message","toString","msgSuffix","regexp_to_ast_1","result","type","i","length","terms","term","atom","addOptimizedIdxToResult","complement","Error","code","range","rangeCode","from","to","lexer_1","minUnOptVal","maxUnOptVal","minOptIdx","maxOptIdx","currOptIdx","isOptionalQuantifier","quantifier","undefined","atLeast","isWholeOptional","optimizedCharIdx","handleIgnoreCase","char","String","fromCharCode","upperChar","toUpperCase","charCodeAt","lowerChar","toLowerCase","findCode","setNode","targetCharCodes","codeOrRange","range_1","targetCode","__extends","_super","_this","CharCodeFinder","node","found","visitLookahead","visitNegativeLookahead","visitChildren","call","canMatchCharCode","charCodes","pattern","RegExp","charCodeFinder","visit"],"sources":["D:\\Jord\\l4fycy\\node_modules\\chevrotain\\src\\scan\\reg_exp.ts"],"sourcesContent":["import {\n  Alternative,\n  Atom,\n  BaseRegExpVisitor,\n  Character,\n  Disjunction,\n  Group,\n  Set,\n  Term,\n  VERSION\n} from \"regexp-to-ast\"\nimport isArray from \"lodash/isArray\"\nimport every from \"lodash/every\"\nimport forEach from \"lodash/forEach\"\nimport find from \"lodash/find\"\nimport values from \"lodash/values\"\nimport includes from \"lodash/includes\"\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\"\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser\"\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer\"\n\nconst complementErrorMessage =\n  \"Complement Sets are not supported for first char optimization\"\nexport const failedOptimizationPrefixMsg =\n  'Unable to use \"first char\" lexer optimizations:\\n'\n\nexport function getOptimizedStartCodesIndices(\n  regExp: RegExp,\n  ensureOptimizations = false\n): number[] {\n  try {\n    const ast = getRegExpAst(regExp)\n    const firstChars = firstCharOptimizedIndices(\n      ast.value,\n      {},\n      ast.flags.ignoreCase\n    )\n    return firstChars\n  } catch (e) {\n    /* istanbul ignore next */\n    // Testing this relies on the regexp-to-ast library having a bug... */\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n    if (e.message === complementErrorMessage) {\n      if (ensureOptimizations) {\n        PRINT_WARNING(\n          `${failedOptimizationPrefixMsg}` +\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\"\n        )\n      }\n    } else {\n      let msgSuffix = \"\"\n      if (ensureOptimizations) {\n        msgSuffix =\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\"\n      }\n      PRINT_ERROR(\n        `${failedOptimizationPrefixMsg}\\n` +\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n          `\\tUsing the regexp-to-ast library version: ${VERSION}\\n` +\n          \"\\tPlease open an issue at: https://github.com/bd82/regexp-to-ast/issues\" +\n          msgSuffix\n      )\n    }\n  }\n\n  return []\n}\n\nexport function firstCharOptimizedIndices(\n  ast: ASTNode,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n): number[] {\n  switch (ast.type) {\n    case \"Disjunction\":\n      for (let i = 0; i < ast.value.length; i++) {\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase)\n      }\n      break\n    case \"Alternative\":\n      const terms = ast.value\n      for (let i = 0; i < terms.length; i++) {\n        const term = terms[i]\n\n        // skip terms that cannot effect the first char results\n        switch (term.type) {\n          case \"EndAnchor\":\n          // A group back reference cannot affect potential starting char.\n          // because if a back reference is the first production than automatically\n          // the group being referenced has had to come BEFORE so its codes have already been added\n          case \"GroupBackReference\":\n          // assertions do not affect potential starting codes\n          case \"Lookahead\":\n          case \"NegativeLookahead\":\n          case \"StartAnchor\":\n          case \"WordBoundary\":\n          case \"NonWordBoundary\":\n            continue\n        }\n\n        const atom = term\n        switch (atom.type) {\n          case \"Character\":\n            addOptimizedIdxToResult(atom.value, result, ignoreCase)\n            break\n          case \"Set\":\n            if (atom.complement === true) {\n              throw Error(complementErrorMessage)\n            }\n            forEach(atom.value, (code) => {\n              if (typeof code === \"number\") {\n                addOptimizedIdxToResult(code, result, ignoreCase)\n              } else {\n                // range\n                const range = code as any\n                // cannot optimize when ignoreCase is\n                if (ignoreCase === true) {\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n                }\n                // Optimization (2 orders of magnitude less work for very large ranges)\n                else {\n                  // handle unoptimized values\n                  for (\n                    let rangeCode = range.from;\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\n                    rangeCode++\n                  ) {\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase)\n                  }\n\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\n                  if (range.to >= minOptimizationVal) {\n                    const minUnOptVal =\n                      range.from >= minOptimizationVal\n                        ? range.from\n                        : minOptimizationVal\n                    const maxUnOptVal = range.to\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal)\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal)\n\n                    for (\n                      let currOptIdx = minOptIdx;\n                      currOptIdx <= maxOptIdx;\n                      currOptIdx++\n                    ) {\n                      result[currOptIdx] = currOptIdx\n                    }\n                  }\n                }\n              }\n            })\n            break\n          case \"Group\":\n            firstCharOptimizedIndices(atom.value, result, ignoreCase)\n            break\n          /* istanbul ignore next */\n          default:\n            throw Error(\"Non Exhaustive Match\")\n        }\n\n        // reached a mandatory production, no more **start** codes can be found on this alternative\n        const isOptionalQuantifier =\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0\n        if (\n          // A group may be optional due to empty contents /(?:)/\n          // or if everything inside it is optional /((a)?)/\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\n          // If this term is not a group it may only be optional if it has an optional quantifier\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\n        ) {\n          break\n        }\n      }\n      break\n    /* istanbul ignore next */\n    default:\n      throw Error(\"non exhaustive match!\")\n  }\n\n  // console.log(Object.keys(result).length)\n  return values(result)\n}\n\nfunction addOptimizedIdxToResult(\n  code: number,\n  result: { [charCode: number]: number },\n  ignoreCase: boolean\n) {\n  const optimizedCharIdx = charCodeToOptimizedIndex(code)\n  result[optimizedCharIdx] = optimizedCharIdx\n\n  if (ignoreCase === true) {\n    handleIgnoreCase(code, result)\n  }\n}\n\nfunction handleIgnoreCase(\n  code: number,\n  result: { [charCode: number]: number }\n) {\n  const char = String.fromCharCode(code)\n  const upperChar = char.toUpperCase()\n  /* istanbul ignore else */\n  if (upperChar !== char) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0))\n    result[optimizedCharIdx] = optimizedCharIdx\n  } else {\n    const lowerChar = char.toLowerCase()\n    if (lowerChar !== char) {\n      const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0))\n      result[optimizedCharIdx] = optimizedCharIdx\n    }\n  }\n}\n\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\n  return find(setNode.value, (codeOrRange) => {\n    if (typeof codeOrRange === \"number\") {\n      return includes(targetCharCodes, codeOrRange)\n    } else {\n      // range\n      const range = <any>codeOrRange\n      return (\n        find(\n          targetCharCodes,\n          (targetCode) => range.from <= targetCode && targetCode <= range.to\n        ) !== undefined\n      )\n    }\n  })\n}\n\nfunction isWholeOptional(ast: any): boolean {\n  const quantifier = (ast as Atom).quantifier\n  if (quantifier && quantifier.atLeast === 0) {\n    return true\n  }\n\n  if (!ast.value) {\n    return false\n  }\n\n  return isArray(ast.value)\n    ? every(ast.value, isWholeOptional)\n    : isWholeOptional(ast.value)\n}\n\nclass CharCodeFinder extends BaseRegExpVisitor {\n  found: boolean = false\n\n  constructor(private targetCharCodes: number[]) {\n    super()\n  }\n\n  visitChildren(node: ASTNode) {\n    // No need to keep looking...\n    if (this.found === true) {\n      return\n    }\n\n    // switch lookaheads as they do not actually consume any characters thus\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n    switch (node.type) {\n      case \"Lookahead\":\n        this.visitLookahead(node)\n        return\n      case \"NegativeLookahead\":\n        this.visitNegativeLookahead(node)\n        return\n    }\n\n    super.visitChildren(node)\n  }\n\n  visitCharacter(node: Character) {\n    if (includes(this.targetCharCodes, node.value)) {\n      this.found = true\n    }\n  }\n\n  visitSet(node: Set) {\n    if (node.complement) {\n      if (findCode(node, this.targetCharCodes) === undefined) {\n        this.found = true\n      }\n    } else {\n      if (findCode(node, this.targetCharCodes) !== undefined) {\n        this.found = true\n      }\n    }\n  }\n}\n\nexport function canMatchCharCode(\n  charCodes: number[],\n  pattern: RegExp | string\n) {\n  if (pattern instanceof RegExp) {\n    const ast = getRegExpAst(pattern)\n    const charCodeFinder = new CharCodeFinder(charCodes)\n    charCodeFinder.visit(ast)\n    return charCodeFinder.found\n  } else {\n    return (\n      find(<any>pattern, (char) => {\n        return includes(charCodes, (<string>char).charCodeAt(0))\n      }) !== undefined\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}