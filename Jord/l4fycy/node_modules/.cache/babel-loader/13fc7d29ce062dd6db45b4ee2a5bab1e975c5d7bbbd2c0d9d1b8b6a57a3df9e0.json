{"ast":null,"code":"import { FLOAT32_EPSILON } from '../Constants.js';\nimport { makeEmptyBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds(triangleBounds, offset, count, target) {\n  let centroidTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  let minx = Infinity;\n  let miny = Infinity;\n  let minz = Infinity;\n  let maxx = -Infinity;\n  let maxy = -Infinity;\n  let maxz = -Infinity;\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  const includeCentroid = centroidTarget !== null;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    const hx = triangleBounds[i + 1];\n    const lx = cx - hx;\n    const rx = cx + hx;\n    if (lx < minx) minx = lx;\n    if (rx > maxx) maxx = rx;\n    if (includeCentroid && cx < cminx) cminx = cx;\n    if (includeCentroid && cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    const hy = triangleBounds[i + 3];\n    const ly = cy - hy;\n    const ry = cy + hy;\n    if (ly < miny) miny = ly;\n    if (ry > maxy) maxy = ry;\n    if (includeCentroid && cy < cminy) cminy = cy;\n    if (includeCentroid && cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    const hz = triangleBounds[i + 5];\n    const lz = cz - hz;\n    const rz = cz + hz;\n    if (lz < minz) minz = lz;\n    if (rz > maxz) maxz = rz;\n    if (includeCentroid && cz < cminz) cminz = cz;\n    if (includeCentroid && cz > cmaxz) cmaxz = cz;\n  }\n  target[0] = minx;\n  target[1] = miny;\n  target[2] = minz;\n  target[3] = maxx;\n  target[4] = maxy;\n  target[5] = maxz;\n  if (includeCentroid) {\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n  }\n}\n\n// A stand alone function for retrieving the centroid bounds.\nexport function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n  let cminx = Infinity;\n  let cminy = Infinity;\n  let cminz = Infinity;\n  let cmaxx = -Infinity;\n  let cmaxy = -Infinity;\n  let cmaxz = -Infinity;\n  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {\n    const cx = triangleBounds[i + 0];\n    if (cx < cminx) cminx = cx;\n    if (cx > cmaxx) cmaxx = cx;\n    const cy = triangleBounds[i + 2];\n    if (cy < cminy) cminy = cy;\n    if (cy > cmaxy) cmaxy = cy;\n    const cz = triangleBounds[i + 4];\n    if (cz < cminz) cminz = cz;\n    if (cz > cmaxz) cmaxz = cz;\n  }\n  centroidTarget[0] = cminx;\n  centroidTarget[1] = cminy;\n  centroidTarget[2] = cminz;\n  centroidTarget[3] = cmaxx;\n  centroidTarget[4] = cmaxy;\n  centroidTarget[5] = cmaxz;\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds(geo, fullBounds) {\n  // clear the bounds to empty\n  makeEmptyBounds(fullBounds);\n  const posAttr = geo.attributes.position;\n  const index = geo.index ? geo.index.array : null;\n  const triCount = getTriCount(geo);\n  const triangleBounds = new Float32Array(triCount * 6);\n  const normalized = posAttr.normalized;\n\n  // used for non-normalized positions\n  const posArr = posAttr.array;\n\n  // support for an interleaved position buffer\n  const bufferOffset = posAttr.offset || 0;\n  let stride = 3;\n  if (posAttr.isInterleavedBufferAttribute) {\n    stride = posAttr.data.stride;\n  }\n\n  // used for normalized positions\n  const getters = ['getX', 'getY', 'getZ'];\n  for (let tri = 0; tri < triCount; tri++) {\n    const tri3 = tri * 3;\n    const tri6 = tri * 6;\n    let ai = tri3 + 0;\n    let bi = tri3 + 1;\n    let ci = tri3 + 2;\n    if (index) {\n      ai = index[ai];\n      bi = index[bi];\n      ci = index[ci];\n    }\n\n    // we add the stride and offset here since we access the array directly\n    // below for the sake of performance\n    if (!normalized) {\n      ai = ai * stride + bufferOffset;\n      bi = bi * stride + bufferOffset;\n      ci = ci * stride + bufferOffset;\n    }\n    for (let el = 0; el < 3; el++) {\n      let a, b, c;\n      if (normalized) {\n        a = posAttr[getters[el]](ai);\n        b = posAttr[getters[el]](bi);\n        c = posAttr[getters[el]](ci);\n      } else {\n        a = posArr[ai + el];\n        b = posArr[bi + el];\n        c = posArr[ci + el];\n      }\n      let min = a;\n      if (b < min) min = b;\n      if (c < min) min = c;\n      let max = a;\n      if (b > max) max = b;\n      if (c > max) max = c;\n\n      // Increase the bounds size by float32 epsilon to avoid precision errors when\n      // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n      // worked with.\n      const halfExtents = (max - min) / 2;\n      const el2 = el * 2;\n      triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;\n      if (min < fullBounds[el]) fullBounds[el] = min;\n      if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n    }\n  }\n  return triangleBounds;\n}","map":{"version":3,"names":["FLOAT32_EPSILON","makeEmptyBounds","getTriCount","getBounds","triangleBounds","offset","count","target","centroidTarget","arguments","length","undefined","minx","Infinity","miny","minz","maxx","maxy","maxz","cminx","cminy","cminz","cmaxx","cmaxy","cmaxz","includeCentroid","i","end","cx","hx","lx","rx","cy","hy","ly","ry","cz","hz","lz","rz","getCentroidBounds","computeTriangleBounds","geo","fullBounds","posAttr","attributes","position","index","array","triCount","Float32Array","normalized","posArr","bufferOffset","stride","isInterleavedBufferAttribute","data","getters","tri","tri3","tri6","ai","bi","ci","el","a","b","c","min","max","halfExtents","el2","Math","abs"],"sources":["D:/Github/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js"],"sourcesContent":["import { FLOAT32_EPSILON } from '../Constants.js';\nimport { makeEmptyBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget = null ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tconst includeCentroid = centroidTarget !== null;\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( includeCentroid && cx < cminx ) cminx = cx;\n\t\tif ( includeCentroid && cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( includeCentroid && cy < cminy ) cminy = cy;\n\t\tif ( includeCentroid && cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( includeCentroid && cz < cminz ) cminz = cz;\n\t\tif ( includeCentroid && cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tif ( includeCentroid ) {\n\n\t\tcentroidTarget[ 0 ] = cminx;\n\t\tcentroidTarget[ 1 ] = cminy;\n\t\tcentroidTarget[ 2 ] = cminz;\n\n\t\tcentroidTarget[ 3 ] = cmaxx;\n\t\tcentroidTarget[ 4 ] = cmaxy;\n\t\tcentroidTarget[ 5 ] = cmaxz;\n\n\t}\n\n}\n\n// A stand alone function for retrieving the centroid bounds.\nexport function getCentroidBounds( triangleBounds, offset, count, centroidTarget ) {\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, fullBounds ) {\n\n\t// clear the bounds to empty\n\tmakeEmptyBounds( fullBounds );\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst triangleBounds = new Float32Array( triCount * 6 );\n\tconst normalized = posAttr.normalized;\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = 0; tri < triCount; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t\tif ( min < fullBounds[ el ] ) fullBounds[ el ] = min;\n\t\t\tif ( max > fullBounds[ el + 3 ] ) fullBounds[ el + 3 ] = max;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}