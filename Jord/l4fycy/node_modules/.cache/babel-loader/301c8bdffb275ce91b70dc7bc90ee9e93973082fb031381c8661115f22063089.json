{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useRef, useMemo, useLayoutEffect } from 'react';\nimport { extend, useThree, useFrame } from '@react-three/fiber';\nimport { MeshBVHUniformStruct, MeshBVH, SAH } from 'three-mesh-bvh';\nimport { MeshRefractionMaterial as MeshRefractionMaterial$1 } from '../materials/MeshRefractionMaterial.js';\nconst isCubeTexture = def => def && def.isCubeTexture;\nfunction MeshRefractionMaterial(_ref2) {\n  let {\n    aberrationStrength = 0,\n    fastChroma = true,\n    envMap,\n    ...props\n  } = _ref2;\n  extend({\n    MeshRefractionMaterial: MeshRefractionMaterial$1\n  });\n  const material = useRef();\n  const {\n    size\n  } = useThree();\n  const defines = useMemo(() => {\n    var _ref, _envMap$image$;\n    const temp = {};\n    // Sampler2D and SamplerCube need different defines\n    const isCubeMap = isCubeTexture(envMap);\n    const w = (_ref = isCubeMap ? (_envMap$image$ = envMap.image[0]) == null ? void 0 : _envMap$image$.width : envMap.image.width) !== null && _ref !== void 0 ? _ref : 1024;\n    const cubeSize = w / 4;\n    const _lodMax = Math.floor(Math.log2(cubeSize));\n    const _cubeSize = Math.pow(2, _lodMax);\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\n    const height = 4 * _cubeSize;\n    if (isCubeMap) temp.ENVMAP_TYPE_CUBEM = '';\n    temp.CUBEUV_TEXEL_WIDTH = \"\".concat(1.0 / width);\n    temp.CUBEUV_TEXEL_HEIGHT = \"\".concat(1.0 / height);\n    temp.CUBEUV_MAX_MIP = \"\".concat(_lodMax, \".0\");\n    // Add defines from chromatic aberration\n    if (aberrationStrength > 0) temp.CHROMATIC_ABERRATIONS = '';\n    if (fastChroma) temp.FAST_CHROMA = '';\n    return temp;\n  }, [aberrationStrength, fastChroma]);\n  useLayoutEffect(() => {\n    var _material$current;\n    // Get the geometry of this materials parent\n    const geometry = (_material$current = material.current) == null || (_material$current = _material$current.__r3f) == null || (_material$current = _material$current.parent) == null ? void 0 : _material$current.geometry;\n    // Update the BVH\n    if (geometry) {\n      material.current.bvh = new MeshBVHUniformStruct();\n      material.current.bvh.updateFrom(new MeshBVH(geometry.clone().toNonIndexed(), {\n        lazyGeneration: false,\n        strategy: SAH\n      }));\n    }\n  }, []);\n  useFrame(_ref3 => {\n    let {\n      camera\n    } = _ref3;\n    material.current.viewMatrixInverse = camera.matrixWorld;\n    material.current.projectionMatrixInverse = camera.projectionMatrixInverse;\n  });\n  return /*#__PURE__*/React.createElement(\"meshRefractionMaterial\", _extends({\n    // @ts-ignore\n    key: JSON.stringify(defines)\n    // @ts-ignore\n    ,\n\n    defines: defines,\n    ref: material,\n    resolution: [size.width, size.height],\n    aberrationStrength: aberrationStrength,\n    envMap: envMap\n  }, props));\n}\nexport { MeshRefractionMaterial };","map":{"version":3,"names":["_extends","React","useRef","useMemo","useLayoutEffect","extend","useThree","useFrame","MeshBVHUniformStruct","MeshBVH","SAH","MeshRefractionMaterial","MeshRefractionMaterial$1","isCubeTexture","def","_ref2","aberrationStrength","fastChroma","envMap","props","material","size","defines","_ref","_envMap$image$","temp","isCubeMap","w","image","width","cubeSize","_lodMax","Math","floor","log2","_cubeSize","pow","max","height","ENVMAP_TYPE_CUBEM","CUBEUV_TEXEL_WIDTH","concat","CUBEUV_TEXEL_HEIGHT","CUBEUV_MAX_MIP","CHROMATIC_ABERRATIONS","FAST_CHROMA","_material$current","geometry","current","__r3f","parent","bvh","updateFrom","clone","toNonIndexed","lazyGeneration","strategy","_ref3","camera","viewMatrixInverse","matrixWorld","projectionMatrixInverse","createElement","key","JSON","stringify","ref","resolution"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/@react-three/drei/core/MeshRefractionMaterial.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\r\nimport * as React from 'react';\r\nimport { useRef, useMemo, useLayoutEffect } from 'react';\r\nimport { extend, useThree, useFrame } from '@react-three/fiber';\r\nimport { MeshBVHUniformStruct, MeshBVH, SAH } from 'three-mesh-bvh';\r\nimport { MeshRefractionMaterial as MeshRefractionMaterial$1 } from '../materials/MeshRefractionMaterial.js';\r\n\r\nconst isCubeTexture = def => def && def.isCubeTexture;\r\nfunction MeshRefractionMaterial({\r\n  aberrationStrength = 0,\r\n  fastChroma = true,\r\n  envMap,\r\n  ...props\r\n}) {\r\n  extend({\r\n    MeshRefractionMaterial: MeshRefractionMaterial$1\r\n  });\r\n  const material = useRef();\r\n  const {\r\n    size\r\n  } = useThree();\r\n  const defines = useMemo(() => {\r\n    var _ref, _envMap$image$;\r\n    const temp = {};\r\n    // Sampler2D and SamplerCube need different defines\r\n    const isCubeMap = isCubeTexture(envMap);\r\n    const w = (_ref = isCubeMap ? (_envMap$image$ = envMap.image[0]) == null ? void 0 : _envMap$image$.width : envMap.image.width) !== null && _ref !== void 0 ? _ref : 1024;\r\n    const cubeSize = w / 4;\r\n    const _lodMax = Math.floor(Math.log2(cubeSize));\r\n    const _cubeSize = Math.pow(2, _lodMax);\r\n    const width = 3 * Math.max(_cubeSize, 16 * 7);\r\n    const height = 4 * _cubeSize;\r\n    if (isCubeMap) temp.ENVMAP_TYPE_CUBEM = '';\r\n    temp.CUBEUV_TEXEL_WIDTH = `${1.0 / width}`;\r\n    temp.CUBEUV_TEXEL_HEIGHT = `${1.0 / height}`;\r\n    temp.CUBEUV_MAX_MIP = `${_lodMax}.0`;\r\n    // Add defines from chromatic aberration\r\n    if (aberrationStrength > 0) temp.CHROMATIC_ABERRATIONS = '';\r\n    if (fastChroma) temp.FAST_CHROMA = '';\r\n    return temp;\r\n  }, [aberrationStrength, fastChroma]);\r\n  useLayoutEffect(() => {\r\n    var _material$current;\r\n    // Get the geometry of this materials parent\r\n    const geometry = (_material$current = material.current) == null || (_material$current = _material$current.__r3f) == null || (_material$current = _material$current.parent) == null ? void 0 : _material$current.geometry;\r\n    // Update the BVH\r\n    if (geometry) {\r\n      material.current.bvh = new MeshBVHUniformStruct();\r\n      material.current.bvh.updateFrom(new MeshBVH(geometry.clone().toNonIndexed(), {\r\n        lazyGeneration: false,\r\n        strategy: SAH\r\n      }));\r\n    }\r\n  }, []);\r\n  useFrame(({\r\n    camera\r\n  }) => {\r\n    material.current.viewMatrixInverse = camera.matrixWorld;\r\n    material.current.projectionMatrixInverse = camera.projectionMatrixInverse;\r\n  });\r\n  return /*#__PURE__*/React.createElement(\"meshRefractionMaterial\", _extends({\r\n    // @ts-ignore\r\n    key: JSON.stringify(defines)\r\n    // @ts-ignore\r\n    ,\r\n    defines: defines,\r\n    ref: material,\r\n    resolution: [size.width, size.height],\r\n    aberrationStrength: aberrationStrength,\r\n    envMap: envMap\r\n  }, props));\r\n}\r\n\r\nexport { MeshRefractionMaterial };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}