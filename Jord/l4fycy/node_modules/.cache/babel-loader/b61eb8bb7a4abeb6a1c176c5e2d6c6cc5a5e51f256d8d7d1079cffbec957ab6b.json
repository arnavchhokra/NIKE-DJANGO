{"ast":null,"code":"import { BufferAttribute } from 'three';\nexport function getVertexCount(geo) {\n  return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nexport function getTriCount(geo) {\n  return getVertexCount(geo) / 3;\n}\nexport function getIndexArray(vertexCount) {\n  let BufferConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ArrayBuffer;\n  if (vertexCount > 65535) {\n    return new Uint32Array(new BufferConstructor(4 * vertexCount));\n  } else {\n    return new Uint16Array(new BufferConstructor(2 * vertexCount));\n  }\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex(geo, options) {\n  if (!geo.index) {\n    const vertexCount = geo.attributes.position.count;\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    const index = getIndexArray(vertexCount, BufferConstructor);\n    geo.setIndex(new BufferAttribute(index, 1));\n    for (let i = 0; i < vertexCount; i++) {\n      index[i] = i;\n    }\n  }\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange(geo) {\n  const triCount = getTriCount(geo);\n  const drawRange = geo.drawRange;\n  const start = drawRange.start / 3;\n  const end = (drawRange.start + drawRange.count) / 3;\n  const offset = Math.max(0, start);\n  const count = Math.min(triCount, end) - offset;\n  return [{\n    offset: Math.floor(offset),\n    count: Math.floor(count)\n  }];\n}\nexport function getRootIndexRanges(geo) {\n  if (!geo.groups || !geo.groups.length) {\n    return getFullGeometryRange(geo);\n  }\n  const ranges = [];\n  const rangeBoundaries = new Set();\n  const drawRange = geo.drawRange;\n  const drawRangeStart = drawRange.start / 3;\n  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n  for (const group of geo.groups) {\n    const groupStart = group.start / 3;\n    const groupEnd = (group.start + group.count) / 3;\n    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n  }\n\n  // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);\n  for (let i = 0; i < sortedBoundaries.length - 1; i++) {\n    const start = sortedBoundaries[i];\n    const end = sortedBoundaries[i + 1];\n    ranges.push({\n      offset: Math.floor(start),\n      count: Math.floor(end - start)\n    });\n  }\n  return ranges;\n}\nexport function hasGroupGaps(geometry) {\n  if (geometry.groups.length === 0) {\n    return false;\n  }\n  const vertexCount = getTriCount(geometry);\n  const groups = getRootIndexRanges(geometry).sort((a, b) => a.offset - b.offset);\n  const finalGroup = groups[groups.length - 1];\n  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n  let total = 0;\n  groups.forEach(_ref => {\n    let {\n      count\n    } = _ref;\n    return total += count;\n  });\n  return vertexCount !== total;\n}","map":{"version":3,"names":["BufferAttribute","getVertexCount","geo","index","count","attributes","position","getTriCount","getIndexArray","vertexCount","BufferConstructor","arguments","length","undefined","ArrayBuffer","Uint32Array","Uint16Array","ensureIndex","options","useSharedArrayBuffer","SharedArrayBuffer","setIndex","i","getFullGeometryRange","triCount","drawRange","start","end","offset","Math","max","min","floor","getRootIndexRanges","groups","ranges","rangeBoundaries","Set","drawRangeStart","drawRangeEnd","group","groupStart","groupEnd","add","sortedBoundaries","Array","from","values","sort","a","b","push","hasGroupGaps","geometry","finalGroup","total","forEach","_ref"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js"],"sourcesContent":["import { BufferAttribute } from 'three';\r\n\r\nexport function getVertexCount( geo ) {\r\n\r\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\r\n\r\n}\r\n\r\nexport function getTriCount( geo ) {\r\n\r\n\treturn getVertexCount( geo ) / 3;\r\n\r\n}\r\n\r\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\r\n\r\n\tif ( vertexCount > 65535 ) {\r\n\r\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\r\n\r\n\t} else {\r\n\r\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// ensures that an index is present on the geometry\r\nexport function ensureIndex( geo, options ) {\r\n\r\n\tif ( ! geo.index ) {\r\n\r\n\t\tconst vertexCount = geo.attributes.position.count;\r\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\r\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\r\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\r\n\r\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\r\n\r\n\t\t\tindex[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\r\n// region in the geometry index that belongs to a different set of material groups requires\r\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\r\n// with triangle indices belongs to another group. For example, if the groups were like this:\r\n//\r\n// [-------------------------------------------------------------]\r\n// |__________________|\r\n//   g0 = [0, 20]  |______________________||_____________________|\r\n//                      g1 = [16, 40]           g2 = [41, 60]\r\n//\r\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\r\nexport function getFullGeometryRange( geo ) {\r\n\r\n\tconst triCount = getTriCount( geo );\r\n\tconst drawRange = geo.drawRange;\r\n\tconst start = drawRange.start / 3;\r\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\r\n\r\n\tconst offset = Math.max( 0, start );\r\n\tconst count = Math.min( triCount, end ) - offset;\r\n\treturn [ {\r\n\t\toffset: Math.floor( offset ),\r\n\t\tcount: Math.floor( count ),\r\n\t} ];\r\n\r\n}\r\n\r\nexport function getRootIndexRanges( geo ) {\r\n\r\n\tif ( ! geo.groups || ! geo.groups.length ) {\r\n\r\n\t\treturn getFullGeometryRange( geo );\r\n\r\n\t}\r\n\r\n\tconst ranges = [];\r\n\tconst rangeBoundaries = new Set();\r\n\r\n\tconst drawRange = geo.drawRange;\r\n\tconst drawRangeStart = drawRange.start / 3;\r\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\r\n\tfor ( const group of geo.groups ) {\r\n\r\n\t\tconst groupStart = group.start / 3;\r\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\r\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\r\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\r\n\r\n\t}\r\n\r\n\r\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\r\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\r\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\r\n\r\n\t\tconst start = sortedBoundaries[ i ];\r\n\t\tconst end = sortedBoundaries[ i + 1 ];\r\n\r\n\t\tranges.push( {\r\n\t\t\toffset: Math.floor( start ),\r\n\t\t\tcount: Math.floor( end - start ),\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\treturn ranges;\r\n\r\n}\r\n\r\nexport function hasGroupGaps( geometry ) {\r\n\r\n\tif ( geometry.groups.length === 0 ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tconst vertexCount = getTriCount( geometry );\r\n\tconst groups = getRootIndexRanges( geometry )\r\n\t\t.sort( ( a, b ) => a.offset - b.offset );\r\n\r\n\tconst finalGroup = groups[ groups.length - 1 ];\r\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\r\n\r\n\tlet total = 0;\r\n\tgroups.forEach( ( { count } ) => total += count );\r\n\treturn vertexCount !== total;\r\n\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}