{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.areTokenCategoriesNotUsed = exports.isStrictPrefixOfPath = exports.containsPath = exports.getLookaheadPathsForOptionalProd = exports.getLookaheadPathsForOr = exports.lookAheadSequenceFromAlternatives = exports.buildSingleAlternativeLookaheadFunction = exports.buildAlternativesLookAheadFunc = exports.buildLookaheadFuncForOptionalProd = exports.buildLookaheadFuncForOr = exports.getProdType = exports.PROD_TYPE = void 0;\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar flatten_1 = __importDefault(require(\"lodash/flatten\"));\n\nvar every_1 = __importDefault(require(\"lodash/every\"));\n\nvar map_1 = __importDefault(require(\"lodash/map\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar has_1 = __importDefault(require(\"lodash/has\"));\n\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nvar interpreter_1 = require(\"./interpreter\");\n\nvar rest_1 = require(\"./rest\");\n\nvar tokens_1 = require(\"../../scan/tokens\");\n\nvar gast_1 = require(\"@chevrotain/gast\");\n\nvar gast_2 = require(\"@chevrotain/gast\");\n\nvar PROD_TYPE;\n\n(function (PROD_TYPE) {\n  PROD_TYPE[PROD_TYPE[\"OPTION\"] = 0] = \"OPTION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION\"] = 1] = \"REPETITION\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY\"] = 2] = \"REPETITION_MANDATORY\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_MANDATORY_WITH_SEPARATOR\"] = 3] = \"REPETITION_MANDATORY_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"REPETITION_WITH_SEPARATOR\"] = 4] = \"REPETITION_WITH_SEPARATOR\";\n  PROD_TYPE[PROD_TYPE[\"ALTERNATION\"] = 5] = \"ALTERNATION\";\n})(PROD_TYPE = exports.PROD_TYPE || (exports.PROD_TYPE = {}));\n\nfunction getProdType(prod) {\n  /* istanbul ignore else */\n  if (prod instanceof gast_1.Option) {\n    return PROD_TYPE.OPTION;\n  } else if (prod instanceof gast_1.Repetition) {\n    return PROD_TYPE.REPETITION;\n  } else if (prod instanceof gast_1.RepetitionMandatory) {\n    return PROD_TYPE.REPETITION_MANDATORY;\n  } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n  } else if (prod instanceof gast_1.RepetitionWithSeparator) {\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n  } else if (prod instanceof gast_1.Alternation) {\n    return PROD_TYPE.ALTERNATION;\n  } else {\n    throw Error(\"non exhaustive match\");\n  }\n}\n\nexports.getProdType = getProdType;\n\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n  return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n\nexports.buildLookaheadFuncForOr = buildLookaheadFuncForOr;\n/**\r\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\r\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\r\n *\r\n *  Example: given a production:\r\n *  ABC(DE)?DF\r\n *\r\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\r\n *  alternatives.\r\n *\r\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\r\n */\n\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n  var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n  var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\n\nexports.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;\n\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n  var numOfAlts = alts.length;\n  var areAllOneTokenLookahead = (0, every_1.default)(alts, function (currAlt) {\n    return (0, every_1.default)(currAlt, function (currPath) {\n      return currPath.length === 1;\n    });\n  }); // This version takes into account the predicates as well.\n\n  if (hasPredicates) {\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\n    return function (orAlts) {\n      // unfortunately the predicates must be extracted every single time\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n      var predicates = (0, map_1.default)(orAlts, function (currAlt) {\n        return currAlt.GATE;\n      });\n\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n        var currPredicate = predicates[t];\n\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\n          // if the predicate does not match there is no point in checking the paths\n          continue;\n        }\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n    var singleTokenAlts = (0, map_1.default)(alts, function (currAlt) {\n      return (0, flatten_1.default)(currAlt);\n    });\n    var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function (result, currAlt, idx) {\n      (0, forEach_1.default)(currAlt, function (currTokType) {\n        if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {\n          result[currTokType.tokenTypeIdx] = idx;\n        }\n\n        (0, forEach_1.default)(currTokType.categoryMatches, function (currExtendingType) {\n          if (!(0, has_1.default)(result, currExtendingType)) {\n            result[currExtendingType] = idx;\n          }\n        });\n      });\n      return result;\n    }, {});\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\n\n    return function () {\n      var nextToken = this.LA(1);\n      return choiceToAlt_1[nextToken.tokenTypeIdx];\n    };\n  } else {\n    // optimized lookahead without needing to check the predicates at all.\n    // this causes code duplication which is intentional to improve performance.\n\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\n    return function () {\n      for (var t = 0; t < numOfAlts; t++) {\n        var currAlt = alts[t];\n        var currNumOfPaths = currAlt.length;\n\n        nextPath: for (var j = 0; j < currNumOfPaths; j++) {\n          var currPath = currAlt[j];\n          var currPathLength = currPath.length;\n\n          for (var i = 0; i < currPathLength; i++) {\n            var nextToken = this.LA(i + 1);\n\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\n              // mismatch in current path\n              // try the next pth\n              continue nextPath;\n            }\n          } // found a full path that matches.\n          // this will also work for an empty ALT as the loop will be skipped\n\n\n          return t;\n        } // none of the paths for the current alternative matched\n        // try the next alternative\n\n      } // none of the alternatives could be matched\n\n\n      return undefined;\n    };\n  }\n}\n\nexports.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;\n\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n  var areAllOneTokenLookahead = (0, every_1.default)(alt, function (currPath) {\n    return currPath.length === 1;\n  });\n  var numOfPaths = alt.length; // optimized (common) case of all the lookaheads paths requiring only\n  // a single token lookahead.\n\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n    var singleTokensTypes = (0, flatten_1.default)(alt);\n\n    if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {\n      var expectedTokenType = singleTokensTypes[0];\n      var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;\n      return function () {\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;\n      };\n    } else {\n      var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function (result, currTokType, idx) {\n        result[currTokType.tokenTypeIdx] = true;\n        (0, forEach_1.default)(currTokType.categoryMatches, function (currExtendingType) {\n          result[currExtendingType] = true;\n        });\n        return result;\n      }, []);\n      return function () {\n        var nextToken = this.LA(1);\n        return choiceToAlt_2[nextToken.tokenTypeIdx] === true;\n      };\n    }\n  } else {\n    return function () {\n      nextPath: for (var j = 0; j < numOfPaths; j++) {\n        var currPath = alt[j];\n        var currPathLength = currPath.length;\n\n        for (var i = 0; i < currPathLength; i++) {\n          var nextToken = this.LA(i + 1);\n\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\n            // mismatch in current path\n            // try the next pth\n            continue nextPath;\n          }\n        } // found a full path that matches.\n\n\n        return true;\n      } // none of the paths matched\n\n\n      return false;\n    };\n  }\n}\n\nexports.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;\n\nvar RestDefinitionFinderWalker =\n/** @class */\nfunction (_super) {\n  __extends(RestDefinitionFinderWalker, _super);\n\n  function RestDefinitionFinderWalker(topProd, targetOccurrence, targetProdType) {\n    var _this = _super.call(this) || this;\n\n    _this.topProd = topProd;\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    return _this;\n  }\n\n  RestDefinitionFinderWalker.prototype.startWalking = function () {\n    this.walk(this.topProd);\n    return this.restDef;\n  };\n\n  RestDefinitionFinderWalker.prototype.checkIsTarget = function (node, expectedProdType, currRest, prevRest) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {\n      this.restDef = currRest.concat(prevRest);\n      return true;\n    } // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n\n\n    return false;\n  };\n\n  RestDefinitionFinderWalker.prototype.walkOption = function (optionProd, currRest, prevRest) {\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkAtLeastOneSep = function (atLeastOneSepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  RestDefinitionFinderWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n      _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return RestDefinitionFinderWalker;\n}(rest_1.RestWalker);\n/**\r\n * Returns the definition of a target production in a top level level rule.\r\n */\n\n\nvar InsideDefinitionFinderVisitor =\n/** @class */\nfunction (_super) {\n  __extends(InsideDefinitionFinderVisitor, _super);\n\n  function InsideDefinitionFinderVisitor(targetOccurrence, targetProdType, targetRef) {\n    var _this = _super.call(this) || this;\n\n    _this.targetOccurrence = targetOccurrence;\n    _this.targetProdType = targetProdType;\n    _this.targetRef = targetRef;\n    _this.result = [];\n    return _this;\n  }\n\n  InsideDefinitionFinderVisitor.prototype.checkIsTarget = function (node, expectedProdName) {\n    if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === undefined || node === this.targetRef)) {\n      this.result = node.definition;\n    }\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitOption = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetition = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatory = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionMandatoryWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitRepetitionWithSeparator = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n  };\n\n  InsideDefinitionFinderVisitor.prototype.visitAlternation = function (node) {\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n  };\n\n  return InsideDefinitionFinderVisitor;\n}(gast_2.GAstVisitor);\n\nfunction initializeArrayOfArrays(size) {\n  var result = new Array(size);\n\n  for (var i = 0; i < size; i++) {\n    result[i] = [];\n  }\n\n  return result;\n}\n/**\r\n * A sort of hash function between a Path in the grammar and a string.\r\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\r\n * -  A single path with categories may match multiple **actual** paths.\r\n */\n\n\nfunction pathToHashKeys(path) {\n  var keys = [\"\"];\n\n  for (var i = 0; i < path.length; i++) {\n    var tokType = path[i];\n    var longerKeys = [];\n\n    for (var j = 0; j < keys.length; j++) {\n      var currShorterKey = keys[j];\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\n\n      for (var t = 0; t < tokType.categoryMatches.length; t++) {\n        var categoriesKeySuffix = \"_\" + tokType.categoryMatches[t];\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\n      }\n    }\n\n    keys = longerKeys;\n  }\n\n  return keys;\n}\n/**\r\n * Imperative style due to being called from a hot spot\r\n */\n\n\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n  for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n    // We only want to test vs the other alternatives\n    if (currAltIdx === idx) {\n      continue;\n    }\n\n    var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n\n    for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n      var searchKey = searchPathKeys[searchIdx];\n\n      if (otherAltKnownPathsKeys[searchKey] === true) {\n        return false;\n      }\n    }\n  } // None of the SearchPathKeys were found in any of the other alternatives\n\n\n  return true;\n}\n\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n  var partialAlts = (0, map_1.default)(altsDefs, function (currAlt) {\n    return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);\n  });\n  var finalResult = initializeArrayOfArrays(partialAlts.length);\n  var altsHashes = (0, map_1.default)(partialAlts, function (currAltPaths) {\n    var dict = {};\n    (0, forEach_1.default)(currAltPaths, function (item) {\n      var keys = pathToHashKeys(item.partialPath);\n      (0, forEach_1.default)(keys, function (currKey) {\n        dict[currKey] = true;\n      });\n    });\n    return dict;\n  });\n  var newData = partialAlts; // maxLookahead loop\n\n  for (var pathLength = 1; pathLength <= k; pathLength++) {\n    var currDataset = newData;\n    newData = initializeArrayOfArrays(currDataset.length);\n\n    var _loop_1 = function _loop_1(altIdx) {\n      var currAltPathsAndSuffixes = currDataset[altIdx]; // paths in current alternative loop\n\n      for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n        var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n        var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n        var prefixKeys = pathToHashKeys(currPathPrefix);\n        var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx); // End of the line for this path.\n\n        if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {\n          var currAltResult = finalResult[altIdx]; // TODO: Can we implement a containsPath using Maps/Dictionaries?\n\n          if (containsPath(currAltResult, currPathPrefix) === false) {\n            currAltResult.push(currPathPrefix); // Update all new  keys for the current path.\n\n            for (var j = 0; j < prefixKeys.length; j++) {\n              var currKey = prefixKeys[j];\n              altsHashes[altIdx][currKey] = true;\n            }\n          }\n        } // Expand longer paths\n        else {\n          var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes); // Update keys for new known paths\n\n          (0, forEach_1.default)(newPartialPathsAndSuffixes, function (item) {\n            var prefixKeys = pathToHashKeys(item.partialPath);\n            (0, forEach_1.default)(prefixKeys, function (key) {\n              altsHashes[altIdx][key] = true;\n            });\n          });\n        }\n      }\n    }; // alternatives loop\n\n\n    for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {\n      _loop_1(altIdx);\n    }\n  }\n\n  return finalResult;\n}\n\nexports.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;\n\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n  var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n  ruleGrammar.accept(visitor);\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\n\nexports.getLookaheadPathsForOr = getLookaheadPathsForOr;\n\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n  var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n  ruleGrammar.accept(insideDefVisitor);\n  var insideDef = insideDefVisitor.result;\n  var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n  var afterDef = afterDefWalker.startWalking();\n  var insideFlat = new gast_1.Alternative({\n    definition: insideDef\n  });\n  var afterFlat = new gast_1.Alternative({\n    definition: afterDef\n  });\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\n\nexports.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;\n\nfunction containsPath(alternative, searchPath) {\n  compareOtherPath: for (var i = 0; i < alternative.length; i++) {\n    var otherPath = alternative[i];\n\n    if (otherPath.length !== searchPath.length) {\n      continue;\n    }\n\n    for (var j = 0; j < otherPath.length; j++) {\n      var searchTok = searchPath[j];\n      var otherTok = otherPath[j];\n      var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n\n      if (matchingTokens === false) {\n        continue compareOtherPath;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nexports.containsPath = containsPath;\n\nfunction isStrictPrefixOfPath(prefix, other) {\n  return prefix.length < other.length && (0, every_1.default)(prefix, function (tokType, idx) {\n    var otherTokType = other[idx];\n    return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];\n  });\n}\n\nexports.isStrictPrefixOfPath = isStrictPrefixOfPath;\n\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n  return (0, every_1.default)(lookAheadPaths, function (singleAltPaths) {\n    return (0, every_1.default)(singleAltPaths, function (singlePath) {\n      return (0, every_1.default)(singlePath, function (token) {\n        return (0, isEmpty_1.default)(token.categoryMatches);\n      });\n    });\n  });\n}\n\nexports.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;","map":{"version":3,"mappings":"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","names":["PROD_TYPE","exports","getProdType","prod","gast_1","OPTION","REPETITION","REPETITION_MANDATORY","REPETITION_MANDATORY_WITH_SEPARATOR","REPETITION_WITH_SEPARATOR","ALTERNATION","Error","buildLookaheadFuncForOr","occurrence","ruleGrammar","maxLookahead","hasPredicates","dynamicTokensEnabled","laFuncBuilder","lookAheadPaths","getLookaheadPathsForOr","tokenMatcher","areTokenCategoriesNotUsed","tokens_1","buildLookaheadFuncForOptionalProd","k","prodType","lookaheadBuilder","getLookaheadPathsForOptionalProd","buildAlternativesLookAheadFunc","alts","numOfAlts","length","areAllOneTokenLookahead","currAlt","currPath","orAlts","predicates","GATE","t","currNumOfPaths","currPredicate","undefined","call","nextPath","j","currPathLength","i","nextToken","LA","singleTokenAlts","choiceToAlt_1","result","idx","currTokType","tokenTypeIdx","categoryMatches","currExtendingType","buildSingleAlternativeLookaheadFunction","alt","numOfPaths","singleTokensTypes","expectedTokenType","expectedTokenUniqueKey_1","choiceToAlt_2","__extends","topProd","targetOccurrence","targetProdType","_super","_this","RestDefinitionFinderWalker","walk","restDef","node","expectedProdType","currRest","prevRest","concat","optionProd","checkIsTarget","walkOption","atLeastOneProd","atLeastOneSepProd","manyProd","manySepProd","rest_1","targetRef","InsideDefinitionFinderVisitor","expectedProdName","definition","gast_2","initializeArrayOfArrays","size","Array","pathToHashKeys","path","keys","tokType","longerKeys","currShorterKey","push","categoriesKeySuffix","isUniquePrefixHash","altKnownPathsKeys","searchPathKeys","currAltIdx","otherAltKnownPathsKeys","searchIdx","searchKey","lookAheadSequenceFromAlternatives","altsDefs","partialAlts","finalResult","altsHashes","currAltPaths","dict","item","partialPath","currKey","newData","pathLength","currDataset","altIdx","currAltPathsAndSuffixes","currPathIdx","currPathPrefix","suffixDef","prefixKeys","isUnique","currAltResult","containsPath","newPartialPathsAndSuffixes","key","orProd","visitor","accept","insideDefVisitor","insideDef","afterDefWalker","afterDef","startWalking","insideFlat","afterFlat","alternative","searchPath","compareOtherPath","otherPath","searchTok","otherTok","matchingTokens","categoryMatchesMap","isStrictPrefixOfPath","prefix","other","otherTokType","singleAltPaths","singlePath","token"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\chevrotain\\src\\parse\\grammar\\lookahead.ts"],"sourcesContent":["import isEmpty from \"lodash/isEmpty\"\r\nimport flatten from \"lodash/flatten\"\r\nimport every from \"lodash/every\"\r\nimport map from \"lodash/map\"\r\nimport forEach from \"lodash/forEach\"\r\nimport has from \"lodash/has\"\r\nimport reduce from \"lodash/reduce\"\r\nimport { possiblePathsFrom } from \"./interpreter\"\r\nimport { RestWalker } from \"./rest\"\r\nimport { Predicate, TokenMatcher, LookAheadSequence } from \"../parser/parser\"\r\nimport {\r\n  tokenStructuredMatcher,\r\n  tokenStructuredMatcherNoCategories\r\n} from \"../../scan/tokens\"\r\nimport {\r\n  Alternation,\r\n  Alternative as AlternativeGAST,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule\r\n} from \"@chevrotain/gast\"\r\nimport { GAstVisitor } from \"@chevrotain/gast\"\r\nimport {\r\n  IOrAlt,\r\n  IProduction,\r\n  IProductionWithOccurrence,\r\n  TokenType\r\n} from \"@chevrotain/types\"\r\n\r\nexport enum PROD_TYPE {\r\n  OPTION,\r\n  REPETITION,\r\n  REPETITION_MANDATORY,\r\n  REPETITION_MANDATORY_WITH_SEPARATOR,\r\n  REPETITION_WITH_SEPARATOR,\r\n  ALTERNATION\r\n}\r\n\r\nexport function getProdType(prod: IProduction): PROD_TYPE {\r\n  /* istanbul ignore else */\r\n  if (prod instanceof Option) {\r\n    return PROD_TYPE.OPTION\r\n  } else if (prod instanceof Repetition) {\r\n    return PROD_TYPE.REPETITION\r\n  } else if (prod instanceof RepetitionMandatory) {\r\n    return PROD_TYPE.REPETITION_MANDATORY\r\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\r\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR\r\n  } else if (prod instanceof RepetitionWithSeparator) {\r\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR\r\n  } else if (prod instanceof Alternation) {\r\n    return PROD_TYPE.ALTERNATION\r\n  } else {\r\n    throw Error(\"non exhaustive match\")\r\n  }\r\n}\r\n\r\nexport function buildLookaheadFuncForOr(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  maxLookahead: number,\r\n  hasPredicates: boolean,\r\n  dynamicTokensEnabled: boolean,\r\n  laFuncBuilder: Function\r\n): (orAlts?: IOrAlt<any>[]) => number {\r\n  const lookAheadPaths = getLookaheadPathsForOr(\r\n    occurrence,\r\n    ruleGrammar,\r\n    maxLookahead\r\n  )\r\n\r\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\r\n    ? tokenStructuredMatcherNoCategories\r\n    : tokenStructuredMatcher\r\n\r\n  return laFuncBuilder(\r\n    lookAheadPaths,\r\n    hasPredicates,\r\n    tokenMatcher,\r\n    dynamicTokensEnabled\r\n  )\r\n}\r\n\r\n/**\r\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\r\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\r\n *\r\n *  Example: given a production:\r\n *  ABC(DE)?DF\r\n *\r\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\r\n *  alternatives.\r\n *\r\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\r\n */\r\nexport function buildLookaheadFuncForOptionalProd(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  k: number,\r\n  dynamicTokensEnabled: boolean,\r\n  prodType: PROD_TYPE,\r\n  lookaheadBuilder: (\r\n    lookAheadSequence: LookAheadSequence,\r\n    tokenMatcher: TokenMatcher,\r\n    dynamicTokensEnabled: boolean\r\n  ) => () => boolean\r\n): () => boolean {\r\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(\r\n    occurrence,\r\n    ruleGrammar,\r\n    prodType,\r\n    k\r\n  )\r\n\r\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\r\n    ? tokenStructuredMatcherNoCategories\r\n    : tokenStructuredMatcher\r\n\r\n  return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled)\r\n}\r\n\r\nexport type Alternative = TokenType[][]\r\n\r\nexport function buildAlternativesLookAheadFunc(\r\n  alts: LookAheadSequence[],\r\n  hasPredicates: boolean,\r\n  tokenMatcher: TokenMatcher,\r\n  dynamicTokensEnabled: boolean\r\n): (orAlts: IOrAlt<any>[]) => number | undefined {\r\n  const numOfAlts = alts.length\r\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\r\n    return every(currAlt, (currPath) => {\r\n      return currPath.length === 1\r\n    })\r\n  })\r\n\r\n  // This version takes into account the predicates as well.\r\n  if (hasPredicates) {\r\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\r\n    return function (orAlts: IOrAlt<any>[]): number | undefined {\r\n      // unfortunately the predicates must be extracted every single time\r\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\r\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\r\n      const predicates: (Predicate | undefined)[] = map(\r\n        orAlts,\r\n        (currAlt) => currAlt.GATE\r\n      )\r\n\r\n      for (let t = 0; t < numOfAlts; t++) {\r\n        const currAlt = alts[t]\r\n        const currNumOfPaths = currAlt.length\r\n\r\n        const currPredicate = predicates[t]\r\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\r\n          // if the predicate does not match there is no point in checking the paths\r\n          continue\r\n        }\r\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\r\n          const currPath = currAlt[j]\r\n          const currPathLength = currPath.length\r\n          for (let i = 0; i < currPathLength; i++) {\r\n            const nextToken = this.LA(i + 1)\r\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\r\n              // mismatch in current path\r\n              // try the next pth\r\n              continue nextPath\r\n            }\r\n          }\r\n          // found a full path that matches.\r\n          // this will also work for an empty ALT as the loop will be skipped\r\n          return t\r\n        }\r\n        // none of the paths for the current alternative matched\r\n        // try the next alternative\r\n      }\r\n      // none of the alternatives could be matched\r\n      return undefined\r\n    }\r\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\r\n    // optimized (common) case of all the lookaheads paths requiring only\r\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\r\n    const singleTokenAlts = map(alts, (currAlt) => {\r\n      return flatten(currAlt)\r\n    })\r\n\r\n    const choiceToAlt = reduce(\r\n      singleTokenAlts,\r\n      (result, currAlt, idx) => {\r\n        forEach(currAlt, (currTokType) => {\r\n          if (!has(result, currTokType.tokenTypeIdx!)) {\r\n            result[currTokType.tokenTypeIdx!] = idx\r\n          }\r\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\r\n            if (!has(result, currExtendingType)) {\r\n              result[currExtendingType] = idx\r\n            }\r\n          })\r\n        })\r\n        return result\r\n      },\r\n      {} as Record<number, number>\r\n    )\r\n\r\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\r\n    return function (): number {\r\n      const nextToken = this.LA(1)\r\n      return choiceToAlt[nextToken.tokenTypeIdx]\r\n    }\r\n  } else {\r\n    // optimized lookahead without needing to check the predicates at all.\r\n    // this causes code duplication which is intentional to improve performance.\r\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\r\n    return function (): number | undefined {\r\n      for (let t = 0; t < numOfAlts; t++) {\r\n        const currAlt = alts[t]\r\n        const currNumOfPaths = currAlt.length\r\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\r\n          const currPath = currAlt[j]\r\n          const currPathLength = currPath.length\r\n          for (let i = 0; i < currPathLength; i++) {\r\n            const nextToken = this.LA(i + 1)\r\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\r\n              // mismatch in current path\r\n              // try the next pth\r\n              continue nextPath\r\n            }\r\n          }\r\n          // found a full path that matches.\r\n          // this will also work for an empty ALT as the loop will be skipped\r\n          return t\r\n        }\r\n        // none of the paths for the current alternative matched\r\n        // try the next alternative\r\n      }\r\n      // none of the alternatives could be matched\r\n      return undefined\r\n    }\r\n  }\r\n}\r\n\r\nexport function buildSingleAlternativeLookaheadFunction(\r\n  alt: LookAheadSequence,\r\n  tokenMatcher: TokenMatcher,\r\n  dynamicTokensEnabled: boolean\r\n): () => boolean {\r\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\r\n    return currPath.length === 1\r\n  })\r\n\r\n  const numOfPaths = alt.length\r\n\r\n  // optimized (common) case of all the lookaheads paths requiring only\r\n  // a single token lookahead.\r\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\r\n    const singleTokensTypes = flatten(alt)\r\n\r\n    if (\r\n      singleTokensTypes.length === 1 &&\r\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\r\n    ) {\r\n      const expectedTokenType = singleTokensTypes[0]\r\n      const expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx\r\n\r\n      return function (): boolean {\r\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\r\n      }\r\n    } else {\r\n      const choiceToAlt = reduce(\r\n        singleTokensTypes,\r\n        (result, currTokType, idx) => {\r\n          result[currTokType.tokenTypeIdx!] = true\r\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\r\n            result[currExtendingType] = true\r\n          })\r\n          return result\r\n        },\r\n        [] as boolean[]\r\n      )\r\n\r\n      return function (): boolean {\r\n        const nextToken = this.LA(1)\r\n        return choiceToAlt[nextToken.tokenTypeIdx] === true\r\n      }\r\n    }\r\n  } else {\r\n    return function (): boolean {\r\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\r\n        const currPath = alt[j]\r\n        const currPathLength = currPath.length\r\n        for (let i = 0; i < currPathLength; i++) {\r\n          const nextToken = this.LA(i + 1)\r\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\r\n            // mismatch in current path\r\n            // try the next pth\r\n            continue nextPath\r\n          }\r\n        }\r\n        // found a full path that matches.\r\n        return true\r\n      }\r\n\r\n      // none of the paths matched\r\n      return false\r\n    }\r\n  }\r\n}\r\n\r\nclass RestDefinitionFinderWalker extends RestWalker {\r\n  private restDef: IProduction[]\r\n\r\n  constructor(\r\n    private topProd: Rule,\r\n    private targetOccurrence: number,\r\n    private targetProdType: PROD_TYPE\r\n  ) {\r\n    super()\r\n  }\r\n\r\n  startWalking(): IProduction[] {\r\n    this.walk(this.topProd)\r\n    return this.restDef\r\n  }\r\n\r\n  private checkIsTarget(\r\n    node: IProductionWithOccurrence,\r\n    expectedProdType: PROD_TYPE,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): boolean {\r\n    if (\r\n      node.idx === this.targetOccurrence &&\r\n      this.targetProdType === expectedProdType\r\n    ) {\r\n      this.restDef = currRest.concat(prevRest)\r\n      return true\r\n    }\r\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\r\n    return false\r\n  }\r\n\r\n  walkOption(\r\n    optionProd: Option,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\r\n      super.walkOption(optionProd, currRest, prevRest)\r\n    }\r\n  }\r\n\r\n  walkAtLeastOne(\r\n    atLeastOneProd: RepetitionMandatory,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(\r\n        atLeastOneProd,\r\n        PROD_TYPE.REPETITION_MANDATORY,\r\n        currRest,\r\n        prevRest\r\n      )\r\n    ) {\r\n      super.walkOption(atLeastOneProd, currRest, prevRest)\r\n    }\r\n  }\r\n\r\n  walkAtLeastOneSep(\r\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(\r\n        atLeastOneSepProd,\r\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\r\n        currRest,\r\n        prevRest\r\n      )\r\n    ) {\r\n      super.walkOption(atLeastOneSepProd, currRest, prevRest)\r\n    }\r\n  }\r\n\r\n  walkMany(\r\n    manyProd: Repetition,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\r\n    ) {\r\n      super.walkOption(manyProd, currRest, prevRest)\r\n    }\r\n  }\r\n\r\n  walkManySep(\r\n    manySepProd: RepetitionWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(\r\n        manySepProd,\r\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\r\n        currRest,\r\n        prevRest\r\n      )\r\n    ) {\r\n      super.walkOption(manySepProd, currRest, prevRest)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the definition of a target production in a top level level rule.\r\n */\r\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\r\n  public result: IProduction[] = []\r\n\r\n  constructor(\r\n    private targetOccurrence: number,\r\n    private targetProdType: PROD_TYPE,\r\n    private targetRef?: any\r\n  ) {\r\n    super()\r\n  }\r\n\r\n  private checkIsTarget(\r\n    node: { definition: IProduction[] } & IProductionWithOccurrence,\r\n    expectedProdName: PROD_TYPE\r\n  ): void {\r\n    if (\r\n      node.idx === this.targetOccurrence &&\r\n      this.targetProdType === expectedProdName &&\r\n      (this.targetRef === undefined || node === this.targetRef)\r\n    ) {\r\n      this.result = node.definition\r\n    }\r\n  }\r\n\r\n  public visitOption(node: Option): void {\r\n    this.checkIsTarget(node, PROD_TYPE.OPTION)\r\n  }\r\n\r\n  public visitRepetition(node: Repetition): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION)\r\n  }\r\n\r\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY)\r\n  }\r\n\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    node: RepetitionMandatoryWithSeparator\r\n  ): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR)\r\n  }\r\n\r\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR)\r\n  }\r\n\r\n  public visitAlternation(node: Alternation): void {\r\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION)\r\n  }\r\n}\r\n\r\nfunction initializeArrayOfArrays(size: number): any[][] {\r\n  const result = new Array(size)\r\n  for (let i = 0; i < size; i++) {\r\n    result[i] = []\r\n  }\r\n  return result\r\n}\r\n\r\n/**\r\n * A sort of hash function between a Path in the grammar and a string.\r\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\r\n * -  A single path with categories may match multiple **actual** paths.\r\n */\r\nfunction pathToHashKeys(path: TokenType[]): string[] {\r\n  let keys = [\"\"]\r\n  for (let i = 0; i < path.length; i++) {\r\n    const tokType = path[i]\r\n    const longerKeys = []\r\n    for (let j = 0; j < keys.length; j++) {\r\n      const currShorterKey = keys[j]\r\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx)\r\n      for (let t = 0; t < tokType.categoryMatches!.length; t++) {\r\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches![t]\r\n        longerKeys.push(currShorterKey + categoriesKeySuffix)\r\n      }\r\n    }\r\n    keys = longerKeys\r\n  }\r\n  return keys\r\n}\r\n\r\n/**\r\n * Imperative style due to being called from a hot spot\r\n */\r\nfunction isUniquePrefixHash(\r\n  altKnownPathsKeys: Record<string, boolean>[],\r\n  searchPathKeys: string[],\r\n  idx: number\r\n): boolean {\r\n  for (\r\n    let currAltIdx = 0;\r\n    currAltIdx < altKnownPathsKeys.length;\r\n    currAltIdx++\r\n  ) {\r\n    // We only want to test vs the other alternatives\r\n    if (currAltIdx === idx) {\r\n      continue\r\n    }\r\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx]\r\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\r\n      const searchKey = searchPathKeys[searchIdx]\r\n      if (otherAltKnownPathsKeys[searchKey] === true) {\r\n        return false\r\n      }\r\n    }\r\n  }\r\n  // None of the SearchPathKeys were found in any of the other alternatives\r\n  return true\r\n}\r\n\r\nexport function lookAheadSequenceFromAlternatives(\r\n  altsDefs: IProduction[],\r\n  k: number\r\n): LookAheadSequence[] {\r\n  const partialAlts = map(altsDefs, (currAlt) =>\r\n    possiblePathsFrom([currAlt], 1)\r\n  )\r\n  const finalResult = initializeArrayOfArrays(partialAlts.length)\r\n  const altsHashes = map(partialAlts, (currAltPaths) => {\r\n    const dict: { [key: string]: boolean } = {}\r\n    forEach(currAltPaths, (item) => {\r\n      const keys = pathToHashKeys(item.partialPath)\r\n      forEach(keys, (currKey) => {\r\n        dict[currKey] = true\r\n      })\r\n    })\r\n    return dict\r\n  })\r\n  let newData = partialAlts\r\n\r\n  // maxLookahead loop\r\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\r\n    const currDataset = newData\r\n    newData = initializeArrayOfArrays(currDataset.length)\r\n\r\n    // alternatives loop\r\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\r\n      const currAltPathsAndSuffixes = currDataset[altIdx]\r\n      // paths in current alternative loop\r\n      for (\r\n        let currPathIdx = 0;\r\n        currPathIdx < currAltPathsAndSuffixes.length;\r\n        currPathIdx++\r\n      ) {\r\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath\r\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef\r\n        const prefixKeys = pathToHashKeys(currPathPrefix)\r\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx)\r\n        // End of the line for this path.\r\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\r\n          const currAltResult = finalResult[altIdx]\r\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\r\n          if (containsPath(currAltResult, currPathPrefix) === false) {\r\n            currAltResult.push(currPathPrefix)\r\n            // Update all new  keys for the current path.\r\n            for (let j = 0; j < prefixKeys.length; j++) {\r\n              const currKey = prefixKeys[j]\r\n              altsHashes[altIdx][currKey] = true\r\n            }\r\n          }\r\n        }\r\n        // Expand longer paths\r\n        else {\r\n          const newPartialPathsAndSuffixes = possiblePathsFrom(\r\n            suffixDef,\r\n            pathLength + 1,\r\n            currPathPrefix\r\n          )\r\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes)\r\n\r\n          // Update keys for new known paths\r\n          forEach(newPartialPathsAndSuffixes, (item) => {\r\n            const prefixKeys = pathToHashKeys(item.partialPath)\r\n            forEach(prefixKeys, (key) => {\r\n              altsHashes[altIdx][key] = true\r\n            })\r\n          })\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return finalResult\r\n}\r\n\r\nexport function getLookaheadPathsForOr(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  k: number,\r\n  orProd?: Alternation\r\n): LookAheadSequence[] {\r\n  const visitor = new InsideDefinitionFinderVisitor(\r\n    occurrence,\r\n    PROD_TYPE.ALTERNATION,\r\n    orProd\r\n  )\r\n  ruleGrammar.accept(visitor)\r\n  return lookAheadSequenceFromAlternatives(visitor.result, k)\r\n}\r\n\r\nexport function getLookaheadPathsForOptionalProd(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  prodType: PROD_TYPE,\r\n  k: number\r\n): LookAheadSequence[] {\r\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(\r\n    occurrence,\r\n    prodType\r\n  )\r\n  ruleGrammar.accept(insideDefVisitor)\r\n  const insideDef = insideDefVisitor.result\r\n\r\n  const afterDefWalker = new RestDefinitionFinderWalker(\r\n    ruleGrammar,\r\n    occurrence,\r\n    prodType\r\n  )\r\n  const afterDef = afterDefWalker.startWalking()\r\n\r\n  const insideFlat = new AlternativeGAST({ definition: insideDef })\r\n  const afterFlat = new AlternativeGAST({ definition: afterDef })\r\n\r\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k)\r\n}\r\n\r\nexport function containsPath(\r\n  alternative: Alternative,\r\n  searchPath: TokenType[]\r\n): boolean {\r\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\r\n    const otherPath = alternative[i]\r\n    if (otherPath.length !== searchPath.length) {\r\n      continue\r\n    }\r\n    for (let j = 0; j < otherPath.length; j++) {\r\n      const searchTok = searchPath[j]\r\n      const otherTok = otherPath[j]\r\n\r\n      const matchingTokens =\r\n        searchTok === otherTok ||\r\n        otherTok.categoryMatchesMap![searchTok.tokenTypeIdx!] !== undefined\r\n      if (matchingTokens === false) {\r\n        continue compareOtherPath\r\n      }\r\n    }\r\n    return true\r\n  }\r\n\r\n  return false\r\n}\r\n\r\nexport function isStrictPrefixOfPath(\r\n  prefix: TokenType[],\r\n  other: TokenType[]\r\n): boolean {\r\n  return (\r\n    prefix.length < other.length &&\r\n    every(prefix, (tokType, idx) => {\r\n      const otherTokType = other[idx]\r\n      return (\r\n        tokType === otherTokType ||\r\n        otherTokType.categoryMatchesMap![tokType.tokenTypeIdx!]\r\n      )\r\n    })\r\n  )\r\n}\r\n\r\nexport function areTokenCategoriesNotUsed(\r\n  lookAheadPaths: LookAheadSequence[]\r\n): boolean {\r\n  return every(lookAheadPaths, (singleAltPaths) =>\r\n    every(singleAltPaths, (singlePath) =>\r\n      every(singlePath, (token) => isEmpty(token.categoryMatches!))\r\n    )\r\n  )\r\n}\r\n"]},"metadata":{},"sourceType":"script"}