{"ast":null,"code":"\"use strict\";\n/* istanbul ignore next */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.nextPossibleTokensAfter = exports.possiblePathsFrom = exports.NextTerminalAfterAtLeastOneSepWalker = exports.NextTerminalAfterAtLeastOneWalker = exports.NextTerminalAfterManySepWalker = exports.NextTerminalAfterManyWalker = exports.AbstractNextTerminalAfterProductionWalker = exports.NextAfterTokenWalker = exports.AbstractNextPossibleTokensWalker = void 0;\n\nvar rest_1 = require(\"./rest\");\n\nvar first_1 = __importDefault(require(\"lodash/first\"));\n\nvar isEmpty_1 = __importDefault(require(\"lodash/isEmpty\"));\n\nvar dropRight_1 = __importDefault(require(\"lodash/dropRight\"));\n\nvar drop_1 = __importDefault(require(\"lodash/drop\"));\n\nvar last_1 = __importDefault(require(\"lodash/last\"));\n\nvar forEach_1 = __importDefault(require(\"lodash/forEach\"));\n\nvar clone_1 = __importDefault(require(\"lodash/clone\"));\n\nvar first_2 = require(\"./first\");\n\nvar gast_1 = require(\"@chevrotain/gast\");\n\nvar AbstractNextPossibleTokensWalker =\n/** @class */\nfunction (_super) {\n  __extends(AbstractNextPossibleTokensWalker, _super);\n\n  function AbstractNextPossibleTokensWalker(topProd, path) {\n    var _this = _super.call(this)\n    /* istanbul ignore next */\n    || this;\n\n    _this.topProd = topProd;\n    _this.path = path;\n    _this.possibleTokTypes = [];\n    _this.nextProductionName = \"\";\n    _this.nextProductionOccurrence = 0;\n    _this.found = false;\n    _this.isAtEndOfPath = false;\n    return _this;\n  }\n\n  AbstractNextPossibleTokensWalker.prototype.startWalking = function () {\n    this.found = false;\n\n    if (this.path.ruleStack[0] !== this.topProd.name) {\n      throw Error(\"The path does not start with the walker's top Rule!\");\n    } // immutable for the win\n\n\n    this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse(); // intelij bug requires assertion\n\n    this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n    // already verified that the first production is valid, we now seek the 2nd production\n\n    this.ruleStack.pop();\n    this.occurrenceStack.pop();\n    this.updateExpectedNext();\n    this.walk(this.topProd);\n    return this.possibleTokTypes;\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walk = function (prod, prevRest) {\n    if (prevRest === void 0) {\n      prevRest = [];\n    } // stop scanning once we found the path\n\n\n    if (!this.found) {\n      _super.prototype.walk.call(this, prod, prevRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.walkProdRef = function (refProd, currRest, prevRest) {\n    // found the next production, need to keep walking in it\n    if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {\n      var fullRest = currRest.concat(prevRest);\n      this.updateExpectedNext();\n      this.walk(refProd.referencedRule, fullRest);\n    }\n  };\n\n  AbstractNextPossibleTokensWalker.prototype.updateExpectedNext = function () {\n    // need to consume the Terminal\n    if ((0, isEmpty_1.default)(this.ruleStack)) {\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n      // really seeking is the last Terminal...\n      this.nextProductionName = \"\";\n      this.nextProductionOccurrence = 0;\n      this.isAtEndOfPath = true;\n    } else {\n      this.nextProductionName = this.ruleStack.pop();\n      this.nextProductionOccurrence = this.occurrenceStack.pop();\n    }\n  };\n\n  return AbstractNextPossibleTokensWalker;\n}(rest_1.RestWalker);\n\nexports.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;\n\nvar NextAfterTokenWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextAfterTokenWalker, _super);\n\n  function NextAfterTokenWalker(topProd, path) {\n    var _this = _super.call(this, topProd, path)\n    /* istanbul ignore next */\n    || this;\n\n    _this.path = path;\n    _this.nextTerminalName = \"\";\n    _this.nextTerminalOccurrence = 0;\n    _this.nextTerminalName = _this.path.lastTok.name;\n    _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;\n    return _this;\n  }\n\n  NextAfterTokenWalker.prototype.walkTerminal = function (terminal, currRest, prevRest) {\n    if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {\n      var fullRest = currRest.concat(prevRest);\n      var restProd = new gast_1.Alternative({\n        definition: fullRest\n      });\n      this.possibleTokTypes = (0, first_2.first)(restProd);\n      this.found = true;\n    }\n  };\n\n  return NextAfterTokenWalker;\n}(AbstractNextPossibleTokensWalker);\n\nexports.NextAfterTokenWalker = NextAfterTokenWalker;\n/**\r\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\r\n * it never \"follows\" production refs\r\n */\n\nvar AbstractNextTerminalAfterProductionWalker =\n/** @class */\nfunction (_super) {\n  __extends(AbstractNextTerminalAfterProductionWalker, _super);\n\n  function AbstractNextTerminalAfterProductionWalker(topRule, occurrence) {\n    var _this = _super.call(this)\n    /* istanbul ignore next */\n    || this;\n\n    _this.topRule = topRule;\n    _this.occurrence = occurrence;\n    _this.result = {\n      token: undefined,\n      occurrence: undefined,\n      isEndOfRule: undefined\n    };\n    return _this;\n  }\n\n  AbstractNextTerminalAfterProductionWalker.prototype.startWalking = function () {\n    this.walk(this.topRule);\n    return this.result;\n  };\n\n  return AbstractNextTerminalAfterProductionWalker;\n}(rest_1.RestWalker);\n\nexports.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;\n\nvar NextTerminalAfterManyWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterManyWalker, _super);\n\n  function NextTerminalAfterManyWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterManyWalker.prototype.walkMany = function (manyProd, currRest, prevRest) {\n    if (manyProd.idx === this.occurrence) {\n      var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterMany === undefined;\n\n      if (firstAfterMany instanceof gast_1.Terminal) {\n        this.result.token = firstAfterMany.terminalType;\n        this.result.occurrence = firstAfterMany.idx;\n      }\n    } else {\n      _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManyWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;\n\nvar NextTerminalAfterManySepWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterManySepWalker, _super);\n\n  function NextTerminalAfterManySepWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterManySepWalker.prototype.walkManySep = function (manySepProd, currRest, prevRest) {\n    if (manySepProd.idx === this.occurrence) {\n      var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterManySep === undefined;\n\n      if (firstAfterManySep instanceof gast_1.Terminal) {\n        this.result.token = firstAfterManySep.terminalType;\n        this.result.occurrence = firstAfterManySep.idx;\n      }\n    } else {\n      _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterManySepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;\n\nvar NextTerminalAfterAtLeastOneWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterAtLeastOneWalker, _super);\n\n  function NextTerminalAfterAtLeastOneWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterAtLeastOneWalker.prototype.walkAtLeastOne = function (atLeastOneProd, currRest, prevRest) {\n    if (atLeastOneProd.idx === this.occurrence) {\n      var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n\n      if (firstAfterAtLeastOne instanceof gast_1.Terminal) {\n        this.result.token = firstAfterAtLeastOne.terminalType;\n        this.result.occurrence = firstAfterAtLeastOne.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker; // TODO: reduce code duplication in the AfterWalkers\n\nvar NextTerminalAfterAtLeastOneSepWalker =\n/** @class */\nfunction (_super) {\n  __extends(NextTerminalAfterAtLeastOneSepWalker, _super);\n\n  function NextTerminalAfterAtLeastOneSepWalker() {\n    return _super !== null && _super.apply(this, arguments)\n    /* istanbul ignore next */\n    || this;\n  }\n\n  NextTerminalAfterAtLeastOneSepWalker.prototype.walkAtLeastOneSep = function (atleastOneSepProd, currRest, prevRest) {\n    if (atleastOneSepProd.idx === this.occurrence) {\n      var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n\n      if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n      }\n    } else {\n      _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);\n    }\n  };\n\n  return NextTerminalAfterAtLeastOneSepWalker;\n}(AbstractNextTerminalAfterProductionWalker);\n\nexports.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;\n\nfunction possiblePathsFrom(targetDef, maxLength, currPath) {\n  if (currPath === void 0) {\n    currPath = [];\n  } // avoid side effects\n\n\n  currPath = (0, clone_1.default)(currPath);\n  var result = [];\n  var i = 0; // TODO: avoid inner funcs\n\n  function remainingPathWith(nextDef) {\n    return nextDef.concat((0, drop_1.default)(targetDef, i + 1));\n  } // TODO: avoid inner funcs\n\n\n  function getAlternativesForProd(definition) {\n    var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n    return result.concat(alternatives);\n  }\n  /**\r\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\r\n   * following (rest) of the targetDef.\r\n   *\r\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\r\n   * the optional production.\r\n   */\n\n\n  while (currPath.length < maxLength && i < targetDef.length) {\n    var prod = targetDef[i];\n    /* istanbul ignore else */\n\n    if (prod instanceof gast_1.Alternative) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_1.NonTerminal) {\n      return getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_1.Option) {\n      result = getAlternativesForProd(prod.definition);\n    } else if (prod instanceof gast_1.RepetitionMandatory) {\n      var newDef = prod.definition.concat([new gast_1.Repetition({\n        definition: prod.definition\n      })]);\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {\n      var newDef = [new gast_1.Alternative({\n        definition: prod.definition\n      }), new gast_1.Repetition({\n        definition: [new gast_1.Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })];\n      return getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.RepetitionWithSeparator) {\n      var newDef = prod.definition.concat([new gast_1.Repetition({\n        definition: [new gast_1.Terminal({\n          terminalType: prod.separator\n        })].concat(prod.definition)\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.Repetition) {\n      var newDef = prod.definition.concat([new gast_1.Repetition({\n        definition: prod.definition\n      })]);\n      result = getAlternativesForProd(newDef);\n    } else if (prod instanceof gast_1.Alternation) {\n      (0, forEach_1.default)(prod.definition, function (currAlt) {\n        // TODO: this is a limited check for empty alternatives\n        //   It would prevent a common case of infinite loops during parser initialization.\n        //   However **in-directly** empty alternatives may still cause issues.\n        if ((0, isEmpty_1.default)(currAlt.definition) === false) {\n          result = getAlternativesForProd(currAlt.definition);\n        }\n      });\n      return result;\n    } else if (prod instanceof gast_1.Terminal) {\n      currPath.push(prod.terminalType);\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n\n    i++;\n  }\n\n  result.push({\n    partialPath: currPath,\n    suffixDef: (0, drop_1.default)(targetDef, i)\n  });\n  return result;\n}\n\nexports.possiblePathsFrom = possiblePathsFrom;\n\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n  var EXIT_NON_TERMINAL = \"EXIT_NONE_TERMINAL\"; // to avoid creating a new Array each time.\n\n  var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n  var EXIT_ALTERNATIVE = \"EXIT_ALTERNATIVE\";\n  var foundCompletePath = false;\n  var tokenVectorLength = tokenVector.length;\n  var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n  var result = [];\n  var possiblePaths = [];\n  possiblePaths.push({\n    idx: -1,\n    def: initialDef,\n    ruleStack: [],\n    occurrenceStack: []\n  });\n\n  while (!(0, isEmpty_1.default)(possiblePaths)) {\n    var currPath = possiblePaths.pop(); // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n\n    if (currPath === EXIT_ALTERNATIVE) {\n      if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {\n        // remove irrelevant alternative\n        possiblePaths.pop();\n      }\n\n      continue;\n    }\n\n    var currDef = currPath.def;\n    var currIdx = currPath.idx;\n    var currRuleStack = currPath.ruleStack;\n    var currOccurrenceStack = currPath.occurrenceStack; // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n\n    if ((0, isEmpty_1.default)(currDef)) {\n      continue;\n    }\n\n    var prod = currDef[0];\n    /* istanbul ignore else */\n\n    if (prod === EXIT_NON_TERMINAL) {\n      var nextPath = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: (0, dropRight_1.default)(currRuleStack),\n        occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.Terminal) {\n      /* istanbul ignore else */\n      if (currIdx < tokenVectorLength - 1) {\n        var nextIdx = currIdx + 1;\n        var actualToken = tokenVector[nextIdx];\n\n        if (tokMatcher(actualToken, prod.terminalType)) {\n          var nextPath = {\n            idx: nextIdx,\n            def: (0, drop_1.default)(currDef),\n            ruleStack: currRuleStack,\n            occurrenceStack: currOccurrenceStack\n          };\n          possiblePaths.push(nextPath);\n        } // end of the line\n\n      } else if (currIdx === tokenVectorLength - 1) {\n        // IGNORE ABOVE ELSE\n        result.push({\n          nextTokenType: prod.terminalType,\n          nextTokenOccurrence: prod.idx,\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        });\n        foundCompletePath = true;\n      } else {\n        throw Error(\"non exhaustive match\");\n      }\n    } else if (prod instanceof gast_1.NonTerminal) {\n      var newRuleStack = (0, clone_1.default)(currRuleStack);\n      newRuleStack.push(prod.nonTerminalName);\n      var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);\n      newOccurrenceStack.push(prod.idx);\n      var nextPath = {\n        idx: currIdx,\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),\n        ruleStack: newRuleStack,\n        occurrenceStack: newOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.Option) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var nextPathWith = {\n        idx: currIdx,\n        def: prod.definition.concat((0, drop_1.default)(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_1.RepetitionMandatory) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var secondIteration = new gast_1.Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {\n      // TODO:(THE NEW operators here take a while...) (convert once?)\n      var separatorGast = new gast_1.Terminal({\n        terminalType: prod.separator\n      });\n      var secondIteration = new gast_1.Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));\n      var nextPath = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPath);\n    } else if (prod instanceof gast_1.RepetitionWithSeparator) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE);\n      var separatorGast = new gast_1.Terminal({\n        terminalType: prod.separator\n      });\n      var nthRepetition = new gast_1.Repetition({\n        definition: [separatorGast].concat(prod.definition),\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_1.Repetition) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      var nextPathWithout = {\n        idx: currIdx,\n        def: (0, drop_1.default)(currDef),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWithout); // required marker to avoid backtracking paths whose higher priority alternatives already matched\n\n      possiblePaths.push(EXIT_ALTERNATIVE); // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n\n      var nthRepetition = new gast_1.Repetition({\n        definition: prod.definition,\n        idx: prod.idx\n      });\n      var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));\n      var nextPathWith = {\n        idx: currIdx,\n        def: nextDef,\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      };\n      possiblePaths.push(nextPathWith);\n    } else if (prod instanceof gast_1.Alternation) {\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n      for (var i = prod.definition.length - 1; i >= 0; i--) {\n        var currAlt = prod.definition[i];\n        var currAltPath = {\n          idx: currIdx,\n          def: currAlt.definition.concat((0, drop_1.default)(currDef)),\n          ruleStack: currRuleStack,\n          occurrenceStack: currOccurrenceStack\n        };\n        possiblePaths.push(currAltPath);\n        possiblePaths.push(EXIT_ALTERNATIVE);\n      }\n    } else if (prod instanceof gast_1.Alternative) {\n      possiblePaths.push({\n        idx: currIdx,\n        def: prod.definition.concat((0, drop_1.default)(currDef)),\n        ruleStack: currRuleStack,\n        occurrenceStack: currOccurrenceStack\n      });\n    } else if (prod instanceof gast_1.Rule) {\n      // last because we should only encounter at most a single one of these per invocation.\n      possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n    } else {\n      throw Error(\"non exhaustive match\");\n    }\n  }\n\n  return result;\n}\n\nexports.nextPossibleTokensAfter = nextPossibleTokensAfter;\n\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n  var newRuleStack = (0, clone_1.default)(currRuleStack);\n  newRuleStack.push(topRule.name);\n  var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack); // top rule is always assumed to have been called with occurrence index 1\n\n  newCurrOccurrenceStack.push(1);\n  return {\n    idx: currIdx,\n    def: topRule.definition,\n    ruleStack: newRuleStack,\n    occurrenceStack: newCurrOccurrenceStack\n  };\n}","map":{"version":3,"mappings":"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","names":["__extends","topProd","path","_super","_this","AbstractNextPossibleTokensWalker","found","ruleStack","name","Error","reverse","occurrenceStack","pop","updateExpectedNext","walk","possibleTokTypes","prod","prevRest","call","refProd","currRest","referencedRule","nextProductionName","idx","nextProductionOccurrence","fullRest","concat","isAtEndOfPath","rest_1","exports","nextTerminalName","lastTok","nextTerminalOccurrence","lastTokOccurrence","NextAfterTokenWalker","terminal","terminalType","restProd","gast_1","definition","topRule","occurrence","token","undefined","isEndOfRule","AbstractNextTerminalAfterProductionWalker","result","NextTerminalAfterManyWalker","manyProd","firstAfterMany","walkMany","NextTerminalAfterManySepWalker","manySepProd","firstAfterManySep","walkManySep","NextTerminalAfterAtLeastOneWalker","atLeastOneProd","firstAfterAtLeastOne","walkAtLeastOne","NextTerminalAfterAtLeastOneSepWalker","atleastOneSepProd","firstAfterfirstAfterAtLeastOneSep","walkAtLeastOneSep","possiblePathsFrom","targetDef","maxLength","currPath","i","remainingPathWith","nextDef","getAlternativesForProd","alternatives","length","newDef","separator","currAlt","push","partialPath","suffixDef","nextPossibleTokensAfter","initialDef","tokenVector","tokMatcher","maxLookAhead","EXIT_NON_TERMINAL","EXIT_NON_TERMINAL_ARR","EXIT_ALTERNATIVE","foundCompletePath","tokenVectorLength","minimalAlternativesIndex","possiblePaths","def","currDef","currIdx","currRuleStack","currOccurrenceStack","nextPath","nextIdx","actualToken","nextTokenType","nextTokenOccurrence","newRuleStack","nonTerminalName","newOccurrenceStack","nextPathWithout","nextPathWith","secondIteration","separatorGast","nthRepetition","currAltPath","expandTopLevelRule","newCurrOccurrenceStack"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\chevrotain\\src\\parse\\grammar\\interpreter.ts"],"sourcesContent":["import { RestWalker } from \"./rest\"\r\nimport _first from \"lodash/first\"\r\nimport isEmpty from \"lodash/isEmpty\"\r\nimport dropRight from \"lodash/dropRight\"\r\nimport drop from \"lodash/drop\"\r\nimport last from \"lodash/last\"\r\nimport forEach from \"lodash/forEach\"\r\nimport clone from \"lodash/clone\"\r\nimport { first } from \"./first\"\r\nimport { TokenMatcher } from \"../parser/parser\"\r\nimport {\r\n  Alternation,\r\n  Alternative,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule,\r\n  Terminal\r\n} from \"@chevrotain/gast\"\r\nimport {\r\n  IGrammarPath,\r\n  IProduction,\r\n  ISyntacticContentAssistPath,\r\n  IToken,\r\n  ITokenGrammarPath,\r\n  TokenType\r\n} from \"@chevrotain/types\"\r\n\r\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\r\n  protected possibleTokTypes: TokenType[] = []\r\n  protected ruleStack: string[]\r\n  protected occurrenceStack: number[]\r\n\r\n  protected nextProductionName = \"\"\r\n  protected nextProductionOccurrence = 0\r\n  protected found = false\r\n  protected isAtEndOfPath = false\r\n\r\n  constructor(protected topProd: Rule, protected path: IGrammarPath) {\r\n    super()\r\n  }\r\n\r\n  startWalking(): TokenType[] {\r\n    this.found = false\r\n\r\n    if (this.path.ruleStack[0] !== this.topProd.name) {\r\n      throw Error(\"The path does not start with the walker's top Rule!\")\r\n    }\r\n\r\n    // immutable for the win\r\n    this.ruleStack = clone(this.path.ruleStack).reverse() // intelij bug requires assertion\r\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse() // intelij bug requires assertion\r\n\r\n    // already verified that the first production is valid, we now seek the 2nd production\r\n    this.ruleStack.pop()\r\n    this.occurrenceStack.pop()\r\n\r\n    this.updateExpectedNext()\r\n    this.walk(this.topProd)\r\n\r\n    return this.possibleTokTypes\r\n  }\r\n\r\n  walk(\r\n    prod: { definition: IProduction[] },\r\n    prevRest: IProduction[] = []\r\n  ): void {\r\n    // stop scanning once we found the path\r\n    if (!this.found) {\r\n      super.walk(prod, prevRest)\r\n    }\r\n  }\r\n\r\n  walkProdRef(\r\n    refProd: NonTerminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    // found the next production, need to keep walking in it\r\n    if (\r\n      refProd.referencedRule.name === this.nextProductionName &&\r\n      refProd.idx === this.nextProductionOccurrence\r\n    ) {\r\n      const fullRest = currRest.concat(prevRest)\r\n      this.updateExpectedNext()\r\n      this.walk(refProd.referencedRule, <any>fullRest)\r\n    }\r\n  }\r\n\r\n  updateExpectedNext(): void {\r\n    // need to consume the Terminal\r\n    if (isEmpty(this.ruleStack)) {\r\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\r\n      // really seeking is the last Terminal...\r\n      this.nextProductionName = \"\"\r\n      this.nextProductionOccurrence = 0\r\n      this.isAtEndOfPath = true\r\n    } else {\r\n      this.nextProductionName = this.ruleStack.pop()!\r\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!\r\n    }\r\n  }\r\n}\r\n\r\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\r\n  private nextTerminalName = \"\"\r\n  private nextTerminalOccurrence = 0\r\n\r\n  constructor(topProd: Rule, protected path: ITokenGrammarPath) {\r\n    super(topProd, path)\r\n    this.nextTerminalName = this.path.lastTok.name\r\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence\r\n  }\r\n\r\n  walkTerminal(\r\n    terminal: Terminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (\r\n      this.isAtEndOfPath &&\r\n      terminal.terminalType.name === this.nextTerminalName &&\r\n      terminal.idx === this.nextTerminalOccurrence &&\r\n      !this.found\r\n    ) {\r\n      const fullRest = currRest.concat(prevRest)\r\n      const restProd = new Alternative({ definition: fullRest })\r\n      this.possibleTokTypes = first(restProd)\r\n      this.found = true\r\n    }\r\n  }\r\n}\r\n\r\nexport type AlternativesFirstTokens = TokenType[][]\r\n\r\nexport interface IFirstAfterRepetition {\r\n  token: TokenType | undefined\r\n  occurrence: number | undefined\r\n  isEndOfRule: boolean | undefined\r\n}\r\n\r\n/**\r\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\r\n * it never \"follows\" production refs\r\n */\r\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\r\n  protected result: IFirstAfterRepetition = {\r\n    token: undefined,\r\n    occurrence: undefined,\r\n    isEndOfRule: undefined\r\n  }\r\n\r\n  constructor(protected topRule: Rule, protected occurrence: number) {\r\n    super()\r\n  }\r\n\r\n  startWalking(): IFirstAfterRepetition {\r\n    this.walk(this.topRule)\r\n    return this.result\r\n  }\r\n}\r\n\r\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkMany(\r\n    manyProd: Repetition,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (manyProd.idx === this.occurrence) {\r\n      const firstAfterMany = _first(currRest.concat(prevRest))\r\n      this.result.isEndOfRule = firstAfterMany === undefined\r\n      if (firstAfterMany instanceof Terminal) {\r\n        this.result.token = firstAfterMany.terminalType\r\n        this.result.occurrence = firstAfterMany.idx\r\n      }\r\n    } else {\r\n      super.walkMany(manyProd, currRest, prevRest)\r\n    }\r\n  }\r\n}\r\n\r\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkManySep(\r\n    manySepProd: RepetitionWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (manySepProd.idx === this.occurrence) {\r\n      const firstAfterManySep = _first(currRest.concat(prevRest))\r\n      this.result.isEndOfRule = firstAfterManySep === undefined\r\n      if (firstAfterManySep instanceof Terminal) {\r\n        this.result.token = firstAfterManySep.terminalType\r\n        this.result.occurrence = firstAfterManySep.idx\r\n      }\r\n    } else {\r\n      super.walkManySep(manySepProd, currRest, prevRest)\r\n    }\r\n  }\r\n}\r\n\r\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkAtLeastOne(\r\n    atLeastOneProd: RepetitionMandatory,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (atLeastOneProd.idx === this.occurrence) {\r\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest))\r\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined\r\n      if (firstAfterAtLeastOne instanceof Terminal) {\r\n        this.result.token = firstAfterAtLeastOne.terminalType\r\n        this.result.occurrence = firstAfterAtLeastOne.idx\r\n      }\r\n    } else {\r\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest)\r\n    }\r\n  }\r\n}\r\n\r\n// TODO: reduce code duplication in the AfterWalkers\r\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkAtLeastOneSep(\r\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[]\r\n  ): void {\r\n    if (atleastOneSepProd.idx === this.occurrence) {\r\n      const firstAfterfirstAfterAtLeastOneSep = _first(\r\n        currRest.concat(prevRest)\r\n      )\r\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined\r\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\r\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType\r\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx\r\n      }\r\n    } else {\r\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest)\r\n    }\r\n  }\r\n}\r\n\r\nexport interface PartialPathAndSuffixes {\r\n  partialPath: TokenType[]\r\n  suffixDef: IProduction[]\r\n}\r\n\r\nexport function possiblePathsFrom(\r\n  targetDef: IProduction[],\r\n  maxLength: number,\r\n  currPath: TokenType[] = []\r\n): PartialPathAndSuffixes[] {\r\n  // avoid side effects\r\n  currPath = clone(currPath)\r\n  let result: PartialPathAndSuffixes[] = []\r\n  let i = 0\r\n\r\n  // TODO: avoid inner funcs\r\n  function remainingPathWith(nextDef: IProduction[]) {\r\n    return nextDef.concat(drop(targetDef, i + 1))\r\n  }\r\n\r\n  // TODO: avoid inner funcs\r\n  function getAlternativesForProd(definition: IProduction[]) {\r\n    const alternatives = possiblePathsFrom(\r\n      remainingPathWith(definition),\r\n      maxLength,\r\n      currPath\r\n    )\r\n    return result.concat(alternatives)\r\n  }\r\n\r\n  /**\r\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\r\n   * following (rest) of the targetDef.\r\n   *\r\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\r\n   * the optional production.\r\n   */\r\n  while (currPath.length < maxLength && i < targetDef.length) {\r\n    const prod = targetDef[i]\r\n\r\n    /* istanbul ignore else */\r\n    if (prod instanceof Alternative) {\r\n      return getAlternativesForProd(prod.definition)\r\n    } else if (prod instanceof NonTerminal) {\r\n      return getAlternativesForProd(prod.definition)\r\n    } else if (prod instanceof Option) {\r\n      result = getAlternativesForProd(prod.definition)\r\n    } else if (prod instanceof RepetitionMandatory) {\r\n      const newDef = prod.definition.concat([\r\n        new Repetition({\r\n          definition: prod.definition\r\n        })\r\n      ])\r\n      return getAlternativesForProd(newDef)\r\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\r\n      const newDef = [\r\n        new Alternative({ definition: prod.definition }),\r\n        new Repetition({\r\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\r\n            <any>prod.definition\r\n          )\r\n        })\r\n      ]\r\n      return getAlternativesForProd(newDef)\r\n    } else if (prod instanceof RepetitionWithSeparator) {\r\n      const newDef = prod.definition.concat([\r\n        new Repetition({\r\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\r\n            <any>prod.definition\r\n          )\r\n        })\r\n      ])\r\n      result = getAlternativesForProd(newDef)\r\n    } else if (prod instanceof Repetition) {\r\n      const newDef = prod.definition.concat([\r\n        new Repetition({\r\n          definition: prod.definition\r\n        })\r\n      ])\r\n      result = getAlternativesForProd(newDef)\r\n    } else if (prod instanceof Alternation) {\r\n      forEach(prod.definition, (currAlt) => {\r\n        // TODO: this is a limited check for empty alternatives\r\n        //   It would prevent a common case of infinite loops during parser initialization.\r\n        //   However **in-directly** empty alternatives may still cause issues.\r\n        if (isEmpty(currAlt.definition) === false) {\r\n          result = getAlternativesForProd(currAlt.definition)\r\n        }\r\n      })\r\n      return result\r\n    } else if (prod instanceof Terminal) {\r\n      currPath.push(prod.terminalType)\r\n    } else {\r\n      throw Error(\"non exhaustive match\")\r\n    }\r\n\r\n    i++\r\n  }\r\n  result.push({\r\n    partialPath: currPath,\r\n    suffixDef: drop(targetDef, i)\r\n  })\r\n\r\n  return result\r\n}\r\n\r\ninterface IPathToExamine {\r\n  idx: number\r\n  def: IProduction[]\r\n  ruleStack: string[]\r\n  occurrenceStack: number[]\r\n}\r\n\r\nexport function nextPossibleTokensAfter(\r\n  initialDef: IProduction[],\r\n  tokenVector: IToken[],\r\n  tokMatcher: TokenMatcher,\r\n  maxLookAhead: number\r\n): ISyntacticContentAssistPath[] {\r\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\"\r\n  // to avoid creating a new Array each time.\r\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL]\r\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\"\r\n  let foundCompletePath = false\r\n\r\n  const tokenVectorLength = tokenVector.length\r\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1\r\n\r\n  const result: ISyntacticContentAssistPath[] = []\r\n\r\n  const possiblePaths: IPathToExamine[] = []\r\n  possiblePaths.push({\r\n    idx: -1,\r\n    def: initialDef,\r\n    ruleStack: [],\r\n    occurrenceStack: []\r\n  })\r\n\r\n  while (!isEmpty(possiblePaths)) {\r\n    const currPath = possiblePaths.pop()!\r\n\r\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\r\n    if (currPath === EXIT_ALTERNATIVE) {\r\n      if (\r\n        foundCompletePath &&\r\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\r\n      ) {\r\n        // remove irrelevant alternative\r\n        possiblePaths.pop()\r\n      }\r\n      continue\r\n    }\r\n\r\n    const currDef = currPath.def\r\n    const currIdx = currPath.idx\r\n    const currRuleStack = currPath.ruleStack\r\n    const currOccurrenceStack = currPath.occurrenceStack\r\n\r\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\r\n    if (isEmpty(currDef)) {\r\n      continue\r\n    }\r\n\r\n    const prod = currDef[0]\r\n    /* istanbul ignore else */\r\n    if (prod === EXIT_NON_TERMINAL) {\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: dropRight(currRuleStack),\r\n        occurrenceStack: dropRight(currOccurrenceStack)\r\n      }\r\n      possiblePaths.push(nextPath)\r\n    } else if (prod instanceof Terminal) {\r\n      /* istanbul ignore else */\r\n      if (currIdx < tokenVectorLength - 1) {\r\n        const nextIdx = currIdx + 1\r\n        const actualToken = tokenVector[nextIdx]\r\n        if (tokMatcher!(actualToken, prod.terminalType)) {\r\n          const nextPath = {\r\n            idx: nextIdx,\r\n            def: drop(currDef),\r\n            ruleStack: currRuleStack,\r\n            occurrenceStack: currOccurrenceStack\r\n          }\r\n          possiblePaths.push(nextPath)\r\n        }\r\n        // end of the line\r\n      } else if (currIdx === tokenVectorLength - 1) {\r\n        // IGNORE ABOVE ELSE\r\n        result.push({\r\n          nextTokenType: prod.terminalType,\r\n          nextTokenOccurrence: prod.idx,\r\n          ruleStack: currRuleStack,\r\n          occurrenceStack: currOccurrenceStack\r\n        })\r\n        foundCompletePath = true\r\n      } else {\r\n        throw Error(\"non exhaustive match\")\r\n      }\r\n    } else if (prod instanceof NonTerminal) {\r\n      const newRuleStack = clone(currRuleStack)\r\n      newRuleStack.push(prod.nonTerminalName)\r\n\r\n      const newOccurrenceStack = clone(currOccurrenceStack)\r\n      newOccurrenceStack.push(prod.idx)\r\n\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\r\n        ruleStack: newRuleStack,\r\n        occurrenceStack: newOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPath)\r\n    } else if (prod instanceof Option) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      const nextPathWithout = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPathWithout)\r\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n      possiblePaths.push(EXIT_ALTERNATIVE)\r\n\r\n      const nextPathWith = {\r\n        idx: currIdx,\r\n        def: prod.definition.concat(drop(currDef)),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPathWith)\r\n    } else if (prod instanceof RepetitionMandatory) {\r\n      // TODO:(THE NEW operators here take a while...) (convert once?)\r\n      const secondIteration = new Repetition({\r\n        definition: prod.definition,\r\n        idx: prod.idx\r\n      })\r\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPath)\r\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\r\n      // TODO:(THE NEW operators here take a while...) (convert once?)\r\n      const separatorGast = new Terminal({\r\n        terminalType: prod.separator\r\n      })\r\n      const secondIteration = new Repetition({\r\n        definition: [<any>separatorGast].concat(prod.definition),\r\n        idx: prod.idx\r\n      })\r\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef))\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPath)\r\n    } else if (prod instanceof RepetitionWithSeparator) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      const nextPathWithout = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPathWithout)\r\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n      possiblePaths.push(EXIT_ALTERNATIVE)\r\n\r\n      const separatorGast = new Terminal({\r\n        terminalType: prod.separator\r\n      })\r\n      const nthRepetition = new Repetition({\r\n        definition: [<any>separatorGast].concat(prod.definition),\r\n        idx: prod.idx\r\n      })\r\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\r\n      const nextPathWith = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPathWith)\r\n    } else if (prod instanceof Repetition) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      const nextPathWithout = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPathWithout)\r\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n      possiblePaths.push(EXIT_ALTERNATIVE)\r\n\r\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\r\n      const nthRepetition = new Repetition({\r\n        definition: prod.definition,\r\n        idx: prod.idx\r\n      })\r\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef))\r\n      const nextPathWith = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      }\r\n      possiblePaths.push(nextPathWith)\r\n    } else if (prod instanceof Alternation) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\r\n        const currAlt: any = prod.definition[i]\r\n        const currAltPath = {\r\n          idx: currIdx,\r\n          def: currAlt.definition.concat(drop(currDef)),\r\n          ruleStack: currRuleStack,\r\n          occurrenceStack: currOccurrenceStack\r\n        }\r\n        possiblePaths.push(currAltPath)\r\n        possiblePaths.push(EXIT_ALTERNATIVE)\r\n      }\r\n    } else if (prod instanceof Alternative) {\r\n      possiblePaths.push({\r\n        idx: currIdx,\r\n        def: prod.definition.concat(drop(currDef)),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack\r\n      })\r\n    } else if (prod instanceof Rule) {\r\n      // last because we should only encounter at most a single one of these per invocation.\r\n      possiblePaths.push(\r\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack)\r\n      )\r\n    } else {\r\n      throw Error(\"non exhaustive match\")\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\nfunction expandTopLevelRule(\r\n  topRule: Rule,\r\n  currIdx: number,\r\n  currRuleStack: string[],\r\n  currOccurrenceStack: number[]\r\n): IPathToExamine {\r\n  const newRuleStack = clone(currRuleStack)\r\n  newRuleStack.push(topRule.name)\r\n\r\n  const newCurrOccurrenceStack = clone(currOccurrenceStack)\r\n  // top rule is always assumed to have been called with occurrence index 1\r\n  newCurrOccurrenceStack.push(1)\r\n\r\n  return {\r\n    idx: currIdx,\r\n    def: topRule.definition,\r\n    ruleStack: newRuleStack,\r\n    occurrenceStack: newCurrOccurrenceStack\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}