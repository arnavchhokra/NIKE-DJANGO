{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.defaultGrammarValidatorErrorProvider = exports.defaultGrammarResolverErrorProvider = exports.defaultParserErrorProvider = void 0;\n\nvar tokens_public_1 = require(\"../scan/tokens_public\");\n\nvar first_1 = __importDefault(require(\"lodash/first\"));\n\nvar map_1 = __importDefault(require(\"lodash/map\"));\n\nvar reduce_1 = __importDefault(require(\"lodash/reduce\"));\n\nvar gast_1 = require(\"@chevrotain/gast\");\n\nvar gast_2 = require(\"@chevrotain/gast\");\n\nexports.defaultParserErrorProvider = {\n  buildMismatchTokenMessage: function buildMismatchTokenMessage(_a) {\n    var expected = _a.expected,\n        actual = _a.actual,\n        previous = _a.previous,\n        ruleName = _a.ruleName;\n    var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);\n    var expectedMsg = hasLabel ? \"--> \".concat((0, tokens_public_1.tokenLabel)(expected), \" <--\") : \"token of type --> \".concat(expected.name, \" <--\");\n    var msg = \"Expecting \".concat(expectedMsg, \" but found --> '\").concat(actual.image, \"' <--\");\n    return msg;\n  },\n  buildNotAllInputParsedMessage: function buildNotAllInputParsedMessage(_a) {\n    var firstRedundant = _a.firstRedundant,\n        ruleName = _a.ruleName;\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\n  },\n  buildNoViableAltMessage: function buildNoViableAltMessage(_a) {\n    var expectedPathsPerAlt = _a.expectedPathsPerAlt,\n        actual = _a.actual,\n        previous = _a.previous,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = (0, first_1.default)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function (result, currAltPaths) {\n        return result.concat(currAltPaths);\n      }, []);\n      var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function (currPath) {\n        return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\", \"), \"]\");\n      });\n      var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function (itemMsg, idx) {\n        return \"  \".concat(idx + 1, \". \").concat(itemMsg);\n      });\n      var calculatedDescription = \"one of these possible Token sequences:\\n\".concat(nextValidSequenceItems.join(\"\\n\"));\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  },\n  buildEarlyExitMessage: function buildEarlyExitMessage(_a) {\n    var expectedIterationPaths = _a.expectedIterationPaths,\n        actual = _a.actual,\n        customUserDescription = _a.customUserDescription,\n        ruleName = _a.ruleName;\n    var errPrefix = \"Expecting: \"; // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n\n    var actualText = (0, first_1.default)(actual).image;\n    var errSuffix = \"\\nbut found: '\" + actualText + \"'\";\n\n    if (customUserDescription) {\n      return errPrefix + customUserDescription + errSuffix;\n    } else {\n      var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function (currPath) {\n        return \"[\".concat((0, map_1.default)(currPath, function (currTokenType) {\n          return (0, tokens_public_1.tokenLabel)(currTokenType);\n        }).join(\",\"), \"]\");\n      });\n      var calculatedDescription = \"expecting at least one iteration which starts with one of these possible Token sequences::\\n  \" + \"<\".concat(nextValidTokenSequences.join(\" ,\"), \">\");\n      return errPrefix + calculatedDescription + errSuffix;\n    }\n  }\n};\nObject.freeze(exports.defaultParserErrorProvider);\nexports.defaultGrammarResolverErrorProvider = {\n  buildRuleNotFoundError: function buildRuleNotFoundError(topLevelRule, undefinedRule) {\n    var msg = \"Invalid grammar, reference to a rule which is not defined: ->\" + undefinedRule.nonTerminalName + \"<-\\n\" + \"inside top level rule: ->\" + topLevelRule.name + \"<-\";\n    return msg;\n  }\n};\nexports.defaultGrammarValidatorErrorProvider = {\n  buildDuplicateFoundError: function buildDuplicateFoundError(topLevelRule, duplicateProds) {\n    function getExtraProductionArgument(prod) {\n      if (prod instanceof gast_1.Terminal) {\n        return prod.terminalType.name;\n      } else if (prod instanceof gast_1.NonTerminal) {\n        return prod.nonTerminalName;\n      } else {\n        return \"\";\n      }\n    }\n\n    var topLevelName = topLevelRule.name;\n    var duplicateProd = (0, first_1.default)(duplicateProds);\n    var index = duplicateProd.idx;\n    var dslName = (0, gast_2.getProductionDslName)(duplicateProd);\n    var extraArgument = getExtraProductionArgument(duplicateProd);\n    var hasExplicitIndex = index > 0;\n    var msg = \"->\".concat(dslName).concat(hasExplicitIndex ? index : \"\", \"<- \").concat(extraArgument ? \"with argument: ->\".concat(extraArgument, \"<-\") : \"\", \"\\n                  appears more than once (\").concat(duplicateProds.length, \" times) in the top level rule: ->\").concat(topLevelName, \"<-.                  \\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \\n                  \"); // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n\n    msg = msg.replace(/[ \\t]+/g, \" \");\n    msg = msg.replace(/\\s\\s+/g, \"\\n\");\n    return msg;\n  },\n  buildNamespaceConflictError: function buildNamespaceConflictError(rule) {\n    var errMsg = \"Namespace conflict found in grammar.\\n\" + \"The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <\".concat(rule.name, \">.\\n\") + \"To resolve this make sure each Terminal and Non-Terminal names are unique\\n\" + \"This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n\" + \"and Non-Terminal names start with a lower case letter.\";\n    return errMsg;\n  },\n  buildAlternationPrefixAmbiguityError: function buildAlternationPrefixAmbiguityError(options) {\n    var pathMsg = (0, map_1.default)(options.prefixPath, function (currTok) {\n      return (0, tokens_public_1.tokenLabel)(currTok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var errMsg = \"Ambiguous alternatives: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> due to common lookahead prefix\\n\") + \"in <OR\".concat(occurrence, \"> inside <\").concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\") + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n\" + \"For Further details.\";\n    return errMsg;\n  },\n  buildAlternationAmbiguityError: function buildAlternationAmbiguityError(options) {\n    var pathMsg = (0, map_1.default)(options.prefixPath, function (currtok) {\n      return (0, tokens_public_1.tokenLabel)(currtok);\n    }).join(\", \");\n    var occurrence = options.alternation.idx === 0 ? \"\" : options.alternation.idx;\n    var currMessage = \"Ambiguous Alternatives Detected: <\".concat(options.ambiguityIndices.join(\" ,\"), \"> in <OR\").concat(occurrence, \">\") + \" inside <\".concat(options.topLevelRule.name, \"> Rule,\\n\") + \"<\".concat(pathMsg, \"> may appears as a prefix path in all these alternatives.\\n\");\n    currMessage = currMessage + \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n\" + \"For Further details.\";\n    return currMessage;\n  },\n  buildEmptyRepetitionError: function buildEmptyRepetitionError(options) {\n    var dslName = (0, gast_2.getProductionDslName)(options.repetition);\n\n    if (options.repetition.idx !== 0) {\n      dslName += options.repetition.idx;\n    }\n\n    var errMsg = \"The repetition <\".concat(dslName, \"> within Rule <\").concat(options.topLevelRule.name, \"> can never consume any tokens.\\n\") + \"This could lead to an infinite loop.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildTokenNameError: function buildTokenNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildEmptyAlternationError: function buildEmptyAlternationError(options) {\n    var errMsg = \"Ambiguous empty alternative: <\".concat(options.emptyChoiceIdx + 1, \">\") + \" in <OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n\") + \"Only the last alternative may be an empty alternative.\";\n    return errMsg;\n  },\n  buildTooManyAlternativesError: function buildTooManyAlternativesError(options) {\n    var errMsg = \"An Alternation cannot have more than 256 alternatives:\\n\" + \"<OR\".concat(options.alternation.idx, \"> inside <\").concat(options.topLevelRule.name, \"> Rule.\\n has \").concat(options.alternation.definition.length + 1, \" alternatives.\");\n    return errMsg;\n  },\n  buildLeftRecursionError: function buildLeftRecursionError(options) {\n    var ruleName = options.topLevelRule.name;\n    var pathNames = (0, map_1.default)(options.leftRecursionPath, function (currRule) {\n      return currRule.name;\n    });\n    var leftRecursivePath = \"\".concat(ruleName, \" --> \").concat(pathNames.concat([ruleName]).join(\" --> \"));\n    var errMsg = \"Left Recursion found in grammar.\\n\" + \"rule: <\".concat(ruleName, \"> can be invoked from itself (directly or indirectly)\\n\") + \"without consuming any Tokens. The grammar path that causes this is: \\n \".concat(leftRecursivePath, \"\\n\") + \" To fix this refactor your grammar to remove the left recursion.\\n\" + \"see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.\";\n    return errMsg;\n  },\n  // TODO: remove - `errors_public` from nyc.config.js exclude\n  //       once this method is fully removed from this file\n  buildInvalidRuleNameError: function buildInvalidRuleNameError(options) {\n    /* istanbul ignore next */\n    return \"deprecated\";\n  },\n  buildDuplicateRuleNameError: function buildDuplicateRuleNameError(options) {\n    var ruleName;\n\n    if (options.topLevelRule instanceof gast_1.Rule) {\n      ruleName = options.topLevelRule.name;\n    } else {\n      ruleName = options.topLevelRule;\n    }\n\n    var errMsg = \"Duplicate definition, rule: ->\".concat(ruleName, \"<- is already defined in the grammar: ->\").concat(options.grammarName, \"<-\");\n    return errMsg;\n  }\n};","map":{"version":3,"mappings":"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","names":["exports","buildMismatchTokenMessage","_a","expected","actual","previous","ruleName","hasLabel","expectedMsg","name","msg","concat","image","buildNotAllInputParsedMessage","firstRedundant","buildNoViableAltMessage","expectedPathsPerAlt","customUserDescription","errPrefix","actualText","errSuffix","allLookAheadPaths","result","currAltPaths","nextValidTokenSequences","currPath","currTokenType","join","nextValidSequenceItems","itemMsg","idx","calculatedDescription","buildEarlyExitMessage","expectedIterationPaths","Object","freeze","buildRuleNotFoundError","topLevelRule","undefinedRule","nonTerminalName","buildDuplicateFoundError","duplicateProds","getExtraProductionArgument","prod","gast_1","terminalType","topLevelName","duplicateProd","index","dslName","extraArgument","hasExplicitIndex","length","replace","buildNamespaceConflictError","rule","errMsg","buildAlternationPrefixAmbiguityError","options","pathMsg","prefixPath","currTok","occurrence","alternation","ambiguityIndices","buildAlternationAmbiguityError","currtok","currMessage","buildEmptyRepetitionError","repetition","buildTokenNameError","buildEmptyAlternationError","emptyChoiceIdx","buildTooManyAlternativesError","definition","buildLeftRecursionError","pathNames","leftRecursionPath","currRule","leftRecursivePath","buildInvalidRuleNameError","buildDuplicateRuleNameError","grammarName"],"sources":["D:\\Github\\NIKE-DJANGO\\Jord\\l4fycy\\node_modules\\chevrotain\\src\\parse\\errors_public.ts"],"sourcesContent":["import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public\"\r\nimport first from \"lodash/first\"\r\nimport map from \"lodash/map\"\r\nimport reduce from \"lodash/reduce\"\r\nimport { Alternation, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\"\r\nimport { getProductionDslName } from \"@chevrotain/gast\"\r\nimport {\r\n  IParserErrorMessageProvider,\r\n  IProductionWithOccurrence,\r\n  TokenType\r\n} from \"@chevrotain/types\"\r\nimport {\r\n  IGrammarResolverErrorMessageProvider,\r\n  IGrammarValidatorErrorMessageProvider\r\n} from \"./grammar/types\"\r\n\r\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\r\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\r\n    const hasLabel = hasTokenLabel(expected)\r\n    const expectedMsg = hasLabel\r\n      ? `--> ${tokenLabel(expected)} <--`\r\n      : `token of type --> ${expected.name} <--`\r\n\r\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`\r\n\r\n    return msg\r\n  },\r\n\r\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\r\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image\r\n  },\r\n\r\n  buildNoViableAltMessage({\r\n    expectedPathsPerAlt,\r\n    actual,\r\n    previous,\r\n    customUserDescription,\r\n    ruleName\r\n  }): string {\r\n    const errPrefix = \"Expecting: \"\r\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\r\n    const actualText = first(actual)!.image\r\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\r\n\r\n    if (customUserDescription) {\r\n      return errPrefix + customUserDescription + errSuffix\r\n    } else {\r\n      const allLookAheadPaths = reduce(\r\n        expectedPathsPerAlt,\r\n        (result, currAltPaths) => result.concat(currAltPaths),\r\n        [] as TokenType[][]\r\n      )\r\n      const nextValidTokenSequences = map(\r\n        allLookAheadPaths,\r\n        (currPath) =>\r\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\r\n            \", \"\r\n          )}]`\r\n      )\r\n      const nextValidSequenceItems = map(\r\n        nextValidTokenSequences,\r\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`\r\n      )\r\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\r\n        \"\\n\"\r\n      )}`\r\n\r\n      return errPrefix + calculatedDescription + errSuffix\r\n    }\r\n  },\r\n\r\n  buildEarlyExitMessage({\r\n    expectedIterationPaths,\r\n    actual,\r\n    customUserDescription,\r\n    ruleName\r\n  }): string {\r\n    const errPrefix = \"Expecting: \"\r\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\r\n    const actualText = first(actual)!.image\r\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\"\r\n\r\n    if (customUserDescription) {\r\n      return errPrefix + customUserDescription + errSuffix\r\n    } else {\r\n      const nextValidTokenSequences = map(\r\n        expectedIterationPaths,\r\n        (currPath) =>\r\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\r\n            \",\"\r\n          )}]`\r\n      )\r\n      const calculatedDescription =\r\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\r\n        `<${nextValidTokenSequences.join(\" ,\")}>`\r\n\r\n      return errPrefix + calculatedDescription + errSuffix\r\n    }\r\n  }\r\n}\r\n\r\nObject.freeze(defaultParserErrorProvider)\r\n\r\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\r\n  {\r\n    buildRuleNotFoundError(\r\n      topLevelRule: Rule,\r\n      undefinedRule: NonTerminal\r\n    ): string {\r\n      const msg =\r\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\r\n        undefinedRule.nonTerminalName +\r\n        \"<-\\n\" +\r\n        \"inside top level rule: ->\" +\r\n        topLevelRule.name +\r\n        \"<-\"\r\n      return msg\r\n    }\r\n  }\r\n\r\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\r\n  {\r\n    buildDuplicateFoundError(\r\n      topLevelRule: Rule,\r\n      duplicateProds: IProductionWithOccurrence[]\r\n    ): string {\r\n      function getExtraProductionArgument(\r\n        prod: IProductionWithOccurrence\r\n      ): string {\r\n        if (prod instanceof Terminal) {\r\n          return prod.terminalType.name\r\n        } else if (prod instanceof NonTerminal) {\r\n          return prod.nonTerminalName\r\n        } else {\r\n          return \"\"\r\n        }\r\n      }\r\n\r\n      const topLevelName = topLevelRule.name\r\n      const duplicateProd = first(duplicateProds)!\r\n      const index = duplicateProd.idx\r\n      const dslName = getProductionDslName(duplicateProd)\r\n      const extraArgument = getExtraProductionArgument(duplicateProd)\r\n\r\n      const hasExplicitIndex = index > 0\r\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\r\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\r\n      }\r\n                  appears more than once (${\r\n                    duplicateProds.length\r\n                  } times) in the top level rule: ->${topLevelName}<-.                  \r\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \r\n                  `\r\n\r\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\r\n      msg = msg.replace(/[ \\t]+/g, \" \")\r\n      msg = msg.replace(/\\s\\s+/g, \"\\n\")\r\n\r\n      return msg\r\n    },\r\n\r\n    buildNamespaceConflictError(rule: Rule): string {\r\n      const errMsg =\r\n        `Namespace conflict found in grammar.\\n` +\r\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\r\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\r\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\r\n        `and Non-Terminal names start with a lower case letter.`\r\n\r\n      return errMsg\r\n    },\r\n\r\n    buildAlternationPrefixAmbiguityError(options: {\r\n      topLevelRule: Rule\r\n      prefixPath: TokenType[]\r\n      ambiguityIndices: number[]\r\n      alternation: Alternation\r\n    }): string {\r\n      const pathMsg = map(options.prefixPath, (currTok) =>\r\n        tokenLabel(currTok)\r\n      ).join(\", \")\r\n      const occurrence =\r\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\r\n      const errMsg =\r\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\r\n          \" ,\"\r\n        )}> due to common lookahead prefix\\n` +\r\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\r\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\r\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\r\n        `For Further details.`\r\n\r\n      return errMsg\r\n    },\r\n\r\n    buildAlternationAmbiguityError(options: {\r\n      topLevelRule: Rule\r\n      prefixPath: TokenType[]\r\n      ambiguityIndices: number[]\r\n      alternation: Alternation\r\n    }): string {\r\n      const pathMsg = map(options.prefixPath, (currtok) =>\r\n        tokenLabel(currtok)\r\n      ).join(\", \")\r\n      const occurrence =\r\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx\r\n      let currMessage =\r\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\r\n          \" ,\"\r\n        )}> in <OR${occurrence}>` +\r\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\r\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\r\n\r\n      currMessage =\r\n        currMessage +\r\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\r\n        `For Further details.`\r\n      return currMessage\r\n    },\r\n\r\n    buildEmptyRepetitionError(options: {\r\n      topLevelRule: Rule\r\n      repetition: IProductionWithOccurrence\r\n    }): string {\r\n      let dslName = getProductionDslName(options.repetition)\r\n      if (options.repetition.idx !== 0) {\r\n        dslName += options.repetition.idx\r\n      }\r\n\r\n      const errMsg =\r\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\r\n        `This could lead to an infinite loop.`\r\n\r\n      return errMsg\r\n    },\r\n\r\n    // TODO: remove - `errors_public` from nyc.config.js exclude\r\n    //       once this method is fully removed from this file\r\n    buildTokenNameError(options: {\r\n      tokenType: TokenType\r\n      expectedPattern: RegExp\r\n    }): string {\r\n      /* istanbul ignore next */\r\n      return \"deprecated\"\r\n    },\r\n\r\n    buildEmptyAlternationError(options: {\r\n      topLevelRule: Rule\r\n      alternation: Alternation\r\n      emptyChoiceIdx: number\r\n    }): string {\r\n      const errMsg =\r\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\r\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\r\n        `Only the last alternative may be an empty alternative.`\r\n\r\n      return errMsg\r\n    },\r\n\r\n    buildTooManyAlternativesError(options: {\r\n      topLevelRule: Rule\r\n      alternation: Alternation\r\n    }): string {\r\n      const errMsg =\r\n        `An Alternation cannot have more than 256 alternatives:\\n` +\r\n        `<OR${options.alternation.idx}> inside <${\r\n          options.topLevelRule.name\r\n        }> Rule.\\n has ${\r\n          options.alternation.definition.length + 1\r\n        } alternatives.`\r\n\r\n      return errMsg\r\n    },\r\n\r\n    buildLeftRecursionError(options: {\r\n      topLevelRule: Rule\r\n      leftRecursionPath: Rule[]\r\n    }): string {\r\n      const ruleName = options.topLevelRule.name\r\n      const pathNames = map(\r\n        options.leftRecursionPath,\r\n        (currRule) => currRule.name\r\n      )\r\n      const leftRecursivePath = `${ruleName} --> ${pathNames\r\n        .concat([ruleName])\r\n        .join(\" --> \")}`\r\n      const errMsg =\r\n        `Left Recursion found in grammar.\\n` +\r\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\r\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\r\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\r\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`\r\n\r\n      return errMsg\r\n    },\r\n\r\n    // TODO: remove - `errors_public` from nyc.config.js exclude\r\n    //       once this method is fully removed from this file\r\n    buildInvalidRuleNameError(options: {\r\n      topLevelRule: Rule\r\n      expectedPattern: RegExp\r\n    }): string {\r\n      /* istanbul ignore next */\r\n      return \"deprecated\"\r\n    },\r\n\r\n    buildDuplicateRuleNameError(options: {\r\n      topLevelRule: Rule | string\r\n      grammarName: string\r\n    }): string {\r\n      let ruleName\r\n      if (options.topLevelRule instanceof Rule) {\r\n        ruleName = options.topLevelRule.name\r\n      } else {\r\n        ruleName = options.topLevelRule\r\n      }\r\n\r\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`\r\n\r\n      return errMsg\r\n    }\r\n  }\r\n"]},"metadata":{},"sourceType":"script"}