{"ast":null,"code":"import * as THREE from 'three';\nimport { shaderMaterial } from '../core/shaderMaterial.js';\nimport { shaderStructs, shaderIntersectFunction, MeshBVHUniformStruct } from 'three-mesh-bvh';\nimport { version } from '../helpers/constants.js';\n\n// Author: N8Programs\nconst MeshRefractionMaterial = /* @__PURE__ */shaderMaterial({\n  envMap: null,\n  bounces: 3,\n  ior: 2.4,\n  correctMips: true,\n  aberrationStrength: 0.01,\n  fresnel: 0,\n  bvh: /* @__PURE__ */new MeshBVHUniformStruct(),\n  color: /* @__PURE__ */new THREE.Color('white'),\n  resolution: /* @__PURE__ */new THREE.Vector2(),\n  viewMatrixInverse: /* @__PURE__ */new THREE.Matrix4(),\n  projectionMatrixInverse: /* @__PURE__ */new THREE.Matrix4()\n}, /*glsl*/\"\\n  uniform mat4 viewMatrixInverse;\\n\\n  varying vec3 vWorldPosition;  \\n  varying vec3 vNormal;\\n  varying mat4 vModelMatrixInverse;\\n\\n  #ifdef USE_INSTANCING_COLOR\\n    varying vec3 vInstanceColor;\\n  #endif\\n\\n  void main() {        \\n    vec4 transformedNormal = vec4(normal, 0.0);\\n    vec4 transformedPosition = vec4(position, 1.0);\\n    #ifdef USE_INSTANCING\\n      transformedNormal = instanceMatrix * transformedNormal;\\n      transformedPosition = instanceMatrix * transformedPosition;\\n    #endif\\n\\n    #ifdef USE_INSTANCING\\n      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);\\n    #else\\n      vModelMatrixInverse = inverse(modelMatrix);\\n    #endif\\n\\n    #ifdef USE_INSTANCING_COLOR\\n      vInstanceColor = instanceColor.rgb;\\n    #endif\\n\\n    vWorldPosition = (modelMatrix * transformedPosition).xyz;\\n    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);\\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;\\n  }\", /*glsl*/\"\\n  #define ENVMAP_TYPE_CUBE_UV\\n  precision highp isampler2D;\\n  precision highp usampler2D;\\n  varying vec3 vWorldPosition;\\n  varying vec3 vNormal;\\n  varying mat4 vModelMatrixInverse;\\n\\n  #ifdef USE_INSTANCING_COLOR\\n    varying vec3 vInstanceColor;\\n  #endif\\n    \\n  #ifdef ENVMAP_TYPE_CUBEM\\n    uniform samplerCube envMap;\\n  #else\\n    uniform sampler2D envMap;\\n  #endif\\n    \\n  uniform float bounces;\\n  \".concat(shaderStructs, \"\\n  \").concat(shaderIntersectFunction, \"\\n  uniform BVH bvh;\\n  uniform float ior;\\n  uniform bool correctMips;\\n  uniform vec2 resolution;\\n  uniform float fresnel;\\n  uniform mat4 modelMatrix;\\n  uniform mat4 projectionMatrixInverse;\\n  uniform mat4 viewMatrixInverse;\\n  uniform float aberrationStrength;\\n  uniform vec3 color;\\n  \\n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\\n  }\\n    \\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\\n    vec3 rayOrigin = ro;\\n    vec3 rayDirection = rd;\\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\\n    for(float i = 0.0; i < bounces; i++) {\\n      uvec4 faceIndices = uvec4( 0u );\\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\\n      vec3 barycoord = vec3( 0.0 );\\n      float side = 1.0;\\n      float dist = 0.0;\\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);      \\n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\\n      if (length(tempDir) != 0.0) {\\n        rayDirection = tempDir;\\n        break;\\n      }\\n      rayDirection = reflect(rayDirection, faceNormal);\\n      rayOrigin = hitPos + rayDirection * 0.01;\\n    }\\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\\n    return rayDirection;\\n  }\\n    \\n  #include <common>\\n  #include <cube_uv_reflection_fragment>\\n    \\n  #ifdef ENVMAP_TYPE_CUBEM\\n    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\\n      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\\n    }\\n  #else\\n    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\\n      vec2 uvv = equirectUv( rayDirection );\\n      vec2 smoothUv = equirectUv( directionCamPerfect );\\n      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\\n    }\\n  #endif\\n  \\n  void main() {\\n    vec2 uv = gl_FragCoord.xy / resolution;\\n    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\\n    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\\n    directionCamPerfect = normalize(directionCamPerfect);\\n    vec3 normal = vNormal;\\n    vec3 rayOrigin = cameraPosition;\\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\\n    vec3 finalColor;\\n    #ifdef CHROMATIC_ABERRATIONS\\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\\n      #ifdef FAST_CHROMA \\n        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\\n        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\\n      #else\\n        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\\n        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\\n      #endif\\n      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\\n      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\\n      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\\n      finalColor = vec3(finalColorR, finalColorG, finalColorB);\\n    #else\\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\\n      finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;    \\n    #endif\\n\\n    finalColor *= color;\\n    #ifdef USE_INSTANCING_COLOR\\n      finalColor *= vInstanceColor;\\n    #endif\\n\\n    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);\\n    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\\n    gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);      \\n    #include <tonemapping_fragment>\\n    #include <\").concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n  }\"));\nexport { MeshRefractionMaterial };","map":{"version":3,"names":["THREE","shaderMaterial","shaderStructs","shaderIntersectFunction","MeshBVHUniformStruct","version","MeshRefractionMaterial","envMap","bounces","ior","correctMips","aberrationStrength","fresnel","bvh","color","Color","resolution","Vector2","viewMatrixInverse","Matrix4","projectionMatrixInverse","concat"],"sources":["D:/Repos/NIKE-DJANGO/Jord/l4fycy/node_modules/@react-three/drei/materials/MeshRefractionMaterial.js"],"sourcesContent":["import * as THREE from 'three';\r\nimport { shaderMaterial } from '../core/shaderMaterial.js';\r\nimport { shaderStructs, shaderIntersectFunction, MeshBVHUniformStruct } from 'three-mesh-bvh';\r\nimport { version } from '../helpers/constants.js';\r\n\r\n// Author: N8Programs\r\nconst MeshRefractionMaterial = /* @__PURE__ */shaderMaterial({\r\n  envMap: null,\r\n  bounces: 3,\r\n  ior: 2.4,\r\n  correctMips: true,\r\n  aberrationStrength: 0.01,\r\n  fresnel: 0,\r\n  bvh: /* @__PURE__ */new MeshBVHUniformStruct(),\r\n  color: /* @__PURE__ */new THREE.Color('white'),\r\n  resolution: /* @__PURE__ */new THREE.Vector2(),\r\n  viewMatrixInverse: /* @__PURE__ */new THREE.Matrix4(),\r\n  projectionMatrixInverse: /* @__PURE__ */new THREE.Matrix4()\r\n}, /*glsl*/`\r\n  uniform mat4 viewMatrixInverse;\r\n\r\n  varying vec3 vWorldPosition;  \r\n  varying vec3 vNormal;\r\n  varying mat4 vModelMatrixInverse;\r\n\r\n  #ifdef USE_INSTANCING_COLOR\r\n    varying vec3 vInstanceColor;\r\n  #endif\r\n\r\n  void main() {        \r\n    vec4 transformedNormal = vec4(normal, 0.0);\r\n    vec4 transformedPosition = vec4(position, 1.0);\r\n    #ifdef USE_INSTANCING\r\n      transformedNormal = instanceMatrix * transformedNormal;\r\n      transformedPosition = instanceMatrix * transformedPosition;\r\n    #endif\r\n\r\n    #ifdef USE_INSTANCING\r\n      vModelMatrixInverse = inverse(modelMatrix * instanceMatrix);\r\n    #else\r\n      vModelMatrixInverse = inverse(modelMatrix);\r\n    #endif\r\n\r\n    #ifdef USE_INSTANCING_COLOR\r\n      vInstanceColor = instanceColor.rgb;\r\n    #endif\r\n\r\n    vWorldPosition = (modelMatrix * transformedPosition).xyz;\r\n    vNormal = normalize((viewMatrixInverse * vec4(normalMatrix * transformedNormal.xyz, 0.0)).xyz);\r\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * transformedPosition;\r\n  }`, /*glsl*/`\r\n  #define ENVMAP_TYPE_CUBE_UV\r\n  precision highp isampler2D;\r\n  precision highp usampler2D;\r\n  varying vec3 vWorldPosition;\r\n  varying vec3 vNormal;\r\n  varying mat4 vModelMatrixInverse;\r\n\r\n  #ifdef USE_INSTANCING_COLOR\r\n    varying vec3 vInstanceColor;\r\n  #endif\r\n    \r\n  #ifdef ENVMAP_TYPE_CUBEM\r\n    uniform samplerCube envMap;\r\n  #else\r\n    uniform sampler2D envMap;\r\n  #endif\r\n    \r\n  uniform float bounces;\r\n  ${shaderStructs}\r\n  ${shaderIntersectFunction}\r\n  uniform BVH bvh;\r\n  uniform float ior;\r\n  uniform bool correctMips;\r\n  uniform vec2 resolution;\r\n  uniform float fresnel;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 projectionMatrixInverse;\r\n  uniform mat4 viewMatrixInverse;\r\n  uniform float aberrationStrength;\r\n  uniform vec3 color;\r\n  \r\n  float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {\r\n    return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );\r\n  }\r\n    \r\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {\r\n    vec3 rayOrigin = ro;\r\n    vec3 rayDirection = rd;\r\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\r\n    rayOrigin = vWorldPosition + rayDirection * 0.001;\r\n    rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;\r\n    rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);\r\n    for(float i = 0.0; i < bounces; i++) {\r\n      uvec4 faceIndices = uvec4( 0u );\r\n      vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n      vec3 barycoord = vec3( 0.0 );\r\n      float side = 1.0;\r\n      float dist = 0.0;\r\n      bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\r\n      vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);      \r\n      vec3 tempDir = refract(rayDirection, faceNormal, ior);\r\n      if (length(tempDir) != 0.0) {\r\n        rayDirection = tempDir;\r\n        break;\r\n      }\r\n      rayDirection = reflect(rayDirection, faceNormal);\r\n      rayOrigin = hitPos + rayDirection * 0.01;\r\n    }\r\n    rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);\r\n    return rayDirection;\r\n  }\r\n    \r\n  #include <common>\r\n  #include <cube_uv_reflection_fragment>\r\n    \r\n  #ifdef ENVMAP_TYPE_CUBEM\r\n    vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {\r\n      return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));\r\n    }\r\n  #else\r\n    vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {\r\n      vec2 uvv = equirectUv( rayDirection );\r\n      vec2 smoothUv = equirectUv( directionCamPerfect );\r\n      return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));\r\n    }\r\n  #endif\r\n  \r\n  void main() {\r\n    vec2 uv = gl_FragCoord.xy / resolution;\r\n    vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;\r\n    directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;\r\n    directionCamPerfect = normalize(directionCamPerfect);\r\n    vec3 normal = vNormal;\r\n    vec3 rayOrigin = cameraPosition;\r\n    vec3 rayDirection = normalize(vWorldPosition - cameraPosition);\r\n    vec3 finalColor;\r\n    #ifdef CHROMATIC_ABERRATIONS\r\n      vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\r\n      #ifdef FAST_CHROMA \r\n        vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));\r\n        vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));\r\n      #else\r\n        vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);\r\n        vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);\r\n      #endif\r\n      float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;\r\n      float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;\r\n      float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;\r\n      finalColor = vec3(finalColorR, finalColorG, finalColorB);\r\n    #else\r\n      rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);\r\n      finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;    \r\n    #endif\r\n\r\n    finalColor *= color;\r\n    #ifdef USE_INSTANCING_COLOR\r\n      finalColor *= vInstanceColor;\r\n    #endif\r\n\r\n    vec3 viewDirection = normalize(vWorldPosition - cameraPosition);\r\n    float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;\r\n    gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);      \r\n    #include <tonemapping_fragment>\r\n    #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\r\n  }`);\r\n\r\nexport { MeshRefractionMaterial };\r\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,aAAa,EAAEC,uBAAuB,EAAEC,oBAAoB,QAAQ,gBAAgB;AAC7F,SAASC,OAAO,QAAQ,yBAAyB;;AAEjD;AACA,MAAMC,sBAAsB,GAAG,eAAeL,cAAc,CAAC;EAC3DM,MAAM,EAAE,IAAI;EACZC,OAAO,EAAE,CAAC;EACVC,GAAG,EAAE,GAAG;EACRC,WAAW,EAAE,IAAI;EACjBC,kBAAkB,EAAE,IAAI;EACxBC,OAAO,EAAE,CAAC;EACVC,GAAG,EAAE,eAAe,IAAIT,oBAAoB,CAAC,CAAC;EAC9CU,KAAK,EAAE,eAAe,IAAId,KAAK,CAACe,KAAK,CAAC,OAAO,CAAC;EAC9CC,UAAU,EAAE,eAAe,IAAIhB,KAAK,CAACiB,OAAO,CAAC,CAAC;EAC9CC,iBAAiB,EAAE,eAAe,IAAIlB,KAAK,CAACmB,OAAO,CAAC,CAAC;EACrDC,uBAAuB,EAAE,eAAe,IAAIpB,KAAK,CAACmB,OAAO,CAAC;AAC5D,CAAC,EAAE,8gCAgCG,4aAAAE,MAAA,CAmBFnB,aAAa,UAAAmB,MAAA,CACblB,uBAAuB,+1IAAAkB,MAAA,CA8FXhB,OAAO,IAAI,GAAG,GAAG,qBAAqB,GAAG,oBAAoB,WACzE,CAAC;AAEL,SAASC,sBAAsB"},"metadata":{},"sourceType":"module","externalDependencies":[]}