{"ast":null,"code":"import _regeneratorRuntime from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createClass from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _assertThisInitialized from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"D:/Jord/l4fycy/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from 'three'; // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nvar FINISH_TYPE_DEFAULT = 0;\nvar FINISH_TYPE_CHROME = 1;\nvar FINISH_TYPE_PEARLESCENT = 2;\nvar FINISH_TYPE_RUBBER = 3;\nvar FINISH_TYPE_MATTE_METALLIC = 4;\nvar FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nvar FILE_LOCATION_AS_IS = 0;\nvar FILE_LOCATION_TRY_PARTS = 1;\nvar FILE_LOCATION_TRY_P = 2;\nvar FILE_LOCATION_TRY_MODELS = 3;\nvar FILE_LOCATION_TRY_RELATIVE = 4;\nvar FILE_LOCATION_TRY_ABSOLUTE = 5;\nvar FILE_LOCATION_NOT_FOUND = 6;\nvar MAIN_COLOUR_CODE = '16';\nvar MAIN_EDGE_COLOUR_CODE = '24';\n\nvar _tempVec0 = new Vector3();\n\nvar _tempVec1 = new Vector3();\n\nvar LDrawConditionalLineMaterial = /*#__PURE__*/function (_ShaderMaterial) {\n  _inherits(LDrawConditionalLineMaterial, _ShaderMaterial);\n\n  var _super = _createSuper(LDrawConditionalLineMaterial);\n\n  function LDrawConditionalLineMaterial(parameters) {\n    var _this;\n\n    _classCallCheck(this, LDrawConditionalLineMaterial);\n\n    _this = _super.call(this, {\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1.0\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      \"\\n        attribute vec3 control0;\\n        attribute vec3 control1;\\n        attribute vec3 direction;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_vertex>\\n        #include <fog_pars_vertex>\\n        #include <logdepthbuf_pars_vertex>\\n        #include <clipping_planes_pars_vertex>\\n\\n        void main() {\\n          #include <color_vertex>\\n\\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n          gl_Position = projectionMatrix * mvPosition;\\n\\n          // Transform the line segment ends and control points into camera clip space\\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\\n\\n          c0.xy /= c0.w;\\n          c1.xy /= c1.w;\\n          p0.xy /= p0.w;\\n          p1.xy /= p1.w;\\n\\n          // Get the direction of the segment and an orthogonal vector\\n          vec2 dir = p1.xy - p0.xy;\\n          vec2 norm = vec2(-dir.y, dir.x);\\n\\n          // Get control point directions from the line\\n          vec2 c0dir = c0.xy - p1.xy;\\n          vec2 c1dir = c1.xy - p1.xy;\\n\\n          // If the vectors to the controls points are pointed in different directions away\\n          // from the line segment then the line should not be drawn.\\n          float d0 = dot(normalize(norm), normalize(c0dir));\\n          float d1 = dot(normalize(norm), normalize(c1dir));\\n          discardFlag = float(sign(d0) != sign(d1));\\n\\n          #include <logdepthbuf_vertex>\\n          #include <clipping_planes_vertex>\\n          #include <fog_vertex>\\n        }\\n      \",\n      fragmentShader:\n      /* glsl */\n      \"\\n        uniform vec3 diffuse;\\n        uniform float opacity;\\n        varying float discardFlag;\\n\\n        #include <common>\\n        #include <color_pars_fragment>\\n        #include <fog_pars_fragment>\\n        #include <logdepthbuf_pars_fragment>\\n        #include <clipping_planes_pars_fragment>\\n\\n        void main() {\\n          if (discardFlag > 0.5) discard;\\n\\n          #include <clipping_planes_fragment>\\n          vec3 outgoingLight = vec3(0.0);\\n          vec4 diffuseColor = vec4(diffuse, opacity);\\n          #include <logdepthbuf_fragment>\\n          #include <color_fragment>\\n          outgoingLight = diffuseColor.rgb; // simple shader\\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\\n          #include <tonemapping_fragment>\\n          #include <encodings_fragment>\\n          #include <fog_fragment>\\n          #include <premultiplied_alpha_fragment>\\n        }\\n      \"\n    });\n    Object.defineProperties(_assertThisInitialized(_this), {\n      opacity: {\n        get: function get() {\n          return this.uniforms.opacity.value;\n        },\n        set: function set(value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function get() {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n\n    _this.setValues(parameters);\n\n    _this.isLDrawConditionalLineMaterial = true;\n    return _this;\n  }\n\n  return _createClass(LDrawConditionalLineMaterial);\n}(ShaderMaterial);\n\nvar ConditionalLineSegments = /*#__PURE__*/function (_LineSegments) {\n  _inherits(ConditionalLineSegments, _LineSegments);\n\n  var _super2 = _createSuper(ConditionalLineSegments);\n\n  function ConditionalLineSegments(geometry, material) {\n    var _this2;\n\n    _classCallCheck(this, ConditionalLineSegments);\n\n    _this2 = _super2.call(this, geometry, material);\n    _this2.isConditionalLine = true;\n    return _this2;\n  }\n\n  return _createClass(ConditionalLineSegments);\n}(LineSegments);\n\nfunction generateFaceNormals(faces) {\n  for (var i = 0, l = faces.length; i < l; i++) {\n    var face = faces[i];\n    var vertices = face.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    var v2 = vertices[2];\n\n    _tempVec0.subVectors(v1, v0);\n\n    _tempVec1.subVectors(v2, v1);\n\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\n\nvar _ray = new Ray();\n\nfunction smoothNormals(faces, lineSegments) {\n  var checkSubSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n  var hashMultiplier = (1 + 1e-10) * 1e2;\n\n  function hashVertex(v) {\n    var x = ~~(v.x * hashMultiplier);\n    var y = ~~(v.y * hashMultiplier);\n    var z = ~~(v.z * hashMultiplier);\n    return \"\".concat(x, \",\").concat(y, \",\").concat(z);\n  }\n\n  function hashEdge(v0, v1) {\n    return \"\".concat(hashVertex(v0), \"_\").concat(hashVertex(v1));\n  } // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n\n\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    var scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n\n  var hardEdges = new Set();\n  var hardEdgeRays = new Map();\n  var halfEdgeList = {};\n  var normals = []; // Save the list of hard edges by hash\n\n  for (var i = 0, l = lineSegments.length; i < l; i++) {\n    var ls = lineSegments[i];\n    var vertices = ls.vertices;\n    var v0 = vertices[0];\n    var v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0)); // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      var ray = toNormalizedRay(v0, v1, new Ray());\n      var rh1 = hashRay(ray);\n\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        var rh2 = hashRay(ray);\n        var _info = {\n          ray: ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, _info);\n        hardEdgeRays.set(rh2, _info);\n      } // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n\n\n      var info = hardEdgeRays.get(rh1);\n      var d0 = info.ray.direction.dot(v0);\n      var d1 = info.ray.direction.dot(v1);\n\n      if (d0 > d1) {\n        var _ref = [d1, d0];\n        d0 = _ref[0];\n        d1 = _ref[1];\n      }\n\n      info.distances.push(d0, d1);\n    }\n  } // track the half edges associated with each triangle\n\n\n  for (var _i = 0, _l = faces.length; _i < _l; _i++) {\n    var tri = faces[_i];\n    var _vertices = tri.vertices;\n    var vertCount = _vertices.length;\n\n    for (var i2 = 0; i2 < vertCount; i2++) {\n      var index = i2;\n      var next = (i2 + 1) % vertCount;\n      var _v = _vertices[index];\n      var _v2 = _vertices[next];\n      var hash = hashEdge(_v, _v2); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) {\n        continue;\n      } // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\n\n      if (checkSubSegments) {\n        toNormalizedRay(_v, _v2, _ray);\n        var rayHash = hashRay(_ray);\n\n        if (hardEdgeRays.has(rayHash)) {\n          var _info3 = hardEdgeRays.get(rayHash);\n\n          var _ray2 = _info3.ray,\n              distances = _info3.distances;\n\n          var _d = _ray2.direction.dot(_v);\n\n          var _d2 = _ray2.direction.dot(_v2);\n\n          if (_d > _d2) {\n            var _ref2 = [_d2, _d];\n            _d = _ref2[0];\n            _d2 = _ref2[1];\n          } // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\n\n          var found = false;\n\n          for (var _i2 = 0, _l2 = distances.length; _i2 < _l2; _i2 += 2) {\n            if (_d >= distances[_i2] && _d2 <= distances[_i2 + 1]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            continue;\n          }\n        }\n      }\n\n      var _info2 = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = _info2;\n    }\n  } // Iterate until we've tried to connect all faces to share normals\n\n\n  while (true) {\n    // Stop if there are no more faces left\n    var halfEdge = null;\n\n    for (var key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n\n    if (halfEdge === null) {\n      break;\n    } // Exhaustively find all connected faces\n\n\n    var queue = [halfEdge];\n\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      var _tri = queue.pop().tri;\n      var _vertices2 = _tri.vertices;\n      var vertNormals = _tri.normals;\n      var faceNormal = _tri.faceNormal; // Check if any edge is connected to another triangle edge\n\n      var _vertCount = _vertices2.length;\n\n      for (var _i3 = 0; _i3 < _vertCount; _i3++) {\n        var _index = _i3;\n\n        var _next = (_i3 + 1) % _vertCount;\n\n        var _v3 = _vertices2[_index];\n        var _v4 = _vertices2[_next]; // delete this triangle from the list so it won't be found again\n\n        var _hash = hashEdge(_v3, _v4);\n\n        delete halfEdgeList[_hash];\n        var reverseHash = hashEdge(_v4, _v3);\n        var otherInfo = halfEdgeList[reverseHash];\n\n        if (otherInfo) {\n          var otherTri = otherInfo.tri;\n          var otherIndex = otherInfo.index;\n          var otherNormals = otherTri.normals;\n          var otherVertCount = otherNormals.length;\n          var otherFaceNormal = otherTri.faceNormal; // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n\n          if (Math.abs(otherTri.faceNormal.dot(_tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          } // share the first normal\n\n\n          var otherNext = (otherIndex + 1) % otherVertCount;\n\n          if (vertNormals[_index] && otherNormals[otherNext] && vertNormals[_index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[_index].norm);\n            vertNormals[_index].norm = otherNormals[otherNext].norm;\n          }\n\n          var sharedNormal1 = vertNormals[_index] || otherNormals[otherNext];\n\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n\n          if (vertNormals[_index] === null) {\n            vertNormals[_index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          } // share the second normal\n\n\n          if (vertNormals[_next] && otherNormals[otherIndex] && vertNormals[_next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[_next].norm);\n            vertNormals[_next].norm = otherNormals[otherIndex].norm;\n          }\n\n          var sharedNormal2 = vertNormals[_next] || otherNormals[otherIndex];\n\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n\n          if (vertNormals[_next] === null) {\n            vertNormals[_next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (var _i4 = 0, _l3 = normals.length; _i4 < _l3; _i4++) {\n    normals[_i4].normalize();\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part';\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nvar LineParser = /*#__PURE__*/function () {\n  function LineParser(line, lineNumber) {\n    _classCallCheck(this, LineParser);\n\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  _createClass(LineParser, [{\n    key: \"seekNonSpace\",\n    value: function seekNonSpace() {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken() {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    }\n  }, {\n    key: \"getVector\",\n    value: function getVector() {\n      return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n    }\n  }, {\n    key: \"getRemainingString\",\n    value: function getRemainingString() {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    }\n  }, {\n    key: \"isAtTheEnd\",\n    value: function isAtTheEnd() {\n      return this.currentCharIndex >= this.lineLength;\n    }\n  }, {\n    key: \"setToEnd\",\n    value: function setToEnd() {\n      this.currentCharIndex = this.lineLength;\n    }\n  }, {\n    key: \"getLineNumberString\",\n    value: function getLineNumberString() {\n      return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n    }\n  }]);\n\n  return LineParser;\n}(); // Fetches and parses an intermediate representation of LDraw parts files.\n\n\nvar LDrawParsedCache = /*#__PURE__*/function () {\n  function LDrawParsedCache(loader) {\n    _classCallCheck(this, LDrawParsedCache);\n\n    this.loader = loader;\n    this._cache = {};\n  }\n\n  _createClass(LDrawParsedCache, [{\n    key: \"cloneResult\",\n    value: function cloneResult(original) {\n      var result = {}; // vertices are transformed and normals computed before being converted to geometry\n      // so these pieces must be cloned.\n\n      result.faces = original.faces.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          normals: face.normals.map(function () {\n            return null;\n          }),\n          faceNormal: null\n        };\n      });\n      result.conditionalSegments = original.conditionalSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          }),\n          controlPoints: face.controlPoints.map(function (v) {\n            return v.clone();\n          })\n        };\n      });\n      result.lineSegments = original.lineSegments.map(function (face) {\n        return {\n          colorCode: face.colorCode,\n          material: face.material,\n          vertices: face.vertices.map(function (v) {\n            return v.clone();\n          })\n        };\n      }); // none if this is subsequently modified\n\n      result.type = original.type;\n      result.category = original.category;\n      result.keywords = original.keywords;\n      result.subobjects = original.subobjects;\n      result.totalFaces = original.totalFaces;\n      result.startingConstructionStep = original.startingConstructionStep;\n      result.materials = original.materials;\n      result.group = null;\n      return result;\n    }\n  }, {\n    key: \"fetchData\",\n    value: function () {\n      var _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fileName) {\n        var triedLowerCase, locationState, subobjectURL, loader, fileLoader, text;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                triedLowerCase = false;\n                locationState = FILE_LOCATION_AS_IS;\n\n              case 2:\n                if (!(locationState !== FILE_LOCATION_NOT_FOUND)) {\n                  _context.next = 40;\n                  break;\n                }\n\n                subobjectURL = fileName;\n                _context.t0 = locationState;\n                _context.next = _context.t0 === FILE_LOCATION_AS_IS ? 7 : _context.t0 === FILE_LOCATION_TRY_PARTS ? 9 : _context.t0 === FILE_LOCATION_TRY_P ? 12 : _context.t0 === FILE_LOCATION_TRY_MODELS ? 15 : _context.t0 === FILE_LOCATION_TRY_RELATIVE ? 18 : _context.t0 === FILE_LOCATION_TRY_ABSOLUTE ? 21 : 23;\n                break;\n\n              case 7:\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 9:\n                subobjectURL = 'parts/' + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 12:\n                subobjectURL = 'p/' + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 15:\n                subobjectURL = 'models/' + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 18:\n                subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL;\n                locationState = locationState + 1;\n                return _context.abrupt(\"break\", 23);\n\n              case 21:\n                if (triedLowerCase) {\n                  // Try absolute path\n                  locationState = FILE_LOCATION_NOT_FOUND;\n                } else {\n                  // Next attempt is lower case\n                  fileName = fileName.toLowerCase();\n                  subobjectURL = fileName;\n                  triedLowerCase = true;\n                  locationState = FILE_LOCATION_AS_IS;\n                }\n\n                return _context.abrupt(\"break\", 23);\n\n              case 23:\n                loader = this.loader;\n                fileLoader = new FileLoader(loader.manager);\n                fileLoader.setPath(loader.partsLibraryPath);\n                fileLoader.setRequestHeader(loader.requestHeader);\n                fileLoader.setWithCredentials(loader.withCredentials);\n                _context.prev = 28;\n                _context.next = 31;\n                return fileLoader.loadAsync(subobjectURL);\n\n              case 31:\n                text = _context.sent;\n                return _context.abrupt(\"return\", text);\n\n              case 35:\n                _context.prev = 35;\n                _context.t1 = _context[\"catch\"](28);\n                return _context.abrupt(\"continue\", 2);\n\n              case 38:\n                _context.next = 2;\n                break;\n\n              case 40:\n                throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n\n              case 41:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[28, 35]]);\n      }));\n\n      function fetchData(_x) {\n        return _fetchData.apply(this, arguments);\n      }\n\n      return fetchData;\n    }()\n  }, {\n    key: \"parse\",\n    value: function parse(text) {\n      var fileName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var loader = this.loader; // final results\n\n      var faces = [];\n      var lineSegments = [];\n      var conditionalSegments = [];\n      var subobjects = [];\n      var materials = {};\n\n      var getLocalMaterial = function getLocalMaterial(colorCode) {\n        return materials[colorCode] || null;\n      };\n\n      var type = 'Model';\n      var category = null;\n      var keywords = null;\n      var totalFaces = 0; // split into lines\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var startingConstructionStep = false; // Parse all line commands\n\n      for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.setData(currentEmbeddedFileName, currentEmbeddedText); // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n\n        var lineType = lp.getToken();\n        var material = void 0;\n        var colorCode = void 0;\n        var segment = void 0;\n        var ccw = void 0;\n        var doubleSided = void 0;\n        var v0 = void 0,\n            v1 = void 0,\n            v2 = void 0,\n            v3 = void 0,\n            c0 = void 0,\n            c1 = void 0;\n\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  break;\n\n                case '!COLOUR':\n                  material = loader.parseColorMetaDirective(lp);\n\n                  if (material) {\n                    materials[material.userData.code] = material;\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n              }\n            }\n\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n\n            var _fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n            if (loader.fileMap[_fileName]) {\n              // Found the subobject path in the preloaded file path map\n              _fileName = loader.fileMap[_fileName];\n            } else {\n              // Standardized subfolders\n              if (_fileName.startsWith('s/')) {\n                _fileName = 'parts/' + _fileName;\n              } else if (_fileName.startsWith('48/')) {\n                _fileName = 'p/' + _fileName;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              colorCode: colorCode,\n              matrix: matrix,\n              fileName: _fileName,\n              inverted: bfcInverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1]\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            c0 = lp.getVector();\n            c1 = lp.getVector();\n            segment = {\n              material: material,\n              colorCode: colorCode,\n              vertices: [v0, v1],\n              controlPoints: [c0, c1]\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n            } else {\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            }\n\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v2, v1, v0],\n                normals: [null, null, null]\n              });\n              totalFaces++;\n            }\n\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            colorCode = lp.getToken();\n            material = getLocalMaterial(colorCode);\n            ccw = bfcCCW;\n            doubleSided = !bfcCertified || !bfcCull;\n\n            if (ccw === true) {\n              v0 = lp.getVector();\n              v1 = lp.getVector();\n              v2 = lp.getVector();\n              v3 = lp.getVector();\n            } else {\n              v3 = lp.getVector();\n              v2 = lp.getVector();\n              v1 = lp.getVector();\n              v0 = lp.getVector();\n            } // specifically place the triangle diagonal in the v0 and v1 slots so we can\n            // account for the doubling of vertices later when smoothing normals.\n\n\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v0, v1, v2, v3],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n\n            if (doubleSided === true) {\n              faces.push({\n                material: material,\n                colorCode: colorCode,\n                faceNormal: null,\n                vertices: [v3, v2, v1, v0],\n                normals: [null, null, null, null]\n              });\n              totalFaces += 2;\n            }\n\n            break;\n\n          default:\n            throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.');\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.setData(currentEmbeddedFileName, currentEmbeddedText);\n      }\n\n      return {\n        faces: faces,\n        conditionalSegments: conditionalSegments,\n        lineSegments: lineSegments,\n        type: type,\n        category: category,\n        keywords: keywords,\n        subobjects: subobjects,\n        totalFaces: totalFaces,\n        startingConstructionStep: startingConstructionStep,\n        materials: materials,\n        fileName: fileName,\n        group: null\n      };\n    } // returns an (optionally cloned) instance of the data\n\n  }, {\n    key: \"getData\",\n    value: function getData(fileName) {\n      var clone = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var key = fileName.toLowerCase();\n      var result = this._cache[key];\n\n      if (result === null || result instanceof Promise) {\n        return null;\n      }\n\n      if (clone) {\n        return this.cloneResult(result);\n      } else {\n        return result;\n      }\n    } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n    // the data is ready to use and can be retrieved synchronously with \"getData\".\n\n  }, {\n    key: \"ensureDataLoaded\",\n    value: function () {\n      var _ensureDataLoaded = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(fileName) {\n        var _this3 = this;\n\n        var key;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                key = fileName.toLowerCase();\n\n                if (!(key in this._cache)) {\n                  // replace the promise with a copy of the parsed data for immediate processing\n                  this._cache[key] = this.fetchData(fileName).then(function (text) {\n                    var info = _this3.parse(text, fileName);\n\n                    _this3._cache[key] = info;\n                    return info;\n                  });\n                }\n\n                _context2.next = 4;\n                return this._cache[key];\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function ensureDataLoaded(_x2) {\n        return _ensureDataLoaded.apply(this, arguments);\n      }\n\n      return ensureDataLoaded;\n    }() // sets the data in the cache from parsed data\n\n  }, {\n    key: \"setData\",\n    value: function setData(fileName, text) {\n      var key = fileName.toLowerCase();\n      this._cache[key] = this.parse(text, fileName);\n    }\n  }]);\n\n  return LDrawParsedCache;\n}(); // returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\n\n\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n\n  return materialHierarchy[colorCode] || null;\n} // Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\n\n\nvar LDrawPartsGeometryCache = /*#__PURE__*/function () {\n  function LDrawPartsGeometryCache(loader) {\n    _classCallCheck(this, LDrawPartsGeometryCache);\n\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  } // Convert the given file information into a mesh by processing subobjects.\n\n\n  _createClass(LDrawPartsGeometryCache, [{\n    key: \"processIntoMesh\",\n    value: function () {\n      var _processIntoMesh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(info) {\n        var _this4 = this;\n\n        var loader, parseCache, faceMaterials, processInfoSubobjects, i, l, checkSubSegments, group;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                loader = this.loader;\n                parseCache = this.parseCache;\n                faceMaterials = new Set(); // Processes the part subobject information to load child parts and merge geometry onto part\n                // piece object.\n\n                processInfoSubobjects = /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(info) {\n                    var subobject,\n                        subobjects,\n                        promises,\n                        _loop,\n                        i,\n                        l,\n                        group,\n                        subobjectInfos,\n                        _i5,\n                        _l4,\n                        _subobject,\n                        subobjectInfo,\n                        subobjectGroup,\n                        parentLineSegments,\n                        parentConditionalSegments,\n                        parentFaces,\n                        lineSegments,\n                        conditionalSegments,\n                        faces,\n                        matrix,\n                        inverted,\n                        matrixScaleInverted,\n                        colorCode,\n                        lineColorCode,\n                        _i6,\n                        _l5,\n                        ls,\n                        vertices,\n                        _i7,\n                        _l6,\n                        os,\n                        _vertices3,\n                        controlPoints,\n                        _i8,\n                        _l7,\n                        tri,\n                        _vertices4,\n                        _i9,\n                        _l8,\n                        _args3 = arguments;\n\n                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            subobject = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : null;\n                            subobjects = info.subobjects;\n                            promises = []; // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n                            // group which lets instruction steps apply correctly.\n\n                            _loop = function _loop(i, l) {\n                              var subobject = subobjects[i];\n                              var promise = parseCache.ensureDataLoaded(subobject.fileName).then(function () {\n                                var subobjectInfo = parseCache.getData(subobject.fileName, false);\n\n                                if (!isPrimitiveType(subobjectInfo.type)) {\n                                  return _this4.loadModel(subobject.fileName).catch(function (error) {\n                                    console.warn(error);\n                                    return null;\n                                  });\n                                }\n\n                                return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\n                              });\n                              promises.push(promise);\n                            };\n\n                            for (i = 0, l = subobjects.length; i < l; i++) {\n                              _loop(i, l);\n                            }\n\n                            group = new Group();\n                            group.userData.category = info.category;\n                            group.userData.keywords = info.keywords;\n                            info.group = group;\n                            _context3.next = 11;\n                            return Promise.all(promises);\n\n                          case 11:\n                            subobjectInfos = _context3.sent;\n                            _i5 = 0, _l4 = subobjectInfos.length;\n\n                          case 13:\n                            if (!(_i5 < _l4)) {\n                              _context3.next = 45;\n                              break;\n                            }\n\n                            _subobject = info.subobjects[_i5];\n                            subobjectInfo = subobjectInfos[_i5];\n\n                            if (!(subobjectInfo === null)) {\n                              _context3.next = 18;\n                              break;\n                            }\n\n                            return _context3.abrupt(\"continue\", 42);\n\n                          case 18:\n                            if (!subobjectInfo.isGroup) {\n                              _context3.next = 26;\n                              break;\n                            }\n\n                            subobjectGroup = subobjectInfo;\n\n                            _subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n\n                            subobjectGroup.userData.startingConstructionStep = _subobject.startingConstructionStep;\n                            subobjectGroup.name = _subobject.fileName;\n                            loader.applyMaterialsToMesh(subobjectGroup, _subobject.colorCode, info.materials);\n                            group.add(subobjectGroup);\n                            return _context3.abrupt(\"continue\", 42);\n\n                          case 26:\n                            // add the subobject group if it has children in case it has both children and primitives\n                            if (subobjectInfo.group.children.length) {\n                              group.add(subobjectInfo.group);\n                            } // transform the primitives into the local space of the parent piece and append them to\n                            // to the parent primitives list.\n\n\n                            parentLineSegments = info.lineSegments;\n                            parentConditionalSegments = info.conditionalSegments;\n                            parentFaces = info.faces;\n                            lineSegments = subobjectInfo.lineSegments;\n                            conditionalSegments = subobjectInfo.conditionalSegments;\n                            faces = subobjectInfo.faces;\n                            matrix = _subobject.matrix;\n                            inverted = _subobject.inverted;\n                            matrixScaleInverted = matrix.determinant() < 0;\n                            colorCode = _subobject.colorCode;\n                            lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\n                            for (_i6 = 0, _l5 = lineSegments.length; _i6 < _l5; _i6++) {\n                              ls = lineSegments[_i6];\n                              vertices = ls.vertices;\n                              vertices[0].applyMatrix4(matrix);\n                              vertices[1].applyMatrix4(matrix);\n                              ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n                              ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\n                              parentLineSegments.push(ls);\n                            }\n\n                            for (_i7 = 0, _l6 = conditionalSegments.length; _i7 < _l6; _i7++) {\n                              os = conditionalSegments[_i7];\n                              _vertices3 = os.vertices;\n                              controlPoints = os.controlPoints;\n\n                              _vertices3[0].applyMatrix4(matrix);\n\n                              _vertices3[1].applyMatrix4(matrix);\n\n                              controlPoints[0].applyMatrix4(matrix);\n                              controlPoints[1].applyMatrix4(matrix);\n                              os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n                              os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\n                              parentConditionalSegments.push(os);\n                            }\n\n                            for (_i8 = 0, _l7 = faces.length; _i8 < _l7; _i8++) {\n                              tri = faces[_i8];\n                              _vertices4 = tri.vertices;\n\n                              for (_i9 = 0, _l8 = _vertices4.length; _i9 < _l8; _i9++) {\n                                _vertices4[_i9].applyMatrix4(matrix);\n                              }\n\n                              tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n                              tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\n                              faceMaterials.add(tri.colorCode); // If the scale of the object is negated then the triangle winding order\n                              // needs to be flipped.\n\n                              if (matrixScaleInverted !== inverted) {\n                                _vertices4.reverse();\n                              }\n\n                              parentFaces.push(tri);\n                            }\n\n                            info.totalFaces += subobjectInfo.totalFaces;\n\n                          case 42:\n                            _i5++;\n                            _context3.next = 13;\n                            break;\n\n                          case 45:\n                            // Apply the parent subobjects pass through material code to this object. This is done several times due\n                            // to material scoping.\n                            if (subobject) {\n                              loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\n                            }\n\n                            return _context3.abrupt(\"return\", info);\n\n                          case 47:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function processInfoSubobjects(_x4) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }(); // Track material use to see if we need to use the normal smooth slow path for hard edges.\n\n\n                for (i = 0, l = info.faces; i < l; i++) {\n                  faceMaterials.add(info.faces[i].colorCode);\n                }\n\n                _context4.next = 7;\n                return processInfoSubobjects(info);\n\n              case 7:\n                if (loader.smoothNormals) {\n                  checkSubSegments = faceMaterials.size > 1;\n                  generateFaceNormals(info.faces);\n                  smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n                } // Add the primitive objects and metadata.\n\n\n                group = info.group;\n\n                if (info.faces.length > 0) {\n                  group.add(createObject(info.faces, 3, false, info.totalFaces));\n                }\n\n                if (info.lineSegments.length > 0) {\n                  group.add(createObject(info.lineSegments, 2));\n                }\n\n                if (info.conditionalSegments.length > 0) {\n                  group.add(createObject(info.conditionalSegments, 2, true));\n                }\n\n                return _context4.abrupt(\"return\", group);\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function processIntoMesh(_x3) {\n        return _processIntoMesh.apply(this, arguments);\n      }\n\n      return processIntoMesh;\n    }()\n  }, {\n    key: \"hasCachedModel\",\n    value: function hasCachedModel(fileName) {\n      return fileName !== null && fileName.toLowerCase() in this._cache;\n    }\n  }, {\n    key: \"getCachedModel\",\n    value: function () {\n      var _getCachedModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(fileName) {\n        var key, group;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(fileName !== null && this.hasCachedModel(fileName))) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                key = fileName.toLowerCase();\n                _context5.next = 4;\n                return this._cache[key];\n\n              case 4:\n                group = _context5.sent;\n                return _context5.abrupt(\"return\", group.clone());\n\n              case 8:\n                return _context5.abrupt(\"return\", null);\n\n              case 9:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getCachedModel(_x5) {\n        return _getCachedModel.apply(this, arguments);\n      }\n\n      return getCachedModel;\n    }() // Loads and parses the model with the given file name. Returns a cached copy if available.\n\n  }, {\n    key: \"loadModel\",\n    value: function () {\n      var _loadModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(fileName) {\n        var parseCache, key, info, promise, group;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                parseCache = this.parseCache;\n                key = fileName.toLowerCase();\n\n                if (!this.hasCachedModel(fileName)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", this.getCachedModel(fileName));\n\n              case 6:\n                _context6.next = 8;\n                return parseCache.ensureDataLoaded(fileName);\n\n              case 8:\n                info = parseCache.getData(fileName);\n                promise = this.processIntoMesh(info); // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n                // so check the cache again to see if it's been added since the last async operation so we don't\n                // do unnecessary work.\n\n                if (!this.hasCachedModel(fileName)) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", this.getCachedModel(fileName));\n\n              case 12:\n                // Cache object if it's a part so it can be reused later.\n                if (isPartType(info.type)) {\n                  this._cache[key] = promise;\n                } // return a copy\n\n\n                _context6.next = 15;\n                return promise;\n\n              case 15:\n                group = _context6.sent;\n                return _context6.abrupt(\"return\", group.clone());\n\n              case 17:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function loadModel(_x6) {\n        return _loadModel.apply(this, arguments);\n      }\n\n      return loadModel;\n    }() // parses the given model text into a renderable object. Returns cached copy if available.\n\n  }, {\n    key: \"parseModel\",\n    value: function () {\n      var _parseModel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(text) {\n        var parseCache, info;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                parseCache = this.parseCache;\n                info = parseCache.parse(text);\n\n                if (!(isPartType(info.type) && this.hasCachedModel(info.fileName))) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", this.getCachedModel(info.fileName));\n\n              case 4:\n                return _context7.abrupt(\"return\", this.processIntoMesh(info));\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function parseModel(_x7) {\n        return _parseModel.apply(this, arguments);\n      }\n\n      return parseModel;\n    }()\n  }]);\n\n  return LDrawPartsGeometryCache;\n}();\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize) {\n  var isConditionalSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var totalElements = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial);\n\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n\n  var positions = new Float32Array(elementSize * totalElements * 3);\n  var normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  var materials = [];\n  var quadArray = new Array(6);\n  var bufferGeometry = new BufferGeometry();\n  var prevMaterial = null;\n  var index0 = 0;\n  var numGroupVerts = 0;\n  var offset = 0;\n\n  for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    var elem = elements[iElem];\n    var vertices = elem.vertices;\n\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n\n    for (var j = 0, l = vertices.length; j < l; j++) {\n      var v = vertices[j];\n      var index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    } // create the normals array if this is a set of faces\n\n\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        var v0 = vertices[0];\n        var v1 = vertices[1];\n        var v2 = vertices[2];\n\n        _tempVec0.subVectors(v1, v0);\n\n        _tempVec1.subVectors(v2, v1);\n\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n\n      var elemNormals = elem.normals;\n\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n\n      for (var _j = 0, _l9 = elemNormals.length; _j < _l9; _j++) {\n        // use face normal if a vertex normal is not provided\n        var n = elem.faceNormal;\n\n        if (elemNormals[_j]) {\n          n = elemNormals[_j].norm;\n        }\n\n        var _index2 = offset + _j * 3;\n\n        normals[_index2 + 0] = n.x;\n        normals[_index2 + 1] = n.y;\n        normals[_index2 + 2] = n.z;\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      var material = elem.material;\n\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode);\n      }\n\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n\n    offset += 3 * vertices.length;\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\n  }\n\n  var object3d = null;\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    var controlArray0 = new Float32Array(elements.length * 3 * 2);\n    var controlArray1 = new Float32Array(elements.length * 3 * 2);\n    var directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (var i = 0, _l10 = elements.length; i < _l10; i++) {\n      var os = elements[i];\n      var _vertices5 = os.vertices;\n      var controlPoints = os.controlPoints;\n      var c0 = controlPoints[0];\n      var c1 = controlPoints[1];\n      var _v5 = _vertices5[0];\n      var _v6 = _vertices5[1];\n\n      var _index3 = i * 3 * 2;\n\n      controlArray0[_index3 + 0] = c0.x;\n      controlArray0[_index3 + 1] = c0.y;\n      controlArray0[_index3 + 2] = c0.z;\n      controlArray0[_index3 + 3] = c0.x;\n      controlArray0[_index3 + 4] = c0.y;\n      controlArray0[_index3 + 5] = c0.z;\n      controlArray1[_index3 + 0] = c1.x;\n      controlArray1[_index3 + 1] = c1.y;\n      controlArray1[_index3 + 2] = c1.z;\n      controlArray1[_index3 + 3] = c1.x;\n      controlArray1[_index3 + 4] = c1.y;\n      controlArray1[_index3 + 5] = c1.z;\n      directionArray[_index3 + 0] = _v6.x - _v5.x;\n      directionArray[_index3 + 1] = _v6.y - _v5.y;\n      directionArray[_index3 + 2] = _v6.z - _v5.z;\n      directionArray[_index3 + 3] = _v6.x - _v5.x;\n      directionArray[_index3 + 4] = _v6.y - _v5.y;\n      directionArray[_index3 + 5] = _v6.z - _v5.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nvar LDrawLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(LDrawLoader, _Loader);\n\n  var _super3 = _createSuper(LDrawLoader);\n\n  function LDrawLoader(manager) {\n    var _this5;\n\n    _classCallCheck(this, LDrawLoader);\n\n    _this5 = _super3.call(this, manager); // Array of THREE.Material\n\n    _this5.materials = [];\n    _this5.materialLibrary = {}; // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    _this5.partsCache = new LDrawPartsGeometryCache(_assertThisInitialized(_this5)); // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    _this5.fileMap = {}; // Initializes the materials library with default materials\n\n    _this5.setMaterials([]); // If this flag is set to true the vertex normals will be smoothed.\n\n\n    _this5.smoothNormals = true; // The path to load parts from the LDraw parts library from.\n\n    _this5.partsLibraryPath = '';\n    return _this5;\n  }\n\n  _createClass(LDrawLoader, [{\n    key: \"setPartsLibraryPath\",\n    value: function setPartsLibraryPath(path) {\n      this.partsLibraryPath = path;\n      return this;\n    }\n  }, {\n    key: \"preloadMaterials\",\n    value: function () {\n      var _preloadMaterials = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(url) {\n        var fileLoader, text, colorLineRegex, lines, materials, i, l, line, directive, material;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                fileLoader = new FileLoader(this.manager);\n                fileLoader.setPath(this.path);\n                fileLoader.setRequestHeader(this.requestHeader);\n                fileLoader.setWithCredentials(this.withCredentials);\n                _context8.next = 6;\n                return fileLoader.loadAsync(url);\n\n              case 6:\n                text = _context8.sent;\n                colorLineRegex = /^0 !COLOUR/;\n                lines = text.split(/[\\n\\r]/g);\n                materials = [];\n\n                for (i = 0, l = lines.length; i < l; i++) {\n                  line = lines[i];\n\n                  if (colorLineRegex.test(line)) {\n                    directive = line.replace(colorLineRegex, '');\n                    material = this.parseColorMetaDirective(new LineParser(directive));\n                    materials.push(material);\n                  }\n                }\n\n                this.setMaterials(materials);\n\n              case 12:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function preloadMaterials(_x8) {\n        return _preloadMaterials.apply(this, arguments);\n      }\n\n      return preloadMaterials;\n    }()\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this6 = this;\n\n      var fileLoader = new FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        _this6.partsCache.parseModel(text, _this6.materialLibrary).then(function (group) {\n          _this6.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, _this6.materialLibrary, true);\n\n          _this6.computeConstructionSteps(group);\n\n          onLoad(group);\n        }).catch(onError);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(text, onLoad) {\n      var _this7 = this;\n\n      this.partsCache.parseModel(text, this.materialLibrary).then(function (group) {\n        _this7.computeConstructionSteps(group);\n\n        onLoad(group);\n      });\n    }\n  }, {\n    key: \"setMaterials\",\n    value: function setMaterials(materials) {\n      this.materialLibrary = {};\n      this.materials = [];\n\n      for (var i = 0, l = materials.length; i < l; i++) {\n        this.addMaterial(materials[i]);\n      } // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\n\n      this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')));\n      this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')));\n      return this;\n    }\n  }, {\n    key: \"setFileMap\",\n    value: function setFileMap(fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    }\n  }, {\n    key: \"addMaterial\",\n    value: function addMaterial(material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.materialLibrary;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n        matLib[material.userData.code] = material;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getMaterial\",\n    value: function getMaterial(colorCode) {\n      if (colorCode.startsWith('0x2')) {\n        // Special 'direct' material value (RGB color)\n        var color = colorCode.substring(3);\n        return this.parseColorMetaDirective(new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''));\n      }\n\n      return this.materialLibrary[colorCode] || null;\n    } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n    // in the material array if they need to be filled in.\n\n  }, {\n    key: \"applyMaterialsToMesh\",\n    value: function applyMaterialsToMesh(group, parentColorCode, materialHierarchy) {\n      var finalMaterialPass = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n      var loader = this;\n      var parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n      group.traverse(function (c) {\n        if (c.isMesh || c.isLineSegments) {\n          if (Array.isArray(c.material)) {\n            for (var i = 0, l = c.material.length; i < l; i++) {\n              if (!c.material[i].isMaterial) {\n                c.material[i] = getMaterial(c, c.material[i]);\n              }\n            }\n          } else if (!c.material.isMaterial) {\n            c.material = getMaterial(c, c.material);\n          }\n        }\n      }); // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n      // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n      // simply returned for the subsequent material application.\n\n      function getMaterial(c, colorCode) {\n        // if our parent is a passthrough color code and we don't have the current material color available then\n        // return early.\n        if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n          return colorCode;\n        }\n\n        var forEdge = c.isLineSegments || c.isConditionalLine;\n        var isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n        if (isPassthrough) {\n          colorCode = parentColorCode;\n        }\n\n        var material = null;\n\n        if (colorCode in materialHierarchy) {\n          material = materialHierarchy[colorCode];\n        } else if (finalMaterialPass) {\n          // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n          // parse the \"direct\" colors\n          material = loader.getMaterial(colorCode);\n\n          if (material === null) {\n            // otherwise throw an error if this is final opportunity to set the material\n            throw new Error(\"LDrawLoader: Material properties for code \".concat(colorCode, \" not available.\"));\n          }\n        } else {\n          return colorCode;\n        }\n\n        if (c.isLineSegments) {\n          material = material.userData.edgeMaterial;\n\n          if (c.isConditionalLine) {\n            material = material.userData.conditionalEdgeMaterial;\n          }\n        }\n\n        return material;\n      }\n    }\n  }, {\n    key: \"getMainMaterial\",\n    value: function getMainMaterial() {\n      return this.getMaterial(MAIN_COLOUR_CODE);\n    }\n  }, {\n    key: \"getMainEdgeMaterial\",\n    value: function getMainEdgeMaterial() {\n      return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n    }\n  }, {\n    key: \"parseColorMetaDirective\",\n    value: function parseColorMetaDirective(lineParser) {\n      // Parses a color definition and returns a THREE.Material\n      var code = null; // Triangle and line colors\n\n      var color = 0xff00ff;\n      var edgeColor = 0xff00ff; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = FINISH_TYPE_DEFAULT;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.');\n      } // Parse tag tokens and their parameters\n\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case 'CODE':\n            code = lineParser.getToken();\n            break;\n\n          case 'VALUE':\n            color = lineParser.getToken();\n\n            if (color.startsWith('0x')) {\n              color = '#' + color.substring(2);\n            } else if (!color.startsWith('#')) {\n              throw new Error('LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.');\n            }\n\n            break;\n\n          case 'EDGE':\n            edgeColor = lineParser.getToken();\n\n            if (edgeColor.startsWith('0x')) {\n              edgeColor = '#' + edgeColor.substring(2);\n            } else if (!edgeColor.startsWith('#')) {\n              // Try to see if edge color is a color code\n              edgeMaterial = this.getMaterial(edgeColor);\n\n              if (!edgeMaterial) {\n                throw new Error('LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.');\n              } // Get the edge material for this triangle material\n\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw new Error('LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.');\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw new Error('LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.');\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case 'CHROME':\n            finishType = FINISH_TYPE_CHROME;\n            break;\n\n          case 'PEARLESCENT':\n            finishType = FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case 'RUBBER':\n            finishType = FINISH_TYPE_RUBBER;\n            break;\n\n          case 'MATTE_METALLIC':\n            finishType = FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case 'METAL':\n            finishType = FINISH_TYPE_METAL;\n            break;\n\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.');\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case FINISH_TYPE_DEFAULT:\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by making the surface glossy\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.3,\n            metalness: 0.25\n          });\n          break;\n\n        case FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.9,\n            metalness: 0\n          });\n          break;\n\n        case FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new MeshStandardMaterial({\n            color: color,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new LineBasicMaterial({\n          color: edgeColor,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + ' - Edge'; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n          fog: true,\n          transparent: isTransparent,\n          depthWrite: !isTransparent,\n          color: edgeColor,\n          opacity: alpha\n        });\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      this.addMaterial(material);\n      return material;\n    }\n  }, {\n    key: \"computeConstructionSteps\",\n    value: function computeConstructionSteps(model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(function (c) {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    }\n  }]);\n\n  return LDrawLoader;\n}(Loader);\n\nexport { LDrawLoader };","map":{"version":3,"names":["Vector3","Ray","Loader","FileLoader","MeshStandardMaterial","LineBasicMaterial","ShaderMaterial","UniformsUtils","UniformsLib","Color","BufferGeometry","BufferAttribute","LineSegments","Mesh","Matrix4","Group","FINISH_TYPE_DEFAULT","FINISH_TYPE_CHROME","FINISH_TYPE_PEARLESCENT","FINISH_TYPE_RUBBER","FINISH_TYPE_MATTE_METALLIC","FINISH_TYPE_METAL","FILE_LOCATION_AS_IS","FILE_LOCATION_TRY_PARTS","FILE_LOCATION_TRY_P","FILE_LOCATION_TRY_MODELS","FILE_LOCATION_TRY_RELATIVE","FILE_LOCATION_TRY_ABSOLUTE","FILE_LOCATION_NOT_FOUND","MAIN_COLOUR_CODE","MAIN_EDGE_COLOUR_CODE","_tempVec0","_tempVec1","LDrawConditionalLineMaterial","parameters","uniforms","merge","fog","diffuse","value","opacity","vertexShader","fragmentShader","Object","defineProperties","get","set","color","setValues","isLDrawConditionalLineMaterial","ConditionalLineSegments","geometry","material","isConditionalLine","generateFaceNormals","faces","i","l","length","face","vertices","v0","v1","v2","subVectors","faceNormal","crossVectors","normalize","_ray","smoothNormals","lineSegments","checkSubSegments","hashMultiplier","hashVertex","v","x","y","z","hashEdge","toNormalizedRay","targetRay","direction","scalar","dot","origin","copy","addScaledVector","hashRay","ray","hardEdges","Set","hardEdgeRays","Map","halfEdgeList","normals","ls","add","rh1","has","rh2","info","distances","d0","d1","push","tri","vertCount","i2","index","next","hash","rayHash","found","halfEdge","key","queue","pop","vertNormals","reverseHash","otherInfo","otherTri","otherIndex","otherNormals","otherVertCount","otherFaceNormal","Math","abs","otherNext","norm","sharedNormal1","sharedNormal2","isPartType","type","isPrimitiveType","test","LineParser","line","lineNumber","lineLength","currentCharIndex","currentChar","charAt","pos0","pos1","seekNonSpace","substring","parseFloat","getToken","LDrawParsedCache","loader","_cache","original","result","map","colorCode","clone","conditionalSegments","controlPoints","category","keywords","subobjects","totalFaces","startingConstructionStep","materials","group","fileName","triedLowerCase","locationState","subobjectURL","lastIndexOf","toLowerCase","fileLoader","manager","setPath","partsLibraryPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","loadAsync","text","Error","getLocalMaterial","indexOf","replace","lines","split","numLines","parsingEmbeddedFiles","currentEmbeddedFileName","currentEmbeddedText","bfcCertified","bfcCCW","bfcInverted","bfcCull","lineIndex","startsWith","setData","lp","isAtTheEnd","lineType","segment","ccw","doubleSided","v3","c0","c1","meta","parseColorMetaDirective","userData","code","console","warn","getLineNumberString","newKeywords","getRemainingString","forEach","keyword","trim","token","posX","posY","posZ","m0","m1","m2","m3","m4","m5","m6","m7","m8","matrix","fileMap","inverted","getVector","Promise","cloneResult","fetchData","then","parse","getMaterialFromCode","parentColorCode","materialHierarchy","forEdge","isPassthrough","LDrawPartsGeometryCache","parseCache","faceMaterials","processInfoSubobjects","subobject","promises","promise","ensureDataLoaded","subobjectInfo","getData","loadModel","catch","error","all","subobjectInfos","isGroup","subobjectGroup","decompose","position","quaternion","scale","name","applyMaterialsToMesh","children","parentLineSegments","parentConditionalSegments","parentFaces","matrixScaleInverted","determinant","lineColorCode","applyMatrix4","os","reverse","size","createObject","hasCachedModel","getCachedModel","processIntoMesh","sortByMaterial","a","b","elements","elementSize","isConditionalSegments","totalElements","sort","positions","Float32Array","quadArray","Array","bufferGeometry","prevMaterial","index0","numGroupVerts","offset","iElem","nElem","elem","j","elemNormals","n","addGroup","edgeMaterial","conditionalEdgeMaterial","Infinity","setAttribute","object3d","controlArray0","controlArray1","directionArray","LDrawLoader","materialLibrary","partsCache","setMaterials","path","url","colorLineRegex","directive","onLoad","onProgress","onError","load","parseModel","computeConstructionSteps","addMaterial","matLib","finalMaterialPass","parentIsPassthrough","traverse","c","isMesh","isLineSegments","isArray","isMaterial","getMaterial","lineParser","edgeColor","alpha","isTransparent","luminance","finishType","toUpperCase","parseInt","isNaN","max","min","setToEnd","roughness","metalness","transparent","premultipliedAlpha","depthWrite","polygonOffset","polygonOffsetFactor","emissive","multiplyScalar","model","stepNumber","constructionStep","numConstructionSteps"],"sources":["D:/Jord/l4fycy/node_modules/three-stdlib/loaders/LDrawLoader.js"],"sourcesContent":["import { Vector3, Ray, Loader, FileLoader, MeshStandardMaterial, LineBasicMaterial, ShaderMaterial, UniformsUtils, UniformsLib, Color, BufferGeometry, BufferAttribute, LineSegments, Mesh, Matrix4, Group } from 'three';\n\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\n\nconst FILE_LOCATION_AS_IS = 0;\nconst FILE_LOCATION_TRY_PARTS = 1;\nconst FILE_LOCATION_TRY_P = 2;\nconst FILE_LOCATION_TRY_MODELS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst _tempVec0 = new Vector3();\n\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super({\n      uniforms: UniformsUtils.merge([UniformsLib.fog, {\n        diffuse: {\n          value: new Color()\n        },\n        opacity: {\n          value: 1.0\n        }\n      }]),\n      vertexShader:\n      /* glsl */\n      `\n        attribute vec3 control0;\n        attribute vec3 control1;\n        attribute vec3 direction;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_vertex>\n        #include <fog_pars_vertex>\n        #include <logdepthbuf_pars_vertex>\n        #include <clipping_planes_pars_vertex>\n\n        void main() {\n          #include <color_vertex>\n\n          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n\n          // Transform the line segment ends and control points into camera clip space\n          vec4 c0 = projectionMatrix * modelViewMatrix * vec4(control0, 1.0);\n          vec4 c1 = projectionMatrix * modelViewMatrix * vec4(control1, 1.0);\n          vec4 p0 = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n          vec4 p1 = projectionMatrix * modelViewMatrix * vec4(position + direction, 1.0);\n\n          c0.xy /= c0.w;\n          c1.xy /= c1.w;\n          p0.xy /= p0.w;\n          p1.xy /= p1.w;\n\n          // Get the direction of the segment and an orthogonal vector\n          vec2 dir = p1.xy - p0.xy;\n          vec2 norm = vec2(-dir.y, dir.x);\n\n          // Get control point directions from the line\n          vec2 c0dir = c0.xy - p1.xy;\n          vec2 c1dir = c1.xy - p1.xy;\n\n          // If the vectors to the controls points are pointed in different directions away\n          // from the line segment then the line should not be drawn.\n          float d0 = dot(normalize(norm), normalize(c0dir));\n          float d1 = dot(normalize(norm), normalize(c1dir));\n          discardFlag = float(sign(d0) != sign(d1));\n\n          #include <logdepthbuf_vertex>\n          #include <clipping_planes_vertex>\n          #include <fog_vertex>\n        }\n      `,\n      fragmentShader:\n      /* glsl */\n      `\n        uniform vec3 diffuse;\n        uniform float opacity;\n        varying float discardFlag;\n\n        #include <common>\n        #include <color_pars_fragment>\n        #include <fog_pars_fragment>\n        #include <logdepthbuf_pars_fragment>\n        #include <clipping_planes_pars_fragment>\n\n        void main() {\n          if (discardFlag > 0.5) discard;\n\n          #include <clipping_planes_fragment>\n          vec3 outgoingLight = vec3(0.0);\n          vec4 diffuseColor = vec4(diffuse, opacity);\n          #include <logdepthbuf_fragment>\n          #include <color_fragment>\n          outgoingLight = diffuseColor.rgb; // simple shader\n          gl_FragColor = vec4(outgoingLight, diffuseColor.a);\n          #include <tonemapping_fragment>\n          #include <encodings_fragment>\n          #include <fog_fragment>\n          #include <premultiplied_alpha_fragment>\n        }\n      `\n    });\n    Object.defineProperties(this, {\n      opacity: {\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      color: {\n        get: function () {\n          return this.uniforms.diffuse.value;\n        }\n      }\n    });\n    this.setValues(parameters);\n    this.isLDrawConditionalLineMaterial = true;\n  }\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.isConditionalLine = true;\n  }\n\n}\n\nfunction generateFaceNormals(faces) {\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const face = faces[i];\n    const vertices = face.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    const v2 = vertices[2];\n\n    _tempVec0.subVectors(v1, v0);\n\n    _tempVec1.subVectors(v2, v1);\n\n    face.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n  }\n}\n\nconst _ray = new Ray();\n\nfunction smoothNormals(faces, lineSegments, checkSubSegments = false) {\n  // NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n  // it allows edges to be smoothed as expected (see minifig arms).\n  // --\n  // And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n  // point errors on vertices along quantization boundaries. Ie after matrix multiplication\n  // vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n  // get merged. This added epsilon attempts to push these error values to the same quantized\n  // value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n  const hashMultiplier = (1 + 1e-10) * 1e2;\n\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n\n  function hashEdge(v0, v1) {\n    return `${hashVertex(v0)}_${hashVertex(v1)}`;\n  } // converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n  // onto the original line.\n\n\n  function toNormalizedRay(v0, v1, targetRay) {\n    targetRay.direction.subVectors(v1, v0).normalize();\n    const scalar = v0.dot(targetRay.direction);\n    targetRay.origin.copy(v0).addScaledVector(targetRay.direction, -scalar);\n    return targetRay;\n  }\n\n  function hashRay(ray) {\n    return hashEdge(ray.origin, ray.direction);\n  }\n\n  const hardEdges = new Set();\n  const hardEdgeRays = new Map();\n  const halfEdgeList = {};\n  const normals = []; // Save the list of hard edges by hash\n\n  for (let i = 0, l = lineSegments.length; i < l; i++) {\n    const ls = lineSegments[i];\n    const vertices = ls.vertices;\n    const v0 = vertices[0];\n    const v1 = vertices[1];\n    hardEdges.add(hashEdge(v0, v1));\n    hardEdges.add(hashEdge(v1, v0)); // only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n    // and requires more memory.\n\n    if (checkSubSegments) {\n      // add both ray directions to the map\n      const ray = toNormalizedRay(v0, v1, new Ray());\n      const rh1 = hashRay(ray);\n\n      if (!hardEdgeRays.has(rh1)) {\n        toNormalizedRay(v1, v0, ray);\n        const rh2 = hashRay(ray);\n        const info = {\n          ray,\n          distances: []\n        };\n        hardEdgeRays.set(rh1, info);\n        hardEdgeRays.set(rh2, info);\n      } // store both segments ends in min, max order in the distances array to check if a face edge is a\n      // subsegment later.\n\n\n      const info = hardEdgeRays.get(rh1);\n      let d0 = info.ray.direction.dot(v0);\n      let d1 = info.ray.direction.dot(v1);\n\n      if (d0 > d1) {\n        [d0, d1] = [d1, d0];\n      }\n\n      info.distances.push(d0, d1);\n    }\n  } // track the half edges associated with each triangle\n\n\n  for (let i = 0, l = faces.length; i < l; i++) {\n    const tri = faces[i];\n    const vertices = tri.vertices;\n    const vertCount = vertices.length;\n\n    for (let i2 = 0; i2 < vertCount; i2++) {\n      const index = i2;\n      const next = (i2 + 1) % vertCount;\n      const v0 = vertices[index];\n      const v1 = vertices[next];\n      const hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n      if (hardEdges.has(hash)) {\n        continue;\n      } // if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\n\n      if (checkSubSegments) {\n        toNormalizedRay(v0, v1, _ray);\n        const rayHash = hashRay(_ray);\n\n        if (hardEdgeRays.has(rayHash)) {\n          const info = hardEdgeRays.get(rayHash);\n          const {\n            ray,\n            distances\n          } = info;\n          let d0 = ray.direction.dot(v0);\n          let d1 = ray.direction.dot(v1);\n\n          if (d0 > d1) {\n            [d0, d1] = [d1, d0];\n          } // return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\n\n          let found = false;\n\n          for (let i = 0, l = distances.length; i < l; i += 2) {\n            if (d0 >= distances[i] && d1 <= distances[i + 1]) {\n              found = true;\n              break;\n            }\n          }\n\n          if (found) {\n            continue;\n          }\n        }\n      }\n\n      const info = {\n        index: index,\n        tri: tri\n      };\n      halfEdgeList[hash] = info;\n    }\n  } // Iterate until we've tried to connect all faces to share normals\n\n\n  while (true) {\n    // Stop if there are no more faces left\n    let halfEdge = null;\n\n    for (const key in halfEdgeList) {\n      halfEdge = halfEdgeList[key];\n      break;\n    }\n\n    if (halfEdge === null) {\n      break;\n    } // Exhaustively find all connected faces\n\n\n    const queue = [halfEdge];\n\n    while (queue.length > 0) {\n      // initialize all vertex normals in this triangle\n      const tri = queue.pop().tri;\n      const vertices = tri.vertices;\n      const vertNormals = tri.normals;\n      const faceNormal = tri.faceNormal; // Check if any edge is connected to another triangle edge\n\n      const vertCount = vertices.length;\n\n      for (let i2 = 0; i2 < vertCount; i2++) {\n        const index = i2;\n        const next = (i2 + 1) % vertCount;\n        const v0 = vertices[index];\n        const v1 = vertices[next]; // delete this triangle from the list so it won't be found again\n\n        const hash = hashEdge(v0, v1);\n        delete halfEdgeList[hash];\n        const reverseHash = hashEdge(v1, v0);\n        const otherInfo = halfEdgeList[reverseHash];\n\n        if (otherInfo) {\n          const otherTri = otherInfo.tri;\n          const otherIndex = otherInfo.index;\n          const otherNormals = otherTri.normals;\n          const otherVertCount = otherNormals.length;\n          const otherFaceNormal = otherTri.faceNormal; // NOTE: If the angle between faces is > 67.5 degrees then assume it's\n          // hard edge. There are some cases where the line segments do not line up exactly\n          // with or span multiple triangle edges (see Lunar Vehicle wheels).\n\n          if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n            continue;\n          } // if this triangle has already been traversed then it won't be in\n          // the halfEdgeList. If it has not then add it to the queue and delete\n          // it so it won't be found again.\n\n\n          if (reverseHash in halfEdgeList) {\n            queue.push(otherInfo);\n            delete halfEdgeList[reverseHash];\n          } // share the first normal\n\n\n          const otherNext = (otherIndex + 1) % otherVertCount;\n\n          if (vertNormals[index] && otherNormals[otherNext] && vertNormals[index] !== otherNormals[otherNext]) {\n            otherNormals[otherNext].norm.add(vertNormals[index].norm);\n            vertNormals[index].norm = otherNormals[otherNext].norm;\n          }\n\n          let sharedNormal1 = vertNormals[index] || otherNormals[otherNext];\n\n          if (sharedNormal1 === null) {\n            // it's possible to encounter an edge of a triangle that has already been traversed meaning\n            // both edges already have different normals defined and shared. To work around this we create\n            // a wrapper object so when those edges are merged the normals can be updated everywhere.\n            sharedNormal1 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal1.norm);\n          }\n\n          if (vertNormals[index] === null) {\n            vertNormals[index] = sharedNormal1;\n            sharedNormal1.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherNext] === null) {\n            otherNormals[otherNext] = sharedNormal1;\n            sharedNormal1.norm.add(otherFaceNormal);\n          } // share the second normal\n\n\n          if (vertNormals[next] && otherNormals[otherIndex] && vertNormals[next] !== otherNormals[otherIndex]) {\n            otherNormals[otherIndex].norm.add(vertNormals[next].norm);\n            vertNormals[next].norm = otherNormals[otherIndex].norm;\n          }\n\n          let sharedNormal2 = vertNormals[next] || otherNormals[otherIndex];\n\n          if (sharedNormal2 === null) {\n            sharedNormal2 = {\n              norm: new Vector3()\n            };\n            normals.push(sharedNormal2.norm);\n          }\n\n          if (vertNormals[next] === null) {\n            vertNormals[next] = sharedNormal2;\n            sharedNormal2.norm.add(faceNormal);\n          }\n\n          if (otherNormals[otherIndex] === null) {\n            otherNormals[otherIndex] = sharedNormal2;\n            sharedNormal2.norm.add(otherFaceNormal);\n          }\n        }\n      }\n    }\n  } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n  for (let i = 0, l = normals.length; i < l; i++) {\n    normals[i].normalize();\n  }\n}\n\nfunction isPartType(type) {\n  return type === 'Part' || type === 'Unofficial_Part';\n}\n\nfunction isPrimitiveType(type) {\n  return /primitive/i.test(type) || type === 'Subpart';\n}\n\nclass LineParser {\n  constructor(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  seekNonSpace() {\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n        return;\n      }\n\n      this.currentCharIndex++;\n    }\n  }\n\n  getToken() {\n    const pos0 = this.currentCharIndex++; // Seek space\n\n    while (this.currentCharIndex < this.lineLength) {\n      this.currentChar = this.line.charAt(this.currentCharIndex);\n\n      if (this.currentChar === ' ' || this.currentChar === '\\t') {\n        break;\n      }\n\n      this.currentCharIndex++;\n    }\n\n    const pos1 = this.currentCharIndex;\n    this.seekNonSpace();\n    return this.line.substring(pos0, pos1);\n  }\n\n  getVector() {\n    return new Vector3(parseFloat(this.getToken()), parseFloat(this.getToken()), parseFloat(this.getToken()));\n  }\n\n  getRemainingString() {\n    return this.line.substring(this.currentCharIndex, this.lineLength);\n  }\n\n  isAtTheEnd() {\n    return this.currentCharIndex >= this.lineLength;\n  }\n\n  setToEnd() {\n    this.currentCharIndex = this.lineLength;\n  }\n\n  getLineNumberString() {\n    return this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n  }\n\n} // Fetches and parses an intermediate representation of LDraw parts files.\n\n\nclass LDrawParsedCache {\n  constructor(loader) {\n    this.loader = loader;\n    this._cache = {};\n  }\n\n  cloneResult(original) {\n    const result = {}; // vertices are transformed and normals computed before being converted to geometry\n    // so these pieces must be cloned.\n\n    result.faces = original.faces.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        normals: face.normals.map(() => null),\n        faceNormal: null\n      };\n    });\n    result.conditionalSegments = original.conditionalSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone()),\n        controlPoints: face.controlPoints.map(v => v.clone())\n      };\n    });\n    result.lineSegments = original.lineSegments.map(face => {\n      return {\n        colorCode: face.colorCode,\n        material: face.material,\n        vertices: face.vertices.map(v => v.clone())\n      };\n    }); // none if this is subsequently modified\n\n    result.type = original.type;\n    result.category = original.category;\n    result.keywords = original.keywords;\n    result.subobjects = original.subobjects;\n    result.totalFaces = original.totalFaces;\n    result.startingConstructionStep = original.startingConstructionStep;\n    result.materials = original.materials;\n    result.group = null;\n    return result;\n  }\n\n  async fetchData(fileName) {\n    let triedLowerCase = false;\n    let locationState = FILE_LOCATION_AS_IS;\n\n    while (locationState !== FILE_LOCATION_NOT_FOUND) {\n      let subobjectURL = fileName;\n\n      switch (locationState) {\n        case FILE_LOCATION_AS_IS:\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_PARTS:\n          subobjectURL = 'parts/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_P:\n          subobjectURL = 'p/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_MODELS:\n          subobjectURL = 'models/' + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_RELATIVE:\n          subobjectURL = fileName.substring(0, fileName.lastIndexOf('/') + 1) + subobjectURL;\n          locationState = locationState + 1;\n          break;\n\n        case FILE_LOCATION_TRY_ABSOLUTE:\n          if (triedLowerCase) {\n            // Try absolute path\n            locationState = FILE_LOCATION_NOT_FOUND;\n          } else {\n            // Next attempt is lower case\n            fileName = fileName.toLowerCase();\n            subobjectURL = fileName;\n            triedLowerCase = true;\n            locationState = FILE_LOCATION_AS_IS;\n          }\n\n          break;\n      }\n\n      const loader = this.loader;\n      const fileLoader = new FileLoader(loader.manager);\n      fileLoader.setPath(loader.partsLibraryPath);\n      fileLoader.setRequestHeader(loader.requestHeader);\n      fileLoader.setWithCredentials(loader.withCredentials);\n\n      try {\n        const text = await fileLoader.loadAsync(subobjectURL);\n        return text;\n      } catch {\n        continue;\n      }\n    }\n\n    throw new Error('LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.');\n  }\n\n  parse(text, fileName = null) {\n    const loader = this.loader; // final results\n\n    const faces = [];\n    const lineSegments = [];\n    const conditionalSegments = [];\n    const subobjects = [];\n    const materials = {};\n\n    const getLocalMaterial = colorCode => {\n      return materials[colorCode] || null;\n    };\n\n    let type = 'Model';\n    let category = null;\n    let keywords = null;\n    let totalFaces = 0; // split into lines\n\n    if (text.indexOf('\\r\\n') !== -1) {\n      // This is faster than String.split with regex that splits on both\n      text = text.replace(/\\r\\n/g, '\\n');\n    }\n\n    const lines = text.split('\\n');\n    const numLines = lines.length;\n    let parsingEmbeddedFiles = false;\n    let currentEmbeddedFileName = null;\n    let currentEmbeddedText = null;\n    let bfcCertified = false;\n    let bfcCCW = true;\n    let bfcInverted = false;\n    let bfcCull = true;\n    let startingConstructionStep = false; // Parse all line commands\n\n    for (let lineIndex = 0; lineIndex < numLines; lineIndex++) {\n      const line = lines[lineIndex];\n      if (line.length === 0) continue;\n\n      if (parsingEmbeddedFiles) {\n        if (line.startsWith('0 FILE ')) {\n          // Save previous embedded file in the cache\n          this.setData(currentEmbeddedFileName, currentEmbeddedText); // New embedded text file\n\n          currentEmbeddedFileName = line.substring(7);\n          currentEmbeddedText = '';\n        } else {\n          currentEmbeddedText += line + '\\n';\n        }\n\n        continue;\n      }\n\n      const lp = new LineParser(line, lineIndex + 1);\n      lp.seekNonSpace();\n\n      if (lp.isAtTheEnd()) {\n        // Empty line\n        continue;\n      } // Parse the line type\n\n\n      const lineType = lp.getToken();\n      let material;\n      let colorCode;\n      let segment;\n      let ccw;\n      let doubleSided;\n      let v0, v1, v2, v3, c0, c1;\n\n      switch (lineType) {\n        // Line type 0: Comment or META\n        case '0':\n          // Parse meta directive\n          const meta = lp.getToken();\n\n          if (meta) {\n            switch (meta) {\n              case '!LDRAW_ORG':\n                type = lp.getToken();\n                break;\n\n              case '!COLOUR':\n                material = loader.parseColorMetaDirective(lp);\n\n                if (material) {\n                  materials[material.userData.code] = material;\n                } else {\n                  console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                }\n\n                break;\n\n              case '!CATEGORY':\n                category = lp.getToken();\n                break;\n\n              case '!KEYWORDS':\n                const newKeywords = lp.getRemainingString().split(',');\n\n                if (newKeywords.length > 0) {\n                  if (!keywords) {\n                    keywords = [];\n                  }\n\n                  newKeywords.forEach(function (keyword) {\n                    keywords.push(keyword.trim());\n                  });\n                }\n\n                break;\n\n              case 'FILE':\n                if (lineIndex > 0) {\n                  // Start embedded text files parsing\n                  parsingEmbeddedFiles = true;\n                  currentEmbeddedFileName = lp.getRemainingString();\n                  currentEmbeddedText = '';\n                  bfcCertified = false;\n                  bfcCCW = true;\n                }\n\n                break;\n\n              case 'BFC':\n                // Changes to the backface culling state\n                while (!lp.isAtTheEnd()) {\n                  const token = lp.getToken();\n\n                  switch (token) {\n                    case 'CERTIFY':\n                    case 'NOCERTIFY':\n                      bfcCertified = token === 'CERTIFY';\n                      bfcCCW = true;\n                      break;\n\n                    case 'CW':\n                    case 'CCW':\n                      bfcCCW = token === 'CCW';\n                      break;\n\n                    case 'INVERTNEXT':\n                      bfcInverted = true;\n                      break;\n\n                    case 'CLIP':\n                    case 'NOCLIP':\n                      bfcCull = token === 'CLIP';\n                      break;\n\n                    default:\n                      console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                      break;\n                  }\n                }\n\n                break;\n\n              case 'STEP':\n                startingConstructionStep = true;\n                break;\n            }\n          }\n\n          break;\n        // Line type 1: Sub-object file\n\n        case '1':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          const posX = parseFloat(lp.getToken());\n          const posY = parseFloat(lp.getToken());\n          const posZ = parseFloat(lp.getToken());\n          const m0 = parseFloat(lp.getToken());\n          const m1 = parseFloat(lp.getToken());\n          const m2 = parseFloat(lp.getToken());\n          const m3 = parseFloat(lp.getToken());\n          const m4 = parseFloat(lp.getToken());\n          const m5 = parseFloat(lp.getToken());\n          const m6 = parseFloat(lp.getToken());\n          const m7 = parseFloat(lp.getToken());\n          const m8 = parseFloat(lp.getToken());\n          const matrix = new Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n          let fileName = lp.getRemainingString().trim().replace(/\\\\/g, '/');\n\n          if (loader.fileMap[fileName]) {\n            // Found the subobject path in the preloaded file path map\n            fileName = loader.fileMap[fileName];\n          } else {\n            // Standardized subfolders\n            if (fileName.startsWith('s/')) {\n              fileName = 'parts/' + fileName;\n            } else if (fileName.startsWith('48/')) {\n              fileName = 'p/' + fileName;\n            }\n          }\n\n          subobjects.push({\n            material: material,\n            colorCode: colorCode,\n            matrix: matrix,\n            fileName: fileName,\n            inverted: bfcInverted,\n            startingConstructionStep: startingConstructionStep\n          });\n          bfcInverted = false;\n          break;\n        // Line type 2: Line segment\n\n        case '2':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1]\n          };\n          lineSegments.push(segment);\n          break;\n        // Line type 5: Conditional Line segment\n\n        case '5':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          v0 = lp.getVector();\n          v1 = lp.getVector();\n          c0 = lp.getVector();\n          c1 = lp.getVector();\n          segment = {\n            material: material,\n            colorCode: colorCode,\n            vertices: [v0, v1],\n            controlPoints: [c0, c1]\n          };\n          conditionalSegments.push(segment);\n          break;\n        // Line type 3: Triangle\n\n        case '3':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n          } else {\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          }\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2],\n            normals: [null, null, null]\n          });\n          totalFaces++;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v2, v1, v0],\n              normals: [null, null, null]\n            });\n            totalFaces++;\n          }\n\n          break;\n        // Line type 4: Quadrilateral\n\n        case '4':\n          colorCode = lp.getToken();\n          material = getLocalMaterial(colorCode);\n          ccw = bfcCCW;\n          doubleSided = !bfcCertified || !bfcCull;\n\n          if (ccw === true) {\n            v0 = lp.getVector();\n            v1 = lp.getVector();\n            v2 = lp.getVector();\n            v3 = lp.getVector();\n          } else {\n            v3 = lp.getVector();\n            v2 = lp.getVector();\n            v1 = lp.getVector();\n            v0 = lp.getVector();\n          } // specifically place the triangle diagonal in the v0 and v1 slots so we can\n          // account for the doubling of vertices later when smoothing normals.\n\n\n          faces.push({\n            material: material,\n            colorCode: colorCode,\n            faceNormal: null,\n            vertices: [v0, v1, v2, v3],\n            normals: [null, null, null, null]\n          });\n          totalFaces += 2;\n\n          if (doubleSided === true) {\n            faces.push({\n              material: material,\n              colorCode: colorCode,\n              faceNormal: null,\n              vertices: [v3, v2, v1, v0],\n              normals: [null, null, null, null]\n            });\n            totalFaces += 2;\n          }\n\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.');\n      }\n    }\n\n    if (parsingEmbeddedFiles) {\n      this.setData(currentEmbeddedFileName, currentEmbeddedText);\n    }\n\n    return {\n      faces,\n      conditionalSegments,\n      lineSegments,\n      type,\n      category,\n      keywords,\n      subobjects,\n      totalFaces,\n      startingConstructionStep,\n      materials,\n      fileName,\n      group: null\n    };\n  } // returns an (optionally cloned) instance of the data\n\n\n  getData(fileName, clone = true) {\n    const key = fileName.toLowerCase();\n    const result = this._cache[key];\n\n    if (result === null || result instanceof Promise) {\n      return null;\n    }\n\n    if (clone) {\n      return this.cloneResult(result);\n    } else {\n      return result;\n    }\n  } // kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n  // the data is ready to use and can be retrieved synchronously with \"getData\".\n\n\n  async ensureDataLoaded(fileName) {\n    const key = fileName.toLowerCase();\n\n    if (!(key in this._cache)) {\n      // replace the promise with a copy of the parsed data for immediate processing\n      this._cache[key] = this.fetchData(fileName).then(text => {\n        const info = this.parse(text, fileName);\n        this._cache[key] = info;\n        return info;\n      });\n    }\n\n    await this._cache[key];\n  } // sets the data in the cache from parsed data\n\n\n  setData(fileName, text) {\n    const key = fileName.toLowerCase();\n    this._cache[key] = this.parse(text, fileName);\n  }\n\n} // returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\n\n\nfunction getMaterialFromCode(colorCode, parentColorCode, materialHierarchy, forEdge) {\n  const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n  if (isPassthrough) {\n    colorCode = parentColorCode;\n  }\n\n  return materialHierarchy[colorCode] || null;\n} // Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\n\n\nclass LDrawPartsGeometryCache {\n  constructor(loader) {\n    this.loader = loader;\n    this.parseCache = new LDrawParsedCache(loader);\n    this._cache = {};\n  } // Convert the given file information into a mesh by processing subobjects.\n\n\n  async processIntoMesh(info) {\n    const loader = this.loader;\n    const parseCache = this.parseCache;\n    const faceMaterials = new Set(); // Processes the part subobject information to load child parts and merge geometry onto part\n    // piece object.\n\n    const processInfoSubobjects = async (info, subobject = null) => {\n      const subobjects = info.subobjects;\n      const promises = []; // Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n      // group which lets instruction steps apply correctly.\n\n      for (let i = 0, l = subobjects.length; i < l; i++) {\n        const subobject = subobjects[i];\n        const promise = parseCache.ensureDataLoaded(subobject.fileName).then(() => {\n          const subobjectInfo = parseCache.getData(subobject.fileName, false);\n\n          if (!isPrimitiveType(subobjectInfo.type)) {\n            return this.loadModel(subobject.fileName).catch(error => {\n              console.warn(error);\n              return null;\n            });\n          }\n\n          return processInfoSubobjects(parseCache.getData(subobject.fileName), subobject);\n        });\n        promises.push(promise);\n      }\n\n      const group = new Group();\n      group.userData.category = info.category;\n      group.userData.keywords = info.keywords;\n      info.group = group;\n      const subobjectInfos = await Promise.all(promises);\n\n      for (let i = 0, l = subobjectInfos.length; i < l; i++) {\n        const subobject = info.subobjects[i];\n        const subobjectInfo = subobjectInfos[i];\n\n        if (subobjectInfo === null) {\n          // the subobject failed to load\n          continue;\n        } // if the subobject was loaded as a separate group then apply the parent scopes materials\n\n\n        if (subobjectInfo.isGroup) {\n          const subobjectGroup = subobjectInfo;\n          subobject.matrix.decompose(subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale);\n          subobjectGroup.userData.startingConstructionStep = subobject.startingConstructionStep;\n          subobjectGroup.name = subobject.fileName;\n          loader.applyMaterialsToMesh(subobjectGroup, subobject.colorCode, info.materials);\n          group.add(subobjectGroup);\n          continue;\n        } // add the subobject group if it has children in case it has both children and primitives\n\n\n        if (subobjectInfo.group.children.length) {\n          group.add(subobjectInfo.group);\n        } // transform the primitives into the local space of the parent piece and append them to\n        // to the parent primitives list.\n\n\n        const parentLineSegments = info.lineSegments;\n        const parentConditionalSegments = info.conditionalSegments;\n        const parentFaces = info.faces;\n        const lineSegments = subobjectInfo.lineSegments;\n        const conditionalSegments = subobjectInfo.conditionalSegments;\n        const faces = subobjectInfo.faces;\n        const matrix = subobject.matrix;\n        const inverted = subobject.inverted;\n        const matrixScaleInverted = matrix.determinant() < 0;\n        const colorCode = subobject.colorCode;\n        const lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\n        for (let i = 0, l = lineSegments.length; i < l; i++) {\n          const ls = lineSegments[i];\n          const vertices = ls.vertices;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          ls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n          ls.material = ls.material || getMaterialFromCode(ls.colorCode, ls.colorCode, info.materials, true);\n          parentLineSegments.push(ls);\n        }\n\n        for (let i = 0, l = conditionalSegments.length; i < l; i++) {\n          const os = conditionalSegments[i];\n          const vertices = os.vertices;\n          const controlPoints = os.controlPoints;\n          vertices[0].applyMatrix4(matrix);\n          vertices[1].applyMatrix4(matrix);\n          controlPoints[0].applyMatrix4(matrix);\n          controlPoints[1].applyMatrix4(matrix);\n          os.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n          os.material = os.material || getMaterialFromCode(os.colorCode, os.colorCode, info.materials, true);\n          parentConditionalSegments.push(os);\n        }\n\n        for (let i = 0, l = faces.length; i < l; i++) {\n          const tri = faces[i];\n          const vertices = tri.vertices;\n\n          for (let i = 0, l = vertices.length; i < l; i++) {\n            vertices[i].applyMatrix4(matrix);\n          }\n\n          tri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n          tri.material = tri.material || getMaterialFromCode(tri.colorCode, colorCode, info.materials, false);\n          faceMaterials.add(tri.colorCode); // If the scale of the object is negated then the triangle winding order\n          // needs to be flipped.\n\n          if (matrixScaleInverted !== inverted) {\n            vertices.reverse();\n          }\n\n          parentFaces.push(tri);\n        }\n\n        info.totalFaces += subobjectInfo.totalFaces;\n      } // Apply the parent subobjects pass through material code to this object. This is done several times due\n      // to material scoping.\n\n\n      if (subobject) {\n        loader.applyMaterialsToMesh(group, subobject.colorCode, info.materials);\n      }\n\n      return info;\n    }; // Track material use to see if we need to use the normal smooth slow path for hard edges.\n\n\n    for (let i = 0, l = info.faces; i < l; i++) {\n      faceMaterials.add(info.faces[i].colorCode);\n    }\n\n    await processInfoSubobjects(info);\n\n    if (loader.smoothNormals) {\n      const checkSubSegments = faceMaterials.size > 1;\n      generateFaceNormals(info.faces);\n      smoothNormals(info.faces, info.lineSegments, checkSubSegments);\n    } // Add the primitive objects and metadata.\n\n\n    const group = info.group;\n\n    if (info.faces.length > 0) {\n      group.add(createObject(info.faces, 3, false, info.totalFaces));\n    }\n\n    if (info.lineSegments.length > 0) {\n      group.add(createObject(info.lineSegments, 2));\n    }\n\n    if (info.conditionalSegments.length > 0) {\n      group.add(createObject(info.conditionalSegments, 2, true));\n    }\n\n    return group;\n  }\n\n  hasCachedModel(fileName) {\n    return fileName !== null && fileName.toLowerCase() in this._cache;\n  }\n\n  async getCachedModel(fileName) {\n    if (fileName !== null && this.hasCachedModel(fileName)) {\n      const key = fileName.toLowerCase();\n      const group = await this._cache[key];\n      return group.clone();\n    } else {\n      return null;\n    }\n  } // Loads and parses the model with the given file name. Returns a cached copy if available.\n\n\n  async loadModel(fileName) {\n    const parseCache = this.parseCache;\n    const key = fileName.toLowerCase();\n\n    if (this.hasCachedModel(fileName)) {\n      // Return cached model if available.\n      return this.getCachedModel(fileName);\n    } else {\n      // Otherwise parse a new model.\n      // Ensure the file data is loaded and pre parsed.\n      await parseCache.ensureDataLoaded(fileName);\n      const info = parseCache.getData(fileName);\n      const promise = this.processIntoMesh(info); // Now that the file has loaded it's possible that another part parse has been waiting in parallel\n      // so check the cache again to see if it's been added since the last async operation so we don't\n      // do unnecessary work.\n\n      if (this.hasCachedModel(fileName)) {\n        return this.getCachedModel(fileName);\n      } // Cache object if it's a part so it can be reused later.\n\n\n      if (isPartType(info.type)) {\n        this._cache[key] = promise;\n      } // return a copy\n\n\n      const group = await promise;\n      return group.clone();\n    }\n  } // parses the given model text into a renderable object. Returns cached copy if available.\n\n\n  async parseModel(text) {\n    const parseCache = this.parseCache;\n    const info = parseCache.parse(text);\n\n    if (isPartType(info.type) && this.hasCachedModel(info.fileName)) {\n      return this.getCachedModel(info.fileName);\n    }\n\n    return this.processIntoMesh(info);\n  }\n\n}\n\nfunction sortByMaterial(a, b) {\n  if (a.colorCode === b.colorCode) {\n    return 0;\n  }\n\n  if (a.colorCode < b.colorCode) {\n    return -1;\n  }\n\n  return 1;\n}\n\nfunction createObject(elements, elementSize, isConditionalSegments = false, totalElements = null) {\n  // Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n  // With per face / segment material, implemented with mesh groups and materials array\n  // Sort the faces or line segments by color code to make later the mesh groups\n  elements.sort(sortByMaterial);\n\n  if (totalElements === null) {\n    totalElements = elements.length;\n  }\n\n  const positions = new Float32Array(elementSize * totalElements * 3);\n  const normals = elementSize === 3 ? new Float32Array(elementSize * totalElements * 3) : null;\n  const materials = [];\n  const quadArray = new Array(6);\n  const bufferGeometry = new BufferGeometry();\n  let prevMaterial = null;\n  let index0 = 0;\n  let numGroupVerts = 0;\n  let offset = 0;\n\n  for (let iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n    const elem = elements[iElem];\n    let vertices = elem.vertices;\n\n    if (vertices.length === 4) {\n      quadArray[0] = vertices[0];\n      quadArray[1] = vertices[1];\n      quadArray[2] = vertices[2];\n      quadArray[3] = vertices[0];\n      quadArray[4] = vertices[2];\n      quadArray[5] = vertices[3];\n      vertices = quadArray;\n    }\n\n    for (let j = 0, l = vertices.length; j < l; j++) {\n      const v = vertices[j];\n      const index = offset + j * 3;\n      positions[index + 0] = v.x;\n      positions[index + 1] = v.y;\n      positions[index + 2] = v.z;\n    } // create the normals array if this is a set of faces\n\n\n    if (elementSize === 3) {\n      if (!elem.faceNormal) {\n        const v0 = vertices[0];\n        const v1 = vertices[1];\n        const v2 = vertices[2];\n\n        _tempVec0.subVectors(v1, v0);\n\n        _tempVec1.subVectors(v2, v1);\n\n        elem.faceNormal = new Vector3().crossVectors(_tempVec0, _tempVec1).normalize();\n      }\n\n      let elemNormals = elem.normals;\n\n      if (elemNormals.length === 4) {\n        quadArray[0] = elemNormals[0];\n        quadArray[1] = elemNormals[1];\n        quadArray[2] = elemNormals[2];\n        quadArray[3] = elemNormals[0];\n        quadArray[4] = elemNormals[2];\n        quadArray[5] = elemNormals[3];\n        elemNormals = quadArray;\n      }\n\n      for (let j = 0, l = elemNormals.length; j < l; j++) {\n        // use face normal if a vertex normal is not provided\n        let n = elem.faceNormal;\n\n        if (elemNormals[j]) {\n          n = elemNormals[j].norm;\n        }\n\n        const index = offset + j * 3;\n        normals[index + 0] = n.x;\n        normals[index + 1] = n.y;\n        normals[index + 2] = n.z;\n      }\n    }\n\n    if (prevMaterial !== elem.colorCode) {\n      if (prevMaterial !== null) {\n        bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n      }\n\n      const material = elem.material;\n\n      if (material !== null) {\n        if (elementSize === 3) {\n          materials.push(material);\n        } else if (elementSize === 2) {\n          if (material !== null) {\n            if (isConditionalSegments) {\n              materials.push(material.userData.edgeMaterial.userData.conditionalEdgeMaterial);\n            } else {\n              materials.push(material.userData.edgeMaterial);\n            }\n          } else {\n            materials.push(null);\n          }\n        }\n      } else {\n        // If a material has not been made available yet then keep the color code string in the material array\n        // to save the spot for the material once a parent scopes materials are being applied to the object.\n        materials.push(elem.colorCode);\n      }\n\n      prevMaterial = elem.colorCode;\n      index0 = offset / 3;\n      numGroupVerts = vertices.length;\n    } else {\n      numGroupVerts += vertices.length;\n    }\n\n    offset += 3 * vertices.length;\n  }\n\n  if (numGroupVerts > 0) {\n    bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n  }\n\n  bufferGeometry.setAttribute('position', new BufferAttribute(positions, 3));\n\n  if (normals !== null) {\n    bufferGeometry.setAttribute('normal', new BufferAttribute(normals, 3));\n  }\n\n  let object3d = null;\n\n  if (elementSize === 2) {\n    if (isConditionalSegments) {\n      object3d = new ConditionalLineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    } else {\n      object3d = new LineSegments(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n    }\n  } else if (elementSize === 3) {\n    object3d = new Mesh(bufferGeometry, materials.length === 1 ? materials[0] : materials);\n  }\n\n  if (isConditionalSegments) {\n    object3d.isConditionalLine = true;\n    const controlArray0 = new Float32Array(elements.length * 3 * 2);\n    const controlArray1 = new Float32Array(elements.length * 3 * 2);\n    const directionArray = new Float32Array(elements.length * 3 * 2);\n\n    for (let i = 0, l = elements.length; i < l; i++) {\n      const os = elements[i];\n      const vertices = os.vertices;\n      const controlPoints = os.controlPoints;\n      const c0 = controlPoints[0];\n      const c1 = controlPoints[1];\n      const v0 = vertices[0];\n      const v1 = vertices[1];\n      const index = i * 3 * 2;\n      controlArray0[index + 0] = c0.x;\n      controlArray0[index + 1] = c0.y;\n      controlArray0[index + 2] = c0.z;\n      controlArray0[index + 3] = c0.x;\n      controlArray0[index + 4] = c0.y;\n      controlArray0[index + 5] = c0.z;\n      controlArray1[index + 0] = c1.x;\n      controlArray1[index + 1] = c1.y;\n      controlArray1[index + 2] = c1.z;\n      controlArray1[index + 3] = c1.x;\n      controlArray1[index + 4] = c1.y;\n      controlArray1[index + 5] = c1.z;\n      directionArray[index + 0] = v1.x - v0.x;\n      directionArray[index + 1] = v1.y - v0.y;\n      directionArray[index + 2] = v1.z - v0.z;\n      directionArray[index + 3] = v1.x - v0.x;\n      directionArray[index + 4] = v1.y - v0.y;\n      directionArray[index + 5] = v1.z - v0.z;\n    }\n\n    bufferGeometry.setAttribute('control0', new BufferAttribute(controlArray0, 3, false));\n    bufferGeometry.setAttribute('control1', new BufferAttribute(controlArray1, 3, false));\n    bufferGeometry.setAttribute('direction', new BufferAttribute(directionArray, 3, false));\n  }\n\n  return object3d;\n} //\n\n\nclass LDrawLoader extends Loader {\n  constructor(manager) {\n    super(manager); // Array of THREE.Material\n\n    this.materials = [];\n    this.materialLibrary = {}; // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.partsCache = new LDrawPartsGeometryCache(this); // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = {}; // Initializes the materials library with default materials\n\n    this.setMaterials([]); // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true; // The path to load parts from the LDraw parts library from.\n\n    this.partsLibraryPath = '';\n  }\n\n  setPartsLibraryPath(path) {\n    this.partsLibraryPath = path;\n    return this;\n  }\n\n  async preloadMaterials(url) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    const text = await fileLoader.loadAsync(url);\n    const colorLineRegex = /^0 !COLOUR/;\n    const lines = text.split(/[\\n\\r]/g);\n    const materials = [];\n\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i];\n\n      if (colorLineRegex.test(line)) {\n        const directive = line.replace(colorLineRegex, '');\n        const material = this.parseColorMetaDirective(new LineParser(directive));\n        materials.push(material);\n      }\n    }\n\n    this.setMaterials(materials);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const fileLoader = new FileLoader(this.manager);\n    fileLoader.setPath(this.path);\n    fileLoader.setRequestHeader(this.requestHeader);\n    fileLoader.setWithCredentials(this.withCredentials);\n    fileLoader.load(url, text => {\n      this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n        this.applyMaterialsToMesh(group, MAIN_COLOUR_CODE, this.materialLibrary, true);\n        this.computeConstructionSteps(group);\n        onLoad(group);\n      }).catch(onError);\n    }, onProgress, onError);\n  }\n\n  parse(text, onLoad) {\n    this.partsCache.parseModel(text, this.materialLibrary).then(group => {\n      this.computeConstructionSteps(group);\n      onLoad(group);\n    });\n  }\n\n  setMaterials(materials) {\n    this.materialLibrary = {};\n    this.materials = [];\n\n    for (let i = 0, l = materials.length; i < l; i++) {\n      this.addMaterial(materials[i]);\n    } // Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\n\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Main_Colour CODE 16 VALUE #FF8080 EDGE #333333')));\n    this.addMaterial(this.parseColorMetaDirective(new LineParser('Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333')));\n    return this;\n  }\n\n  setFileMap(fileMap) {\n    this.fileMap = fileMap;\n    return this;\n  }\n\n  addMaterial(material) {\n    // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n    const matLib = this.materialLibrary;\n\n    if (!matLib[material.userData.code]) {\n      this.materials.push(material);\n      matLib[material.userData.code] = material;\n    }\n\n    return this;\n  }\n\n  getMaterial(colorCode) {\n    if (colorCode.startsWith('0x2')) {\n      // Special 'direct' material value (RGB color)\n      const color = colorCode.substring(3);\n      return this.parseColorMetaDirective(new LineParser('Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + ''));\n    }\n\n    return this.materialLibrary[colorCode] || null;\n  } // Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n  // in the material array if they need to be filled in.\n\n\n  applyMaterialsToMesh(group, parentColorCode, materialHierarchy, finalMaterialPass = false) {\n    // find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n    const loader = this;\n    const parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n    group.traverse(c => {\n      if (c.isMesh || c.isLineSegments) {\n        if (Array.isArray(c.material)) {\n          for (let i = 0, l = c.material.length; i < l; i++) {\n            if (!c.material[i].isMaterial) {\n              c.material[i] = getMaterial(c, c.material[i]);\n            }\n          }\n        } else if (!c.material.isMaterial) {\n          c.material = getMaterial(c, c.material);\n        }\n      }\n    }); // Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n    // (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n    // simply returned for the subsequent material application.\n\n    function getMaterial(c, colorCode) {\n      // if our parent is a passthrough color code and we don't have the current material color available then\n      // return early.\n      if (parentIsPassthrough && !(colorCode in materialHierarchy) && !finalMaterialPass) {\n        return colorCode;\n      }\n\n      const forEdge = c.isLineSegments || c.isConditionalLine;\n      const isPassthrough = !forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\n      if (isPassthrough) {\n        colorCode = parentColorCode;\n      }\n\n      let material = null;\n\n      if (colorCode in materialHierarchy) {\n        material = materialHierarchy[colorCode];\n      } else if (finalMaterialPass) {\n        // see if we can get the final material from from the \"getMaterial\" function which will attempt to\n        // parse the \"direct\" colors\n        material = loader.getMaterial(colorCode);\n\n        if (material === null) {\n          // otherwise throw an error if this is final opportunity to set the material\n          throw new Error(`LDrawLoader: Material properties for code ${colorCode} not available.`);\n        }\n      } else {\n        return colorCode;\n      }\n\n      if (c.isLineSegments) {\n        material = material.userData.edgeMaterial;\n\n        if (c.isConditionalLine) {\n          material = material.userData.conditionalEdgeMaterial;\n        }\n      }\n\n      return material;\n    }\n  }\n\n  getMainMaterial() {\n    return this.getMaterial(MAIN_COLOUR_CODE);\n  }\n\n  getMainEdgeMaterial() {\n    return this.getMaterial(MAIN_EDGE_COLOUR_CODE);\n  }\n\n  parseColorMetaDirective(lineParser) {\n    // Parses a color definition and returns a THREE.Material\n    let code = null; // Triangle and line colors\n\n    let color = 0xff00ff;\n    let edgeColor = 0xff00ff; // Transparency\n\n    let alpha = 1;\n    let isTransparent = false; // Self-illumination:\n\n    let luminance = 0;\n    let finishType = FINISH_TYPE_DEFAULT;\n    let edgeMaterial = null;\n    const name = lineParser.getToken();\n\n    if (!name) {\n      throw new Error('LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.');\n    } // Parse tag tokens and their parameters\n\n\n    let token = null;\n\n    while (true) {\n      token = lineParser.getToken();\n\n      if (!token) {\n        break;\n      }\n\n      switch (token.toUpperCase()) {\n        case 'CODE':\n          code = lineParser.getToken();\n          break;\n\n        case 'VALUE':\n          color = lineParser.getToken();\n\n          if (color.startsWith('0x')) {\n            color = '#' + color.substring(2);\n          } else if (!color.startsWith('#')) {\n            throw new Error('LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.');\n          }\n\n          break;\n\n        case 'EDGE':\n          edgeColor = lineParser.getToken();\n\n          if (edgeColor.startsWith('0x')) {\n            edgeColor = '#' + edgeColor.substring(2);\n          } else if (!edgeColor.startsWith('#')) {\n            // Try to see if edge color is a color code\n            edgeMaterial = this.getMaterial(edgeColor);\n\n            if (!edgeMaterial) {\n              throw new Error('LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.');\n            } // Get the edge material for this triangle material\n\n\n            edgeMaterial = edgeMaterial.userData.edgeMaterial;\n          }\n\n          break;\n\n        case 'ALPHA':\n          alpha = parseInt(lineParser.getToken());\n\n          if (isNaN(alpha)) {\n            throw new Error('LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.');\n          }\n\n          alpha = Math.max(0, Math.min(1, alpha / 255));\n\n          if (alpha < 1) {\n            isTransparent = true;\n          }\n\n          break;\n\n        case 'LUMINANCE':\n          luminance = parseInt(lineParser.getToken());\n\n          if (isNaN(luminance)) {\n            throw new Error('LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.');\n          }\n\n          luminance = Math.max(0, Math.min(1, luminance / 255));\n          break;\n\n        case 'CHROME':\n          finishType = FINISH_TYPE_CHROME;\n          break;\n\n        case 'PEARLESCENT':\n          finishType = FINISH_TYPE_PEARLESCENT;\n          break;\n\n        case 'RUBBER':\n          finishType = FINISH_TYPE_RUBBER;\n          break;\n\n        case 'MATTE_METALLIC':\n          finishType = FINISH_TYPE_MATTE_METALLIC;\n          break;\n\n        case 'METAL':\n          finishType = FINISH_TYPE_METAL;\n          break;\n\n        case 'MATERIAL':\n          // Not implemented\n          lineParser.setToEnd();\n          break;\n\n        default:\n          throw new Error('LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.');\n      }\n    }\n\n    let material = null;\n\n    switch (finishType) {\n      case FINISH_TYPE_DEFAULT:\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_PEARLESCENT:\n        // Try to imitate pearlescency by making the surface glossy\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.3,\n          metalness: 0.25\n        });\n        break;\n\n      case FINISH_TYPE_CHROME:\n        // Mirror finish surface\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0,\n          metalness: 1\n        });\n        break;\n\n      case FINISH_TYPE_RUBBER:\n        // Rubber finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.9,\n          metalness: 0\n        });\n        break;\n\n      case FINISH_TYPE_MATTE_METALLIC:\n        // Brushed metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.8,\n          metalness: 0.4\n        });\n        break;\n\n      case FINISH_TYPE_METAL:\n        // Average metal finish\n        material = new MeshStandardMaterial({\n          color: color,\n          roughness: 0.2,\n          metalness: 0.85\n        });\n        break;\n    }\n\n    material.transparent = isTransparent;\n    material.premultipliedAlpha = true;\n    material.opacity = alpha;\n    material.depthWrite = !isTransparent;\n    material.polygonOffset = true;\n    material.polygonOffsetFactor = 1;\n\n    if (luminance !== 0) {\n      material.emissive.set(material.color).multiplyScalar(luminance);\n    }\n\n    if (!edgeMaterial) {\n      // This is the material used for edges\n      edgeMaterial = new LineBasicMaterial({\n        color: edgeColor,\n        transparent: isTransparent,\n        opacity: alpha,\n        depthWrite: !isTransparent\n      });\n      edgeMaterial.userData.code = code;\n      edgeMaterial.name = name + ' - Edge'; // This is the material used for conditional edges\n\n      edgeMaterial.userData.conditionalEdgeMaterial = new LDrawConditionalLineMaterial({\n        fog: true,\n        transparent: isTransparent,\n        depthWrite: !isTransparent,\n        color: edgeColor,\n        opacity: alpha\n      });\n    }\n\n    material.userData.code = code;\n    material.name = name;\n    material.userData.edgeMaterial = edgeMaterial;\n    this.addMaterial(material);\n    return material;\n  }\n\n  computeConstructionSteps(model) {\n    // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n    let stepNumber = 0;\n    model.traverse(c => {\n      if (c.isGroup) {\n        if (c.userData.startingConstructionStep) {\n          stepNumber++;\n        }\n\n        c.userData.constructionStep = stepNumber;\n      }\n    });\n    model.userData.numConstructionSteps = stepNumber + 1;\n  }\n\n}\n\nexport { LDrawLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}