"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),r=require("react"),t=require("three"),a=require("@react-three/fiber"),n=require("three-stdlib");function o(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function i(e){if(e&&e.__esModule)return e;var r=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var a=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,a.get?a:{enumerable:!0,get:function(){return e[t]}})}})),r.default=e,Object.freeze(r)}var u=o(e),c=i(r),l=i(t);const s=c.forwardRef((({scale:e=10,frames:r=1/0,opacity:t=1,width:o=1,height:i=1,blur:s=1,far:d=10,resolution:f=512,smooth:h=!0,color:m="#000000",depthWrite:p=!1,renderOrder:g,...v},b)=>{const M=a.useThree((e=>e.scene)),y=a.useThree((e=>e.gl)),w=c.useRef(null);o*=Array.isArray(e)?e[0]:e||1,i*=Array.isArray(e)?e[1]:e||1;const[T,S,x,O,R,j,P]=c.useMemo((()=>{const e=new l.WebGLRenderTarget(f,f),r=new l.WebGLRenderTarget(f,f);r.texture.generateMipmaps=e.texture.generateMipmaps=!1;const t=new l.PlaneBufferGeometry(o,i).rotateX(Math.PI/2),a=new l.Mesh(t),u=new l.MeshDepthMaterial;u.depthTest=u.depthWrite=!1,u.onBeforeCompile=e=>{e.uniforms={...e.uniforms,ucolor:{value:new l.Color(m).convertSRGBToLinear()}},e.fragmentShader=e.fragmentShader.replace("void main() {","uniform vec3 ucolor;\n           void main() {\n          "),e.fragmentShader=e.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );","vec4( ucolor, ( 1.0 - fragCoordZ ) * 1.0 );")};const c=new l.ShaderMaterial(n.HorizontalBlurShader),s=new l.ShaderMaterial(n.VerticalBlurShader);return s.depthTest=c.depthTest=!1,[e,t,u,a,c,s,r]}),[f,o,i,e,m]),B=e=>{O.visible=!0,O.material=R,R.uniforms.tDiffuse.value=T.texture,R.uniforms.h.value=1*e/256,y.setRenderTarget(P),y.render(O,w.current),O.material=j,j.uniforms.tDiffuse.value=P.texture,j.uniforms.v.value=1*e/256,y.setRenderTarget(T),y.render(O,w.current),O.visible=!1};let C=0;return a.useFrame((()=>{if(w.current&&(r===1/0||C<r)){const e=M.background;M.background=null;const r=M.overrideMaterial;M.overrideMaterial=x,y.setRenderTarget(T),y.render(M,w.current),M.overrideMaterial=r,B(s),h&&B(.4*s),y.setRenderTarget(null),M.background=e,C++}})),c.createElement("group",u.default({"rotation-x":Math.PI/2},v,{ref:b}),c.createElement("mesh",{renderOrder:g,geometry:S,scale:[1,-1,1],rotation:[-Math.PI/2,0,0]},c.createElement("meshBasicMaterial",{map:T.texture,"map-encoding":y.outputEncoding,transparent:!0,opacity:t,depthWrite:p})),c.createElement("orthographicCamera",{ref:w,args:[-o/2,o/2,i/2,-i/2,0,d]}))}));exports.ContactShadows=s;
